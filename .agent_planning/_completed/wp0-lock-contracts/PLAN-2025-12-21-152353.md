# WP0: Lock the Contracts - Implementation Plan

**Generated**: 2025-12-21 15:23:53
**Source STATUS**: STATUS-20251221-133500.md
**Completion**: ~35% (per STATUS)
**Target**: 100% contract enforcement with comprehensive validation

---

## Executive Summary

WP0 establishes compile-time contract validation that all downstream work packages can rely on. Current implementation has exactly-one-TimeRoot validation complete, but lacks:

1. **Reserved bus enforcement** - No validation that canonical buses (phaseA, pulse, energy, etc.) have correct TypeDesc and combine modes
2. **TimeRoot dependency validation** - No check preventing TimeRoot from depending on evaluated blocks
3. **Composite TimeRoot constraint** - No validation preventing TimeRoot inside composite definitions
4. **TypeDesc authority** - TypeDesc exists but isn't enforced as the single source of truth

**Critical Dependencies**: None (foundational work package)

**Risks**:
- Ambiguity in spec around semantics field enforcement for reserved buses
- Need to define acceptable TimeRoot input types (Config vs Signal world)
- Combine mode enforcement strictness for reserved buses

---

## Gap Analysis

### Current State (from STATUS-20251221-133500.md)

**✅ Complete (35%)**:
- Exactly-one-TimeRoot validation (E_TIME_ROOT_MISSING, E_TIME_ROOT_MULTIPLE)
- TypeDesc system exists with world/domain/category/busEligible fields
- Reserved bus defaults created in BusStore with correct types
- Combine mode validation infrastructure exists

**❌ Missing (65%)**:
- Reserved bus TypeDesc validation against canonical contracts
- Reserved bus combine mode enforcement
- TimeRoot upstream dependency rejection
- Composite TimeRoot validation
- TypeDesc as authoritative contract (currently descriptive metadata)

### Specification Requirements (from design-docs/)

**From 02-Time-Architecture.md**:
- Line 36: "Exactly one TimeRoot per patch (compile error if 0 or >1)" ✅ DONE
- Line 37: "TimeRoot cannot have upstream dependencies" ❌ NOT IMPLEMENTED
- Line 38: "TimeRoot cannot exist inside composite definitions" ❌ NOT IMPLEMENTED

**From 03-Buses.md**:
- Lines 48-85: Reserved bus TypeDesc contracts (phaseA, phaseB, pulse, energy, progress, palette)
- Line 20: Combine mode semantics (last, sum, or)
- Lines 148-150: "Must not have multiple publishers" for control-plane signals

**From 11-Roadmap.md (WP0)**:
- Line 26: "TypeDesc is authoritative for ports + buses" ❌ PARTIAL
- Line 27: "Reserved bus names/types enforced" ❌ NOT IMPLEMENTED
- Line 28: "Exactly one TimeRoot enforced" ✅ DONE
- Line 29: "TimeRoot cannot have upstream dependencies" ❌ NOT IMPLEMENTED
- Line 30: "No composite may contain a TimeRoot" ❌ NOT IMPLEMENTED

---

## Prioritized Backlog

## [P0] Reserved Bus Validation Registry

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: None
**Spec Reference**: 03-Buses.md lines 48-85 • **Status Reference**: STATUS-20251221-133500.md lines 104-141

### Description

Create a canonical registry of reserved bus contracts and validate all buses against it at compile time. Reserved buses (phaseA, phaseB, pulse, energy, progress, palette) have fixed TypeDesc contracts that must be enforced.

**User Specification**:
- Reserved bus names are NOT user-ownable
- TypeDesc MUST match exactly (world + domain)
- Combine mode MUST match canonical default
- If user tries to create reserved bus with wrong type → hard compile error
- If reserved bus missing, auto-created by BusStore (already implemented)
- If user renames reserved bus → becomes new user bus, reserved bus re-created

### Acceptance Criteria

- [ ] Create `RESERVED_BUS_CONTRACTS` constant in `src/editor/semantic/busContracts.ts` with canonical TypeDesc and combine mode for each reserved bus (phaseA, phaseB, pulse, energy, progress, palette)
- [ ] Add `validateReservedBus()` function that checks bus name against registry and validates TypeDesc match (world + domain)
- [ ] Add `validateReservedBusCombineMode()` function that enforces canonical combine mode for reserved buses
- [ ] Emit `E_RESERVED_BUS_TYPE_MISMATCH` diagnostic when reserved bus has wrong TypeDesc
- [ ] Emit `E_RESERVED_BUS_COMBINE_MODE_MISMATCH` diagnostic when reserved bus has wrong combine mode
- [ ] Integrate validation into `Validator.validateAll()` as new rule
- [ ] Add test coverage: create bus named "phaseA" with wrong domain → expect compile error
- [ ] Add test coverage: create bus named "energy" with combineMode='last' → expect compile error
- [ ] Add test coverage: create bus named "customBus" with any type → expect success (not reserved)

### Technical Notes

**File Locations**:
- New file: `src/editor/semantic/busContracts.ts` - Reserved bus registry
- Modify: `src/editor/semantic/validator.ts` - Add validation rule
- Modify: `src/editor/diagnostics/types.ts` - Add new DiagnosticCode entries

**Canonical Contracts** (from 03-Buses.md):
```typescript
const RESERVED_BUS_CONTRACTS = {
  phaseA: {
    type: { world: 'signal', domain: 'phase', semantics: 'primary', category: 'core', busEligible: true },
    combineMode: 'last'
  },
  phaseB: {
    type: { world: 'signal', domain: 'phase', semantics: 'secondary', category: 'core', busEligible: true },
    combineMode: 'last'
  },
  pulse: {
    type: { world: 'special', domain: 'event', semantics: 'pulse', category: 'core', busEligible: true },
    combineMode: 'or'
  },
  energy: {
    type: { world: 'signal', domain: 'number', semantics: 'energy', category: 'core', busEligible: true },
    combineMode: 'sum'
  },
  progress: {
    type: { world: 'signal', domain: 'unit', semantics: 'progress', category: 'core', busEligible: true },
    combineMode: 'last'
  },
  palette: {
    type: { world: 'signal', domain: 'color', category: 'core', busEligible: true },
    combineMode: 'last'
  },
} as const;
```

**Implementation Pattern**:
```typescript
private validateReservedBuses(patch: PatchDocument): Diagnostic[] {
  const errors: Diagnostic[] = [];

  for (const bus of patch.buses) {
    const contract = RESERVED_BUS_CONTRACTS[bus.name];
    if (!contract) continue; // Not reserved

    // Check TypeDesc match (world + domain required, semantics optional)
    if (bus.type.world !== contract.type.world ||
        bus.type.domain !== contract.type.domain) {
      errors.push(createDiagnostic({
        code: 'E_RESERVED_BUS_TYPE_MISMATCH',
        severity: 'error',
        domain: 'compile',
        primaryTarget: { kind: 'bus', busId: bus.id },
        title: `Reserved bus type mismatch`,
        message: `Reserved bus "${bus.name}" must have type ${contract.type.world}:${contract.type.domain}, got ${bus.type.world}:${bus.type.domain}`,
        patchRevision: this.patchRevision,
      }));
    }

    // Check combine mode (strict for reserved buses)
    if (bus.combineMode !== contract.combineMode) {
      errors.push(createDiagnostic({
        code: 'E_RESERVED_BUS_COMBINE_MODE_MISMATCH',
        severity: 'error',
        domain: 'compile',
        primaryTarget: { kind: 'bus', busId: bus.id },
        title: `Reserved bus combine mode mismatch`,
        message: `Reserved bus "${bus.name}" must use combineMode="${contract.combineMode}", got "${bus.combineMode}"`,
        patchRevision: this.patchRevision,
      }));
    }
  }

  return errors;
}
```

**Ambiguity Resolution**:
- **Semantics field**: REQUIRED for reserved buses (matches spec exactly)
- **Combine mode**: FIXED for reserved buses (hard error if changed)
- **Category field**: REQUIRED = 'core' for all reserved buses

---

## [P0] TimeRoot Upstream Dependency Validation

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: None (uses existing SemanticGraph)
**Spec Reference**: 02-Time-Architecture.md line 37 • **Status Reference**: STATUS-20251221-133500.md lines 144-161

### Description

Prevent TimeRoot blocks from depending on any evaluated block outputs (wires or bus listeners). TimeRoot defines absolute time topology and cannot depend on values that require time to compute.

**User Specification**:
- TimeRoot may depend ONLY on: DefaultSource, ScalarConst, ConfigConst, UIControl, ExternalIO
- TimeRoot cannot depend on any block output via wire connections
- TimeRoot cannot depend on any block output via bus listeners
- Hard error at compile time (no fallback)

### Acceptance Criteria

- [ ] Add `validateTimeRootDependencies()` method to `Validator` class
- [ ] Identify TimeRoot block in patch (already validated as exactly one)
- [ ] For each TimeRoot input port, trace dependency graph backwards using `SemanticGraph`
- [ ] Check if any upstream node is a block output (not DefaultSource/Config/UIControl)
- [ ] Emit `E_TIME_ROOT_UPSTREAM_DEPENDENCY` diagnostic if TimeRoot has evaluated block dependencies
- [ ] Include violating block ID and connection path in diagnostic payload
- [ ] Add test coverage: Wire NumberSource → TimeRoot.param → expect compile error
- [ ] Add test coverage: Bus listener on TimeRoot input from evaluated signal → expect compile error
- [ ] Add test coverage: TimeRoot with only Config params → expect success
- [ ] Add test coverage: TimeRoot with DefaultSource input → expect success

### Technical Notes

**Dependency Graph Analysis**:
- Use existing `SemanticGraph.fromPatch()` infrastructure
- Need to distinguish Config-world inputs (allowed) from Signal-world runtime dependencies (forbidden)
- Consider transitive dependencies (not just direct connections)

**Whitelist of Acceptable TimeRoot Inputs**:
1. **DefaultSource blocks** - Provide constant values at compile time
2. **Config parameters** - Scalar constants set in block params
3. **UI Controls** - Treated as external inputs (MIDI/OSC, knobs)
4. **ExternalIO** - Rare, but valid for clock sync scenarios

**Forbidden TimeRoot Inputs**:
1. Any block's evaluated output (Signal or Field world)
2. Bus listeners subscribed to evaluated buses
3. Transitive dependencies through intermediate blocks

**Implementation Pattern**:
```typescript
private validateTimeRootDependencies(patch: PatchDocument): Diagnostic[] {
  const timeRoot = patch.blocks.find(b =>
    b.type === 'FiniteTimeRoot' ||
    b.type === 'InfiniteTimeRoot'
  );

  if (!timeRoot) return []; // Already validated as exactly-one

  const errors: Diagnostic[] = [];

  // Check wire connections to TimeRoot inputs
  const incomingWires = patch.connections.filter(c => c.to.blockId === timeRoot.id);
  for (const wire of incomingWires) {
    const sourceBlock = patch.blocks.find(b => b.id === wire.from.blockId);
    if (!sourceBlock) continue;

    // Check if source is whitelisted (DefaultSource, Config, UIControl)
    if (!isWhitelistedTimeRootSource(sourceBlock)) {
      errors.push(createDiagnostic({
        code: 'E_TIME_ROOT_UPSTREAM_DEPENDENCY',
        severity: 'error',
        domain: 'compile',
        primaryTarget: { kind: 'timeRoot', blockId: timeRoot.id },
        affectedTargets: [{ kind: 'block', blockId: sourceBlock.id }],
        title: `TimeRoot cannot have upstream dependencies`,
        message: `TimeRoot cannot depend on block "${sourceBlock.label || sourceBlock.type}". TimeRoot may only depend on DefaultSource, Config, UIControl, or ExternalIO.`,
        patchRevision: this.patchRevision,
      }));
    }
  }

  // Check bus listeners on TimeRoot inputs
  const timeRootListeners = patch.busListeners.filter(l => l.toBlockId === timeRoot.id);
  for (const listener of timeRootListeners) {
    // Bus listeners are inherently evaluated signals, so always forbidden
    errors.push(createDiagnostic({
      code: 'E_TIME_ROOT_UPSTREAM_DEPENDENCY',
      severity: 'error',
      domain: 'compile',
      primaryTarget: { kind: 'timeRoot', blockId: timeRoot.id },
      affectedTargets: [{ kind: 'bus', busId: listener.busId }],
      title: `TimeRoot cannot subscribe to buses`,
      message: `TimeRoot cannot have bus listeners. Bus "${listener.busId}" feeds into TimeRoot, which is forbidden.`,
      patchRevision: this.patchRevision,
    }));
  }

  return errors;
}

function isWhitelistedTimeRootSource(block: Block): boolean {
  return (
    block.type === 'DefaultSource' ||
    block.type === 'UIControl' ||
    block.type === 'ExternalIO' ||
    block.tags?.category === 'config'
  );
}
```

**Diagnostic Code Addition**:
```typescript
// In src/editor/diagnostics/types.ts
export type DiagnosticCode =
  // ... existing codes
  | 'E_TIME_ROOT_UPSTREAM_DEPENDENCY'  // NEW
  | 'E_TIME_ROOT_BUS_LISTENER'         // NEW (specific for bus case)
```

**Ambiguity Clarification**:
- **Config-world inputs**: ALLOWED (e.g., TimeRoot.duration parameter)
- **Signal-world inputs**: FORBIDDEN (e.g., wired Signal<number> to TimeRoot.phaseOffset)
- **Transitive depth**: FULL transitive closure (not just direct connections)

---

## [P0] Composite TimeRoot Constraint

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: None
**Spec Reference**: 11-Roadmap.md line 30 • **Status Reference**: STATUS-20251221-133500.md lines 165-187

### Description

Prevent TimeRoot blocks from appearing inside composite definitions. Composites are reusable subgraphs; allowing TimeRoot inside would violate the exactly-one-TimeRoot rule and create ambiguous time ownership.

**User Specification**:
- Composite definitions CANNOT contain any TimeRoot block (Finite/Cycle/Infinite)
- Hard error at composite definition time (not just instance expansion)
- Clear error message explaining why TimeRoot is forbidden in composites

### Acceptance Criteria

- [ ] Add validation to composite definition creation/modification
- [ ] Check all blocks in composite definition graph for TimeRoot types
- [ ] Emit `E_COMPOSITE_CONTAINS_TIMEROOT` diagnostic if TimeRoot found in composite
- [ ] Prevent composite definition save if TimeRoot present
- [ ] Add test coverage: Define composite with only domain/signal blocks → expect success
- [ ] Add test coverage: Patch with TimeRoot + composite (no TimeRoot inside) → expect success
- [ ] Update composite definition UI to show validation error when TimeRoot added

### Technical Notes

**File Locations**:
- Modify: `src/editor/stores/CompositeStore.ts` - Add validation on composite definition
- OR create: `src/editor/semantic/compositeValidator.ts` - Dedicated composite validation
- Modify: `src/editor/diagnostics/types.ts` - Add DiagnosticCode

**Implementation Pattern**:
```typescript
// In CompositeStore or dedicated validator
function validateCompositeDefinition(def: CompositeDefinition): Diagnostic[] {
  const errors: Diagnostic[] = [];

  for (const block of def.graph.blocks) {
    if (isTimeRootBlock(block.type)) {
      errors.push(createDiagnostic({
        code: 'E_COMPOSITE_CONTAINS_TIMEROOT',
        severity: 'error',
        domain: 'compile',
        primaryTarget: { kind: 'composite', compositeDefId: def.id },
        affectedTargets: [{ kind: 'block', blockId: block.id }],
        title: `Composite cannot contain TimeRoot`,
        message: `Composite definitions cannot contain TimeRoot blocks. Found ${block.type} in composite "${def.label}". TimeRoot defines patch-level time topology and must be unique.`,
        patchRevision: 0, // Composite definitions are version-independent
      }));
    }
  }

  return errors;
}

function isTimeRootBlock(blockType: string): boolean {
  return (
    blockType === 'FiniteTimeRoot' ||
    blockType === 'InfiniteTimeRoot'
  );
}
```

**Integration Points**:
- Call validation when composite definition is created
- Call validation when composite definition is modified
- Show validation errors in composite editor UI
- Prevent composite save if validation fails

**Diagnostic Code Addition**:
```typescript
// In src/editor/diagnostics/types.ts
export type DiagnosticCode =
  // ... existing codes
  | 'E_COMPOSITE_CONTAINS_TIMEROOT'  // NEW
```

---

## [P1] Combine Mode Compatibility Matrix

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: P0 Reserved Bus Validation
**Spec Reference**: User specs (combine mode enforcement) • **Status Reference**: STATUS-20251221-133500.md lines 218-238

### Description

Enforce combine mode compatibility with TypeDesc for all buses (not just reserved). Each TypeDesc domain has valid combine modes; others should be compile errors.

**User Specification**:
- Reserved buses: combine mode FIXED (already in P0)
- Non-reserved buses: combine mode user-settable but must be compatible with TypeDesc
- Compatibility matrix defines valid modes per domain
- Hard compile error for incompatible combinations

### Acceptance Criteria

- [ ] Create `COMBINE_MODE_COMPATIBILITY` matrix mapping TypeDesc domain to allowed combine modes
- [ ] Add `validateCombineModeCompatibility()` function
- [ ] For signal:number → allow sum, avg, min, max, last
- [ ] For signal:phase → allow last only
- [ ] For signal:trigger/event → allow or, last
- [ ] For field domains → allow last, layer, sum (if per-element combine defined)
- [ ] Emit `E_BUS_COMBINE_MODE_INCOMPATIBLE` diagnostic for invalid combinations
- [ ] Add test coverage: Bus signal:phase with combineMode='sum' → expect error
- [ ] Add test coverage: Bus signal:number with combineMode='avg' → expect success
- [ ] Add test coverage: Bus signal:trigger with combineMode='or' → expect success

### Technical Notes

**Compatibility Matrix**:
```typescript
const COMBINE_MODE_COMPATIBILITY: Record<string, CombineMode[]> = {
  // Signal domains
  'number': ['sum', 'avg', 'min', 'max', 'last'],
  'phase': ['last'],
  'unit': ['last'],
  'trigger': ['or', 'last'],
  'event': ['or', 'last'],
  'color': ['last', 'blend'],  // Optional: color blending

  // Field domains (limited combine semantics)
  'vec2': ['last', 'layer'],
  'vec3': ['last', 'layer'],
  'color': ['last', 'layer', 'blend'],
};
```

**Implementation Pattern**:
```typescript
private validateCombineModeCompatibility(patch: PatchDocument): Diagnostic[] {
  const errors: Diagnostic[] = [];

  for (const bus of patch.buses) {
    const allowedModes = COMBINE_MODE_COMPATIBILITY[bus.type.domain];
    if (!allowedModes) {
      // Unknown domain - warning, not error
      continue;
    }

    if (!allowedModes.includes(bus.combineMode)) {
      errors.push(createDiagnostic({
        code: 'E_BUS_COMBINE_MODE_INCOMPATIBLE',
        severity: 'error',
        domain: 'compile',
        primaryTarget: { kind: 'bus', busId: bus.id },
        title: `Incompatible combine mode`,
        message: `Bus "${bus.name}" with type ${bus.type.world}:${bus.type.domain} cannot use combineMode="${bus.combineMode}". Allowed modes: ${allowedModes.join(', ')}`,
        patchRevision: this.patchRevision,
      }));
    }
  }

  return errors;
}
```

**Diagnostic Code Addition**:
```typescript
export type DiagnosticCode =
  // ... existing codes
  | 'E_BUS_COMBINE_MODE_INCOMPATIBLE'  // NEW
```

---

## [P2] TypeDesc Authority Enforcement

**Status**: Not Started
**Effort**: Large (1-2 weeks)
**Dependencies**: P0 Reserved Bus Validation, P1 Combine Mode Compatibility
**Spec Reference**: 11-Roadmap.md line 26 • **Status Reference**: STATUS-20251221-133500.md lines 71-100

### Description

Make TypeDesc the single source of truth for all type validation. Currently TypeDesc is descriptive metadata; it should be enforced as authoritative contract. This requires refactoring port declarations and connection validation.

**Currently**:
- Ports declared with SlotType strings (`"Signal<number>"`)
- TypeDesc derived from SlotType via lookup table
- Connection validation uses string matching

**Target**:
- Ports declared with TypeDesc objects
- SlotType becomes display sugar, not authority
- Connection validation uses TypeDesc compatibility checks

### Acceptance Criteria

- [ ] Refactor BlockDefinition to use TypeDesc for input/output declarations (not SlotType strings)
- [ ] Update `isDirectlyCompatible()` to use TypeDesc as primary check
- [ ] Update connection validation to check TypeDesc match (world + domain)
- [ ] Add `E_TYPE_DESC_MISMATCH` diagnostic for incompatible TypeDesc connections
- [ ] Migrate all block definitions to use TypeDesc declarations
- [ ] Add backward compatibility layer for existing SlotType strings during transition
- [ ] Add test coverage: Connect signal:number to signal:phase → expect TypeDesc error
- [ ] Add test coverage: Connect field:vec2 to signal:number → expect world mismatch error
- [ ] Update adapter/lens system to work with TypeDesc compatibility checks

### Technical Notes

**This is a LARGE refactor**. Consider phased approach:

**Phase 1: Add TypeDesc as primary field**
- Add `typeDesc: TypeDesc` field to PortDefinition
- Keep `slotType: SlotType` as deprecated fallback
- Update factory functions to accept either

**Phase 2: Migrate block definitions**
- Update all blocks in `src/editor/blocks/` to use typeDesc
- Auto-generate slotType from typeDesc for display

**Phase 3: Update validators**
- Change `areSlotTypesCompatible()` to use TypeDesc
- Add strict TypeDesc matching with clear error messages

**Phase 4: Remove SlotType**
- Deprecate SlotType entirely
- Use TypeDesc everywhere

**Risk**: High impact across entire codebase. Requires careful testing and migration strategy.

---

## [P3] Multiple Publisher Validation for Control Buses

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0 Reserved Bus Validation
**Spec Reference**: 03-Buses.md lines 148-150 • **Status Reference**: None (new requirement)

### Description

Enforce single-publisher rule for control-plane buses (phaseA, progress). Multiple publishers to control buses create ambiguity and should be compile warnings or errors.

**User Specification** (from 03-Buses.md):
- Control-plane signals (phaseA, progress): Must not have multiple publishers unless user explicitly changes policy
- Data-plane signals (energy, pulse): Multiple publishers expected and valid

### Acceptance Criteria

- [ ] Define `CONTROL_PLANE_BUSES` set containing bus names that should have single publisher (phaseA, phaseB, progress, palette)
- [ ] Define `DATA_PLANE_BUSES` set containing bus names that expect multiple publishers (energy, pulse)
- [ ] Add `validateMultiplePublishers()` function
- [ ] Emit `W_BUS_MULTIPLE_PUBLISHERS_CONTROL` warning if control-plane bus has >1 publisher
- [ ] Allow multiple publishers for data-plane buses without warning
- [ ] Add test coverage: phaseA bus with 2 publishers → expect warning
- [ ] Add test coverage: energy bus with 5 publishers → expect success (no warning)
- [ ] Add test coverage: User bus (not reserved) with multiple publishers → expect success

### Technical Notes

**Implementation Pattern**:
```typescript
const CONTROL_PLANE_BUSES = new Set(['phaseA', 'phaseB', 'progress', 'palette']);
const DATA_PLANE_BUSES = new Set(['energy', 'pulse']);

private validateMultiplePublishers(patch: PatchDocument): Diagnostic[] {
  const warnings: Diagnostic[] = [];

  for (const bus of patch.buses) {
    if (!CONTROL_PLANE_BUSES.has(bus.name)) continue;

    const publisherCount = patch.busPublishers.filter(p => p.busId === bus.id).length;
    if (publisherCount > 1) {
      warnings.push(createDiagnostic({
        code: 'W_BUS_MULTIPLE_PUBLISHERS_CONTROL',
        severity: 'warn',
        domain: 'compile',
        primaryTarget: { kind: 'bus', busId: bus.id },
        title: `Multiple publishers on control bus`,
        message: `Control-plane bus "${bus.name}" has ${publisherCount} publishers. This may cause ambiguous behavior. Consider using a data-plane bus or explicit priority ordering.`,
        patchRevision: this.patchRevision,
      }));
    }
  }

  return warnings;
}
```

**Diagnostic Code Addition**:
```typescript
export type DiagnosticCode =
  // ... existing codes
  | 'W_BUS_MULTIPLE_PUBLISHERS_CONTROL'  // NEW
```

---

## Dependency Graph

```
┌─────────────────────────────────────┐
│ P0: Reserved Bus Validation         │ ← START HERE
└─────────────────────────────────────┘
              │
              ├───────────────────────────────────┐
              │                                   │
              ▼                                   ▼
┌─────────────────────────────────────┐  ┌──────────────────────────────┐
│ P0: TimeRoot Dependency Validation  │  │ P0: Composite TimeRoot Check │
└─────────────────────────────────────┘  └──────────────────────────────┘
              │
              │
              ▼
┌─────────────────────────────────────┐
│ P1: Combine Mode Compatibility      │
└─────────────────────────────────────┘
              │
              ├───────────────────────────────────┐
              │                                   │
              ▼                                   ▼
┌─────────────────────────────────────┐  ┌──────────────────────────────┐
│ P2: TypeDesc Authority Enforcement  │  │ P3: Multiple Publisher Check │
└─────────────────────────────────────┘  └──────────────────────────────┘
```

**Critical Path**: P0 items must complete before P1/P2/P3

---

## Recommended Sprint Planning

### Sprint 1: Core Contracts (P0)
**Goal**: Establish foundational validation rules
**Duration**: 1 week
**Items**:
1. Reserved Bus Validation Registry (2 days)
2. TimeRoot Upstream Dependency Validation (3 days)
3. Composite TimeRoot Constraint (1 day)

**Deliverable**: All P0 validation rules passing with test coverage

### Sprint 2: Semantic Validation (P1)
**Goal**: Enforce combine mode compatibility
**Duration**: 1 week
**Items**:
1. Combine Mode Compatibility Matrix (3 days)
2. Multiple Publisher Validation (2 days)

**Deliverable**: Complete bus validation with compatibility checks

### Sprint 3: Authority Refactor (P2)
**Goal**: Make TypeDesc authoritative
**Duration**: 2 weeks
**Items**:
1. Phase 1: Add TypeDesc as primary field (3 days)
2. Phase 2: Migrate block definitions (4 days)
3. Phase 3: Update validators (3 days)
4. Phase 4: Remove SlotType (2 days)

**Deliverable**: TypeDesc as single source of truth

---

## Risk Assessment

### High Risk Items

**P2: TypeDesc Authority Enforcement**
- **Risk**: Breaking change across entire codebase
- **Impact**: 100+ block definitions need migration
- **Mitigation**: Phased approach with backward compatibility layer
- **Contingency**: Keep as P2, defer to WP1 if blocked

### Medium Risk Items

**P0: TimeRoot Dependency Validation**
- **Risk**: Ambiguity in whitelist definition (Config vs Signal world)
- **Impact**: May reject valid patches or allow invalid ones
- **Mitigation**: Clear spec documentation and conservative whitelist
- **Contingency**: Start with strict whitelist, relax if needed

### Low Risk Items

**P0: Reserved Bus Validation**
- **Risk**: Low - well-defined spec, isolated change
- **Impact**: Only affects bus creation/validation
- **Mitigation**: Comprehensive test coverage

**P0: Composite TimeRoot Constraint**
- **Risk**: Low - simple check, clear error case
- **Impact**: Only affects composite definitions
- **Mitigation**: Clear error messages

---

## Golden Patch Checkpoint

**Target**: "Patch loads, validates, and produces intelligible errors until time/runtime exists."

**Validation Checklist**:
- [ ] Breathing Constellation patch with correct reserved buses → compiles successfully
- [ ] Patch with phaseA bus (wrong type) → clear compile error with diagnostic
- [ ] Patch with multiple TimeRoots → clear error
- [ ] Patch with TimeRoot depending on NumberSource → clear error
- [ ] Patch with signal:phase bus using combineMode='sum' → clear error
- [ ] All diagnostics include primaryTarget, clear message, and suggested actions

---

## File Impact Summary

### New Files
- `src/editor/semantic/busContracts.ts` - Reserved bus registry
- `src/editor/semantic/compositeValidator.ts` - Composite validation (optional)

### Modified Files
- `src/editor/semantic/validator.ts` - Add 4+ new validation rules
- `src/editor/diagnostics/types.ts` - Add 6+ new DiagnosticCode entries
- `src/editor/stores/CompositeStore.ts` - Integrate composite validation
- `src/editor/types.ts` - Potentially refactor PortDefinition for TypeDesc (P2 only)

### Test Files
- `src/editor/semantic/__tests__/validator.test.ts` - Expand with new validation tests
- `src/editor/semantic/__tests__/busContracts.test.ts` - NEW
- `src/editor/semantic/__tests__/compositeValidator.test.ts` - NEW

---

## Success Metrics

**Completion Criteria**:
1. All P0 validation rules implemented with test coverage >90%
2. All new DiagnosticCode entries documented
3. Golden Patch validation checklist passes
4. Zero regressions in existing validation tests
5. Spec docs updated if implementation required changes

**Quality Gates**:
- No compile errors in TypeScript (strict mode)
- All tests passing (`just test`)
- No ESLint errors (`just lint`)
- Diagnostics system shows clear, actionable messages in UI

---

## Open Questions / Ambiguities

### 1. Reserved Bus Semantics Field
**Question**: Must reserved buses match semantics field exactly, or only world+domain?

**Options**:
- A. Exact match required (semantics='primary' for phaseA)
- B. Semantics optional (only world+domain enforced)

**Recommendation**: A (exact match) - Spec is explicit about semantics in TypeDesc contracts

### 2. TimeRoot Input Whitelist
**Question**: Which input types are allowed for TimeRoot?

**Current Understanding**:
- ✅ Allowed: DefaultSource, Config params, UIControl, ExternalIO
- ❌ Forbidden: Evaluated block outputs (Signal/Field world)

**Needs Clarification**: Are scalar constants from NumberSource allowed? Or only compile-time Config?

**Recommendation**: Strict whitelist initially, relax if users encounter valid use cases

### 3. Combine Mode Enforcement Strictness
**Question**: Should reserved bus combine mode be error or warning?

**Options**:
- A. Hard error (cannot compile with wrong mode)
- B. Warning (compiles but shows diagnostic)

**Recommendation**: A (hard error) - User spec says "MUST match canonical default"

---

## Next Steps

1. **Clarify ambiguities** with user/spec review
2. **Implement Sprint 1** (P0 items) - estimated 1 week
3. **Run Golden Patch validation** after Sprint 1
4. **Proceed to Sprint 2** if P0 acceptance criteria met
5. **Defer P2** to separate work package if time constraints exist (can be WP0.5)
