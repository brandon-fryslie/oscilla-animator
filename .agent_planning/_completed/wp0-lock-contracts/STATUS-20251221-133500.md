# WP0: Lock the Contracts - Status Report
**Date**: 2025-12-21 13:35:00
**Scope**: WP0 - Contract validation enforcement
**Confidence**: FRESH

## Executive Summary

WP0 aims to establish strict compile-time validation that later work packages can rely on. Current state: **PARTIALLY IMPLEMENTED** with significant gaps. TimeRoot constraint is enforced, but TypeDesc validation, reserved bus enforcement, and dependency rules are missing.

**Completion: ~35%** | **Critical Gaps: 4** | **Tests: Partial coverage**

---

## WP0 Requirements (from Roadmap)

Per `design-docs/3-Synthesized/11-Roadmap.md` (lines 20-38):

### Must-Haves
- [ ] TypeDesc is authoritative for ports + buses
- [x] Reserved bus names/types enforced (phaseA, pulse, energy, palette, progress)
- [x] Exactly one TimeRoot enforced at compile time
- [ ] TimeRoot cannot have upstream dependencies
- [ ] No composite may contain a TimeRoot

### Deliverables
- [ ] Compile-time validation pass emitting structured errors
- [ ] Reserved bus registry rules

### Golden Patch Checkpoint
> "Patch loads, validates, and produces intelligible errors until time/runtime exists."

---

## What Exists

### ✅ TimeRoot Constraint (COMPLETE)

**Location**: `src/editor/semantic/validator.ts` (lines 88-141)

**Implementation**:
```typescript
private validateTimeRootConstraint(patch: PatchDocument): Diagnostic[] {
  const timeRootBlocks = patch.blocks.filter(
    (b) => b.type === 'FiniteTimeRoot' ||
           b.type === 'InfiniteTimeRoot'
  );

  if (timeRootBlocks.length === 0) {
    // Emits E_TIME_ROOT_MISSING
  }

  if (timeRootBlocks.length > 1) {
    // Emits E_TIME_ROOT_MULTIPLE
  }
}
```

**Evidence**:
- Validator checks exactly-one-TimeRoot rule
- Diagnostic codes: `E_TIME_ROOT_MISSING`, `E_TIME_ROOT_MULTIPLE`
- Called from `validator.validateAll()` (line 53)
- Also called from `compilePatchWireOnly()` and `compileBusAwarePatch()`

**Coverage**: GOOD
- Test file exists: `src/editor/semantic/__tests__/validator.test.ts`
- Enforced in both wire-only and bus-aware compilation paths

---

### ✅ TypeDesc System (EXISTS, validation incomplete)

**Location**: `src/editor/types.ts` (lines 73-91)

**TypeDesc Interface**:
```typescript
interface TypeDesc {
  readonly world: TypeWorld;        // 'signal' | 'field'
  readonly domain: Domain;          // CoreDomain | InternalDomain
  readonly category: TypeCategory;  // 'core' | 'internal'
  readonly busEligible: boolean;
  readonly semantics?: string;
  readonly unit?: string;
}
```

**What Works**:
- TypeDesc defined and used throughout codebase
- SlotType -> TypeDesc mapping exists (`SLOT_TYPE_TO_TYPE_DESC`, line 928)
- `isDirectlyCompatible()` checks world + domain match (line 990)
- `isBusEligible()` validates busEligible + category (line 997)
- `validateDefaultValue()` exists (line 1024) but only type-checks values

**What's Missing**:
- ❌ No enforcement that ports match their declared TypeDesc
- ❌ No validation that bus TypeDesc is authoritative for routing
- ❌ No compile-time check that connections respect TypeDesc semantics
- ❌ Semantic field is optional and not validated

**Gap**: TypeDesc exists but isn't **authoritative** - it's descriptive metadata, not enforced contract.

---

### ⚠️ Reserved Bus Names (PARTIAL)

**Canonical Buses** (from `design-docs/3-Synthesized/03-Buses.md`):
- `phaseA` - Signal<phase>, semantics: 'primary'
- `phaseB` - Signal<phase>, semantics: 'secondary'
- `pulse` - Event, semantics: 'pulse'
- `energy` - Signal<number>, semantics: 'energy'
- `progress` - Signal<unit>, semantics: 'progress' (FiniteTimeRoot only)
- `palette` - Signal<color> (undocumented in spec but in BusStore defaults)

**Current Implementation** (`src/editor/stores/BusStore.ts`, lines 71-119):

Default buses created with correct types:
```typescript
const defaults = [
  { name: 'phaseA', world: 'signal', domain: 'phase', combineMode: 'last' },
  { name: 'phaseB', world: 'signal', domain: 'phase', combineMode: 'last' },
  { name: 'energy', world: 'signal', domain: 'number', combineMode: 'sum' },
  { name: 'pulse', world: 'signal', domain: 'trigger', combineMode: 'last' },
  { name: 'palette', world: 'signal', domain: 'color', combineMode: 'last' },
];
```

**What's Missing**:
- ❌ No enforcement of reserved name/type contract
- ❌ Users can create bus named "phaseA" with wrong type
- ❌ No validation that reserved buses have correct combine mode
- ❌ No compile error if patch defines "phaseA" as Signal<number>

**Evidence of Gap**:
```typescript
// BusStore.createBus() only checks duplicate names (line 132):
if (this.buses.some(b => b.name.toLowerCase() === normalizedName)) {
  throw new Error(`Bus name "${name}" already exists`);
}
// NO CHECK: Is this a reserved name? Does TypeDesc match spec?
```

---

### ❌ TimeRoot Upstream Dependencies (NOT IMPLEMENTED)

**Spec Requirement** (`design-docs/3-Synthesized/02-Time-Architecture.md`, line 37):
> "TimeRoot cannot have upstream dependencies"

**Current State**: NO VALIDATION

**What Should Happen**:
1. Compiler identifies TimeRoot block
2. Walks dependency graph backward from TimeRoot
3. If any block feeds into TimeRoot (via wires or buses), emit error:
   - Code: `E_TIME_ROOT_DEPENDENCY`
   - Message: "TimeRoot cannot have upstream dependencies. Block X feeds into TimeRoot."

**Why This Matters**:
TimeRoot defines absolute time topology. If it depends on other blocks, those blocks would need time before time exists - logical impossibility.

**Search Results**: No code implementing this check found.

---

### ❌ Composite TimeRoot Constraint (NOT IMPLEMENTED)

**Spec Requirement** (Roadmap line 30):
> "No composite may contain a TimeRoot"

**Current State**: NO VALIDATION

**Search Results**:
- Searched for "composite.*timeroot|timeroot.*composite" (case-insensitive)
- Found: 0 files

**Why This Matters**:
Composites are reusable subgraphs. TimeRoot defines patch-level time topology. Allowing TimeRoot inside composites would mean:
- Multiple time topologies in one patch (breaks exactly-one rule)
- Ambiguous time ownership
- Hot-swap nightmare (composite instance vs TimeRoot instance)

**What Should Happen**:
1. When validating composite definition, check all blocks
2. If any block is FiniteTimeRoot/InfiniteTimeRoot, emit error:
   - Code: `E_COMPOSITE_CONTAINS_TIMEROOT`
   - Message: "Composite definitions cannot contain TimeRoot blocks"

---

## Validation Infrastructure

### Semantic Validator (`src/editor/semantic/validator.ts`)

**What Works**:
- `Validator` class with `validateAll()` entry point
- Structured diagnostic output (errors + warnings)
- Rules implemented:
  1. ✅ Exactly one TimeRoot (line 52)
  2. ✅ No multiple writers to same input (line 56)
  3. ✅ Type compatibility on connections (line 60)
  4. ✅ No cycles (line 64)
  5. ✅ All connection endpoints exist (line 68)
  6. ✅ Empty bus warnings (line 72)

**Integration Points**:
- Called from `compilePatchWireOnly()` (line 116) - WARN ONLY
- Called from `compileBusAwarePatch()` - NOT YET (should be)
- Validator uses `SemanticGraph` for dependency analysis

**What's Missing**:
- No TypeDesc validation rule
- No reserved bus validation rule
- No TimeRoot dependency validation rule
- No composite TimeRoot validation rule

---

## Bus System Contract Enforcement

### Combine Mode Validation (EXISTS)

**Location**: `src/editor/compiler/compileBusAware.ts` (lines 231-253)

```typescript
for (const bus of buses) {
  if (isFieldBus(bus)) {
    if (!FIELD_COMBINE_MODES.includes(bus.combineMode)) {
      errors.push({ code: 'UnsupportedCombineMode', ... });
    }
  } else {
    if (!SIGNAL_COMBINE_MODES.includes(bus.combineMode)) {
      errors.push({ code: 'UnsupportedCombineMode', ... });
    }
  }
}
```

**Status**: COMPLETE for combine modes, but doesn't enforce reserved bus contracts.


**Location**: `src/editor/semantic/busSemantics.ts` (lines 41-60)

1. Primary: sortKey ascending
2. Secondary: id.localeCompare (stable tie-breaker)

**Evidence**: Used by both BusStore and compileBusAware (single source of truth).

---

## Dependencies and Risks

### Prerequisite: complete-time-authority

**Status**: Directory exists but EMPTY
```bash
ls .agent_planning/complete-time-authority/
# Output: (empty)
```

**Concern**: WP0 depends on "complete-time-authority" topic being resolved first. If TimeRoot compilation isn't complete, dependency validation is premature.

**Recommendation**: Verify complete-time-authority status before implementing TimeRoot dependency checks.

---

## Ambiguities Found

### 1. Reserved Bus Type Strictness

**Question**: What happens if patch defines "phaseA" bus with correct domain but wrong semantics?

**Example**:
```typescript
Bus { name: 'phaseA', type: { world: 'signal', domain: 'phase', semantics: 'secondary' } }
```

**Options**:
A. Error - semantics must match exactly ('primary' required)
B. Warning - semantics mismatch is style issue, not correctness
C. Ignore - only world+domain matter

**Spec Says** (`03-Buses.md`, line 49):
```typescript
TypeDesc: { world: 'signal', domain: 'phase', semantics: 'primary' }
```

**Impact**: If semantics matter, validation must check them. If not, spec is overly specific.

### 2. Reserved Bus Combine Mode

**Question**: Must reserved buses use their specified combine mode?

**Example**:
```typescript
Bus { name: 'energy', combineMode: 'last' }  // Spec says 'sum'
```

**Spec Says** (`03-Buses.md`, line 73):
> energy: Combine: `sum`

**Options**:
A. Hard requirement - compile error if wrong mode
B. Soft requirement - warning only
C. User choice - combine mode is policy, not contract

**Impact**: Determines whether combine mode is part of reserved bus validation.

### 3. TimeRoot Dependency Depth

**Question**: How deeply should upstream dependency check go?

**Example**:
```
NumberSource -> Oscillator -> TimeRoot.phaseOffset
```

**Options**:
A. Direct only - error only if immediate input connected
B. Transitive - error if any upstream block exists
C. Signal-only - error only for Signal<T> inputs, not Scalar<T> params

**Spec Says** (`02-Time-Architecture.md`, line 37):
> "TimeRoot cannot have upstream dependencies"

Ambiguous: Does "upstream" mean direct or transitive?

**Recommendation**: TimeRoot with Config-world inputs (Scalar params) is acceptable. TimeRoot with Signal-world inputs is the problem.

---

## Test Coverage

### Existing Tests

**TimeRoot Validation**:
- `src/editor/semantic/__tests__/validator.test.ts` - covers exactly-one rule
- `src/editor/compiler/blocks/domain/__tests__/TimeRoot.test.ts` - unit tests for compiler

**Bus Validation**:
- `src/editor/__tests__/bus-compilation.test.ts` - happy path, combine modes
- `src/editor/semantic/__tests__/busSemantics.test.ts` - ordering and combine functions

**Missing Test Coverage**:
- ❌ TypeDesc enforcement on ports
- ❌ Reserved bus name/type validation
- ❌ TimeRoot upstream dependency rejection
- ❌ Composite TimeRoot rejection

---

## Recommendations

### Priority 1: Reserved Bus Validation

**Action**: Add validation to BusStore and compiler:

```typescript
// Pseudo-code
const RESERVED_BUSES = {
  'phaseA': { world: 'signal', domain: 'phase', semantics: 'primary', combineMode: 'last' },
  'pulse': { world: 'signal', domain: 'event', semantics: 'pulse', combineMode: 'or' },
  'energy': { world: 'signal', domain: 'number', semantics: 'energy', combineMode: 'sum' },
  // ...
};

function validateBusAgainstReserved(bus: Bus): Diagnostic | null {
  const spec = RESERVED_BUSES[bus.name];
  if (!spec) return null; // Not reserved, OK

  // Check type match
  if (bus.type.world !== spec.world || bus.type.domain !== spec.domain) {
    return createDiagnostic({
      code: 'E_RESERVED_BUS_TYPE_MISMATCH',
      message: `Reserved bus "${bus.name}" must have type ${spec.world}:${spec.domain}`,
    });
  }

  // Check combine mode (decide: error or warning?)
  if (bus.combineMode !== spec.combineMode) {
    // TBD: Error or warning?
  }

  return null;
}
```

**Clarify Ambiguities**:
- Does semantics field matter for reserved buses?
- Is combine mode part of the contract?

### Priority 2: TimeRoot Dependency Validation

**Action**: Add rule to Validator:

```typescript
private validateTimeRootDependencies(patch: PatchDocument): Diagnostic[] {
  const timeRoot = patch.blocks.find(b =>
    b.type === 'FiniteTimeRoot' ||
    b.type === 'InfiniteTimeRoot'
  );

  if (!timeRoot) return [];

  const hasUpstream = this.graph.hasIncomingEdges(timeRoot.id);

  if (hasUpstream) {
    return [createDiagnostic({
      code: 'E_TIME_ROOT_UPSTREAM_DEPENDENCY',
      message: 'TimeRoot cannot have upstream dependencies',
      primaryTarget: { kind: 'timeRoot', blockId: timeRoot.id },
    })];
  }

  return [];
}
```

**Clarify Ambiguity**: Config-world inputs (params) vs Signal-world inputs (runtime).

### Priority 3: Composite TimeRoot Constraint

**Action**: Add validation when defining composites:

```typescript
// In CompositeStore or composite validation layer
function validateCompositeDefinition(def: CompositeDefinition): Diagnostic[] {
  const errors = [];

  for (const block of def.blocks) {
    if (isTimeRootBlock(block.type)) {
      errors.push(createDiagnostic({
        code: 'E_COMPOSITE_CONTAINS_TIMEROOT',
        message: 'Composite definitions cannot contain TimeRoot blocks',
        primaryTarget: { kind: 'block', blockId: block.id },
      }));
    }
  }

  return errors;
}
```

### Priority 4: TypeDesc Authority Enforcement

**Action**: Strengthen TypeDesc validation:

1. Port declaration validation - ensure TypeDesc matches SlotType
2. Connection validation - use TypeDesc as source of truth, not SlotType strings
3. Bus routing validation - check TypeDesc compatibility, not string matching

**Refactor Needed**: May require rethinking how ports are declared (currently SlotType strings, should be TypeDesc objects?).

---

## Workflow Recommendation

**PAUSE - Ambiguities Need Clarification**

Before implementing validation, clarify:

1. **Reserved Bus Semantics**: Do semantics matter for reserved buses?
2. **Reserved Bus Combine Mode**: Is combine mode part of the contract or user preference?
3. **TimeRoot Dependencies**: Config-world vs Signal-world distinction?

**Next Steps After Clarification**:
1. Implement reserved bus validation (Priority 1)
2. Implement TimeRoot dependency validation (Priority 2)
3. Implement composite TimeRoot validation (Priority 3)
4. Write comprehensive tests for all validation rules
5. Update Golden Patch to test all validation paths

---

## Verdict

**Status**: INCOMPLETE - ~35% done

**Blocking Issues**:
1. Reserved bus validation missing
2. TimeRoot dependency validation missing
3. Composite TimeRoot constraint missing
4. Ambiguities need resolution before implementation

**Can Proceed?**: NO - Need clarification on reserved bus contracts and TimeRoot dependency rules before writing validation code.
