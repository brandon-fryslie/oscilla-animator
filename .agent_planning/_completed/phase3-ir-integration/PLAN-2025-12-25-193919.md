# Phase 3 Bridge Compiler - Sprint 1 Implementation Plan

**Generated:** 2025-12-25-193919
**Source:** STATUS-2025-12-25-200000.md
**Scope:** Core Compilation Passes (Pass 2, 3, 4-5)

---

## Executive Summary

**Current State:** 35% complete - IRBuilder and Pass 1 are done with 38 passing tests.

**Sprint 1 Goal:** Complete the core compilation passes (Pass 2-5) that establish the semantic foundation for dual-emit compilation. These passes transform NormalizedPatch into a validated, cycle-checked dependency graph ready for block lowering.

**Total Work Items:** 10 (P0: 9, P1: 1)

**Dependencies:**
- Pass 2 builds on Pass 1 (COMPLETE)
- Pass 3 requires Pass 2 output
- Pass 4-5 require Pass 3 output
- All passes must be completed before dual-emit compiler (Sprint 2)

**Recommended Approach:** Implement passes sequentially with full test coverage at each step. Use golden patch tests to verify end-to-end pipeline after Pass 5.

---

## Backlog by Priority

### P0-1: Pass 2 - Type Graph Construction

**Status:** Not Started
**Effort:** Medium (3-5 days)
**Dependencies:** Pass 1 (COMPLETE)
**Spec Reference:** 15-Canonical-Lowering-Pipeline.md § Pass 2 • **Status Reference:** STATUS-2025-12-25-200000.md § Topic 1

#### Description

Implement Pass 2 to establish types for every slot and bus using unified TypeDesc. This pass converts editor SlotType strings to IR TypeDesc records, validates bus type eligibility, checks reserved bus constraints, and precomputes type conversion paths using the adapter/lens registry.

**Key Insight from STATUS:** The editor has `TypeDesc` with `category` and `busEligible` fields that the IR `TypeDesc` lacks. This pass must bridge that gap by computing eligibility at compile time.

#### Acceptance Criteria (REQUIRED)

- [ ] Function `pass2TypeGraph(normalized: NormalizedPatch): TypedPatch` exists in `src/editor/compiler/passes/pass2-types.ts`
- [ ] All SlotType strings are converted to IR TypeDesc using `slotTypeToTypeDesc()` helper
- [ ] Bus eligibility validation implemented: rejects types with `busEligible === false`
- [ ] Reserved bus type validation enforces phaseA/pulse/energy/palette constraints per `busContracts.ts`
- [ ] Conversion path precomputation finds adapter/lens chains for incompatible wire types
- [ ] Errors emitted: `PortTypeUnknown`, `BusIneligibleType`, `ReservedBusTypeViolation`, `NoConversionPath`
- [ ] Test suite `pass2-types.test.ts` with minimum 12 tests covering all error cases and conversion paths
- [ ] TypedPatch includes `busTypes: Map<string, TypeDesc>` and `conversionPaths: Map<Connection, string[]>`

#### Technical Notes

**SlotType → TypeDesc Mapping:**
```typescript
function slotTypeToTypeDesc(slotType: string): TypeDesc {
  // "Signal<number>" -> { world: 'signal', domain: 'number' }
  // "Field<vec2>" -> { world: 'field', domain: 'vec2' }
  const match = slotType.match(/^(\w+)<(\w+)>$/);
  if (match) {
    return { world: match[1].toLowerCase(), domain: match[2] };
  }
  throw new Error(`Unknown slot type: ${slotType}`);
}
```

**Bus Eligibility Check:**
- Editor TypeDesc has `busEligible: boolean` property
- IR TypeDesc does not have this property
- Solution: Compute eligibility based on world/domain rules:
  - `world === 'signal'` → always bus-eligible
  - `world === 'field'` → bus-eligible only if domain is scalar (number, bool, etc.)

**Adapter/Lens Registry Access:**
- Located at `src/editor/lenses/LensRegistry.ts`
- Use `findConversionPath(fromType, toType): TransformStepIR[]` to get chain
- Cache results in `TypedPatch.conversionPaths` map

**Reserved Bus Constraints:**
- Defined in `src/editor/semantic/busContracts.ts`
- phaseA: must be `Signal<number>` 0..1
- pulse: must be `Signal<bool>` event trigger
- energy: must be `Signal<number>` 0..∞
- palette: must be `Signal<color>` or `Field<color>`

---

### P0-2: Pass 3 - Time Topology Inference

**Status:** Not Started
**Effort:** Medium (3-5 days)
**Dependencies:** Pass 2
**Spec Reference:** 15-Canonical-Lowering-Pipeline.md § Pass 3 • **Status Reference:** STATUS-2025-12-25-200000.md § Topic 2

#### Description

Implement Pass 3 to discover the single TimeRoot block, validate time constraints, generate canonical time signals using IRBuilder, and produce the authoritative TimeModelIR record. This pass makes time topology explicit and eliminates runtime time model inference.

**Integration Note:** The existing `compileBusAware.ts:inferTimeModel()` already extracts TimeModel from TimeRoot params. Pass 3 formalizes this + emits IR nodes for time signals.

#### Acceptance Criteria (REQUIRED)

- [ ] Function `pass3TimeTopology(typed: TypedPatch): TimeResolvedPatch` exists in `src/editor/compiler/passes/pass3-time.ts`
- [ ] Single TimeRoot discovery: finds exactly one block with `capability === 'time'`
- [ ] TimeRoot validation: errors if zero or multiple TimeRoots found
- [ ] Canonical time signals generated using IRBuilder: `tAbsMs`, `tModelMs`, `phase01` (cyclic only), `wrapEvent` (cyclic only)
- [ ] TimeModelIR record produced: kind (finite/cyclic/infinite), durationMs/periodMs/windowMs as appropriate
- [ ] TimeResolvedPatch includes `timeModel`, `timeRootIndex`, and `timeSignals: TimeSignals`
- [ ] Errors emitted: `MissingTimeRoot`, `MultipleTimeRoots`, `TimeRootViolation`
- [ ] Test suite `pass3-time.test.ts` with minimum 10 tests covering finite/cyclic/infinite time models


#### Technical Notes

**TimeRoot Discovery:**
```typescript
const timeRoots = typed.blocks.filter(b =>
  b.definition.capability === 'time'
);

if (timeRoots.length === 0) {
  throw new Error('MissingTimeRoot');
} else if (timeRoots.length > 1) {
  throw new Error(`MultipleTimeRoots: ${timeRoots.map(r => r.id).join(', ')}`);
}
```

**Time Signal Generation:**
```typescript
const builder = new IRBuilderImpl();

const tAbsMs = builder.sigTimeAbsMs();
const tModelMs = builder.sigMap(tAbsMs, timeModelMappingFn);
const phase01 = isCyclic ? builder.sigPhase01() : undefined;
const wrapEvent = isCyclic ? builder.sigWrapEvent() : undefined;

const timeSignals: TimeSignals = {
  tAbsMs,
  tModelMs,
  phase01,
  wrapEvent
};
```

**TimeModel Extraction:**
```typescript
// Finite: durationMs from block params
if (timeRoot.blockType === 'FiniteTimeRoot') {
  timeModel = {
    kind: 'finite',
    durationMs: timeRoot.params.duration
  };
}

// Cyclic: periodMs + mode from block params

  timeModel = {
    kind: 'cyclic',
    periodMs: timeRoot.params.period,
    mode: timeRoot.params.mode // 'loop' or 'pingpong'
  };
}

// Infinite: default window
if (timeRoot.blockType === 'InfiniteTimeRoot') {
  timeModel = {
    kind: 'infinite',
    windowMs: 30000
  };
}
```

**Constraint Validation:**
- TimeRoot must not have illegal upstream dependencies (e.g., can't depend on blocks that depend on time)
- This is a graph validation - defer to Pass 4-5 or add lightweight check here

---

### P0-3: Pass 4 - Dependency Graph Construction

**Status:** Not Started
**Effort:** Medium (3-5 days)
**Dependencies:** Pass 3
**Spec Reference:** 15-Canonical-Lowering-Pipeline.md § Pass 4 • **Status Reference:** STATUS-2025-12-25-200000.md § Topic 3

#### Description

Implement Pass 4 to build a unified dependency graph with BlockEval and BusValue nodes, and edges for wires, publishers, listeners, and time dependencies. This graph is used for topological scheduling and cycle validation.

**Key Insight:** The existing `compileBusAware.ts:topoSortBlocksWithBuses()` does similar work but produces a flat order. Pass 4 needs the graph structure for SCC analysis.

#### Acceptance Criteria (REQUIRED)

- [ ] Function `pass4DepGraph(timeResolved: TimeResolvedPatch): DepGraph` exists in `src/editor/compiler/passes/pass4-depgraph.ts`
- [ ] BlockEval nodes created for each block: `{ kind: 'BlockEval', blockIndex }`
- [ ] BusValue nodes created for each bus: `{ kind: 'BusValue', busIndex }`
- [ ] Wire edges added: `fromBlock → toBlock`
- [ ] Publisher edges added: `fromBlock → busValue`
- [ ] Listener edges added: `busValue → toBlock`
- [ ] Time edges added: `TimeRoot → all time-dependent blocks` (optional - may defer to Pass 3)
- [ ] DepGraph structure matches types in `ir/patches.ts`: `{ nodes, edges }`
- [ ] Test suite `pass4-depgraph.test.ts` with minimum 8 tests covering node/edge construction
- [ ] Errors emitted: `DanglingConnection`, `DanglingBindingEndpoint`

#### Technical Notes

**Node Construction:**
```typescript
const nodes: DepNode[] = [];

for (const block of timeResolved.blocks) {
  const blockIdx = timeResolved.blockIndexMap.get(block.id)!;
  nodes.push({ kind: 'BlockEval', blockIndex: blockIdx });
}

for (let busIdx = 0; busIdx < timeResolved.buses.length; busIdx++) {
  nodes.push({ kind: 'BusValue', busIndex: busIdx as BusIndex });
}
```

**Edge Construction:**
```typescript
const edges: DepEdge[] = [];

// Wires: block → block
for (const wire of timeResolved.wires) {
  const fromBlockIdx = timeResolved.blockIndexMap.get(wire.from.blockId)!;
  const toBlockIdx = timeResolved.blockIndexMap.get(wire.to.blockId)!;
  edges.push({
    from: { kind: 'BlockEval', blockIndex: fromBlockIdx },
    to: { kind: 'BlockEval', blockIndex: toBlockIdx }
  });
}

// Publishers: block → bus
for (const pub of timeResolved.publishers) {
  const fromBlockIdx = timeResolved.blockIndexMap.get(pub.from.blockId)!;
  const busIdx = timeResolved.buses.findIndex(b => b.id === pub.busId) as BusIndex;
  edges.push({
    from: { kind: 'BlockEval', blockIndex: fromBlockIdx },
    to: { kind: 'BusValue', busIndex: busIdx }
  });
}

// Listeners: bus → block
for (const lis of timeResolved.listeners) {
  const toBlockIdx = timeResolved.blockIndexMap.get(lis.to.blockId)!;
  const busIdx = timeResolved.buses.findIndex(b => b.id === lis.busId) as BusIndex;
  edges.push({
    from: { kind: 'BusValue', busIndex: busIdx },
    to: { kind: 'BlockEval', blockIndex: toBlockIdx }
  });
}
```

**Dangling Reference Detection:**
- Wire references non-existent block → `DanglingConnection`
- Publisher/Listener references non-existent bus → `DanglingBindingEndpoint`

---

### P0-4: Pass 5 - Cycle Validation (SCC)

**Status:** Not Started
**Effort:** High (1-2 weeks)
**Dependencies:** Pass 4
**Spec Reference:** 15-Canonical-Lowering-Pipeline.md § Pass 5 • **Status Reference:** STATUS-2025-12-25-200000.md § Topic 3

#### Description

Implement Pass 5 to detect strongly connected components (SCCs) in the dependency graph and validate that any non-trivial cycles have a state boundary block. This ensures feedback loops are legal under the memory semantics.

**Algorithm Choice:** Tarjan's SCC algorithm is preferred (single-pass, O(V+E) time). Kosaraju is acceptable but requires two passes.

#### Acceptance Criteria (REQUIRED)

- [ ] Function `pass5CycleValidation(depGraph: DepGraph): AcyclicOrLegalGraph` exists in `src/editor/compiler/passes/pass5-scc.ts`
- [ ] Tarjan's SCC algorithm implemented (or Kosaraju as fallback)
- [ ] Trivial SCCs detected: size==1 and no self-loop → skip validation
- [ ] Non-trivial SCCs validated: must contain at least one block with `capability === 'state'` AND `breaksCombinatorialCycle === true`
- [ ] State boundary detection: checks block registry for `breaksCombinatorialCycle` property
- [ ] AcyclicOrLegalGraph structure includes `{ graph, sccs, errors }`
- [ ] Errors emitted: `IllegalCycle`, `CycleWithoutStateBoundary`
- [ ] Test suite `pass5-scc.test.ts` with minimum 12 tests covering trivial/non-trivial SCCs, legal/illegal cycles
- [ ] Self-loop detection for trivial SCCs

#### Technical Notes

**Tarjan's Algorithm Sketch:**
```typescript
function tarjanSCC(graph: DepGraph): SCC[] {
  const sccs: SCC[] = [];
  const index = new Map<DepNode, number>();
  const lowlink = new Map<DepNode, number>();
  const onStack = new Set<DepNode>();
  const stack: DepNode[] = [];
  let indexCounter = 0;

  function strongConnect(node: DepNode) {
    index.set(node, indexCounter);
    lowlink.set(node, indexCounter);
    indexCounter++;
    stack.push(node);
    onStack.add(node);

    // Visit successors
    for (const edge of graph.edges.filter(e => nodesEqual(e.from, node))) {
      const successor = edge.to;
      if (!index.has(successor)) {
        strongConnect(successor);
        lowlink.set(node, Math.min(lowlink.get(node)!, lowlink.get(successor)!));
      } else if (onStack.has(successor)) {
        lowlink.set(node, Math.min(lowlink.get(node)!, index.get(successor)!));
      }
    }

    // Root of SCC
    if (lowlink.get(node) === index.get(node)) {
      const scc: DepNode[] = [];
      let w: DepNode;
      do {
        w = stack.pop()!;
        onStack.delete(w);
        scc.push(w);
      } while (!nodesEqual(w, node));

      const hasStateBoundary = scc.some(n =>
        n.kind === 'BlockEval' && blockHasCapability(n.blockIndex, 'state')
      );
      sccs.push({ nodes: scc, hasStateBoundary });
    }
  }

  for (const node of graph.nodes) {
    if (!index.has(node)) {
      strongConnect(node);
    }
  }

  return sccs;
}
```

**State Boundary Validation:**
- Block must have `capability: 'state'` in its definition
- Block must declare `breaksCombinatorialCycle: true` in registry
- Example state blocks: `SampleDelay`, `Integrator`, `FeedbackBuffer`

**Self-Loop Detection:**
```typescript
function hasSelfLoop(graph: DepGraph, node: DepNode): boolean {
  return graph.edges.some(e => nodesEqual(e.from, node) && nodesEqual(e.to, node));
}
```

---

### P0-5: Pipeline Integration Test

**Status:** Not Started
**Effort:** Small (1-2 days)
**Dependencies:** Passes 1-5 complete
**Spec Reference:** HANDOFF-3-bridge-compiler.md § Testing Strategy

#### Description

Create end-to-end integration test that runs the full Pass 1-5 pipeline on real patches (including golden patch "Breathing Constellation"). This verifies that all passes work together correctly and the output is well-formed.

#### Acceptance Criteria (REQUIRED)

- [ ] Test file `src/editor/compiler/passes/__tests__/pipeline-integration.test.ts` exists
- [ ] Test runs Pass 1 → Pass 2 → Pass 3 → Pass 4 → Pass 5 on minimal patch
- [ ] Test runs full pipeline on golden patch ("Breathing Constellation")
- [ ] Test validates AcyclicOrLegalGraph structure: nodes, edges, sccs, errors
- [ ] Test checks TimeResolvedPatch has valid TimeModel and TimeSignals
- [ ] Test verifies TypedPatch has conversion paths for type mismatches
- [ ] Test confirms no errors for well-formed patches
- [ ] Test confirms errors for malformed patches (missing TimeRoot, illegal cycle, type mismatch)

#### Technical Notes

**Golden Patch Loading:**
```typescript
import { loadGoldenPatch } from '../../../test-utils/goldenPatches';

describe('Pipeline Integration', () => {
  it('compiles breathing constellation without errors', () => {
    const patch = loadGoldenPatch('breathing-constellation');

    const normalized = pass1Normalize(patch);
    const typed = pass2TypeGraph(normalized);
    const timeResolved = pass3TimeTopology(typed);
    const depGraph = pass4DepGraph(timeResolved);
    const validated = pass5CycleValidation(depGraph);

    expect(validated.errors).toHaveLength(0);
    expect(validated.sccs.length).toBeGreaterThan(0);
  });
});
```

**Minimal Patch Test:**
Create a simple patch with:
- 1 TimeRoot (FiniteTimeRoot)
- 2 pure blocks (e.g., SinOsc, Multiply)
- 1 wire connecting them
- No buses

This tests the happy path with minimal complexity.

---

### P0-6: Pass 2 Error Handling Tests

**Status:** Not Started
**Effort:** Small (1-2 days)
**Dependencies:** P0-1 (Pass 2 implementation)
**Spec Reference:** 15-Canonical-Lowering-Pipeline.md § Pass 2 Errors

#### Description

Create comprehensive test coverage for all Pass 2 error cases: `PortTypeUnknown`, `BusIneligibleType`, `ReservedBusTypeViolation`, `NoConversionPath`. These tests ensure the compiler fails fast with clear error messages.

#### Acceptance Criteria (REQUIRED)

- [ ] Test for `PortTypeUnknown`: slot with unrecognized SlotType string
- [ ] Test for `BusIneligibleType`: bus with `world === 'field'` and non-scalar domain
- [ ] Test for `ReservedBusTypeViolation`: phaseA bus with non-Signal<number> type
- [ ] Test for `ReservedBusTypeViolation`: pulse bus with non-Signal<bool> type
- [ ] Test for `NoConversionPath`: wire from Signal<vec2> to Signal<number> with no adapter
- [ ] All tests verify error message includes context (block ID, slot ID, bus ID)
- [ ] Tests use fixtures for invalid patches

---

### P0-7: Pass 3 Error Handling Tests

**Status:** Not Started
**Effort:** Small (1-2 days)
**Dependencies:** P0-2 (Pass 3 implementation)
**Spec Reference:** 15-Canonical-Lowering-Pipeline.md § Pass 3 Errors

#### Description

Create comprehensive test coverage for all Pass 3 error cases: `MissingTimeRoot`, `MultipleTimeRoots`, `TimeRootViolation`. These tests ensure time topology is validated correctly.

#### Acceptance Criteria (REQUIRED)

- [ ] Test for `MissingTimeRoot`: patch with no blocks having `capability === 'time'`
- [ ] Test for `MultipleTimeRoots`: patch with 2+ TimeRoot blocks
- [ ] Test for `TimeRootViolation`: TimeRoot with illegal upstream dependency (if implemented)
- [ ] Tests for all three TimeModel kinds: finite, cyclic, infinite
- [ ] Test verifies `phase01` and `wrapEvent` are only generated for cyclic models
- [ ] All tests verify error message includes context (TimeRoot IDs)

---

### P0-8: Pass 4 Error Handling Tests

**Status:** Not Started
**Effort:** Small (1-2 days)
**Dependencies:** P0-3 (Pass 4 implementation)
**Spec Reference:** 15-Canonical-Lowering-Pipeline.md § Pass 4 Errors

#### Description

Create comprehensive test coverage for all Pass 4 error cases: `DanglingConnection`, `DanglingBindingEndpoint`. These tests ensure graph structure is valid before SCC analysis.

#### Acceptance Criteria (REQUIRED)

- [ ] Test for `DanglingConnection`: wire referencing non-existent block
- [ ] Test for `DanglingBindingEndpoint`: publisher referencing non-existent bus
- [ ] Test for `DanglingBindingEndpoint`: listener referencing non-existent bus
- [ ] Test verifies all nodes are created (BlockEval and BusValue)
- [ ] Test verifies all edge types are created (wire, publisher, listener)
- [ ] All tests verify error message includes context (wire/binding ID)

---

### P0-9: Pass 5 Cycle Validation Tests

**Status:** Not Started
**Effort:** Medium (3-5 days)
**Dependencies:** P0-4 (Pass 5 implementation)
**Spec Reference:** 15-Canonical-Lowering-Pipeline.md § Pass 5

#### Description

Create comprehensive test coverage for Pass 5 cycle validation, including trivial SCCs, legal cycles with state boundaries, and illegal cycles without state boundaries. This is critical for correctness.

#### Acceptance Criteria (REQUIRED)

- [ ] Test for trivial SCC: single node with no self-loop
- [ ] Test for trivial SCC with self-loop: single node with self-edge (must have state boundary)
- [ ] Test for legal cycle: 3+ nodes with one having `capability === 'state'`
- [ ] Test for illegal cycle: 3+ nodes with no state boundary → error
- [ ] Test for multiple SCCs: patch with 2+ independent cycles
- [ ] Test for nested cycles (if relevant)
- [ ] Test verifies SCC node membership is correct
- [ ] Test verifies `hasStateBoundary` flag is correct
- [ ] Test for `IllegalCycle` error includes all node IDs in the cycle

---

### P1-1: TypeDesc Unification Documentation

**Status:** Not Started
**Effort:** Small (1-2 days)
**Dependencies:** P0-1 (Pass 2 implementation)
**Spec Reference:** STATUS-2025-12-25-200000.md § Ambiguities Found

#### Description

Document the decision for how editor TypeDesc (with `category`, `busEligible`) relates to IR TypeDesc (without these fields). This resolves the "TypeDesc Unification" ambiguity from the STATUS report.

**Recommendation:** Keep separate TypeDesc types but add utility functions to compute `busEligible` from IR TypeDesc's `world` and `domain` fields.

#### Acceptance Criteria (REQUIRED)

- [ ] Documentation file created: `design-docs/12-Compiler-Final/TypeDesc-Unification.md`
- [ ] Document explains editor TypeDesc vs IR TypeDesc relationship
- [ ] Document specifies how `busEligible` is computed from `world` + `domain`
- [ ] Document specifies how `category` is derived (or why it's not needed in IR)
- [ ] Utility functions added to `ir/types.ts`: `isBusEligible(type: TypeDesc): boolean`
- [ ] Utility functions tested in `ir/__tests__/types.test.ts`

---

## Dependency Graph

```
Pass 1 (DONE)
    ↓
Pass 2 (P0-1) ←──────────────┐
    ↓                         │
Pass 3 (P0-2)                 │
    ↓                         │
Pass 4 (P0-3)                 │
    ↓                         │
Pass 5 (P0-4)                 │
    ↓                         │
Integration Test (P0-5)       │
    ↓                         │
Error Tests (P0-6,7,8,9) ─────┘
    ↓
TypeDesc Doc (P1-1)
```

**Critical Path:** Pass 2 → Pass 3 → Pass 4 → Pass 5 → Integration Test

**Parallel Work:** Error handling tests can be written in parallel with main implementation if test fixtures are shared.

---

## Recommended Sprint Planning

### Week 1: Type Graph & Time Topology
- **Day 1-2:** Implement Pass 2 (P0-1)
- **Day 3:** Write Pass 2 error tests (P0-6)
- **Day 4-5:** Implement Pass 3 (P0-2)

### Week 2: Dependency Graph & SCC
- **Day 1:** Write Pass 3 error tests (P0-7)
- **Day 2-3:** Implement Pass 4 (P0-3)
- **Day 4:** Write Pass 4 error tests (P0-8)
- **Day 5:** Implement Pass 5 (P0-4)

### Week 3: Validation & Documentation
- **Day 1-2:** Write Pass 5 cycle tests (P0-9)
- **Day 3:** Integration test (P0-5)
- **Day 4:** TypeDesc documentation (P1-1)
- **Day 5:** Buffer / final review

**Total Estimated Time:** 15 days (3 weeks)

---

## Risk Assessment

### High Risk Items

1. **Pass 5 SCC Algorithm Complexity** (P0-4)
   - **Risk:** Tarjan's algorithm is subtle; easy to get wrong
   - **Mitigation:** Use reference implementation, extensive test coverage, verify against known-good SCC libraries
   - **Fallback:** Use existing `topoSortBlocksWithBuses()` logic as temporary solution

2. **Type Conversion Path Computation** (P0-1)
   - **Risk:** Adapter/Lens registry may not have complete coverage
   - **Mitigation:** Start with direct type equality, add adapter chains incrementally
   - **Fallback:** Emit warning instead of error for missing paths in MVP

### Medium Risk Items

3. **Block Registry Integration** (P0-4, P0-9)
   - **Risk:** Block definitions may not have `capability` or `breaksCombinatorialCycle` properties
   - **Mitigation:** Audit block registry first, add missing metadata
   - **Impact:** Could block Pass 5 if metadata is incomplete

4. **TimeRoot Constraint Validation** (P0-2)
   - **Risk:** Unclear what "illegal upstream dependencies" means for TimeRoot
   - **Mitigation:** Skip this validation in MVP, defer to Pass 4-5 cycle detection
   - **Impact:** May allow invalid patches through temporarily

### Low Risk Items

5. **Default Source Handling** (P0-1)
   - **Risk:** Default sources created in Pass 1 may not have correct types
   - **Mitigation:** Use SlotType from input definition, validate in Pass 2
   - **Impact:** Minor - easy to fix if tests catch it

---

## Sprint 2 Preview (Out of Scope)

After completing Sprint 1, the following work remains for Phase 3:

- **P0-10:** Dual-Emit Compiler (Pass 6-8) - Modify `compileBusAware.ts` to emit both closures and IR
- **P0-11:** IR Validator - Validate emitted IR structure
- **P0-12:** Block Compiler Contract - Update all 17 block compilers to emit IR nodes
- **P1-2:** Equivalence Tests - Verify IR and closure paths produce same results

Sprint 2 is estimated at 4-6 weeks due to the complexity of modifying the block compiler contract.

---

## Blockers and Questions

### Resolved (per user input)

1. ✅ **Block Compiler Contract:** Dual-emit approach confirmed - blocks emit both closures and IR during Phase 3
2. ✅ **TypeDesc Divergence:** Pass 2 converts SlotType → IR TypeDesc, computes eligibility at compile time

### Remaining

None - all ambiguities from STATUS-2025-12-25-200000.md have been resolved or deferred to Sprint 2.

---

## Success Criteria

Sprint 1 is complete when:

1. ✅ All 5 compilation passes (1-5) implemented and tested
2. ✅ Full pipeline test runs on golden patch without errors
3. ✅ All error cases have test coverage (minimum 42 tests total)
4. ✅ TypeDesc unification documented
5. ✅ No regressions in existing tests (38 tests still passing)
6. ✅ Ready to begin dual-emit compiler work (Sprint 2)

**Definition of Done:** All P0 items complete, all tests passing, documentation updated, no blockers for Sprint 2.
