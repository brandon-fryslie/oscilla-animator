# Phase 3 Bridge Compiler - Sprint 2 Implementation Plan

**Generated:** 2025-12-25-200731
**Source:** STATUS-2025-12-25-200000.md
**Scope:** Dual-Emit Compilation + IR Validation (Passes 6-8 + Validator)

---

## Executive Summary

**Current State (after Sprint 1):** Passes 1-5 complete - normalized patch, type graph, time topology, dependency graph, and SCC validation all working with full test coverage.

**Sprint 2 Goal:** Implement dual-emit compilation where `compileBusAware.ts` emits both legacy closures (for execution) AND IR nodes (for validation). This bridges the gap between the closure-based runtime and the future IR-based runtime.

**Total Work Items:** 8 (P0: 6, P1: 2)

**Critical Insight:** This sprint modifies the core compiler but does NOT change block compilers yet. The compiler will use IRBuilder to emit IR representations of what the closure-based blocks produce. Block compiler migration happens in Phase 4+.

**Recommended Approach:** Implement Passes 6-8 as post-processing over closure compilation results, then add validation. This minimizes risk to existing compilation pipeline.

---

## Backlog by Priority

### P0-1: Pass 6 - Block Lowering Infrastructure

**Status:** Not Started
**Effort:** Medium (3-5 days)
**Dependencies:** Sprint 1 complete (Passes 1-5)
**Spec Reference:** 15-Canonical-Lowering-Pipeline § Pass 6, 16-Block-Lowering § 2 • **Status Reference:** STATUS-2025-12-25-200000.md § Topic 4

#### Description

Implement Pass 6 infrastructure that translates compiled Artifact closures into IR nodes. This pass iterates blocks in dependency order and uses IRBuilder to create IR representations of block outputs. The key insight: we're NOT modifying block compilers yet - we're inferring IR from the Artifacts they produce.

**Strategy:** For MVP, create IR "stubs" that represent the closure outputs. The IR won't be executable yet, but it will have the correct structure for validation.

#### Acceptance Criteria (REQUIRED)

- [ ] Function `pass6BlockLowering(validated: AcyclicOrLegalGraph, compiledPortMap: Map<string, Artifact>): UnlinkedIRFragments` exists in `src/editor/compiler/passes/pass6-block-lowering.ts`
- [ ] IRBuilder instance is created and passed through compilation context
- [ ] For each block in dependency order, create IR node representing its output
- [ ] Artifact-to-IR mapping for basic types: `Scalar:number` → `sigConst`, `Signal:number` → placeholder `sigOp`
- [ ] UnlinkedIRFragments structure includes: `builder: IRBuilder`, `blockOutputs: Map<BlockIndex, ValueRefPacked[]>`, `errors: CompileError[]`
- [ ] Pass preserves existing closure compilation - closures still work exactly as before
- [ ] Test suite `pass6-block-lowering.test.ts` with minimum 8 tests covering artifact types
- [ ] Integration test confirms pass runs without breaking existing compilation

#### Technical Notes

**Artifact-to-IR Translation Strategy:**

For Sprint 2, we'll create "skeleton" IR nodes that represent the structure without full semantics:

```typescript
function artifactToValueRef(artifact: Artifact, builder: IRBuilder): ValueRefPacked {
  switch (artifact.kind) {
    case 'Scalar:number':
      const constId = builder.constF64(artifact.value);
      const sigId = builder.sigConst({ world: 'signal', domain: 'number' }, constId);
      return { k: 'sig', id: sigId };

    case 'Signal:number':
    case 'Signal:phase':
    case 'Signal:vec2':
    case 'Signal:color':
      // Create placeholder sigOp node
      // Future: parse closure to extract actual operations
      const placeholderId = builder.sigOp('identity', [], typeFromKind(artifact.kind));
      return { k: 'sig', id: placeholderId };

    case 'Field:number':
    case 'Field:vec2':
    case 'Field:color':
      // Create placeholder fieldOp node
      const fieldId = builder.fieldOp('identity', [], typeFromKind(artifact.kind));
      return { k: 'field', id: fieldId };

    case 'RenderTree':
    case 'RenderTreeProgram':
      // Special handling - not a signal/field
      return { k: 'special', tag: 'render', id: builder.allocSpecialId() };

    default:
      throw new Error(`Unsupported artifact kind: ${artifact.kind}`);
  }
}
```

**Key Limitation:** This pass creates IR structure without full semantic equivalence. The IR won't execute correctly yet - that's Phase 4 work. But it will validate structurally.

**Integration Point:** This pass runs AFTER the existing `compileBusAwarePatch()` completes successfully, using the `compiledPortMap` as input.

---

### P0-2: Pass 7 - Bus Lowering to IR

**Status:** Not Started
**Effort:** Medium (3-5 days)
**Dependencies:** P0-1 (Pass 6)
**Spec Reference:** 15-Canonical-Lowering-Pipeline § Pass 7 • **Status Reference:** STATUS-2025-12-25-200000.md § Topic 4

#### Description



#### Acceptance Criteria (REQUIRED)

- [ ] Create `sigCombine` or `fieldCombine` node based on bus type (Signal vs Field)
- [ ] Handle empty buses: use bus.defaultValue as constant node
- [ ] IRWithBusRoots structure includes: `builder: IRBuilder`, `busRoots: Map<BusIndex, ValueRefPacked>`, `errors: CompileError[]`
- [ ] Test verifies Signal buses use Signal combine modes (sum, last)
- [ ] Test verifies Field buses use Field combine modes (sum, average, max, min, last)

#### Technical Notes



```typescript
  sourceRef: ValueRefPacked,
  builder: IRBuilder
): ValueRefPacked {
  let current = sourceRef;

  // Apply adapter chain
      kind: 'adapter',
      adapterId: step.adapterId,
      // ... adapter-specific params
    }));
    const chainId = builder.transformChain(steps);

    if (current.k === 'sig') {
      const transformedId = builder.applyTransformToSig(current.id, chainId, /* outType */);
      current = { k: 'sig', id: transformedId };
    } else if (current.k === 'field') {
      const transformedId = builder.applyTransformToField(current.id, chainId, /* outType */);
      current = { k: 'field', id: transformedId };
    }
  }

  // Apply lens stack (similar approach)
  // ...

  return current;
}
```

**Bus Combine Node Creation:**

```typescript
function createBusCombineNode(
  bus: Bus,
  builder: IRBuilder
): ValueRefPacked {
    const constId = builder.constJSON(bus.defaultValue);
    if (bus.type.world === 'signal') {
      const sigId = builder.sigConst(bus.type, constId);
      return { k: 'sig', id: sigId };
    } else {
      const fieldId = builder.fieldConst(bus.type, constId);
      return { k: 'field', id: fieldId };
    }
  }

  // Extract IDs from terms (all must be same world)

  if (sigIds.length > 0) {
    const combineId = builder.sigCombine(bus.combineMode, sigIds, bus.type);
    return { k: 'sig', id: combineId };
  } else {
    const combineId = builder.fieldCombine(bus.combineMode, fieldIds, bus.type);
    return { k: 'field', id: combineId };
  }
}
```

---

### P0-3: Pass 8 - Link Resolution

**Status:** Not Started
**Effort:** Small (1-2 days)
**Dependencies:** P0-2 (Pass 7)
**Spec Reference:** 15-Canonical-Lowering-Pipeline § Pass 8 • **Status Reference:** STATUS-2025-12-25-200000.md § Topic 4

#### Description

Implement Pass 8 to resolve all ValueRefs into concrete BlockInputRootIR and BlockOutputRootIR tables. This pass finalizes the IR by ensuring every port has a concrete value and there are no dangling references.

**Key Insight:** This pass is mostly bookkeeping - it packages up the work from Passes 6-7 into the final LinkedGraphIR structure that the validator expects.

#### Acceptance Criteria (REQUIRED)

- [ ] Create `BlockInputRootIR` table mapping (blockIdx, inPortIdx) → ValueRefPacked
- [ ] Create `BlockOutputRootIR` table mapping (blockIdx, outPortIdx) → ValueRefPacked
- [ ] Resolve all wire connections: input port → upstream block output
- [ ] Validate no missing roots: every input port has a value source
- [ ] LinkedGraphIR structure matches spec from `ir/program.ts`
- [ ] Test suite `pass8-link-resolution.test.ts` with minimum 6 tests
- [ ] Test for `UnresolvedPort` error when input has no source

#### Technical Notes

**Input Resolution Priority:**

For each block input port, resolve in this order:
1. Wire connection (direct block-to-block)
3. Default source (attached in Pass 1)

```typescript
function resolveBlockInputs(
  blocks: BlockInstance[],
  wires: CompilerConnection[],
  busRoots: Map<BusIndex, ValueRefPacked>,
  blockOutputs: Map<BlockIndex, ValueRefPacked[]>,
  defaultSources: Map<string, DefaultSourceState>
): BlockInputRootIR {
  const refs: ValueRefPacked[] = [];

  for (const [blockIdx, block] of blocks.entries()) {
    for (const [portIdx, inputDef] of block.inputs.entries()) {
      // Check wire
      const wire = wires.find(w => w.to.blockId === block.id && w.to.port === inputDef.name);
      if (wire) {
        const upstreamBlockIdx = /* ... */;
        const upstreamPortIdx = /* ... */;
        const ref = blockOutputs.get(upstreamBlockIdx)![upstreamPortIdx];
        refs.push(ref);
        continue;
      }

        const busIdx = /* ... */;
        const ref = busRoots.get(busIdx)!;
        refs.push(ref);
        continue;
      }

      // Default source
      const defaultRef = /* ... from Pass 1 attachment */;
      refs.push(defaultRef);
    }
  }

  return { refs, indexOf: (blockIdx, portIdx) => /* ... */ };
}
```

---

### P0-4: Dual-Emit Compiler Integration

**Status:** Not Started
**Effort:** Medium (3-5 days)
**Dependencies:** P0-3 (Pass 8)
**Spec Reference:** 01.1-CompilerMigration-Roadmap Phase 3 • **Status Reference:** STATUS-2025-12-25-200000.md § Topic 4

#### Description

Modify `compileBusAware.ts` to run Passes 6-8 after successful closure compilation and return both the legacy CompileResult AND the new IR. The IR is attached as an optional field and does not affect execution.

**Critical:** This integration must be additive only - existing compilation behavior is unchanged.

#### Acceptance Criteria (REQUIRED)

- [ ] `compileBusAwarePatch()` signature extended with optional `emitIR: boolean` flag (default false)
- [ ] When `emitIR === true`, run Passes 6-8 after closure compilation succeeds
- [ ] Passes 6-8 receive `compiledPortMap` as input (the closure compilation results)
- [ ] New field added to `CompileResult`: `ir?: LinkedGraphIR`
- [ ] If IR compilation fails, still return success with closure result (IR errors logged as warnings)
- [ ] Existing tests pass with `emitIR: false` (default)
- [ ] New test suite `dual-emit-integration.test.ts` with minimum 10 tests
- [ ] Test verifies closure and IR both present when `emitIR: true`
- [ ] Test verifies IR compilation errors don't break closure compilation

#### Technical Notes

**Integration Point:**

```typescript
export function compileBusAwarePatch(
  patch: CompilerPatch,
  registry: BlockRegistry,
  seed: Seed,
  ctx: CompileCtx,
  options?: { emitIR?: boolean }
): CompileResult {
  const errors: CompileError[] = [];

  // ... existing closure compilation (lines 240-638) ...

  // If closure compilation succeeded and IR emission requested
  if (errors.length === 0 && options?.emitIR === true) {
    try {
      // Run Pass 1-5 (from Sprint 1)
      const normalized = pass1Normalize(patch);
      const typed = pass2TypeGraph(normalized);
      const timeResolved = pass3TimeTopology(typed);
      const depGraph = pass4DepGraph(timeResolved);
      const validated = pass5CycleValidation(depGraph);

      // Run Pass 6-8 (Sprint 2)
      const unllinked = pass6BlockLowering(validated, compiledPortMap);

      // Attach IR to result
      return {
        ok: true,
        program,
        timeModel,
        errors: [],
        compiledPortMap,
        ir: linkedIR,  // NEW FIELD
      };
    } catch (irError) {
      // IR compilation failed - log but don't fail overall compilation
      console.warn('IR emission failed:', irError);
      return {
        ok: true,
        program,
        timeModel,
        errors: [],
        compiledPortMap,
        irWarnings: [{ code: 'IREmissionFailed', message: String(irError) }],
      };
    }
  }

  // Normal result (IR not requested or compilation failed)
  return { ok: true, program, timeModel, errors: [], compiledPortMap };
}
```

**CompileResult Extension:**

```typescript
export interface CompileResult {
  ok: boolean;
  errors: CompileError[];
  program?: Program<RenderTree>;
  canvasProgram?: Program<RenderTree>;
  timeModel?: TimeModel;
  compiledPortMap?: Map<string, Artifact>;

  // NEW FIELDS for dual-emit
  ir?: LinkedGraphIR;           // Emitted IR (if emitIR: true)
  irWarnings?: CompileError[];  // Non-fatal IR issues
}
```

---

### P0-5: IR Validator Core

**Status:** Not Started
**Effort:** Medium (3-5 days)
**Dependencies:** P0-4 (Dual-emit integration)
**Spec Reference:** 14-Compiled-IR-Program-Contract • **Status Reference:** STATUS-2025-12-25-200000.md § Topic 5

#### Description

Implement IR validator that checks the emitted IR for structural correctness: all node IDs are valid, types are consistent, no dangling references, and the schedule is topologically sound. This validator runs in development mode after every compilation.

**Goal:** Catch IR generation bugs early by validating the IR structure is well-formed, even though it's not executable yet.

#### Acceptance Criteria (REQUIRED)

- [ ] Function `validateIR(ir: LinkedGraphIR): ValidationResult` exists in `src/editor/compiler/ir/validator.ts`
- [ ] Validate all SigExprId references exist in SignalIR table
- [ ] Validate all FieldExprId references exist in FieldIR table
- [ ] Validate all constId references are in bounds for ConstantIR
- [ ] Validate all TransformChainId references exist
- [ ] Validate no circular expression references (signal/field DAGs are acyclic)
- [ ] ValidationResult includes: `valid: boolean`, `errors: IRValidationError[]`, `warnings: IRValidationError[]`
- [ ] Test suite `ir-validator.test.ts` with minimum 15 tests covering all error cases
- [ ] Test for `InvalidSigExprRef` when signal node references non-existent upstream
- [ ] Test for `InvalidFieldExprRef` when field node references non-existent upstream

#### Technical Notes

**Validation Strategy:**

The validator performs multiple passes over the IR:

**Pass 1: ID Bounds Checking**
```typescript
function validateIdBounds(ir: LinkedGraphIR): IRValidationError[] {
  const errors: IRValidationError[] = [];

  // Check signal expression IDs
  for (const [sigId, sigNode] of ir.builder.sigExprTable.entries()) {
    if (sigNode.kind === 'map' || sigNode.kind === 'zip') {
      for (const inputId of sigNode.inputs) {
        if (inputId < 0 || inputId >= ir.builder.sigExprTable.length) {
          errors.push({
            code: 'InvalidSigExprRef',
            message: `Signal node ${sigId} references invalid input ${inputId}`,
            where: { sigId, inputId },
          });
        }
      }
    }
  }

  // Similar for field expressions
  // ...

  return errors;
}
```

**Pass 2: Type Consistency**
```typescript
function validateTypeConsistency(ir: LinkedGraphIR): IRValidationError[] {
  const errors: IRValidationError[] = [];

  // For each signal operation, check operand types match operator expectations
  for (const [sigId, sigNode] of ir.builder.sigExprTable.entries()) {
    if (sigNode.kind === 'zip') {
      const aType = getSignalType(sigNode.inputA);
      const bType = getSignalType(sigNode.inputB);
      const opType = getOpSignature(sigNode.op);

      if (!typesCompatible(aType, opType.inputA) || !typesCompatible(bType, opType.inputB)) {
        errors.push({
          code: 'TypeMismatch',
          message: `Signal zip node ${sigId} has incompatible input types`,
          where: { sigId, expected: opType, actual: { a: aType, b: bType } },
        });
      }
    }
  }

  return errors;
}
```

**Pass 3: Cycle Detection**
```typescript
function validateAcyclicExpressions(ir: LinkedGraphIR): IRValidationError[] {
  const errors: IRValidationError[] = [];
  const visited = new Set<SigExprId>();
  const recStack = new Set<SigExprId>();

  function visit(id: SigExprId): boolean {
    if (recStack.has(id)) {
      errors.push({
        code: 'CircularExprRef',
        message: `Circular reference detected in signal expression ${id}`,
        where: { sigId: id },
      });
      return false;
    }

    if (visited.has(id)) return true;

    visited.add(id);
    recStack.add(id);

    const node = ir.builder.sigExprTable[id];
    // Visit dependencies based on node type
    // ...

    recStack.delete(id);
    return true;
  }

  for (let id = 0; id < ir.builder.sigExprTable.length; id++) {
    visit(id);
  }

  return errors;
}
```

---

### P0-6: IR Validator Integration

**Status:** Not Started
**Effort:** Small (1-2 days)
**Dependencies:** P0-5 (IR Validator)
**Spec Reference:** 14-Compiled-IR-Program-Contract
**Status Reference:** STATUS-2025-12-25-200000.md § Topic 5

#### Description

Integrate the IR validator into the compilation pipeline so it runs automatically in development mode after IR emission. Validation errors are logged but don't prevent closure execution.

#### Acceptance Criteria (REQUIRED)

- [ ] Validator runs automatically when `emitIR: true` and `NODE_ENV === 'development'`
- [ ] Validation runs AFTER Pass 8 completes
- [ ] Validation errors are appended to `CompileResult.irWarnings`
- [ ] Validation errors are logged to console with structured output
- [ ] Environment variable `DISABLE_IR_VALIDATION` can skip validation for performance
- [ ] Test suite `ir-validator-integration.test.ts` with minimum 5 tests
- [ ] Test verifies validator catches intentionally broken IR
- [ ] Test verifies validator runs in dev mode but not production

#### Technical Notes

**Integration Point:**

```typescript
// In compileBusAware.ts after Pass 8
if (options?.emitIR === true) {

  // Validate IR in development
  if (process.env.NODE_ENV === 'development' && !process.env.DISABLE_IR_VALIDATION) {
    const validationResult = validateIR(linkedIR);

    if (!validationResult.valid) {
      console.warn('[IR Validator] Validation failed:', validationResult.errors);
      return {
        ok: true,  // Closure compilation succeeded
        program,
        timeModel,
        errors: [],
        compiledPortMap,
        ir: linkedIR,
        irWarnings: validationResult.errors.map(e => ({
          code: e.code,
          message: e.message,
          where: e.where,
        })),
      };
    }
  }

  return { ok: true, program, timeModel, errors: [], compiledPortMap, ir: linkedIR };
}
```

---

### P1-1: Golden Patch IR Validation Test

**Status:** Not Started
**Effort:** Small (1-2 days)
**Dependencies:** P0-6 (IR Validator Integration)
**Spec Reference:** N/A (test infrastructure)

#### Description

Create end-to-end test that compiles the golden patch ("Breathing Constellation") with dual-emit enabled and validates the IR structure is correct. This serves as a comprehensive integration test for the entire Sprint 2 work.

#### Acceptance Criteria (REQUIRED)

- [ ] Test file `src/editor/compiler/__tests__/golden-patch-ir.test.ts` exists
- [ ] Test loads golden patch from test fixtures
- [ ] Test compiles with `emitIR: true`
- [ ] Test validates CompileResult has both `program` and `ir` fields
- [ ] Test runs IR validator and expects no errors
- [ ] Test verifies IR has expected structure: nodes, buses, constants
- [ ] Test verifies time model in IR matches closure time model

#### Technical Notes

**Golden Patch Test Structure:**

```typescript
import { loadGoldenPatch } from '../../test-utils/goldenPatches';
import { compileBusAwarePatch } from '../compileBusAware';
import { validateIR } from '../ir/validator';

describe('Golden Patch IR Emission', () => {
  it('compiles breathing constellation with valid IR', () => {
    const patch = loadGoldenPatch('breathing-constellation');

    const result = compileBusAwarePatch(
      patch,
      blockRegistry,
      { seed: 12345 },
      { env: {} },
      { emitIR: true }
    );

    // Compilation succeeded
    expect(result.ok).toBe(true);
    expect(result.program).toBeDefined();

    // IR was emitted
    expect(result.ir).toBeDefined();
    expect(result.irWarnings).toBeUndefined();

    // IR is valid
    const validation = validateIR(result.ir!);
    expect(validation.valid).toBe(true);
    expect(validation.errors).toHaveLength(0);

    // IR structure checks
    expect(result.ir!.builder.sigExprTable.length).toBeGreaterThan(0);
    expect(result.ir!.busRoots.size).toBeGreaterThan(0);

    // Time model consistency
    expect(result.ir!.timeModel).toEqual(result.timeModel);
  });
});
```

---

### P1-2: IR Emission Documentation

**Status:** Not Started
**Effort:** Small (1-2 days)
**Dependencies:** P0-6 (IR Validator Integration)
**Spec Reference:** N/A (documentation)

#### Description

Document the dual-emit compilation strategy, IR structure, and validation approach for future maintainers. This resolves the "Block Compiler Contract" ambiguity from STATUS by documenting the Sprint 2 approach as an interim step.

#### Acceptance Criteria (REQUIRED)

- [ ] Documentation file created: `design-docs/12-Compiler-Final/21-Dual-Emit-Strategy.md`
- [ ] Document explains Sprint 2 approach: IR from closures, not from block compilers
- [ ] Document specifies IR limitations: structural only, not executable
- [ ] Document outlines Phase 4 migration path: block compilers will emit IR directly
- [ ] Document includes examples of Artifact→IR translation for common types
- [ ] Document explains validator role and limitations
- [ ] Cross-reference to 16-Block-Lowering.md for future block compiler contract

---

## Dependency Graph

```
Sprint 1 (Passes 1-5) - COMPLETE
    ↓
Pass 6: Block Lowering (P0-1)
    ↓
Pass 7: Bus Lowering (P0-2)
    ↓
Pass 8: Link Resolution (P0-3)
    ↓
Dual-Emit Integration (P0-4)
    ↓
IR Validator Core (P0-5)
    ↓
IR Validator Integration (P0-6)
    ↓
    ├─→ Golden Patch Test (P1-1)
    └─→ Documentation (P1-2)
```

**Critical Path:** P0-1 → P0-2 → P0-3 → P0-4 → P0-5 → P0-6

**Parallel Work:** P1-1 and P1-2 can be done in parallel after P0-6 completes.

---

## Recommended Sprint Planning

### Week 1: Pass 6-7 Implementation
- **Day 1-2:** Implement Pass 6 Block Lowering (P0-1)
- **Day 3:** Write Pass 6 tests
- **Day 4-5:** Implement Pass 7 Bus Lowering (P0-2)

### Week 2: Pass 8 + Integration
- **Day 1:** Write Pass 7 tests
- **Day 2:** Implement Pass 8 Link Resolution (P0-3)
- **Day 3-4:** Dual-Emit Integration (P0-4)
- **Day 5:** Integration testing

### Week 3: Validation + Documentation
- **Day 1-2:** Implement IR Validator Core (P0-5)
- **Day 3:** IR Validator Integration (P0-6)
- **Day 4:** Golden Patch Test (P1-1) + Documentation (P1-2)
- **Day 5:** Buffer / final review

**Total Estimated Time:** 15 days (3 weeks)

---

## Risk Assessment

### High Risk Items

1. **Artifact-to-IR Translation Fidelity** (P0-1)
   - **Risk:** Closure semantics may not map cleanly to IR nodes
   - **Mitigation:** Start with structural IR only, defer semantic equivalence to Phase 4
   - **Fallback:** Create "opaque" IR nodes that just reference closure functions

2. **Transform Chain IR Representation** (P0-2)
   - **Risk:** Adapter/lens chains are complex and may not serialize well
   - **Mitigation:** Use TransformChainIR as-is from Phase 2 schemas, validate structure only
   - **Fallback:** Store transform chains as JSON references for MVP

### Medium Risk Items

3. **IR Validator Completeness** (P0-5)
   - **Risk:** Validator may miss subtle IR structure bugs
   - **Mitigation:** Extensive test coverage, property-based testing
   - **Impact:** IR bugs caught in Phase 4 instead of Sprint 2

4. **Performance Overhead** (P0-4)
   - **Risk:** Running Passes 6-8 after closure compilation could slow compilation
   - **Mitigation:** Make IR emission optional (flag), optimize passes later
   - **Impact:** Dev mode compilation slower, production unaffected

### Low Risk Items

5. **Integration with Existing Tests** (P0-4, P0-6)
   - **Risk:** Dual-emit might break existing test assumptions
   - **Mitigation:** IR emission is opt-in via flag, existing tests unchanged
   - **Impact:** Minimal - new tests for IR path only

---

## Sprint 3 Preview (Out of Scope)

After completing Sprint 2, the remaining Phase 3 work includes:

- **Pass 9:** Render Lowering & Field Materialization Planning
- **Pass 10:** Constants Packing
- **Pass 11:** DebugIndex Generation

Sprint 3 is estimated at 2-3 weeks and completes the full 11-pass compilation pipeline.

---

## Blockers and Questions

### Resolved

1. ✅ **Block Compiler Contract:** Sprint 2 uses Artifact→IR translation, not block compiler modification
2. ✅ **IR Executability:** Sprint 2 IR is structural only, not executable (deferred to Phase 4)

### Remaining

**Question 1: Opaque vs Transparent IR Nodes**
- **Context:** For closures we can't inspect (e.g., complex Signal functions), should we create "opaque" IR nodes that just reference the closure?
- **Options:**
  - Option A: Create opaque `sigOpaque(closureRef)` node type
  - Option B: Create placeholder `sigOp('identity')` and document limitation
  - Option C: Attempt to parse closure source (risky, brittle)
- **Impact:** Affects IR validator expectations and Phase 4 migration complexity

**Recommendation:** Option B for Sprint 2 - use placeholder nodes, document limitations clearly. Defer full semantic IR to Phase 4.

---

## Success Criteria

Sprint 2 is complete when:

1. ✅ Passes 6-8 implemented and tested
2. ✅ Dual-emit integration working in `compileBusAware.ts`
3. ✅ IR validator catches structural errors
4. ✅ Golden patch compiles with valid IR
5. ✅ All existing tests still pass (no regressions)
6. ✅ Documentation explains dual-emit strategy
7. ✅ Ready to begin Pass 9-11 work (Sprint 3)

**Definition of Done:** All P0 items complete, all tests passing (existing + new), documentation updated, IR emitted and validated for golden patch, no blockers for Sprint 3.
