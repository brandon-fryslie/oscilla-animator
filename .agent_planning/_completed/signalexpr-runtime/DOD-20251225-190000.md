# Definition of Done: SignalExpr Runtime - Sprint 1 (Core Evaluator)
Generated: 2025-12-25-190000
Plan: PLAN-20251225-190000.md

## Sprint Goal

Deliver a working SignalExpr evaluator that can evaluate simple pure signal expressions (const, timeAbsMs, map, zip) with per-frame caching.

---

## Acceptance Criteria

### P0: Define SignalExpr IR Types

- [ ] `SignalExprIR` union type defined with node kinds: `const`, `timeAbsMs`, `map`, `zip`
- [ ] Each node type includes `kind` discriminator and `type: TypeDesc` field
- [ ] `SigExprId` type alias defined as `number` (dense index into node array)
- [ ] `PureFnRef` interface defined with `opcode: OpCode` field
- [ ] `OpCode` enum defined with at least: Sin, Cos, Tan, Abs, Floor, Ceil, Add, Sub, Mul, Div, Min, Max
- [ ] Type definitions include JSDoc comments explaining each node kind
- [ ] File exports all types for use in evaluator

### P0: Implement SigFrameCache

- [ ] `SigFrameCache` interface defined with `frameId`, `value`, `stamp`, `validMask` fields
- [ ] `createSigFrameCache(capacity: number)` factory function allocates typed arrays
- [ ] Cache correctly detects hits: `stamp[sigId] === frameId` returns cached value
- [ ] Cache correctly detects misses: `stamp[sigId] !== frameId` requires re-evaluation
- [ ] `newFrame(frameId: number)` method updates frameId without clearing arrays (stamp comparison handles invalidation)
- [ ] Cache supports at least 1024 signal nodes initially (grow dynamically later)
- [ ] Unit tests verify cache hit/miss logic, frame invalidation, and capacity

### P0: Implement SigEnv (Evaluation Environment)

- [ ] `SigEnv` interface defined with `tAbsMs`, `constPool`, `cache` fields
- [ ] `ConstPool` interface defined as `{ numbers: number[] }` (expand later for vec2, color, etc.)
- [ ] `createSigEnv(params)` factory function creates environment with all required fields
- [ ] `getConstNumber(constId)` helper reads from const pool with bounds checking
- [ ] Environment is immutable during frame evaluation (readonly fields where applicable)
- [ ] Unit tests verify const pool access, time value reads, cache reference
- [ ] Type definitions are exported for use in evaluator

### P0: Implement Core Evaluator (const, timeAbsMs)

- [ ] `evalSig(sigId, env, nodes)` function implements cache-first algorithm
- [ ] Cache hit path returns cached value without re-evaluation (O(1) array lookup)
- [ ] Cache miss path evaluates node based on `kind` discriminator
- [ ] `const` nodes return value from const pool via `getConstNumber()`
- [ ] `timeAbsMs` nodes return `env.tAbsMs`
- [ ] Evaluated values are written to cache with current frameId stamp
- [ ] Unknown node kinds throw clear error with kind name
- [ ] Unit tests verify cache behavior: same frame = cached, new frame = re-evaluated
- [ ] Unit tests verify const and timeAbsMs evaluation correctness
- [ ] Performance: cache hit is O(1), no allocations in hot path

### P1: Implement OpCode Registry and Pure Function Application

- [ ] `applyPureFn(fn, input)` function handles all unary opcodes (Sin, Cos, Tan, Abs, Floor, Ceil)
- [ ] `applyBinaryFn(fn, a, b)` function handles all binary opcodes (Add, Sub, Mul, Div, Min, Max)
- [ ] Division by zero returns 0 (safe default, no NaN propagation)
- [ ] All opcodes are tested with known input/output pairs (unit tests)
- [ ] Unknown opcodes throw clear error with opcode value
- [ ] Functions are pure (no side effects, deterministic)
- [ ] Performance: direct Math.* calls, no indirection overhead

### P1: Extend Evaluator for Map and Zip Nodes

- [ ] Evaluator switch statement includes `case 'map'` calling `evalMap(node, env, nodes)`
- [ ] Evaluator switch statement includes `case 'zip'` calling `evalZip(node, env, nodes)`
- [ ] `evalMap()` recursively evaluates `node.src` then applies `applyPureFn()`
- [ ] `evalZip()` recursively evaluates `node.a` and `node.b` then applies `applyBinaryFn()`
- [ ] Recursive calls use cache correctly (shared subexpressions evaluated once)
- [ ] Unit tests verify map evaluation: `sin(1000)` given `timeAbsMs=1000`
- [ ] Unit tests verify zip evaluation: `a + b` given const nodes
- [ ] Integration tests verify DAG evaluation: `sin(t) * 2` requires 4 nodes (time, const, sin, mul)
- [ ] Cache tests verify shared subexpressions: `a + a` evaluates `a` only once

### P1: Create Test Suite for Core Evaluator

- [ ] Unit tests for `evalSig()` with `const` nodes (read from const pool)
- [ ] Unit tests for `evalSig()` with `timeAbsMs` nodes (read from env)
- [ ] Unit tests for `evalSig()` with `map` nodes (sin, cos, abs)
- [ ] Unit tests for `evalSig()` with `zip` nodes (add, mul, min, max)
- [ ] Cache hit tests: same frame, same sigId → cached value returned
- [ ] Cache miss tests: new frame → re-evaluation occurs
- [ ] Cache invalidation tests: `newFrame()` invalidates all cached values
- [ ] Integration test: compose 4+ nodes into DAG (e.g., `sin(t * 0.001)`)
- [ ] Integration test: shared subexpression evaluated once (e.g., `(a + b) + (a + b)`)
- [ ] All tests pass with `just test`
- [ ] Test coverage ≥80% for evaluator, cache, and opcode files

### P2: Documentation and Examples

- [ ] `src/runtime/signal-expr/README.md` created with architecture overview
- [ ] README includes example: construct simple DAG and evaluate it
- [ ] README includes cache behavior explanation (per-frame memoization)
- [ ] README includes section: "Adding new node kinds" (for future sprints)
- [ ] README includes section: "Performance characteristics" (O(1) cache hits, etc.)
- [ ] Code examples are runnable (can copy-paste into tests)
- [ ] All exported functions have JSDoc comments with examples

---

## Sprint Scope

### This Sprint Delivers

1. **Core Evaluator Infrastructure** - Types, cache, environment, evaluator
2. **Pure Node Evaluation** - const, timeAbsMs, map, zip
3. **OpCode Registry** - Unary and binary pure functions

### Explicitly Deferred (Future Sprints)

- Sprint 2+: select nodes, inputSlot nodes
- Sprint 3+: busCombine nodes (bus evaluation)
- Sprint 4+: transform nodes (adapter/lens)
- Sprint 5+: stateful nodes (integrate, delay, etc.)
- Sprint 6+: closureBridge nodes (gradual migration)
- Sprint 7+: Block compiler migration

---

## Quality Gates

### Functional Completeness

- [ ] All 4 node kinds evaluate correctly (const, timeAbsMs, map, zip)
- [ ] Cache hit/miss logic is correct (verified by tests)
- [ ] OpCode registry handles all planned opcodes

### Performance

- [ ] Cache hit path is <10ns (measure with micro-benchmark)
- [ ] No allocations in hot path (evalSig, applyPureFn, applyBinaryFn)
- [ ] Can evaluate 1000-node DAG in <1ms

### Code Quality

- [ ] All tests pass (`just test`)
- [ ] Test coverage ≥80% for new code
- [ ] No TypeScript errors (`just typecheck`)
- [ ] No lint errors (`just lint`)

### Documentation

- [ ] README exists and explains evaluator
- [ ] All public functions have JSDoc comments
- [ ] Code examples are runnable

---

## File Checklist

### New Files Created

- [ ] `src/runtime/signal-expr/types.ts`
- [ ] `src/runtime/signal-expr/SigFrameCache.ts`
- [ ] `src/runtime/signal-expr/SigEnv.ts`
- [ ] `src/runtime/signal-expr/OpCodeRegistry.ts`
- [ ] `src/runtime/signal-expr/SigEvaluator.ts`
- [ ] `src/runtime/signal-expr/__tests__/SigEvaluator.test.ts`
- [ ] `src/runtime/signal-expr/README.md`

### Modified Files

- [ ] None expected (sprint is isolated)

---

## Verification Steps

1. Run full test suite: `just test`
2. Type check: `just typecheck`
3. Lint: `just lint`
4. Manual smoke test: construct DAG, evaluate, verify result
5. Use Chrome DevTools MCP to verify behavior (per CLAUDE.md)
6. Benchmark cache performance

---

## Sprint Complete When

1. All P0 acceptance criteria are met (7/7 items)
2. All P1 acceptance criteria are met (3/3 items)
3. All P2 acceptance criteria are met (1/1 items)
4. All quality gates pass
5. All files are created
6. Code is committed to worktree

**Total Acceptance Criteria**: 68 checkboxes across 7 deliverables

---

## Ready for Next Sprint When

- This sprint's DOD is fully met
- Sprint 2 planning is complete (select and inputSlot nodes)
- No blocking bugs or architectural issues discovered
- Performance benchmarks meet targets

---

## Notes

- Focus on **correctness first, optimization second**
- Per CLAUDE.md: "Doing it right the first time is far more efficient than redoing it later"
- This is **foundation code** - must be rock-solid
- No user-visible features yet - integration happens in later sprints
