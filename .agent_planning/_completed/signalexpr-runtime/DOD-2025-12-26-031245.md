# Definition of Done: Phase 4 SignalExpr Runtime Integration

**Generated**: 2025-12-26-031245
**Plan**: PLAN-2025-12-26-031245.md
**Source STATUS**: STATUS-2025-12-26-040000.md

---

## Sprint Scope

This sprint delivers **full compiler and runtime integration** for SignalExpr IR evaluation:
- Complete all missing SigEvaluator node kinds (13/13 = 100%)
- Wire IR emission into compilation pipeline
- Wire IR evaluation into Player runtime

**Deferred to Future Sprints**:
- Block migration beyond AddSignal (Wave 1: Sprint 8+)
- Oscillator migration (Sprint 9+)
- ClosureBridge removal (Sprint 10+)
- Performance optimization (Sprint 11+)

---

## Acceptance Criteria

### Workstream A: Complete SigEvaluator (P0)

#### Deliverable A1: timeModelMs Node Kind
- [ ] evalTimeModelMs() function implemented in SigEvaluator.ts
- [ ] Reads env.timeModel.tModelMs (or computes from tAbsMs)
- [ ] Returns correct value for InfiniteTimeRoot (tModelMs = tAbsMs)

- [ ] Returns correct value for FiniteTimeRoot (mapped time)
- [ ] Unit tests pass for all TimeRoot kinds
- [ ] Integration test: timeModelMs used in oscillator IR evaluation

#### Deliverable A2: phase01 Node Kind
- [ ] evalPhase01() function implemented in SigEvaluator.ts
- [ ] Reads env.timeModel.phase01 or computes from tModelMs
- [ ] Returns 0.0 at start of cycle
- [ ] Returns 0.5 at midpoint of cycle
- [ ] Wraps correctly at cycle boundary (0.999 -> 0.0)
- [ ] Returns 0 (or throws) for non-cyclic time roots
- [ ] Unit tests pass for phase calculation
- [ ] Integration test: phase01 used in waveform generation

#### Deliverable A3: wrapEvent Node Kind
- [ ] evalWrapEvent() function implemented in SigEvaluator.ts
- [ ] Returns 1.0 on rising edge when phase wraps
- [ ] Returns 0.0 otherwise
- [ ] Uses edgeDetectWrap stateful operation for detection
- [ ] Unit test: wrapEvent fires at cycle boundary
- [ ] Unit test: wrapEvent does not fire mid-cycle
- [ ] Unit test: wrapEvent fires every period for continuous playback
- [ ] Integration test: wrapEvent triggers sample-and-hold

#### Deliverable A4: edgeDetectWrap Stateful Operation
- [ ] evalEdgeDetectWrap() function implemented in SigEvaluator.ts
- [ ] State layout defined: { prevPhase: f64 }
- [ ] Detects wrap when phase drops discontinuously (0.95 -> 0.05)
- [ ] Returns 1.0 on wrap edge, 0.0 otherwise
- [ ] Handles first frame correctly (no previous phase)
- [ ] State persists previous phase across frames
- [ ] Unit tests pass for wrap detection
- [ ] Golden test validates expected behavior

---

### Workstream B: Compiler Integration (P1)

#### Deliverable B1: SignalExprTable in Program Type
- [ ] Program interface extended with `signalTable?: SignalExprTable`
- [ ] Program interface extended with `constPool?: ConstPool`
- [ ] Program interface extended with `stateLayout?: StateLayout`
- [ ] TypeScript compilation succeeds
- [ ] Existing code compiles (backward compatible)
- [ ] Unit test: Program can be created with signalTable
- [ ] Unit test: Program can be created without signalTable

#### Deliverable B2: V2 Adapter for Block Compilers
- [ ] BlockCompilerV2 interface defined (IR-based signature)
- [ ] adaptV2Compiler() function converts V2 -> V1 interface
- [ ] Adapter creates IRBuilder for each block
- [ ] Adapter registers input closures as closureBridge nodes
- [ ] Adapter returns closure that evaluates IR via evalSig
- [ ] Unit test: Adapter compiles simple block
- [ ] Unit test: Adapter handles multiple inputs
- [ ] Unit test: Mixed V1/V2 compilers work together

#### Deliverable B3: StateLayout Computation
- [ ] StateLayout interface defined (f64Count, f32Count, i32Count)
- [ ] StateId type defined (buffer type + offset)
- [ ] computeStateLayout() function implemented
- [ ] Scans all SignalExprStateful nodes
- [ ] Allocates unique offsets for each operation
- [ ] Returns StateLayout with total buffer sizes
- [ ] Unit test: Empty IR produces empty layout
- [ ] Unit test: Multiple stateful ops get unique offsets
- [ ] Unit test: Different buffer types allocated correctly

#### Deliverable B4: AddSignal Block Migration
- [ ] AddSignal updated to V2 signature
- [ ] Emits zip node with OpCode.Add
- [ ] Wrapped with adaptV2Compiler
- [ ] Registered in block registry
- [ ] Unit test: AddSignal compiles to IR
- [ ] Unit test: IR structure is correct
- [ ] Unit test: Closure execution matches IR execution
- [ ] Golden test: AddSignal IR === closure output
- [ ] MIGRATED_BLOCKS.add('AddSignal')

#### Deliverable B5: Pipeline Wiring
- [ ] Compiler creates SignalExprBuilder at compilation start
- [ ] V2 blocks receive builder and emit nodes
- [ ] Compiler collects all nodes into SignalExprTable
- [ ] Compiler computes ConstPool from builder
- [ ] Compiler computes StateLayout from nodes
- [ ] Program includes signalTable, constPool, stateLayout
- [ ] Unit test: Compilation produces SignalExprTable
- [ ] Unit test: SignalExprTable contains V2 block nodes
- [ ] Unit test: ConstPool is deduplicated
- [ ] Integration test: Program has both closure and IR

#### Deliverable B6: End-to-End Compiler Test
- [ ] Test creates patch with AddSignal + constants
- [ ] Test compiles patch and extracts Program
- [ ] Test verifies signalTable, constPool, stateLayout exist
- [ ] Test evaluates closure path
- [ ] Test evaluates IR path
- [ ] Test verifies closure === IR output (tolerance 1e-10)
- [ ] Test runs at multiple time points (0, 100, 500, 1000 ms)
- [ ] All assertions pass

---

### Workstream C: Runtime Integration (P2)

#### Deliverable C1: SigEnv Creation in Player
- [ ] Player checks if program.signalTable exists
- [ ] Player allocates StateBuffer on program load (via stateLayout)
- [ ] Player creates SigEnv each frame with:
  - tAbsMs (player time)
  - constPool (from program)
  - cache (frame cache, reset each frame)
  - state (persistent StateBuffer)
  - runtimeCtx (deltaSec, deltaMs, seed)
  - closureRegistry (for closureBridge)
  - timeModel (from current TimeRoot)
- [ ] StateBuffer persists across frames
- [ ] StateBuffer resets on program reload
- [ ] Unit test: SigEnv created when signalTable exists
- [ ] Unit test: StateBuffer persists across frames

#### Deliverable C2: Wire evalSig into renderOnce()
- [ ] Player.renderOnce() checks if signalTable exists
- [ ] If signalTable exists:
  - Calls evalSig(rootId, env, nodes)
  - Uses IR path for rendering
- [ ] If signalTable missing:
  - Calls program.signal(tMs, ctx)
  - Legacy closure path (backward compat)
- [ ] Unit test: IR path executes when signalTable present
- [ ] Unit test: Closure path executes when signalTable absent
- [ ] Unit test: IR path produces valid RenderTree
- [ ] Integration test: Player renders frames using IR
- [ ] Visual test: No difference between closure and IR

#### Deliverable C3: Update Materializer
- [ ] Materializer imports SigEvaluator from runtime/signal-expr
- [ ] Materializer.evalSig calls real SigEvaluator (not SignalBridge)
- [ ] Materializer creates SigEnv for field materialization
- [ ] Unit test: Materializer evaluates IR correctly
- [ ] Unit test: Field values match previous behavior
- [ ] Integration test: RenderInstances2D works with IR
- [ ] Visual test: No regression in instance rendering

---

## Overall Acceptance Criteria

### Code Quality
- [ ] All TypeScript compilation succeeds (`just typecheck`)
- [ ] No TypeScript errors or warnings
- [ ] All linter rules pass (`just lint`)
- [ ] Code follows existing patterns and conventions

### Testing
- [ ] All existing tests pass (`just test`)
- [ ] New unit tests added for all functions (>90% coverage)
- [ ] Integration tests validate end-to-end behavior
- [ ] Golden tests confirm IR === closure output

### Functionality
- [ ] Dev server runs without errors (`just dev`)
- [ ] Manual test: Patch with AddSignal renders correctly
- [ ] Manual test: Closure path works (no signalTable)
- [ ] Manual test: IR path works (with signalTable)
- [ ] No visual regressions in existing patches

### Documentation
- [ ] Code comments explain complex logic
- [ ] Function signatures have JSDoc
- [ ] Migration status documented (MIGRATED_BLOCKS updated)
- [ ] PLAN and DOD files committed

---

## Exit Criteria (All Must Be True)

1. **SigEvaluator Complete**: 13/13 node kinds implemented and tested
2. **Compiler Produces IR**: SignalExprTable included in Program for V2 blocks
3. **Runtime Executes IR**: Player calls evalSig for IR-based programs
4. **One Block Migrated**: AddSignal works in both closure and IR modes
5. **All Tests Pass**: `just check` succeeds (typecheck + lint + test)
6. **No Regressions**: Existing functionality unchanged
7. **Visual Validation**: Manual testing confirms correct rendering

---

## Non-Goals (Explicitly Out of Scope)

- Migrating blocks beyond AddSignal
- Removing closure path or closureBridge
- Performance optimization
- Hot swap state preservation for IR
- Full oscillator implementation
- Field expression IR (Phase 5+)

---

## Rollback Plan

If integration fails or causes regressions:

1. **Compiler rollback**: Remove signalTable emission, keep V2Adapter but don't use it
2. **Runtime rollback**: Remove IR evaluation path, use closure path always
3. **SigEvaluator**: Infrastructure can remain (doesn't affect production if not called)
4. **Testing**: Revert to closure-only golden tests

All changes are designed to be backward compatible (optional fields, fallback paths).
