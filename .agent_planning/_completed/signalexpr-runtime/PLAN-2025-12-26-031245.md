# Phase 4 SignalExpr Runtime Integration Plan

**Generated**: 2025-12-26-031245
**Source STATUS**: STATUS-2025-12-26-040000.md
**Topic**: signalexpr-runtime
**Sprint Scope**: Complete missing SigEvaluator nodes + Full compiler/runtime integration

---

## Executive Summary

**Current State**: SignalExpr infrastructure is ~30% complete - SigEvaluator, StateBuffer, and SignalExprBuilder are well-implemented and thoroughly tested, but completely isolated from production runtime.

**Key Findings from STATUS-2025-12-26-040000.md**:
- SigEvaluator handles 10/13 node kinds (77%)
- Missing: timeModelMs, phase01, wrapEvent, edgeDetectWrap
- SigEvaluator is ONLY called in tests, NEVER in production
- Player.renderOnce() calls closure functions directly
- No SignalExprTable produced by compiler
- StateBuffer not allocated in runtime
- MIGRATED_BLOCKS set is empty (0/28 blocks migrated)

**Critical Gap**: Despite excellent infrastructure, the entire production rendering path still runs on legacy closures. Block compilers emit closures, not IR.

**Sprint Goal**: Complete the missing SigEvaluator node kinds AND wire the IR evaluator into both compiler output and runtime execution through three parallel workstreams.

**Total Work Items**: 13 (P0: 4, P1: 6, P2: 3)

---

## Gap Analysis by Dimension

### 1. Core Infrastructure (COMPLETE ✓)
- SigEvaluator: 77% node kind coverage
- StateBuffer: Complete implementation with comprehensive tests
- SignalExprBuilder: Complete minimal builder for block migration
- ClosureRegistry: Complete bridge infrastructure
- Test coverage: Excellent (100+ tests in SigEvaluator.test.ts, SigStateful.test.ts)

### 2. Missing Node Kinds (INCOMPLETE - P0)
**Gap**: 3/13 node kinds not implemented
- timeModelMs (time model transformation)
- phase01 (cyclic phase)
- wrapEvent (wrap event trigger)
- edgeDetectWrap (stateful operation)

**Impact**: Cannot evaluate IR for time-model-based blocks (oscillators, cyclic animations)

**Evidence**: STATUS-2025-12-26-040000.md lines 42-44, 62

### 3. Compiler Integration (MISSING - P1)
**Gap**: No IR emission in compilation pipeline
- Block compilers still emit closures (see DEBUGGER-ARCHITECTURE-FACTS.md lines 26-46)
- No SignalExprTable in Program type (see compiler/types.ts:122-125)
- No IR lowering pass
- compiledPortMap contains closures, not IR nodes

**Impact**: SigEvaluator cannot run because no IR is produced

**Evidence**: STATUS-2025-12-26-040000.md lines 91-104, 219-220

### 4. Runtime Integration (MISSING - P2)
**Gap**: Player uses legacy closure execution
- Player.renderOnce() calls program.signal(tMs, ctx) which is a closure
- No SigEnv creation during frame setup
- No evalSig invocation from Player
- Materializer has its own evalSig that wraps closures (see DEBUGGER-ARCHITECTURE-FACTS.md lines 188-206)

**Impact**: IR evaluation path is dead code

**Evidence**: STATUS-2025-12-26-040000.md lines 169-224

### 5. State Management (INFRASTRUCTURE COMPLETE, WIRING MISSING - P3)
**Gap**: StateBuffer not managed by runtime
- No StateLayout computation during compilation
- No StateBuffer allocation during program creation
- No state persistence managed by Player
- SigEnv created in tests includes state, but no production code creates SigEnv

**Impact**: Stateful operations (integrate, delayMs, sampleHold, slew) work in tests but not production

**Evidence**: STATUS-2025-12-26-040000.md lines 227-272

---

## Parallel Workstreams

This plan is structured as **three independent workstreams** that can be executed by separate agents after dependencies are met:

### Workstream A: Complete SigEvaluator
**Goal**: Implement missing node kinds
**Dependencies**: None (can start immediately)
**Owner**: Any agent

### Workstream B: Compiler Integration
**Goal**: Wire IR emission into compilation pipeline
**Dependencies**: None for initial setup; P0-1 from Workstream A required for end-to-end testing
**Owner**: Any agent

### Workstream C: Runtime Integration
**Goal**: Wire IR evaluation into Player
**Dependencies**: Workstream B (compiler must produce IR)
**Owner**: Any agent

---

## Work Items - Workstream A: Complete SigEvaluator

### P0-A1: Implement timeModelMs Node Kind

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: None
**Spec Reference**: design-docs/3-Synthesized/02-Time-Architecture.md • **Status Reference**: STATUS-2025-12-26-040000.md §Question 1 lines 42-44

#### Description
Implement the timeModelMs node kind in SigEvaluator. This node represents model time after time model transformation (e.g., cyclic wrapping, finite duration mapping).

Currently throws "not yet implemented (future sprint)" (SigEvaluator.ts:135-140).

#### Acceptance Criteria
- [ ] evalTimeModelMs() function implemented in SigEvaluator.ts
- [ ] Reads env.timeModel.tModelMs (or computes from tAbsMs if no model)
- [ ] Returns number type (milliseconds)
- [ ] Unit test: timeModelMs returns correct value for InfiniteTimeRoot

- [ ] Unit test: timeModelMs returns correct value for FiniteTimeRoot (mapped)
- [ ] Integration test: timeModelMs used in oscillator IR evaluation

#### Technical Notes
- TimeModel should be available in SigEnv (may need to add env.timeModel field)
- For InfiniteTimeRoot: tModelMs = tAbsMs

- For FiniteTimeRoot: tModelMs = map(tAbsMs, 0, duration, 0, duration)
- See design-docs/3-Synthesized/02-Time-Architecture.md for time model semantics

---

### P0-A2: Implement phase01 Node Kind

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0-A1 (timeModelMs)
**Spec Reference**: design-docs/3-Synthesized/02-Time-Architecture.md • **Status Reference**: STATUS-2025-12-26-040000.md §Question 1 line 43

#### Description
Implement the phase01 node kind in SigEvaluator. This node represents normalized phase [0..1] for cyclic time models.

Currently throws "not yet implemented (future sprint)" (SigEvaluator.ts:135-140).

#### Acceptance Criteria
- [ ] evalPhase01() function implemented in SigEvaluator.ts
- [ ] Reads env.timeModel.phase01 (or computes from tModelMs and period)
- [ ] Returns number type in range [0, 1)
- [ ] Unit test: phase01 returns 0.0 at start of cycle
- [ ] Unit test: phase01 returns 0.5 at midpoint of cycle
- [ ] Unit test: phase01 wraps at cycle boundary (0.999 -> 0.0)
- [ ] Unit test: phase01 is 0 for non-cyclic time roots
- [ ] Integration test: phase01 used in oscillator phase calculation

#### Technical Notes

- phase01 = 0 for InfiniteTimeRoot and FiniteTimeRoot (or throw error)
- This is the primary input for waveform generation (sin, square, saw, etc.)

---

### P0-A3: Implement wrapEvent Node Kind

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0-A2 (phase01)
**Spec Reference**: design-docs/3-Synthesized/02-Time-Architecture.md • **Status Reference**: STATUS-2025-12-26-040000.md §Question 1 line 44

#### Description
Implement the wrapEvent node kind in SigEvaluator. This node emits a trigger signal when phase wraps from 0.999... -> 0.0.

Currently throws "not yet implemented (future sprint)" (SigEvaluator.ts:135-140).

#### Acceptance Criteria
- [ ] evalWrapEvent() function implemented in SigEvaluator.ts
- [ ] Returns 1.0 on rising edge when phase wraps to 0
- [ ] Returns 0.0 otherwise
- [ ] Uses state (edgeDetectWrap stateful op) to detect wrap
- [ ] Unit test: wrapEvent fires at cycle boundary
- [ ] Unit test: wrapEvent does not fire mid-cycle
- [ ] Unit test: wrapEvent fires every period for continuous playback
- [ ] Integration test: wrapEvent triggers sample-and-hold update

#### Technical Notes
- Requires edgeDetectWrap stateful operation (see P0-A4)
- Wrap detection: phase[t-1] > 0.9 && phase[t] < 0.1 (heuristic)
- Or track previous phase in state and detect discontinuity
- See Bus pulse semantics in design-docs/3-Synthesized/03-Buses.md

---

### P0-A4: Implement edgeDetectWrap Stateful Operation

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: P0-A2 (phase01)
**Spec Reference**: design-docs/3-Synthesized/02-Time-Architecture.md • **Status Reference**: STATUS-2025-12-26-040000.md §Question 1 line 62

#### Description
Implement the edgeDetectWrap stateful operation in SigEvaluator. This operation detects phase wrap discontinuities (0.999 -> 0.0) and emits a trigger.

Currently throws "time model operations - future sprint" (SigEvaluator.ts:517-519).

#### Acceptance Criteria
- [ ] evalEdgeDetectWrap() function implemented in SigEvaluator.ts
- [ ] State layout: { prevPhase: f64 }
- [ ] Detects wrap when phase drops discontinuously (e.g., 0.95 -> 0.05)
- [ ] Returns 1.0 on wrap edge, 0.0 otherwise
- [ ] Unit test: detects wrap at cycle boundary
- [ ] Unit test: does not fire on continuous phase increase
- [ ] Unit test: state persists previous phase across frames
- [ ] Unit test: handles first frame (no previous phase)
- [ ] Golden test: matches expected wrap detection behavior

#### Technical Notes
- State structure: { prevPhase: f64 (offset in StateBuffer.f64) }
- Wrap detection logic: (prevPhase > 0.9 && currentPhase < 0.1)
- Edge cases: first frame (prevPhase = NaN or 0), paused playback
- Store currentPhase as prevPhase for next frame
- See SigStateful.test.ts for stateful operation test patterns

---

## Work Items - Workstream B: Compiler Integration

### P1-B1: Add SignalExprTable to Program Type

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: None
**Spec Reference**: design-docs/3-Synthesized/05-Compilation.md • **Status Reference**: STATUS-2025-12-26-040000.md §Question 2 lines 112-113

#### Description
Extend the Program type to include an optional SignalExprTable. This enables the compiler to produce both closure-based AND IR-based representations during migration.

#### Acceptance Criteria
- [ ] Program interface extended with `signalTable?: SignalExprTable`
- [ ] Program interface extended with `constPool?: ConstPool`
- [ ] Program interface extended with `stateLayout?: StateLayout`
- [ ] TypeScript compilation succeeds
- [ ] Existing code compiles (signalTable is optional)
- [ ] Unit test: Program can be created with signalTable
- [ ] Unit test: Program can be created without signalTable (backward compat)

#### Technical Notes
- File: src/editor/compiler/types.ts lines 122-125
- SignalExprTable defined in src/editor/compiler/ir/signalExpr.ts
- ConstPool defined in src/editor/runtime/signal-expr/SignalExprBuilder.ts
- StateLayout will be defined in P1-B3
- This change is non-breaking (optional field)

---

### P1-B2: Create IR Emission Adapter for Block Compilers

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: P1-B1
**Spec Reference**: SPRINT-07-blockCompilerMigration.md §P2 • **Status Reference**: STATUS-2025-12-26-040000.md §Question 2 lines 114-124

#### Description
Create an adapter layer that allows block compilers to emit SignalExpr IR while maintaining compatibility with the existing closure-based pipeline.

This adapter bridges the gap between V2 compilers (emit IR) and the existing pipeline (expects closures).

#### Acceptance Criteria
- [ ] BlockCompilerV2 interface defined with IR-based signature
- [ ] adaptV2Compiler() function converts V2 -> V1 interface
- [ ] Adapter creates IRBuilder for each block compilation
- [ ] Adapter registers input closures as closureBridge nodes
- [ ] Adapter returns closure that evaluates IR via evalSig
- [ ] Unit test: Adapter compiles simple block (AddSignal)
- [ ] Unit test: Adapter handles multiple inputs
- [ ] Unit test: Mixed V1/V2 compilers work together
- [ ] Integration test: Adapted block produces same output as closure

#### Technical Notes
- File: src/editor/compiler/blocks/adapters/V2Adapter.ts (new)
- V2 signature: compile(block, inputs: Record<string, SigExprId>, builder: SignalExprBuilder)
- V1 signature: compile(block, inputs: Record<string, Signal<T>>, env: CompileCtx)
- Adapter wraps each input closure as closureBridge node
- Adapter wraps output IR as closure that calls evalSig
- This enables gradual migration without breaking existing blocks

---

### P1-B3: Define StateLayout Type and Computation

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: None
**Spec Reference**: design-docs/3-Synthesized/05-Compilation.md • **Status Reference**: STATUS-2025-12-26-040000.md §Question 5 lines 254-272

#### Description
Define the StateLayout type and implement compilation-time state layout computation. StateLayout describes the memory layout for all stateful operations in the IR.

#### Acceptance Criteria
- [ ] StateLayout interface defined (f64Count, f32Count, i32Count)
- [ ] StateId type defined (offset + buffer type)
- [ ] computeStateLayout() function implemented
- [ ] Scans all SignalExprStateful nodes
- [ ] Allocates offsets for each stateful operation
- [ ] Returns StateLayout with total buffer sizes
- [ ] Unit test: Empty IR produces empty layout
- [ ] Unit test: Single integrate op allocates f64 slot
- [ ] Unit test: Multiple stateful ops get unique offsets
- [ ] Unit test: Different buffer types allocated correctly

#### Technical Notes
- File: src/editor/compiler/ir/stateLayout.ts (new)
- StateLayout: { f64Count: number, f32Count: number, i32Count: number }
- StateId: { buffer: 'f64' | 'f32' | 'i32', offset: number }
- Each stateful op has known state requirements (e.g., integrate needs 1 f64)
- Layout computation is deterministic (same IR -> same layout)
- Used at Program creation time to allocate StateBuffer

---

### P1-B4: Implement Dual-Emit Mode for One Block (AddSignal)

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: P1-B2, P1-B3
**Spec Reference**: SPRINT-07-blockCompilerMigration.md §P0 • **Status Reference**: STATUS-2025-12-26-040000.md §Question 2 lines 91-99

#### Description
Migrate the AddSignal block compiler to emit both closure AND IR using the V2Adapter. This is the end-to-end validation that compiler integration works.

#### Acceptance Criteria
- [ ] AddSignal block compiler updated to V2 signature
- [ ] Emits zip node with OpCode.Add
- [ ] Wrapped with adaptV2Compiler
- [ ] Registered in block registry
- [ ] Unit test: AddSignal compiles to IR
- [ ] Unit test: IR structure is correct (zip node with Add opcode)
- [ ] Unit test: Closure execution matches IR execution
- [ ] Golden test: AddSignal IR output matches closure output
- [ ] Integration test: AddSignal works in patch graph

#### Technical Notes
- File: src/editor/compiler/blocks/signal/AddSignal.ts
- Old: compile(block, inputs, env) -> { output: (t, ctx) => a(t, ctx) + b(t, ctx) }
- New: compile(block, inputs: Record<string, SigExprId>, builder) -> { output: builder.sigZip(a, b, opcode(OpCode.Add)) }
- Wrapped with adaptV2Compiler for compatibility
- MIGRATED_BLOCKS.add('AddSignal') once verified

---

### P1-B5: Wire SignalExprTable into Compilation Pipeline

**Status**: Not Started
**Effort**: Large (1-2 weeks)
**Dependencies**: P1-B1, P1-B2, P1-B3, P1-B4
**Spec Reference**: design-docs/3-Synthesized/05-Compilation.md • **Status Reference**: STATUS-2025-12-26-040000.md §Question 2 lines 100-124

#### Description
Modify the compiler pipeline to collect IR nodes from all V2 blocks and build a SignalExprTable during compilation.

This is the main integration point where IR becomes part of the compiled Program.

#### Acceptance Criteria
- [ ] Compiler creates SignalExprBuilder at compilation start
- [ ] V2 blocks receive builder and emit nodes
- [ ] Compiler collects all nodes into SignalExprTable
- [ ] Compiler computes ConstPool from builder
- [ ] Compiler computes StateLayout from nodes
- [ ] Program includes signalTable, constPool, stateLayout
- [ ] Unit test: Compilation produces SignalExprTable
- [ ] Unit test: SignalExprTable contains nodes from all V2 blocks
- [ ] Unit test: ConstPool is deduplicated
- [ ] Unit test: StateLayout matches stateful operations
- [ ] Integration test: Compiled program has both closure and IR paths

#### Technical Notes
- File: src/editor/compiler/compileBusAware.ts (modify)
- Create global SignalExprBuilder at compilation start
- Pass builder to V2 blocks during compile
- After all blocks compiled, call builder.build() to get nodes
- Compute StateLayout via computeStateLayout(nodes)
- Attach to Program: { signal, event, signalTable, constPool, stateLayout }
- Closure path remains unchanged (backward compat)

---

### P1-B6: Validate Compiler Output with End-to-End Test

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P1-B5, P0-A1, P0-A2, P0-A3, P0-A4 (all SigEvaluator nodes)
**Spec Reference**: SPRINT-07-blockCompilerMigration.md §P1 • **Status Reference**: STATUS-2025-12-26-040000.md lines 212-215

#### Description
Create end-to-end test that compiles a simple patch with AddSignal, evaluates both closure and IR paths, and verifies they produce identical output.

#### Acceptance Criteria
- [ ] Test creates patch with two constant blocks + AddSignal
- [ ] Test compiles patch and extracts Program
- [ ] Test verifies Program.signalTable exists
- [ ] Test verifies Program.constPool exists
- [ ] Test verifies Program.stateLayout exists
- [ ] Test evaluates closure path: program.signal(t, ctx)
- [ ] Test evaluates IR path: evalSig(rootId, env, nodes)
- [ ] Test verifies closure output === IR output (tolerance 1e-10)
- [ ] Test runs at multiple time points (0, 100, 500, 1000 ms)
- [ ] All assertions pass

#### Technical Notes
- File: src/editor/compiler/__tests__/IRCompilation.test.ts (new)
- This is the "golden test" for compiler integration
- If this test passes, compiler integration is functionally complete
- Any mismatch indicates bug in IR emission or evaluation

---

## Work Items - Workstream C: Runtime Integration

### P2-C1: Add SigEnv Creation to Player

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: Workstream B complete (compiler produces IR)
**Spec Reference**: design-docs/3-Synthesized/06-Runtime.md • **Status Reference**: STATUS-2025-12-26-040000.md §Question 4 lines 254-272

#### Description
Extend Player to create a SigEnv (Signal Evaluation Environment) each frame when a Program has a SignalExprTable. This provides the environment for IR evaluation.

#### Acceptance Criteria
- [ ] Player checks if program.signalTable exists
- [ ] Player allocates StateBuffer on program load (using stateLayout)
- [ ] Player creates SigEnv each frame with:
  - tAbsMs (current player time)
  - constPool (from program)
  - cache (frame cache, reset each frame)
  - state (persistent StateBuffer)
  - runtimeCtx (deltaSec, deltaMs, seed)
  - closureRegistry (for closureBridge nodes)
  - timeModel (from current TimeRoot)
- [ ] Player stores StateBuffer persistently across frames
- [ ] Player resets StateBuffer on program reload
- [ ] Unit test: Player creates SigEnv when signalTable exists
- [ ] Unit test: Player does NOT create SigEnv when signalTable missing
- [ ] Unit test: StateBuffer persists across frames
- [ ] Unit test: StateBuffer reset on program reload

#### Technical Notes
- File: src/editor/runtime/player.ts (modify)
- SigEnv creation: see SigStateful.test.ts for test pattern
- StateBuffer allocation: createStateBuffer(stateLayout)
- Frame cache allocation: createSigFrameCache(nodes.length)
- closureRegistry: extract from existing closure path (if needed)
- This is preparation for IR evaluation but does not change execution path yet

---

### P2-C2: Wire evalSig into Player.renderOnce()

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: P2-C1
**Spec Reference**: design-docs/3-Synthesized/06-Runtime.md • **Status Reference**: STATUS-2025-12-26-040000.md §Question 4 lines 169-187

#### Description
Modify Player.renderOnce() to evaluate the SignalExpr IR path when available, falling back to closure path for backward compatibility.

This is the critical integration point where IR evaluation enters the production runtime.

#### Acceptance Criteria
- [ ] Player.renderOnce() checks if program.signalTable exists
- [ ] If signalTable exists AND has rootId:
  - Calls evalSig(rootId, env, nodes) to get RenderTree
  - Uses IR path for frame rendering
- [ ] If signalTable missing:
  - Calls program.signal(tMs, ctx) (legacy closure path)
  - Backward compatibility maintained
- [ ] Unit test: IR path executes when signalTable present
- [ ] Unit test: Closure path executes when signalTable absent
- [ ] Unit test: IR path produces valid RenderTree
- [ ] Integration test: Player renders frames using IR evaluation
- [ ] Visual test: No visual difference between closure and IR paths

#### Technical Notes
- File: src/editor/runtime/player.ts lines 349-358 (modify renderOnce)
- Current: const tree = this.program.signal(this.tMs, this.runtimeCtx)
- New: if (this.program.signalTable) { tree = evalSigAsRenderTree(...) } else { tree = this.program.signal(...) }
- Need to identify rootId (main render output node)
- May need to add program.rootSigId field to identify output
- Type of evalSig result must be RenderTree (not number)

---

### P2-C3: Update Materializer to Use Real SigEvaluator

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: P2-C2
**Spec Reference**: DEBUGGER-ARCHITECTURE-FACTS.md §5 • **Status Reference**: STATUS-2025-12-26-040000.md §Question 4 lines 188-206

#### Description
Update Materializer to use the real SigEvaluator (from runtime/signal-expr) instead of the legacy SignalBridge wrapper.

This removes the intermediate SignalBridge layer and completes the runtime integration.

#### Acceptance Criteria
- [ ] Materializer imports SigEvaluator from runtime/signal-expr
- [ ] Materializer.evalSig calls SigEvaluator.evalSig (not SignalBridge)
- [ ] SignalBridge removed (or marked deprecated)
- [ ] Materializer creates SigEnv for field materialization
- [ ] Unit test: Materializer evaluates signal expressions correctly
- [ ] Unit test: Materializer produces same field values as before
- [ ] Integration test: RenderInstances2D works with IR-based fields
- [ ] Visual test: No regression in instance rendering

#### Technical Notes
- File: src/editor/runtime/field/Materializer.ts lines 134-146
- Current: env.signalBridge.evalSig(sigId, env) -> wraps closures
- New: evalSig(sigId, env, nodes) -> evaluates IR directly
- SignalBridge was a temporary bridge; can be removed after migration
- This completes the transition from closure-based to IR-based evaluation

---

## Dependency Graph

```
Workstream A (SigEvaluator):
  P0-A1 (timeModelMs) ─┐
                       ├─> P0-A2 (phase01) ─┐
                       │                     ├─> P0-A3 (wrapEvent)
                       │                     └─> P0-A4 (edgeDetectWrap)

Workstream B (Compiler):
  P1-B1 (SignalExprTable type) ─┬─> P1-B2 (V2 Adapter) ─┐
                                │                        │
  P1-B3 (StateLayout) ──────────┴────────────────────────┼─> P1-B4 (AddSignal migration)
                                                          │
                                                          └─> P1-B5 (Pipeline wiring)
                                                              │
  [P0-A1, P0-A2, P0-A3, P0-A4] ─────────────────────────────┴─> P1-B6 (E2E test)

Workstream C (Runtime):
  [Workstream B complete] ─> P2-C1 (SigEnv creation) ─> P2-C2 (Wire evalSig) ─> P2-C3 (Update Materializer)
```

**Critical Path**: A1→A2→A3,A4 (parallel) → B1,B3 (parallel) → B2 → B4 → B5 → B6 → C1 → C2 → C3

**Parallelizable**:
- P0-A3 and P0-A4 can run in parallel after P0-A2
- P1-B1 and P1-B3 can run in parallel
- Workstream A and early Workstream B (B1, B3) can run in parallel

---

## Recommended Sprint Planning

### Sprint 1: Complete SigEvaluator (Workstream A)
**Duration**: 1 week
**Focus**: Implement all missing node kinds

**Deliverables**:
- P0-A1: timeModelMs implementation
- P0-A2: phase01 implementation
- P0-A3: wrapEvent implementation
- P0-A4: edgeDetectWrap implementation
- All SigEvaluator tests passing

**Success Criteria**: SigEvaluator handles 13/13 node kinds (100%)

---

### Sprint 2: Compiler Integration Foundation (Workstream B, Part 1)
**Duration**: 1 week
**Focus**: Set up IR emission infrastructure

**Deliverables**:
- P1-B1: SignalExprTable in Program type
- P1-B2: V2 Adapter for block compilers
- P1-B3: StateLayout computation
- Infrastructure tests passing

**Success Criteria**: Compiler can theoretically produce IR (not yet wired)

---

### Sprint 3: Compiler Integration Execution (Workstream B, Part 2)
**Duration**: 1 week
**Focus**: Wire IR emission into compilation pipeline

**Deliverables**:
- P1-B4: AddSignal migrated to V2
- P1-B5: SignalExprTable wired into pipeline
- P1-B6: End-to-end compiler test passing

**Success Criteria**: Compiler produces IR for migrated blocks, golden tests pass

---

### Sprint 4: Runtime Integration (Workstream C)
**Duration**: 1 week
**Focus**: Wire IR evaluation into Player

**Deliverables**:
- P2-C1: SigEnv creation in Player
- P2-C2: evalSig wired into renderOnce()
- P2-C3: Materializer updated to use SigEvaluator

**Success Criteria**: Production runtime executes IR path, renders correctly

---

## Risk Assessment

### High Risk Items

1. **Time Model Integration (P0-A1, P0-A2)**
   - **Risk**: TimeModel may not be easily accessible in SigEnv
   - **Mitigation**: Add env.timeModel field, populated from Player's TimeRoot
   - **Impact**: Without time model, cyclic animations cannot work in IR

2. **Compiler Pipeline Modification (P1-B5)**
   - **Risk**: Breaking existing compiler functionality
   - **Mitigation**: Dual-emit mode maintains backward compatibility
   - **Impact**: If broken, all compilation fails

3. **Player Integration (P2-C2)**
   - **Risk**: IR path produces different output than closure path
   - **Mitigation**: Golden tests validate equivalence before integration
   - **Impact**: Visual regressions in animation output

### Medium Risk Items

4. **StateBuffer Lifecycle (P2-C1)**
   - **Risk**: State not persisting correctly across frames
   - **Mitigation**: Test patterns from SigStateful.test.ts
   - **Impact**: Stateful operations (integrate, delay) malfunction

5. **Adapter Performance (P1-B2)**
   - **Risk**: V2Adapter overhead slows compilation
   - **Mitigation**: Profile and optimize; adapter is temporary
   - **Impact**: Slower edit-compile-preview cycle

### Low Risk Items

6. **Missing OpCodes (various)**
   - **Risk**: Need additional opcodes for complex blocks
   - **Mitigation**: Add opcodes incrementally as needed
   - **Impact**: Some blocks cannot be fully migrated yet

---

## Definition of Done

Phase 4 is complete when ALL of the following are true:

### Workstream A (SigEvaluator)
- [ ] All 13 node kinds implemented (timeModelMs, phase01, wrapEvent, edgeDetectWrap)
- [ ] All SigEvaluator unit tests passing
- [ ] All SigStateful unit tests passing
- [ ] Golden tests for all node kinds passing

### Workstream B (Compiler)
- [ ] Program type includes signalTable, constPool, stateLayout
- [ ] V2Adapter implemented and tested
- [ ] StateLayout computation working
- [ ] At least one block (AddSignal) migrated to V2
- [ ] Compiler produces SignalExprTable for patches with V2 blocks
- [ ] End-to-end compiler test passing (closure === IR output)

### Workstream C (Runtime)
- [ ] Player creates SigEnv when signalTable present
- [ ] Player calls evalSig for IR-based programs
- [ ] StateBuffer allocated and persisted across frames
- [ ] Materializer uses real SigEvaluator
- [ ] Visual tests confirm no regression

### Overall
- [ ] All TypeScript compilation succeeds (`just typecheck`)
- [ ] All tests pass (`just test`)
- [ ] Dev server runs without errors (`just dev`)
- [ ] Manual testing: simple patch with AddSignal renders correctly
- [ ] MIGRATED_BLOCKS set updated (at least 1 block)

---

## Out of Scope (Future Work)

The following are explicitly OUT OF SCOPE for this sprint:

1. **Block Migration Wave 1** (Sprint 8+)
   - Migrating additional blocks beyond AddSignal
   - SubSignal, MulSignal, DivSignal, MinSignal, MaxSignal, ClampSignal

2. **Oscillator Block Migration** (Sprint 9+)
   - Full oscillator implementation with all waveforms
   - Requires timeModelMs, phase01 (delivered in this sprint)

3. **Closure Bridge Removal** (Sprint 10+)
   - Removing closureBridge node kind
   - Requires 100% block migration (28/28 blocks)

4. **Performance Optimization** (Sprint 11+)
   - Cache optimization
   - Memory layout optimization
   - Profiling and benchmarks

5. **Dual-Emit Removal** (Sprint 12+)
   - Removing closure path entirely
   - Requires all blocks migrated and tested

---

## Files Created/Modified

### Created Files
- `src/editor/compiler/ir/stateLayout.ts` - StateLayout type and computation
- `src/editor/compiler/blocks/adapters/V2Adapter.ts` - V2 compiler adapter
- `src/editor/compiler/__tests__/IRCompilation.test.ts` - E2E compilation test
- `.agent_planning/signalexpr-runtime/PLAN-2025-12-26-031245.md` - This file
- `.agent_planning/signalexpr-runtime/DOD-2025-12-26-031245.md` - Definition of Done

### Modified Files
- `src/editor/runtime/signal-expr/SigEvaluator.ts` - Add timeModelMs, phase01, wrapEvent, edgeDetectWrap
- `src/editor/compiler/types.ts` - Extend Program interface
- `src/editor/compiler/compileBusAware.ts` - Wire SignalExprTable into pipeline
- `src/editor/compiler/blocks/signal/AddSignal.ts` - Migrate to V2
- `src/editor/runtime/player.ts` - SigEnv creation, evalSig wiring
- `src/editor/runtime/field/Materializer.ts` - Use real SigEvaluator
- `src/editor/runtime/signal-expr/SigEnv.ts` - Add timeModel field
- `src/editor/runtime/signal-expr/MigrationTracking.ts` - Update MIGRATED_BLOCKS

---

## Success Metrics

**Quantitative**:
- Node kind coverage: 10/13 (77%) → 13/13 (100%)
- Block migration: 0/28 (0%) → 1/28 (3.5%)
- IR evaluation in production: 0% → 100% (for migrated blocks)
- Test coverage: maintain >90% for all new code

**Qualitative**:
- IR path produces visually identical output to closure path
- No performance regression in edit-compile-preview cycle
- Code quality: clean, well-documented, maintainable
- Developer experience: V2 block compilers are easier to write than V1

---

## Notes and Open Questions

### Open Questions
1. **TimeModel Access**: How should SigEnv access the current TimeModel? Add env.timeModel field populated from Player?
2. **Root Node Identification**: How do we identify the "root" SignalExpr node for RenderTree output? Add program.rootSigId?
3. **Closure Registry Lifecycle**: Who manages ClosureRegistry during migration? Compiler or runtime?
4. **StateBuffer Reset Logic**: When should StateBuffer be reset? Program reload, time seek, user action?

### Design Decisions to Validate
1. **Dual-Emit Strategy**: Keep both closure and IR paths during migration (backward compat)
2. **Adapter Layer**: Use V2Adapter to wrap new compilers for existing pipeline
3. **Gradual Migration**: Migrate one block at a time, validate with golden tests
4. **State Management**: StateLayout computed at compile time, StateBuffer allocated at runtime

### Documentation Needs
1. Update claude_memory/02-type-system.md with SignalExpr IR details
2. Update design-docs/3-Synthesized/06-Runtime.md with IR evaluation path
3. Create migration guide for block compiler authors
4. Document golden test framework usage

---

## References

- **Primary Spec**: design-docs/3-Synthesized/06-Runtime.md
- **Status Report**: STATUS-2025-12-26-040000.md
- **Sprint 7 Plan**: SPRINT-07-blockCompilerMigration.md
- **Architecture Facts**: DEBUGGER-ARCHITECTURE-FACTS.md
- **Time Model Spec**: design-docs/3-Synthesized/02-Time-Architecture.md
- **Bus Semantics**: design-docs/3-Synthesized/03-Buses.md
