# Sprint Plan: SignalExpr Runtime - Sprint 1 (Core Evaluator)
Generated: 2025-12-25-190000
Source: STATUS-20251225.md, HANDOFF.md

## Provenance
- **STATUS File**: STATUS-20251225.md
- **Specification**: HANDOFF.md, design-docs/12-Compiler-Final/01.1-CompilerMigration-Roadmap.md, design-docs/12-Compiler-Final/02-IR-Schema.md
- **Phase**: Phase 4: SignalExpr Runtime (Topic 1: signal-evaluator-core)

---

## Sprint Goal

**Deliver a working SignalExpr evaluator that can evaluate simple pure signal expressions (const, timeAbsMs, map, zip) with per-frame caching.**

This sprint establishes the foundation for all future signal evaluation. When complete, we can compile simple signal blocks to IR and evaluate them deterministically with automatic memoization.

---

## Scope

### In Scope (This Sprint)

1. **Core Evaluator Infrastructure**
   - `SigEvaluator` interface with `sample()` method
   - `SigEnv` evaluation environment
   - `SigFrameCache` per-frame memoization
   - Basic node type definitions (SignalExprIR union)

2. **Pure Node Evaluation**
   - `const` nodes (read from const pool)
   - `timeAbsMs` nodes (read from env)
   - `map` nodes (pure unary functions)
   - `zip` nodes (pure binary functions)

3. **OpCode Registry**
   - Core math opcodes (Add, Sub, Mul, Div, Sin, Cos, Abs, etc.)
   - `applyPureFn` and `applyBinaryFn` implementations

4. **Testing Infrastructure**
   - Unit tests for each node kind
   - Cache correctness tests (same frame = same value)
   - Frame invalidation tests
   - Basic integration tests (compose multiple nodes)

### Explicitly Out of Scope (Future Sprints)

- **Sprint 2+**: Bus combine evaluation (`busCombine` nodes)
- **Sprint 3+**: Transform chain execution (`transform` nodes, adapter/lens)
- **Sprint 4+**: Stateful operations (`stateful` nodes, StateBuffer, integrate/delay/sampleHold)
- **Sprint 5+**: Closure bridge for gradual migration
- **Sprint 6+**: Block compiler migration (all 9 signal blocks)
- **Future**: Full integration with existing compiler pipeline
- **Future**: Runtime player integration
- **Future**: Debug tracing and visualization

---

## Work Items

### P0: Define SignalExpr IR Types

**Status**: Not Started
**Effort**: Medium (1 day)
**Dependencies**: None
**Spec Reference**: HANDOFF.md §1 "Core Signal Evaluator", 02-IR-Schema.md §3 "Program IR"
**Status Reference**: STATUS-20251225.md §"What's COMPLETELY Missing" - "No SignalExprIR union type"

#### Description

Create the TypeScript type definitions for the SignalExpr intermediate representation. These types form the data structure that replaces signal closures.

For this sprint, we only need the **pure, stateless node kinds**:
- `const`: References a constant from the const pool
- `timeAbsMs`: Reads monotonic player time
- `timeModelMs`: Reads time after TimeModel mapping (deferred to later sprint)
- `phase01`: Reads phase for cyclic models (deferred to later sprint)
- `map`: Applies pure unary function to one signal
- `zip`: Applies pure binary function to two signals

Out of scope for Sprint 1: `inputSlot`, `select`, `transform`, `busCombine`, `stateful`, `closureBridge`

#### Acceptance Criteria (REQUIRED)

- [ ] `SignalExprIR` union type defined with node kinds: `const`, `timeAbsMs`, `map`, `zip`
- [ ] Each node type includes `kind` discriminator and `type: TypeDesc` field
- [ ] `SigExprId` type alias defined as `number` (dense index into node array)
- [ ] `PureFnRef` interface defined with `opcode: OpCode` field
- [ ] `OpCode` enum defined with at least: Sin, Cos, Tan, Abs, Floor, Ceil, Add, Sub, Mul, Div, Min, Max
- [ ] Type definitions include JSDoc comments explaining each node kind
- [ ] File exports all types for use in evaluator

#### Technical Notes

- Location: Create new file `src/runtime/signal-expr/types.ts`
- Reference existing `TypeDesc` from `src/editor/compiler/types.ts` (reuse, don't duplicate)
- Node IDs are numeric indices (NOT string IDs) for performance
- Each node must be serializable (no functions, no closures)
- Use discriminated unions for type safety in switch statements

**Example structure:**

```typescript
export type SigExprId = number; // Index into SignalExprIR[]

export type SignalExprIR =
  | ConstNode
  | TimeAbsMsNode
  | MapNode
  | ZipNode;

interface ConstNode {
  kind: 'const';
  type: TypeDesc;
  constId: number; // Index into const pool
}

interface TimeAbsMsNode {
  kind: 'timeAbsMs';
  type: TypeDesc;
}

interface MapNode {
  kind: 'map';
  type: TypeDesc;
  src: SigExprId;
  fn: PureFnRef;
}

interface ZipNode {
  kind: 'zip';
  type: TypeDesc;
  a: SigExprId;
  b: SigExprId;
  fn: PureFnRef;
}

export interface PureFnRef {
  opcode: OpCode;
}

export enum OpCode {
  // Unary
  Sin = 'sin',
  Cos = 'cos',
  Abs = 'abs',
  Floor = 'floor',
  Ceil = 'ceil',
  // Binary
  Add = 'add',
  Sub = 'sub',
  Mul = 'mul',
  Div = 'div',
  Min = 'min',
  Max = 'max',
}
```

---

### P0: Implement SigFrameCache

**Status**: Not Started
**Effort**: Small (0.5 day)
**Dependencies**: P0 (SignalExpr IR Types)
**Spec Reference**: HANDOFF.md §1 "Per-Frame Cache Structure"
**Status Reference**: STATUS-20251225.md §"What's COMPLETELY Missing" - "No per-frame caching (SigFrameCache)"

#### Description

Implement the per-frame memoization cache that ensures each signal is evaluated at most once per frame. This is critical for performance when signals are referenced multiple times (e.g., bus combine, multiple consumers).

The cache uses parallel typed arrays:
- `value: Float64Array` stores computed signal values
- `stamp: Uint32Array` stores the frameId when each value was computed
- Cache hit: `stamp[sigId] === frameId`

#### Acceptance Criteria (REQUIRED)

- [ ] `SigFrameCache` interface defined with `frameId`, `value`, `stamp`, `validMask` fields
- [ ] `createSigFrameCache(capacity: number)` factory function allocates typed arrays
- [ ] Cache correctly detects hits: `stamp[sigId] === frameId` returns cached value
- [ ] Cache correctly detects misses: `stamp[sigId] !== frameId` requires re-evaluation
- [ ] `newFrame(frameId: number)` method updates frameId without clearing arrays (stamp comparison handles invalidation)
- [ ] Cache supports at least 1024 signal nodes initially (grow dynamically later)
- [ ] Unit tests verify cache hit/miss logic, frame invalidation, and capacity

#### Technical Notes

- Location: Create `src/runtime/signal-expr/SigFrameCache.ts`
- Use `Float64Array` for number storage (precision over space for now)
- Use `Uint32Array` for stamps (frameId wraps at 2^32, acceptable)
- `validMask: Uint8Array` reserved for future non-number types (vec2, color, etc.)
- Do NOT clear arrays on `newFrame()` - let stamp comparison handle invalidation (performance)
- Frame IDs increment monotonically from 0; wrap-around at 2^32 is acceptable

**Example structure:**

```typescript
export interface SigFrameCache {
  frameId: number;
  value: Float64Array;
  stamp: Uint32Array;
  validMask: Uint8Array; // Future: for non-number types
}

export function createSigFrameCache(capacity: number): SigFrameCache {
  return {
    frameId: 0,
    value: new Float64Array(capacity),
    stamp: new Uint32Array(capacity),
    validMask: new Uint8Array(capacity),
  };
}

export function newFrame(cache: SigFrameCache, frameId: number): void {
  cache.frameId = frameId;
  // Do NOT clear arrays - stamp comparison handles invalidation
}
```

---

### P0: Implement SigEnv (Evaluation Environment)

**Status**: Not Started
**Effort**: Medium (0.75 day)
**Dependencies**: P0 (SigFrameCache), P0 (SignalExpr IR Types)
**Spec Reference**: HANDOFF.md §1 "The Evaluation Environment"
**Status Reference**: STATUS-20251225.md §"What's COMPLETELY Missing" - "No SigEnv (Evaluation Environment)"

#### Description

Create the evaluation environment that provides context for signal evaluation. This includes time values, const pool access, and the per-frame cache.

For this sprint, we implement a **minimal SigEnv** with only the fields needed for pure evaluation:
- Time values (tAbsMs)
- Const pool reader
- Per-frame cache

Out of scope: `slotValues`, `state`, `transformTable`, `runtimeCtx` (added in later sprints)

#### Acceptance Criteria (REQUIRED)

- [ ] `SigEnv` interface defined with `tAbsMs`, `constPool`, `cache` fields
- [ ] `ConstPool` interface defined as `{ numbers: number[] }` (expand later for vec2, color, etc.)
- [ ] `createSigEnv(params)` factory function creates environment with all required fields
- [ ] `getConstNumber(constId)` helper reads from const pool with bounds checking
- [ ] Environment is immutable during frame evaluation (readonly fields where applicable)
- [ ] Unit tests verify const pool access, time value reads, cache reference
- [ ] Type definitions are exported for use in evaluator

#### Technical Notes

- Location: Create `src/runtime/signal-expr/SigEnv.ts`
- Env is created once per frame, passed to all signal evaluations
- Const pool is shared across entire program (allocated at compile time)
- Time values are frame-scoped (same `tAbsMs` for all signals in one frame)
- Future: Add `tModelMs`, `phase01`, `slotValues`, `state`, `runtimeCtx` fields

**Example structure:**

```typescript
export interface ConstPool {
  numbers: number[];
  // Future: vec2, vec3, color, etc.
}

export interface SigEnv {
  readonly tAbsMs: number;
  readonly constPool: ConstPool;
  readonly cache: SigFrameCache;
  // Future: tModelMs, phase01, slotValues, state, runtimeCtx, debug
}

export function createSigEnv(params: {
  tAbsMs: number;
  constPool: ConstPool;
  cache: SigFrameCache;
}): SigEnv {
  return { ...params };
}

export function getConstNumber(pool: ConstPool, constId: number): number {
  if (constId < 0 || constId >= pool.numbers.length) {
    throw new Error(`Invalid constId: ${constId}`);
  }
  return pool.numbers[constId];
}
```

---

### P0: Implement Core Evaluator (const, timeAbsMs)

**Status**: Not Started
**Effort**: Medium (1 day)
**Dependencies**: P0 (SignalExpr IR Types), P0 (SigFrameCache), P0 (SigEnv)
**Spec Reference**: HANDOFF.md §1 "Core Evaluation Algorithm"
**Status Reference**: STATUS-20251225.md §"What's COMPLETELY Missing" - "No sample<T>(id, env) method"

#### Description

Implement the central signal evaluator with cache-first evaluation logic. This is the core runtime function that all signal evaluation flows through.

For this sprint, implement evaluation for the **simplest node kinds**:
- `const`: Read from const pool
- `timeAbsMs`: Read from environment

These two node kinds are sufficient to test the cache-first algorithm and establish the evaluator pattern.

#### Acceptance Criteria (REQUIRED)

- [ ] `evalSig(sigId, env, nodes)` function implements cache-first algorithm
- [ ] Cache hit path returns cached value without re-evaluation (O(1) array lookup)
- [ ] Cache miss path evaluates node based on `kind` discriminator
- [ ] `const` nodes return value from const pool via `getConstNumber()`
- [ ] `timeAbsMs` nodes return `env.tAbsMs`
- [ ] Evaluated values are written to cache with current frameId stamp
- [ ] Unknown node kinds throw clear error with kind name
- [ ] Unit tests verify cache behavior: same frame = cached, new frame = re-evaluated
- [ ] Unit tests verify const and timeAbsMs evaluation correctness
- [ ] Performance: cache hit is O(1), no allocations in hot path

#### Technical Notes

- Location: Create `src/runtime/signal-expr/SigEvaluator.ts`
- Algorithm follows HANDOFF.md pseudocode exactly
- Use switch statement on `node.kind` (TypeScript discriminated union)
- Write cache AFTER evaluation succeeds (don't cache errors)
- No debug tracing in this sprint (add later)
- Evaluator is pure: no side effects except cache writes

**Example structure:**

```typescript
export function evalSig(
  sigId: SigExprId,
  env: SigEnv,
  nodes: SignalExprIR[]
): number {
  // 1. Check cache
  if (env.cache.stamp[sigId] === env.cache.frameId) {
    return env.cache.value[sigId];
  }

  // 2. Get node
  const node = nodes[sigId];
  let result: number;

  // 3. Evaluate based on kind
  switch (node.kind) {
    case 'const':
      result = getConstNumber(env.constPool, node.constId);
      break;

    case 'timeAbsMs':
      result = env.tAbsMs;
      break;

    default:
      throw new Error(`Unknown signal kind: ${(node as any).kind}`);
  }

  // 4. Write cache
  env.cache.value[sigId] = result;
  env.cache.stamp[sigId] = env.cache.frameId;

  return result;
}
```

---

### P1: Implement OpCode Registry and Pure Function Application

**Status**: Not Started
**Effort**: Medium (1 day)
**Dependencies**: P0 (SignalExpr IR Types)
**Spec Reference**: HANDOFF.md §1 "Map Evaluation", "Zip Evaluation"
**Status Reference**: STATUS-20251225.md §"What's COMPLETELY Missing" - "No PureFnTable"

#### Description

Implement the pure function application layer that powers `map` and `zip` nodes. This includes the OpCode enum (already defined in P0) and the interpreter functions that execute opcodes.

We need two application modes:
- **Unary** (for map): `sin(x)`, `abs(x)`, `floor(x)`, etc.
- **Binary** (for zip): `a + b`, `a * b`, `min(a, b)`, etc.

#### Acceptance Criteria (REQUIRED)

- [ ] `applyPureFn(fn, input)` function handles all unary opcodes (Sin, Cos, Tan, Abs, Floor, Ceil)
- [ ] `applyBinaryFn(fn, a, b)` function handles all binary opcodes (Add, Sub, Mul, Div, Min, Max)
- [ ] Division by zero returns 0 (safe default, no NaN propagation)
- [ ] All opcodes are tested with known input/output pairs (unit tests)
- [ ] Unknown opcodes throw clear error with opcode value
- [ ] Functions are pure (no side effects, deterministic)
- [ ] Performance: direct Math.* calls, no indirection overhead

#### Technical Notes

- Location: Create `src/runtime/signal-expr/OpCodeRegistry.ts`
- Use switch statements on `fn.opcode` for performance (V8 optimizes)
- Division by zero: `b !== 0 ? a / b : 0` (spec decision: silent fallback)
- Future opcodes: Pow, Mod, Atan2, Lerp, Clamp (add as needed)
- No state, no closures - just pure math

**Example structure:**

```typescript
export function applyPureFn(fn: PureFnRef, input: number): number {
  switch (fn.opcode) {
    case OpCode.Sin:   return Math.sin(input);
    case OpCode.Cos:   return Math.cos(input);
    case OpCode.Tan:   return Math.tan(input);
    case OpCode.Abs:   return Math.abs(input);
    case OpCode.Floor: return Math.floor(input);
    case OpCode.Ceil:  return Math.ceil(input);
    default:
      throw new Error(`Unknown unary opcode: ${fn.opcode}`);
  }
}

export function applyBinaryFn(fn: PureFnRef, a: number, b: number): number {
  switch (fn.opcode) {
    case OpCode.Add: return a + b;
    case OpCode.Sub: return a - b;
    case OpCode.Mul: return a * b;
    case OpCode.Div: return b !== 0 ? a / b : 0; // Safe default
    case OpCode.Min: return Math.min(a, b);
    case OpCode.Max: return Math.max(a, b);
    default:
      throw new Error(`Unknown binary opcode: ${fn.opcode}`);
  }
}
```

---

### P1: Extend Evaluator for Map and Zip Nodes

**Status**: Not Started
**Effort**: Medium (1 day)
**Dependencies**: P1 (OpCode Registry), P0 (Core Evaluator)
**Spec Reference**: HANDOFF.md §1 "Map Evaluation", "Zip Evaluation"
**Status Reference**: STATUS-20251225.md §"What's COMPLETELY Missing" - "No evaluation algorithm"

#### Description

Extend the core evaluator to handle `map` and `zip` nodes, enabling recursive evaluation of signal DAGs. This completes the basic evaluator for pure, composable signals.

**Map nodes** apply a unary function to one input signal:
```
map(sin, timeAbsMs) → sin(t)
```

**Zip nodes** apply a binary function to two input signals:
```
zip(add, signal_a, signal_b) → a + b
```

Both recursively evaluate their inputs using `evalSig()`, leveraging the cache for shared subexpressions.

#### Acceptance Criteria (REQUIRED)

- [ ] Evaluator switch statement includes `case 'map'` calling `evalMap(node, env, nodes)`
- [ ] Evaluator switch statement includes `case 'zip'` calling `evalZip(node, env, nodes)`
- [ ] `evalMap()` recursively evaluates `node.src` then applies `applyPureFn()`
- [ ] `evalZip()` recursively evaluates `node.a` and `node.b` then applies `applyBinaryFn()`
- [ ] Recursive calls use cache correctly (shared subexpressions evaluated once)
- [ ] Unit tests verify map evaluation: `sin(1000)` given `timeAbsMs=1000`
- [ ] Unit tests verify zip evaluation: `a + b` given const nodes
- [ ] Integration tests verify DAG evaluation: `sin(t) * 2` requires 4 nodes (time, const, sin, mul)
- [ ] Cache tests verify shared subexpressions: `a + a` evaluates `a` only once

#### Technical Notes

- Map and zip are the core combinators for signal DAGs
- Evaluation is depth-first, left-to-right (deterministic)
- Cache automatically handles diamond dependencies
- No cycle detection yet (compiler must ensure DAG property)

**Example structure:**

```typescript
function evalMap(node: MapNode, env: SigEnv, nodes: SignalExprIR[]): number {
  const src = evalSig(node.src, env, nodes);
  return applyPureFn(node.fn, src);
}

function evalZip(node: ZipNode, env: SigEnv, nodes: SignalExprIR[]): number {
  const a = evalSig(node.a, env, nodes);
  const b = evalSig(node.b, env, nodes);
  return applyBinaryFn(node.fn, a, b);
}

// Add to main evalSig() switch:
case 'map':
  result = evalMap(node, env, nodes);
  break;

case 'zip':
  result = evalZip(node, env, nodes);
  break;
```

---

### P1: Create Test Suite for Core Evaluator

**Status**: Not Started
**Effort**: Medium (1 day)
**Dependencies**: P1 (Map/Zip Evaluator), P1 (OpCode Registry)
**Spec Reference**: HANDOFF.md §8 "Testing Strategy"
**Status Reference**: STATUS-20251225.md §"Test Suite Assessment" - "Phase 4 has no tests"

#### Description

Create a comprehensive test suite that validates the core evaluator, cache behavior, and opcode registry. These tests form the foundation for all future signal evaluation tests.

Tests must cover:
1. **Individual node kinds** (const, timeAbsMs, map, zip)
2. **Cache correctness** (hit/miss logic, frame invalidation)
3. **OpCode registry** (all unary and binary opcodes)
4. **DAG evaluation** (composing multiple nodes)
5. **Shared subexpressions** (cache efficiency)

#### Acceptance Criteria (REQUIRED)

- [ ] Unit tests for `evalSig()` with `const` nodes (read from const pool)
- [ ] Unit tests for `evalSig()` with `timeAbsMs` nodes (read from env)
- [ ] Unit tests for `evalSig()` with `map` nodes (sin, cos, abs)
- [ ] Unit tests for `evalSig()` with `zip` nodes (add, mul, min, max)
- [ ] Cache hit tests: same frame, same sigId → cached value returned
- [ ] Cache miss tests: new frame → re-evaluation occurs
- [ ] Cache invalidation tests: `newFrame()` invalidates all cached values
- [ ] Integration test: compose 4+ nodes into DAG (e.g., `sin(t * 0.001)`)
- [ ] Integration test: shared subexpression evaluated once (e.g., `(a + b) + (a + b)`)
- [ ] All tests pass with `just test`
- [ ] Test coverage ≥80% for evaluator, cache, and opcode files

#### Technical Notes

- Location: Create `src/runtime/signal-expr/__tests__/SigEvaluator.test.ts`
- Use `vitest` for test framework (already in project)
- Create test helpers: `createTestEnv()`, `createTestNodes()`
- Use `toBeCloseTo()` for floating-point comparisons (epsilon = 1e-10)
- Test both correctness AND performance (cache hits should be fast)

**Example test structure:**

```typescript
describe('SigEvaluator', () => {
  describe('const nodes', () => {
    it('evaluates const correctly', () => {
      const nodes: SignalExprIR[] = [
        { kind: 'const', type: numberType, constId: 0 }
      ];
      const env = createTestEnv({ constPool: { numbers: [42] } });
      expect(evalSig(0, env, nodes)).toBe(42);
    });
  });

  describe('timeAbsMs nodes', () => {
    it('evaluates timeAbsMs correctly', () => {
      const nodes: SignalExprIR[] = [
        { kind: 'timeAbsMs', type: numberType }
      ];
      const env = createTestEnv({ tAbsMs: 1234 });
      expect(evalSig(0, env, nodes)).toBe(1234);
    });
  });

  describe('cache behavior', () => {
    it('caches results within frame', () => {
      const nodes: SignalExprIR[] = [
        { kind: 'timeAbsMs', type: numberType }
      ];
      const env = createTestEnv({ tAbsMs: 1000 });

      const result1 = evalSig(0, env, nodes);
      env.tAbsMs = 2000; // Mutate env (but cache should hold)
      const result2 = evalSig(0, env, nodes);

      expect(result2).toBe(1000); // Cache hit
    });

    it('invalidates cache on new frame', () => {
      const nodes: SignalExprIR[] = [
        { kind: 'timeAbsMs', type: numberType }
      ];
      const cache = createSigFrameCache(10);
      const env1 = createSigEnv({ tAbsMs: 1000, cache });

      evalSig(0, env1, nodes); // Prime cache

      newFrame(cache, cache.frameId + 1);
      const env2 = createSigEnv({ tAbsMs: 2000, cache });

      expect(evalSig(0, env2, nodes)).toBe(2000); // New value
    });
  });

  describe('map nodes', () => {
    it('evaluates sin(t) correctly', () => {
      const nodes: SignalExprIR[] = [
        { kind: 'timeAbsMs', type: numberType }, // id: 0
        { kind: 'map', type: numberType, src: 0, fn: { opcode: OpCode.Sin } } // id: 1
      ];
      const env = createTestEnv({ tAbsMs: Math.PI / 2 });
      expect(evalSig(1, env, nodes)).toBeCloseTo(1, 5);
    });
  });

  describe('zip nodes', () => {
    it('evaluates a + b correctly', () => {
      const nodes: SignalExprIR[] = [
        { kind: 'const', type: numberType, constId: 0 }, // 10
        { kind: 'const', type: numberType, constId: 1 }, // 20
        { kind: 'zip', type: numberType, a: 0, b: 1, fn: { opcode: OpCode.Add } }
      ];
      const env = createTestEnv({ constPool: { numbers: [10, 20] } });
      expect(evalSig(2, env, nodes)).toBe(30);
    });
  });

  describe('DAG evaluation', () => {
    it('evaluates sin(t * 0.001) correctly', () => {
      const nodes: SignalExprIR[] = [
        { kind: 'timeAbsMs', type: numberType }, // 0
        { kind: 'const', type: numberType, constId: 0 }, // 1 (value: 0.001)
        { kind: 'zip', type: numberType, a: 0, b: 1, fn: { opcode: OpCode.Mul } }, // 2
        { kind: 'map', type: numberType, src: 2, fn: { opcode: OpCode.Sin } } // 3
      ];
      const env = createTestEnv({
        tAbsMs: Math.PI / 2 * 1000,
        constPool: { numbers: [0.001] }
      });
      expect(evalSig(3, env, nodes)).toBeCloseTo(1, 5);
    });
  });

  describe('shared subexpressions', () => {
    it('evaluates shared nodes once per frame', () => {
      // DAG: (a + b) + (a + b), where a and a+b are shared
      const nodes: SignalExprIR[] = [
        { kind: 'const', type: numberType, constId: 0 }, // 0: a=10
        { kind: 'const', type: numberType, constId: 1 }, // 1: b=20
        { kind: 'zip', type: numberType, a: 0, b: 1, fn: { opcode: OpCode.Add } }, // 2: a+b=30
        { kind: 'zip', type: numberType, a: 2, b: 2, fn: { opcode: OpCode.Add } }  // 3: (a+b)+(a+b)=60
      ];
      const env = createTestEnv({ constPool: { numbers: [10, 20] } });

      expect(evalSig(3, env, nodes)).toBe(60);
      // Verify cache: node 2 should be stamped
      expect(env.cache.stamp[2]).toBe(env.cache.frameId);
    });
  });
});
```

---

### P2: Documentation and Examples

**Status**: Not Started
**Effort**: Small (0.5 day)
**Dependencies**: All P0 and P1 items
**Spec Reference**: N/A (internal documentation)
**Status Reference**: N/A

#### Description

Create developer documentation and usage examples for the new evaluator. This helps future developers (and the next sprint) understand how to use and extend the evaluator.

Documentation should include:
1. **README** explaining the evaluator architecture
2. **Code examples** showing how to construct and evaluate signal DAGs
3. **Migration guide** explaining differences from closure-based signals

#### Acceptance Criteria (REQUIRED)

- [ ] `src/runtime/signal-expr/README.md` created with architecture overview
- [ ] README includes example: construct simple DAG and evaluate it
- [ ] README includes cache behavior explanation (per-frame memoization)
- [ ] README includes section: "Adding new node kinds" (for future sprints)
- [ ] README includes section: "Performance characteristics" (O(1) cache hits, etc.)
- [ ] Code examples are runnable (can copy-paste into tests)
- [ ] All exported functions have JSDoc comments with examples

#### Technical Notes

- Keep README concise (1-2 pages)
- Focus on "how to use" not "how it works internally"
- Include performance notes (cache is critical)
- Link to HANDOFF.md for full design context

---

## Dependencies

### Prerequisites (Must Exist Before This Sprint)

- TypeScript compiler and build system (exists)
- Test infrastructure (`vitest`) (exists)
- `TypeDesc` type from existing compiler (exists in `src/editor/compiler/types.ts`)

### Blockers (From Other Phases)

**NOTE**: The STATUS report indicates Phase 1-3 are NOT STARTED. However, for this sprint, we can proceed with **minimal inline dependencies**:

1. **Type System (Phase 1)**: We'll reuse the existing `TypeDesc` from the current compiler instead of waiting for the unified type system. Future refactor when Phase 1 completes.

2. **IR Schema (Phase 2)**: We're defining a **subset** of SignalExprIR needed for pure evaluation. Full schema (with `busCombine`, `stateful`, etc.) comes in later sprints.

3. **IRBuilder API (Phase 3)**: NOT needed for this sprint. We're hand-constructing test DAGs. Real block compilers migrate in Sprint 6+.

**This sprint is self-contained and can proceed immediately.**

---

## Risks

### High Risk

1. **TypeDesc Dependency**: We're reusing the existing `TypeDesc` from the closure compiler. If it's incompatible with our needs, we may need to create a parallel type (tech debt).
   - **Mitigation**: Review `src/editor/compiler/types.ts` first day. If incompatible, define minimal `SigTypeDesc` and convert later.

2. **Performance Regression**: If cache is too slow, the evaluator won't be viable.
   - **Mitigation**: Benchmark cache hit path (target: <10ns per hit). Use typed arrays, avoid allocations.

### Medium Risk

3. **Test Infrastructure**: Existing tests are unreliable (per CLAUDE.md). Our new tests must be better.
   - **Mitigation**: Use Chrome DevTools MCP to verify behavior, don't rely solely on unit tests.

4. **Integration with Existing Compiler**: This sprint is isolated. Connecting to real compiler happens later.
   - **Mitigation**: Document integration points in README. Plan integration in Sprint 5-6.

### Low Risk

5. **Scope Creep**: Temptation to add features (debug tracing, more opcodes, etc.).
   - **Mitigation**: Strictly enforce "out of scope" list. File issues for future sprints.

---

## Success Metrics

### Functional Completeness

- [ ] All 4 node kinds evaluate correctly (const, timeAbsMs, map, zip)
- [ ] Cache hit/miss logic is correct (verified by tests)
- [ ] OpCode registry handles all planned opcodes

### Performance

- [ ] Cache hit path is <10ns (measure with micro-benchmark)
- [ ] No allocations in hot path (evalSig, applyPureFn, applyBinaryFn)
- [ ] Can evaluate 1000-node DAG in <1ms

### Quality

- [ ] All tests pass (`just test`)
- [ ] Test coverage ≥80% for new code
- [ ] No TypeScript errors (`just typecheck`)
- [ ] No lint errors (`just lint`)

### Documentation

- [ ] README exists and explains evaluator
- [ ] All public functions have JSDoc comments
- [ ] Code examples are runnable

---

## Next Steps (Future Sprints)

After this sprint completes:

1. **Sprint 2**: Add `select` nodes and `inputSlot` nodes (conditional evaluation, external inputs)
3. **Sprint 4**: Add `transform` nodes (adapter/lens execution)
4. **Sprint 5**: Add `stateful` nodes (integrate, delay, sampleHold with explicit StateBuffer)
5. **Sprint 6**: Add `closureBridge` nodes (gradual migration fallback)
6. **Sprint 7**: Migrate first signal block compiler to emit IR (e.g., AddSignal)
7. **Sprint 8+**: Migrate remaining 8 signal block compilers

---

## Definition of Done

This sprint is **complete** when:

1. All P0 work items have passing acceptance criteria
2. All P1 work items have passing acceptance criteria
3. All tests pass (`just test`)
4. No TypeScript errors (`just typecheck`)
5. No lint errors (`just lint`)
6. README documentation exists
7. Code is committed to the worktree (DO NOT merge to main yet)

**Ready for next sprint** when:
- This sprint's DOD is met
- Sprint 2 planning is complete
- No blocking bugs or architectural issues discovered

---

## File Checklist

### New Files Created (This Sprint)

- [ ] `src/runtime/signal-expr/types.ts` (SignalExprIR types)
- [ ] `src/runtime/signal-expr/SigFrameCache.ts` (cache implementation)
- [ ] `src/runtime/signal-expr/SigEnv.ts` (evaluation environment)
- [ ] `src/runtime/signal-expr/OpCodeRegistry.ts` (pure function application)
- [ ] `src/runtime/signal-expr/SigEvaluator.ts` (core evaluator)
- [ ] `src/runtime/signal-expr/__tests__/SigEvaluator.test.ts` (test suite)
- [ ] `src/runtime/signal-expr/README.md` (documentation)

### Modified Files (None Expected)

This sprint is isolated and should not modify existing files.

---

## Time Estimate

Based on complexity estimates:

- **P0 items**: 3.25 days (critical path)
- **P1 items**: 3 days (parallel where possible)
- **P2 items**: 0.5 days
- **Buffer**: 1.25 days (unknowns, integration issues)

**Total**: ~6-8 days for one developer

**Parallelization**: P0 items must be sequential. P1 items (OpCode, Map/Zip, Tests) can partially overlap once P0 completes.

---

## Verification Plan

### During Development

1. Run tests after each work item: `just test`
2. Check types after each file: `just typecheck`
3. Lint after each file: `just lint`

### Sprint Complete

1. Full test suite passes: `just test`
2. No TypeScript errors: `just typecheck`
3. No lint errors: `just lint`
4. Manual smoke test: construct DAG, evaluate, verify result

### Post-Sprint

1. Use Chrome DevTools MCP to verify evaluator behavior (per CLAUDE.md)
2. Benchmark cache performance (micro-benchmark)
3. Review code with team (if applicable)

---

## Notes

- This sprint is **foundation-only**. No user-visible features yet.
- Integration with compiler happens in Sprint 6+ (block migration).
- Focus on **correctness** and **performance** - this code is hot path.
- Per CLAUDE.md: "Doing it right the first time is far more efficient than redoing it later."

---

## References

- **HANDOFF.md**: Full Phase 4 design and examples
- **STATUS-20251225.md**: Current state assessment and gaps
- **design-docs/12-Compiler-Final/01.1-CompilerMigration-Roadmap.md**: Phase ordering and dependencies
- **design-docs/12-Compiler-Final/02-IR-Schema.md**: IR type definitions (partial)
- **CLAUDE.md**: Project conventions and verification strategy
