# Status Report - SignalExpr Runtime Phase 4 ACCURATE AUDIT

Timestamp: 2025-12-26-040000
Scope: project/SignalExpr-runtime-integration
Confidence: FRESH
Git Branch: compiler_rewrite

---

## Executive Summary

**Overall Assessment: INFRASTRUCTURE COMPLETE, RUNTIME NOT WIRED**

The SigEvaluator is a complete, well-tested implementation that handles ALL SignalExprIR node kinds. However:

1. **SigEvaluator is NOT actually called during frame evaluation** - the runtime still uses legacy closures
2. **Block compilers still emit closures, not IR** - despite the "golden test" infrastructure existing
3. **MIGRATED_BLOCKS set is empty** - no blocks have actually been migrated
4. **The closureBridge exists but is backwards** - it's for calling closures FROM IR, not for transitioning TO IR

**Reality Check**: Sprint 7 created excellent infrastructure (SignalExprBuilder, golden tests) but did NOT integrate it into the actual compiler pipeline. The runtime path is:

```
Player.renderOnce()
  -> program.signal(tMs, runtimeCtx)  // CLOSURE-BASED
  -> Block compiler closures execute  // OLD PATH
  -> RenderTree returned
```

SigEvaluator is only called in **tests**, not in production rendering.

---

## Question 1: SigEvaluator Completeness

### Node Kinds Defined in signalExpr.ts

| Kind | Status | Evidence |
|------|--------|----------|
| `const` | COMPLETE | SigEvaluator.ts:94-96 |
| `timeAbsMs` | COMPLETE | SigEvaluator.ts:98-99 |
| `timeModelMs` | NOT IMPLEMENTED | SigEvaluator.ts:135-140 - throws "future sprint" |
| `phase01` | NOT IMPLEMENTED | SigEvaluator.ts:135-140 - throws "future sprint" |
| `wrapEvent` | NOT IMPLEMENTED | SigEvaluator.ts:135-140 - throws "future sprint" |
| `inputSlot` | COMPLETE | SigEvaluator.ts:114-115, evalInputSlot:301-306 |
| `map` | COMPLETE | SigEvaluator.ts:102-103, evalMap:179-186 |
| `zip` | COMPLETE | SigEvaluator.ts:105-106, evalZip:213-221 |
| `select` | COMPLETE | SigEvaluator.ts:108-109, evalSelect:255-268 |
| `transform` | COMPLETE | SigEvaluator.ts:120-121, evalTransform:426-471 |
| `busCombine` | COMPLETE | SigEvaluator.ts:117-118, evalBusCombine:346-381 |
| `stateful` | COMPLETE | SigEvaluator.ts:123-124, evalStateful:493-529 |
| `closureBridge` | COMPLETE | SigEvaluator.ts:127-128, evalClosureBridge:585-627 |

**Stateful Operations**:
| Op | Status | Evidence |
|----|--------|----------|
| `integrate` | COMPLETE | evalIntegrate:648-666 |
| `sampleHold` | COMPLETE | evalSampleHold:692-723 |
| `slew` | COMPLETE | evalSlew:750-760, applySlewCore:774-791 |
| `delayMs` | COMPLETE | evalDelayMs:819-851 |
| `delayFrames` | COMPLETE | evalDelayFrames:877-899 |
| `edgeDetectWrap` | NOT IMPLEMENTED | evalStateful:517-519 - throws "future sprint" |

### TODO Comments / Placeholders

Found in SigEvaluator.ts:
- Line 135-140: `timeModelMs`, `phase01`, `wrapEvent` throw "not yet implemented (future sprint)"
- Line 517-519: `edgeDetectWrap` throws "time model operations - future sprint"
- Line 969-972: `cast` transform step throws "not yet implemented (future sprint)"

**Conclusion**: SigEvaluator handles 10/13 node kinds (77%). Missing kinds are time-model-related (`timeModelMs`, `phase01`, `wrapEvent`) and one stateful op (`edgeDetectWrap`).

---

## Question 2: Integration with Pass 6

### Current State

**SigEvaluator receives IR only in tests**. There is NO integration with the compiler pipeline.

Evidence from test files:
```typescript
// From SigEvaluator.test.ts - manually constructed IR nodes
const nodes: SignalExprIR[] = [
  { kind: "const", type: { world: "signal", domain: "number" }, constId: 0 }
];
evalSig(0, env, nodes);  // Works in tests
```

### What's Missing

1. **Compiler pipeline does NOT emit SignalExprIR** - block compilers emit closure functions:
   ```typescript
   // src/editor/compiler/blocks/signal/Oscillator.ts:61-64
   const signal: Signal<number> = (t: number, ctx: Readonly<RuntimeCtx>): number => {
     const phase = phaseSignal(t, ctx);
     return shapeFn(phase) * amplitudeSignal(t, ctx) + biasSignal(t, ctx);
   };
   ```

2. **No IR lowering pass** - there is no compiler pass that:
   - Takes the patch graph
   - Emits SignalExprIR nodes for each signal block
   - Builds a SignalExprTable
   - Creates the environment for SigEvaluator

3. **Program.signal is closure-based**:
   ```typescript
   // src/editor/runtime/player.ts:353
   const tree = this.program.signal(this.tMs, this.runtimeCtx);
   ```
   This calls the closure directly, not evalSig().

### What Happens When Block Compilers Emit Real IR

When block compilers are migrated to emit IR:
1. Block compiler receives inputs as `SigExprId` (not closures)
2. Uses `SignalExprBuilder` to create nodes
3. Returns `SigExprId` for output
4. Compiler pipeline collects all nodes into `SignalExprTable`
5. Runtime creates `SigEnv` with all necessary state
6. `evalSig()` called for each frame to evaluate the DAG

**This integration work is Sprint 8-9 scope** per SPRINT-07 doc.

---

## Question 3: ClosureBridge Dependency

### Current Status

The `closureBridge` node exists and is fully implemented. It is designed as a **migration aid** to:

> Allow calling legacy closure-based signals from within SignalExpr DAG.

### How It Works

```typescript
// SignalExprClosureBridge from signalExpr.ts:220-227
{
  kind: "closureBridge";
  type: TypeDesc;
  closureId: string;       // Lookup key in ClosureRegistry
  inputSlots: SigExprId[]; // Reserved for future
}
```

When evaluated:
1. Looks up closure in `env.closureRegistry` by `closureId`
2. Creates legacy context via `createLegacyContext(env)`
3. Calls `closure(env.tAbsMs, ctx)`
4. Returns result (cached like any other node)

### What Needs to Happen to Remove Dependency

The closureBridge is designed to be REMOVED once all blocks emit IR:

1. **Each block compiler must be migrated** to emit IR instead of closures
2. **All 28+ signal block types** listed in MigrationTracking.ts need migration
3. **MIGRATED_BLOCKS set must be updated** for each migrated block
4. **When MIGRATED_BLOCKS.size === ALL_SIGNAL_BLOCKS.length**, closureBridge can be removed

Current progress: **0/28 blocks migrated** (0%)

---

## Question 4: Missing Runtime Wiring

### Critical Finding: SigEvaluator is NOT Called During Frame Evaluation

**Evidence**:

1. **Player.ts calls program.signal directly**:
   ```typescript
   // src/editor/runtime/player.ts:353
   const tree = this.program.signal(this.tMs, this.runtimeCtx);
   ```

2. **Program.signal is a closure function**, not IR evaluation:
   ```typescript
   // src/editor/compiler/types.ts (conceptually)
   type Program<T> = {
     signal: (t: number, ctx: RuntimeCtx) => T;  // CLOSURE!
     // ...
   };
   ```

3. **Materializer has its OWN evalSig that uses SignalBridge**:
   ```typescript
   // src/editor/runtime/field/Materializer.ts:134-146
   function evalSig(sigId, env, _nodes): number {
     if (env.signalBridge !== undefined) {
       return env.signalBridge.evalSig(sigId, env);  // Uses closure bridge!
     }
     return 0;  // Fallback
   }
   ```

4. **SignalBridge wraps closures, not IR**:
   ```typescript
   // src/editor/runtime/integration/SignalBridge.ts:128-136
   evalSig(sigId, env): number {
     const closure = this.signalClosures.get(sigId);
     return closure(env.time);  // Executes closure directly
   }
   ```

### Where evalSig from SigEvaluator IS Called

ONLY in test files:
- `SigEvaluator.test.ts` - 100+ direct calls
- `SigStateful.test.ts` - 50+ direct calls
- `SigClosureBridge.test.ts` - 20+ direct calls
- `goldenTests.test.ts` - golden test framework
- `blockMigration.test.ts` - migration validation tests

### What Wiring is Missing

1. **No IR emission from compiler** - blocks still emit closures
2. **No SignalExprTable in Program** - not produced during compilation
3. **No SigEnv creation** during runtime frame setup
4. **No evalSig invocation** from Player or render loop
5. **StateBuffer not managed** by runtime (only in tests)

---

## Question 5: State Management

### StateBuffer Implementation

StateBuffer is **complete and well-designed**:
```typescript
// src/editor/runtime/signal-expr/StateBuffer.ts
interface StateBuffer {
  f64: Float64Array;  // Most signals
  f32: Float32Array;  // Low-precision
  i32: Int32Array;    // Indices, counters
}
```

### Test Coverage

Comprehensive tests in `SigStateful.test.ts`:
- integrate: accumulation over time, dt=0.1s
- sampleHold: rising edge detection, held value persistence
- slew: exponential smoothing, rate variation
- delayMs: time-based ring buffer
- delayFrames: frame-based ring buffer

All tests PASS with real state persistence across frames.

### Integration Status

**StateBuffer is NOT integrated with production runtime**:

1. **No StateLayout computation** during compilation
2. **No StateBuffer allocation** during program creation
3. **No state persistence** managed by Player

The SigEnv created in tests includes state, but no production code creates SigEnv:
```typescript
// From test - this pattern exists nowhere in production code
const env = createSigEnv({
  tAbsMs: 1000,
  constPool: { numbers: [1, 0.1] },
  cache: createSigFrameCache(10),
  state: createStateBuffer({ f64Count: 10, f32Count: 0, i32Count: 0 }),
  runtimeCtx: { deltaSec: 0.1, deltaMs: 100 },
  // ...
});
```

---

## Recommendations

### Immediate (P0)

1. **Do NOT mark any blocks as migrated** until compiler integration is complete
2. **Update SPRINT-07 status** to reflect that it created infrastructure only
3. **Plan Sprint 8** to focus on compiler pipeline integration, not more block migration

### Required for Phase 4 Completion

1. **Add SignalExprTable to compiled Program**
   - Compiler must produce IR nodes alongside/instead of closures
   - Program type needs `signalTable?: SignalExprTable` field

2. **Wire SigEvaluator into runtime**
   - Player.renderOnce needs to call evalSig for signal evaluation
   - Or, create adapter that converts between closure and IR interfaces

3. **Implement StateBuffer lifecycle**
   - Create StateLayout during compilation
   - Allocate StateBuffer when Program instantiated
   - Pass state to SigEnv each frame
   - Reset on program restart

4. **Implement missing time-model nodes**
   - `timeModelMs`, `phase01`, `wrapEvent` for cyclic animations
   - `edgeDetectWrap` for wrap event detection

### Suggested Migration Path

```
Sprint 8: Compiler Integration
  1. Add SignalExprTable to compiler output
  2. Create runtime adapter (Program -> evalSig bridge)
  3. Migrate one simple block end-to-end
  4. Verify frame rendering works with IR

Sprint 9: Block Migration Wave 1
  1. Pure math blocks (Add, Sub, Mul, Div, Min, Max, Clamp)
  2. Update MIGRATED_BLOCKS as each completes

Sprint 10: Block Migration Wave 2
  1. Oscillator, Shaper
  2. ColorLFO
  3. Time-model-related blocks

Sprint 11: Cleanup
  1. Remove closureBridge once all blocks migrated
  2. Remove SignalBridge (legacy)
  3. Simplify Materializer to use real SigEvaluator
```

---

## Verdict

**Status**: INFRASTRUCTURE COMPLETE, INTEGRATION MISSING

The SignalExpr runtime (SigEvaluator, StateBuffer, ClosureBridge, SignalExprBuilder) is well-implemented and thoroughly tested. However, it exists in complete isolation from the production rendering path.

**No signals are evaluated via IR in production**. The entire system still runs on closures.

Sprint 7 documentation overstates completion - it says blocks are "validated" but the MIGRATED_BLOCKS set is empty and no compiler changes were made. The golden tests validate that IR CAN match closure output, not that it IS matching in production.

**Workflow Recommendation**: CONTINUE - the path forward is clear, but expectations must be reset that Phase 4 is about 30% complete (infrastructure done, integration pending).

---

## Files Examined

- `/Users/bmf/code/oscilla-animator_codex/src/editor/runtime/signal-expr/SigEvaluator.ts` - 1040 lines
- `/Users/bmf/code/oscilla-animator_codex/src/editor/compiler/ir/signalExpr.ts` - 244 lines
- `/Users/bmf/code/oscilla-animator_codex/src/editor/runtime/signal-expr/StateBuffer.ts` - 130 lines
- `/Users/bmf/code/oscilla-animator_codex/src/editor/runtime/signal-expr/SignalExprBuilder.ts` - 248 lines
- `/Users/bmf/code/oscilla-animator_codex/src/editor/runtime/signal-expr/MigrationTracking.ts` - 201 lines
- `/Users/bmf/code/oscilla-animator_codex/src/editor/runtime/signal-expr/ClosureRegistry.ts` - 99 lines
- `/Users/bmf/code/oscilla-animator_codex/src/editor/runtime/integration/SignalBridge.ts` - 177 lines
- `/Users/bmf/code/oscilla-animator_codex/src/editor/runtime/field/Materializer.ts` - 716 lines
- `/Users/bmf/code/oscilla-animator_codex/src/editor/runtime/player.ts` - 502 lines
- `/Users/bmf/code/oscilla-animator_codex/src/editor/compiler/blocks/signal/Oscillator.ts` - 71 lines
- `/Users/bmf/code/oscilla-animator_codex/.agent_planning/signalexpr-runtime/SPRINT-07-blockCompilerMigration.md` - 698 lines
