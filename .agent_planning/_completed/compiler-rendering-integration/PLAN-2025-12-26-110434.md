# Implementation Plan: Compiler Rendering Integration

**Generated:** 2025-12-26-110434
**Source:** STATUS-2025-12-26-110434.md
**Topic:** Wire IR Compiler to Player for Rendering

---

## Executive Summary

**Goal:** Enable patches to render using the new IR compiler and ScheduleExecutor runtime.

**Current State:** IR compiler and runtime are complete (1839 tests passing) but not connected to the rendering pipeline. Patches do not render when `useUnifiedCompiler` flag is enabled.

**Strategy:** Create IRRuntimeAdapter to bridge ScheduleExecutor output to Player's Program<RenderTree> interface, fix render tree extraction, and wire through feature flag.

**Sprint Scope:** 3 deliverables, 2-3 days effort

---

## Backlog by Priority

### P0 (Critical) - Foundation

---

## P0-1: Fix ScheduleExecutor Render Tree Extraction

**Status:** Not Started
**Effort:** Small (1-2 hours)
**Dependencies:** None
**Spec Reference:** design-docs/12-Compiler-Final/17-Scheduler-Full.md §5
**Status Reference:** STATUS-2025-12-26-110434.md §"ScheduleExecutor RenderOutput Issue"

### Description

ScheduleExecutor.extractRenderOutput() currently returns a stub with `renderData: undefined`. It must extract the actual RenderTree from the output slot specified in `program.outputs[0].slot`.

**Current Code (line 221-227):**
```typescript
private extractRenderOutput(runtime: RuntimeState): RenderOutput {
  return {
    frameId: runtime.frameId,
    renderData: undefined, // TODO: Extract from output slots
  };
}
```

**Required:**
```typescript
private extractRenderOutput(
  program: CompiledProgramIR,
  runtime: RuntimeState
): RenderTree {
  // 1. Get output spec from program.outputs[0]
  // 2. Read RenderTree from runtime.values at output slot
  // 3. Validate it's a RenderTree
  // 4. Return it
}
```

### Acceptance Criteria

- [ ] `extractRenderOutput()` reads from `program.outputs[0].slot`
- [ ] Returns actual `RenderTree` type (not `RenderOutput`)
- [ ] Validates slot contains a RenderTree (type guard)
- [ ] Throws descriptive error if output slot is empty or wrong type
- [ ] Updates `executeFrame()` signature to return `RenderTree` instead of `RenderOutput`
- [ ] All existing ScheduleExecutor tests still pass

### Technical Notes

- Output slot is set by RenderAssemble step (`executeRenderAssemble`)
- RenderTree types defined in `src/editor/runtime/renderTree.ts`
- ValueStore.read() returns `unknown`, needs type guard
- May need to handle case where program.outputs is empty (return empty group)

---

## P0-2: Create IRRuntimeAdapter

**Status:** Not Started
**Effort:** Medium (3-5 hours)
**Dependencies:** P0-1 (render tree extraction)
**Spec Reference:** design-docs/12-Compiler-Final/14-Compiled-IR-Program-Contract.md §9
**Status Reference:** STATUS-2025-12-26-110434.md §"Missing Component: IRRuntimeAdapter"

### Description

Create a bridge adapter that wraps ScheduleExecutor and CompiledProgramIR to provide the Program<RenderTree> interface expected by Player.

**Architecture:**
```typescript
class IRRuntimeAdapter {
  private executor: ScheduleExecutor
  private program: CompiledProgramIR
  private runtime: RuntimeState

  constructor(program: CompiledProgramIR)
  createProgram(): Program<RenderTree>
  swapProgram(newProgram: CompiledProgramIR): void
}
```

**Location:** `src/editor/runtime/executor/IRRuntimeAdapter.ts`

### Acceptance Criteria

- [ ] IRRuntimeAdapter class created in `src/editor/runtime/executor/`
- [ ] Constructor accepts `CompiledProgramIR` and initializes RuntimeState
- [ ] `createProgram()` returns `Program<RenderTree>` compatible with Player
- [ ] `signal(tMs, runtimeCtx)` calls `executor.executeFrame()` and returns RenderTree
- [ ] `event()` returns empty array (stub - events not implemented yet)
- [ ] `swapProgram(newProgram)` performs hot-swap via `executor.swapProgram()`
- [ ] RuntimeState lifecycle managed correctly (not recreated every frame)
- [ ] Unit tests cover basic frame execution and hot-swap
- [ ] Type-checks without errors

### Technical Notes

**Key Challenge:** RuntimeCtx handling
- Player passes `runtimeCtx` to `signal()`, but ScheduleExecutor doesn't use it
- Options:
  1. Ignore runtimeCtx (simplest for MVP)
  2. Store viewport info in RuntimeState
  3. Thread through as step input
- **Decision:** Option 1 for this sprint (validate later if needed)

**State Management:**
- RuntimeState should be created once in constructor
- Preserved across frames (not recreated)
- Only replaced during `swapProgram()`

**Reference Implementation:**
- See `RuntimeAdapter.ts` for patterns (but don't copy - it's for old compiler)
- Key insight: Program<T> is just a thin wrapper around frame execution

---

## P0-3: Wire Player to Use IR Path

**Status:** Not Started
**Effort:** Small (1-2 hours)
**Dependencies:** P0-2 (IRRuntimeAdapter exists)
**Spec Reference:** N/A (integration work)
**Status Reference:** STATUS-2025-12-26-110434.md §"Integration Points"

### Description

Modify Player to conditionally use IRRuntimeAdapter when `useUnifiedCompiler` feature flag is enabled, while preserving legacy path for fallback.

**Integration Points:**
1. Player.setFactory() - accept IR program factory
2. Player.renderOnce() - no changes needed (calls program.signal)
3. Player.instantiateProgram() - conditional logic based on feature flag

### Acceptance Criteria

- [ ] Player accepts both legacy and IR program factories (type union or overload)
- [ ] When `useUnifiedCompiler: true`, Player uses IRRuntimeAdapter path
- [ ] When `useUnifiedCompiler: false`, Player uses legacy path (existing behavior)
- [ ] Feature flag checked at program instantiation time
- [ ] Hot-swap works in both modes (existing `setFactory` behavior preserved)
- [ ] No runtime errors when switching feature flag
- [ ] Existing Player tests still pass with flag=false
- [ ] New test verifies IR path renders with flag=true

### Technical Notes

**Implementation Strategy:**

Option A: Type union in setFactory
```typescript
setFactory(
  factory: ProgramFactory<RenderTree> | { ir: CompiledProgramIR }
): void {
  if ('ir' in factory) {
    // IR path: create IRRuntimeAdapter
    const adapter = new IRRuntimeAdapter(factory.ir);
    this.program = adapter.createProgram();
  } else {
    // Legacy path: factory is already ProgramFactory
    this.programFactory = factory;
    this.instantiateProgram();
  }
}
```

Option B: Separate method
```typescript
setIRProgram(program: CompiledProgramIR): void {
  const adapter = new IRRuntimeAdapter(program);
  this.program = adapter.createProgram();
  this.renderOnce();
}
```

**Recommendation:** Option B (cleaner, no type confusion)

**Feature Flag Check:**
- Feature flag should be checked by the code calling Player, not inside Player
- Player is a dumb runtime - caller decides which path to use
- This keeps Player simple and testable

---

### P1 (High) - Verification

---

## P1-1: End-to-End Integration Test

**Status:** Not Started
**Effort:** Small (2-3 hours)
**Dependencies:** P0-1, P0-2, P0-3 (full integration complete)
**Spec Reference:** N/A (testing work)
**Status Reference:** STATUS-2025-12-26-110434.md §"Test Coverage"

### Description

Create integration test that compiles a simple patch with the IR compiler, wires it through IRRuntimeAdapter to Player, and verifies it renders correctly.

**Test Patch Requirements:**
- TimeRoot block (sets time model)
- Single primitive block that outputs RenderTree
- No buses or complex wiring
- Expected output: Simple group with one shape

### Acceptance Criteria

- [ ] Test file created: `src/editor/runtime/__tests__/IRRuntimeIntegration.test.ts`
- [ ] Test compiles minimal patch using IR compiler
- [ ] Test creates IRRuntimeAdapter from CompiledProgramIR
- [ ] Test creates Player and sets IR program
- [ ] Test calls play() and scrubTo(1000) to trigger frames
- [ ] Test verifies onFrame callback receives valid RenderTree
- [ ] Test verifies RenderTree structure matches expected output
- [ ] Test verifies hot-swap: recompile patch, swap, verify new tree
- [ ] Test passes with `useUnifiedCompiler: true`
- [ ] Test is skipped or disabled when flag is false (feature-gated)

### Technical Notes

**Minimal Test Patch:**
```typescript
// Pseudo-code for test patch
const patch = {
  blocks: [
    { type: 'TimeRoot', mode: 'infinite' },
    { type: 'ConstantShape', shape: 'circle', id: 'test-circle' }
  ],
  connections: []
};
```

**Test Structure:**
1. Compile patch → CompiledProgramIR
2. Create adapter → IRRuntimeAdapter
3. Create player → Player
4. Set program → player.setIRProgram(program)
5. Capture frame → onFrame callback
6. Assert tree structure

**Golden Assertions:**
- `tree.kind === 'group'` or `tree.kind === 'shape'`
- `tree.id` is stable
- Tree has expected structure (depends on test patch design)

---

## P1-2: Verify Feature Flag Toggle

**Status:** Not Started
**Effort:** Small (1 hour)
**Dependencies:** P0-3 (Player wiring)
**Spec Reference:** featureFlags.ts
**Status Reference:** STATUS-2025-12-26-110434.md §"Feature Flag System"

### Description

Verify that toggling `useUnifiedCompiler` flag correctly switches between legacy and IR rendering paths without errors.

### Acceptance Criteria

- [ ] Test toggles flag from false → true → false
- [ ] With flag=false: legacy path is used (existing behavior)
- [ ] With flag=true: IR path is used (new behavior)
- [ ] No runtime errors when toggling
- [ ] No console warnings about missing implementations
- [ ] Player state is correctly reset when switching paths
- [ ] Rendering works in both modes (legacy and IR)

### Technical Notes

**Test Approach:**
1. Start with flag=false, render a frame
2. Set flag=true, render a frame
3. Set flag=false again, render a frame
4. Assert all three frames succeeded

**Edge Case:**
- What happens if flag changes mid-playback?
- Should Player support dynamic flag changes, or only at initialization?
- **Decision for MVP:** Flag is checked once at program load, not dynamically

---

## P2 (Medium) - Documentation and Polish

---

## P2-1: Add Integration Documentation

**Status:** Not Started
**Effort:** Small (1-2 hours)
**Dependencies:** P0-1, P0-2, P0-3 (implementation complete)
**Spec Reference:** N/A
**Status Reference:** N/A

### Description

Document how the IR compiler → ScheduleExecutor → Player rendering pipeline works, for future maintainers.

### Acceptance Criteria

- [ ] README or doc file in `.agent_planning/compiler-rendering-integration/`
- [ ] Documents IRRuntimeAdapter purpose and usage
- [ ] Diagrams showing legacy vs IR rendering paths
- [ ] Code examples showing how to use IR path
- [ ] Notes on feature flag behavior
- [ ] Notes on hot-swap behavior in IR path

### Technical Notes

**Sections:**
1. Architecture Overview
2. Component Responsibilities (ScheduleExecutor, IRRuntimeAdapter, Player)
3. Data Flow Diagram
4. Feature Flag Behavior
5. Hot-Swap Protocol
6. Testing Strategy

---

## P2-2: Update Compiler Phase Documentation

**Status:** Not Started
**Effort:** Small (30 min)
**Dependencies:** None
**Spec Reference:** N/A
**Status Reference:** N/A

### Description

Update compiler phase documentation to reflect that Phase 6 (Scheduled Runtime) is now connected to rendering.

### Acceptance Criteria

- [ ] Update HANDOFF.md or equivalent to mark runtime integration as complete
- [ ] Update any "TODO: Phase 6" comments in code
- [ ] Mark ScheduleExecutor as "production-ready" (vs "experimental")

### Technical Notes

Low priority, can be deferred to cleanup sprint.

---

## P3 (Low) - Future Enhancements

---

## P3-1: RuntimeCtx Propagation

**Status:** Deferred
**Effort:** Medium (3-4 hours)
**Dependencies:** P0-1, P0-2, P0-3 (core integration)
**Spec Reference:** design-docs/12-Compiler-Final/17-Scheduler-Full.md
**Status Reference:** STATUS-2025-12-26-110434.md §"Risk 2: RuntimeCtx Not Used"

### Description

Thread RuntimeCtx (viewport dimensions, DPR) through ScheduleExecutor so blocks can access viewport information.

**Deferred because:** Not needed for MVP rendering. Most blocks don't use viewport yet.

### Acceptance Criteria

- [ ] RuntimeState contains viewport info from RuntimeCtx
- [ ] Blocks can access viewport during evaluation
- [ ] Player passes RuntimeCtx to IRRuntimeAdapter
- [ ] IRRuntimeAdapter initializes RuntimeState with viewport

### Technical Notes

**Options:**
1. Add viewport to RuntimeState
2. Pass RuntimeCtx as parameter to executeFrame
3. Store in CompileCtx and embed at compile time

**Recommendation:** Option 2 (matches Player's signal signature)

---

## P3-2: Performance Baseline

**Status:** Deferred
**Effort:** Medium (2-3 hours)
**Dependencies:** P1-1 (integration test)
**Spec Reference:** N/A
**Status Reference:** N/A

### Description

Establish performance baseline for IR path vs legacy path. Measure frame time, memory usage, and hot-swap latency.

**Deferred because:** Premature optimization. Get correctness first.

### Acceptance Criteria

- [ ] Benchmark test measuring frame execution time
- [ ] Benchmark test measuring hot-swap latency
- [ ] Comparison data: IR path vs legacy path
- [ ] Results documented in performance doc

### Technical Notes

Use performance.now() for timing. Run 1000 frames to get averages.

---

## Dependency Graph

```
P0-1: Fix Render Tree Extraction
  └─→ P0-2: Create IRRuntimeAdapter
       └─→ P0-3: Wire Player
            ├─→ P1-1: E2E Integration Test
            ├─→ P1-2: Feature Flag Toggle Test
            └─→ P2-1: Documentation

P2-2: Update Docs (independent)

P3-1: RuntimeCtx Propagation (deferred)
P3-2: Performance Baseline (deferred)
```

---

## Recommended Sprint Plan

### Sprint 1: Core Integration (This Sprint)

**Goal:** Patches render using IR compiler

**Deliverables:**
1. P0-1: Fix render tree extraction (1-2 hours)
2. P0-2: Create IRRuntimeAdapter (3-5 hours)
3. P0-3: Wire Player to use IR path (1-2 hours)
4. P1-1: E2E integration test (2-3 hours)
5. P1-2: Feature flag toggle test (1 hour)

**Total Effort:** 8-13 hours (1-2 days)

**Success Criteria:**
- Feature flag enables IR rendering
- Simple patch renders correctly
- Hot-swap works
- Tests pass

### Sprint 2: Polish (Future)

**Goal:** Documentation and performance

**Deliverables:**
1. P2-1: Integration documentation
2. P2-2: Update compiler docs
3. P3-2: Performance baseline

**Total Effort:** 3-5 hours

### Sprint 3+: Advanced Features (Future)

**Goal:** RuntimeCtx propagation, optimization

**Deliverables:**
1. P3-1: RuntimeCtx propagation
2. Additional performance work as needed

---

## Risk Assessment

### High-Risk Items

**None.** All infrastructure is proven (1839 tests passing). This is pure integration work.

### Medium-Risk Items

1. **RenderTree Type Mismatch**
   - Risk: Output slot might not contain valid RenderTree
   - Mitigation: Type guards in extractRenderOutput
   - Fallback: Return empty group if invalid

2. **Hot-Swap State Corruption**
   - Risk: State not preserved correctly during program swap
   - Mitigation: Extensive testing of swapProgram
   - Fallback: Hard reset (acceptable for MVP)

### Low-Risk Items

1. **RuntimeCtx Ignored**
   - Impact: Viewport-dependent blocks might not work
   - Assessment: Minimal - most blocks don't need viewport yet
   - Resolution: P3-1 (deferred)

2. **Legacy Path Regression**
   - Risk: Changes to Player break legacy rendering
   - Mitigation: Existing tests guard legacy path
   - Confidence: High

---

## Questions and Uncertainties

### Q1: Does IR compiler emit valid program.outputs?

**Answer Needed:** Verify CompiledProgramIR has populated outputs array
**How to Check:** Add assertion in P0-1 test
**Assumption:** Yes (compiler is tested, outputs are part of spec)

### Q2: Should Player support dynamic flag changes?

**Answer Needed:** Can flag change mid-playback?
**Decision for MVP:** No - flag is checked at program load only
**Future:** May support dynamic switching in debug UI

### Q3: What happens if program has no outputs?

**Answer Needed:** How to handle program.outputs.length === 0?
**Decision:** Return empty group (graceful degradation)
**Implementation:** Add check in extractRenderOutput

---

## Success Metrics

**Sprint Success:**
- [ ] Feature flag toggle switches rendering paths
- [ ] Simple patch renders using IR compiler
- [ ] Hot-swap preserves state and time continuity
- [ ] All existing tests still pass
- [ ] 2+ new integration tests pass

**Phase Success (Future):**
- [ ] Golden patch (Breathing Constellation) renders identically in both paths
- [ ] Performance parity with legacy path (or better)
- [ ] No visual artifacts during hot-swap
- [ ] Debug tools work with IR path

---

## Out of Scope (Future Sprints)

1. **Legacy Compiler Removal** - Separate sprint, requires full parity
2. **Debug Infrastructure** - Phase 7 work (trace events, debugger hooks)
3. **Performance Optimization** - Measure first, optimize later
4. **Golden Patch Parity** - Requires all block types working
5. **Field Materialization** - Phase 5 work, separate from rendering integration
6. **Bus System Completeness** - Already tested separately
7. **Error Reporting UI** - User-facing error handling (separate sprint)

---

## File Manifest

**New Files:**
- `src/editor/runtime/executor/IRRuntimeAdapter.ts` (P0-2)
- `src/editor/runtime/__tests__/IRRuntimeIntegration.test.ts` (P1-1)
- `.agent_planning/compiler-rendering-integration/INTEGRATION.md` (P2-1)

**Modified Files:**
- `src/editor/runtime/executor/ScheduleExecutor.ts` (P0-1)
- `src/editor/runtime/player.ts` (P0-3)

**No Changes:**
- `src/editor/compiler/featureFlags.ts` (already has flag)
- `src/editor/runtime/renderTree.ts` (types complete)
- `src/editor/runtime/executor/RuntimeState.ts` (already has hotSwap)

---

## Summary

**Total Work Items:** 9 (3 P0, 2 P1, 2 P2, 2 P3)
**Sprint Scope:** 5 items (3 P0, 2 P1)
**Estimated Effort:** 8-13 hours
**Dependencies:** None external
**Risk Level:** Low
**Confidence:** High (infrastructure proven)

**Blocker Resolution:**
- Current blocker: No bridge between ScheduleExecutor and Player
- Resolution: P0-2 (IRRuntimeAdapter) directly addresses this
- Timeline: 1-2 days to MVP rendering

**Next Action:** Implement P0-1 (fix render tree extraction) to unblock adapter work.
