# Status Report: Canvas Rendering Backend
Timestamp: 2025-12-24-160000
Scope: canvas-renderer
Confidence: FRESH

## Executive Summary

**Current State**: SVG-only rendering with single block type (RenderInstances2D)
**Missing**: Canvas rendering backend
**Critical Ambiguity**: ARCHITECTURE LEVEL - Is this a renderer swap or a new block type?

**Verdict**: ⚠️ PAUSE - Architecture decision needed before implementation

---

## Evaluation Reuse Summary

**Examined fresh**:
- Runtime architecture: player.ts, svgRenderer.ts, renderTree.ts
- RenderInstances2D block + compiler
- PreviewPanel integration

**Carried forward from eval-cache**:
- architecture.md (RECENT, 1 day old): Block system, compiler pipeline

---

## Architecture Analysis

### Current Rendering Pipeline

```
Block Graph → Compiler → Program<RenderTree> → Player → Renderer → DOM
                                   ↓              ↓         ↓
                              Signal-based    RAF loop   SvgRenderer
                              time-indexed               (keyed recon)
```

**Key Finding**: There are TWO distinct places where Canvas could plug in:

#### Option A: Renderer-Level Swap (Backend Replacement)
```typescript
// In PreviewPanel.tsx:104-130
const renderer = new SvgRenderer(svg);     // Current
const renderer = new CanvasRenderer(ctx);  // Alternative

player.onFrame = (tree: RenderTree, tMs: number) => {
  renderer.render(tree);  // Same interface for both
};
```

**Contract**: `render(tree: RenderTree): void`
- RenderTree stays unchanged
- Player doesn't know/care which renderer
- Single source of truth for animation data

#### Option B: Block-Level Alternative (New Render Block)
```typescript
// New block alongside RenderInstances2D
RenderInstances2DCanvas {
  inputs: [domain, positions, radius, color],
  compile(): { render: Program<CanvasCommands> }  // Different output
}
```

**Contract**: New artifact type, parallel to RenderTree
- Requires Player to handle multiple output types
- Breaks current "RenderTree is the universal IR" model
- Allows per-block renderer choice (mixed SVG + Canvas?)

---

## The Ambiguity (CRITICAL)

**User said**: "it should only be the one block, right?"

**This is ambiguous** because:

1. **If "one block" means "RenderInstances2D stays the only render block"**:
   - Then this is Option A (renderer swap)
   - Canvas is a backend optimization, invisible to patch
   - RenderInstances2D compiler output doesn't change

2. **If "one block" means "only one new Canvas-specific block"**:
   - Then this is Option B (new block type)
   - User would choose SVG vs Canvas at block level
   - Implies future: RenderPaths2DCanvas, RenderText2DCanvas, etc.

3. **If "one block" means "a single CanvasRenderer class"**:
   - Could be either option
   - Doesn't clarify where it plugs in

**Impact of Wrong Choice**:
- Option A + B assumption = Wasted work on parallel block hierarchy
- Option B + A assumption = Canvas renderer can't access per-element data efficiently

---

## Technical Constraints

### What Canvas Needs vs What RenderTree Provides

**RenderTree semantic nodes** (current):
```typescript
type DrawNode = GroupNode | ShapeNode | EffectNode
// High-level: "circle at (x,y) with radius r"
// Renderer interprets and renders
```

**Canvas rendering** needs:
```javascript
ctx.beginPath();
ctx.arc(x, y, r, 0, Math.PI * 2);
ctx.fill();
```

**Key Questions**:
1. Can Canvas renderer efficiently traverse RenderTree and draw?
   - YES for shapes (circle, rect, path)
   - NO for complex effects (filters, deforms)

2. Does Canvas need different data structure for performance?
   - Instance rendering: NO (same circles, just different draw calls)
   - Particle systems (1000s of elements): MAYBE (batching?)
   - Path morphing: MAYBE (direct path commands?)

3. Do we need mixed rendering (SVG filters + Canvas shapes)?
   - Current architecture: NO (single renderer)
   - Would require compositing layer

---

## Current RenderInstances2D Analysis

**Block Definition**: `/src/editor/blocks/domain.ts:212-263`
- Exists in block registry
- Inputs: domain, positions, radius, color
- LaneKind: 'Program' (final output)

**Compiler**: `/src/editor/compiler/blocks/domain/RenderInstances2D.ts`
- Takes Field<vec2>, Field<number>, Field<color>
- Materializes at render time: `positionField(seed, n, fieldCtx)`
- Returns: `{ render: { kind: 'RenderTree', value: renderFn } }`
- `renderFn`: `(tMs, ctx) => DrawNode`

**Current Output**:
```typescript
{
  kind: 'group',
  id: 'instances',
  children: [
    { kind: 'shape', id: 'circle-0', geom: { kind: 'circle', cx, cy, r }, style }
  ]
}
```

**Where Fields Materialize**: Inside compiler's `renderFn` closure
- Fields are NOT materialized at compile time
- Evaluated every frame with current `t`
- This is CORRECT per architecture (lazy field evaluation)

---

## Renderer Interface Analysis

### SvgRenderer (Current)

**Interface** (`svgRenderer.ts:38-93`):
```typescript
class SvgRenderer {
  constructor(svg: SVGSVGElement)
  render(tree: RenderTree): void
  clear(): void
  getSvg(): SVGSVGElement
}
```

**Keyed reconciliation**:
- Stable `node.id` → DOM element mapping
- Incremental updates (only changed nodes modified)
- Groups/effects use `<g>` wrappers

**Performance characteristics**:
- Good: Minimal DOM thrash with stable IDs
- Bad: DOM updates are expensive at scale (>1000 elements)
- Bad: SVG transform/filter overhead

### Hypothetical CanvasRenderer

**If Option A (renderer swap)**:
```typescript
class CanvasRenderer {
  constructor(canvas: HTMLCanvasElement)
  render(tree: RenderTree): void  // Same interface!
  clear(): void
  getCanvas(): HTMLCanvasElement
}
```

**Implementation sketch**:
```typescript
render(tree: RenderTree): void {
  this.ctx.clearRect(0, 0, w, h);
  this.traverseAndDraw(tree);
}

private traverseAndDraw(node: DrawNode, parentCtx: RenderCtx): void {
  if (node.kind === 'shape' && node.geom.kind === 'circle') {
    this.ctx.beginPath();
    this.ctx.arc(cx, cy, r, 0, Math.PI * 2);
    this.ctx.fill();
  }
  // Handle groups, effects, transforms...
}
```

**Performance win**: No DOM, direct pixel operations
**Performance loss**: No incremental updates, full redraw every frame
**Net**: Win for high element counts, lose for static scenes

---

## Missing Information

### Performance Baseline
- What element count triggers SVG slowdown?
- Is current app hitting performance limits?
- User's actual use case (animated particles vs static infographic)?

### Rendering Feature Parity
Does Canvas need to support all RenderTree features?
- Transforms: 2D (yes), 3D (partial - no CSS perspective)
- Effects: opacity (yes), filters (limited - no CSS filters)
- Deforms: wave/ripple (need custom implementation)
- Clip paths (yes, different API)

### Integration Points
- Where does renderer get created? (PreviewPanel.tsx:110)
- Who owns the DOM element? (PreviewPanel renders `<svg>`, would be `<canvas>`)
- How is renderer selected? (Compile-time? Runtime? User setting?)

---

## Questions Needing Answers

### Q1: Architecture Level (CRITICAL)
**Where does Canvas plug in?**

**Option A**: Renderer-level swap
- Pro: RenderTree stays universal, clean separation
- Pro: No changes to blocks or compiler
- Pro: Can switch backends without patch changes
- Con: Canvas locked to RenderTree semantics (may not be optimal)
- Con: Mixed rendering harder (SVG + Canvas in same scene)

**Option B**: Block-level alternative
- Pro: Blocks can choose optimal renderer
- Pro: Canvas-specific optimizations (batching, etc.)
- Con: Breaks RenderTree universality
- Con: Proliferation of block variants (RenderX_SVG, RenderX_Canvas)
- Con: Player must handle multiple output types

**Which one?**

### Q2: Scope (CRITICAL)
**What does "the one block" mean?**
- a) Keep RenderInstances2D, add Canvas backend → Option A
- b) Add RenderInstances2DCanvas block → Option B
- c) Something else?

### Q3: Feature Requirements
**Must Canvas support:**
- 3D transforms? (Current: yes via CSS)
- CSS filters? (Current: yes - blur, drop-shadow)
- Deform effects? (Current: semantic only, no impl)
- Clip paths? (Current: yes)

**Or can Canvas start minimal:**
- 2D shapes only
- Basic fill/stroke
- Simple transforms
- Upgrade later?

### Q4: Selection Mechanism (If Option A)
**How does user choose SVG vs Canvas?**
- a) Global setting (all or nothing)
- b) Per-patch setting
- c) Auto-detect (element count threshold)
- d) No choice, always Canvas (deprecate SVG)

### Q5: DOM Structure (If Option A)
**PreviewPanel currently renders `<svg>` element**:
```tsx
<svg ref={svgRef} width={width} height={height} />
```

**Canvas would need**:
```tsx
<canvas ref={canvasRef} width={width} height={height} />
```

**Options**:
- a) Conditional rendering based on renderer type
- b) Always render both, show/hide based on active
- c) Renderer creates its own DOM element

---

## Data Flow Verification

### Current: SVG Path

```
[User drags RenderInstances2D into patch]
      ↓
[Compiler: RenderInstances2D.compile()]
      ↓
Returns: { render: { kind: 'RenderTree', value: renderFn } }
                                               ↓
                            renderFn(tMs, ctx): DrawNode {
                              // Evaluate fields at frame time
                              positions = positionField(seed, n, ctx)
                              radii = radiusField(seed, n, ctx)
                              colors = colorField(seed, n, ctx)

                              // Build RenderTree
                              return { kind: 'group', children: circles[] }
                            }
      ↓
[Player.setFactory(() => program)]
      ↓
[Player RAF loop]
  program.signal(tMs, ctx) → RenderTree
      ↓
[SvgRenderer.render(tree)]
  - Traverse tree
  - Keyed reconciliation
  - Update DOM elements
      ↓
[Browser renders SVG → pixels]
```

### Hypothetical: Canvas Path (Option A)

```
[Same compilation: RenderInstances2D → RenderTree]
      ↓
[Player RAF loop]
  program.signal(tMs, ctx) → RenderTree
      ↓
[CanvasRenderer.render(tree)]  ← Only this changes
  - ctx.clearRect()
  - Traverse tree
  - Draw primitives directly
      ↓
[Browser composites canvas → pixels]
```

**No changes needed**:
- Block definition ✓
- Compiler ✓
- RenderTree structure ✓
- Player ✓

**Changes needed**:
- PreviewPanel: create CanvasRenderer instead of SvgRenderer
- CanvasRenderer: new class implementing render(tree)

### Hypothetical: Canvas Path (Option B)

```
[User drags RenderInstances2DCanvas into patch]
      ↓
[Compiler: RenderInstances2DCanvas.compile()]
      ↓
Returns: { render: { kind: 'CanvasCommands', value: commandFn } }
                                               ↓
                            commandFn(tMs, ctx): CanvasDrawOps {
                              // Evaluate fields
                              // Return canvas-specific draw calls
                              return { ops: [...] }
                            }
      ↓
[Player needs to handle CanvasCommands artifact type]
      ↓
[PreviewPanel needs to route to CanvasRenderer]
```

**Changes needed**:
- New block: RenderInstances2DCanvas
- New compiler
- New artifact type: CanvasCommands
- Player: handle multiple output types
- PreviewPanel: renderer routing logic

**Benefit**: Canvas-optimized data structures
**Cost**: Complexity, duplication, breaks universality

---

## Architectural Risks

### Risk 1: RenderTree Semantic Mismatch
**RenderTree is designed for retained-mode rendering** (SVG, scene graph)
**Canvas is immediate-mode** (draw and forget)

**Traversing RenderTree to draw Canvas**:
- Every frame: walk tree, interpret nodes, issue draw calls
- No retained benefit (no keyed reconciliation on Canvas)
- Overhead of tree structure without benefit

**Mitigation**:
- If Option A: Accept overhead for small element counts (<1000)
- If Option B: Compiler emits flat draw ops, no tree traversal

### Risk 2: Effect Parity
**Some RenderTree effects can't map to Canvas**:
- CSS filters (blur, drop-shadow) → Canvas has limited filters
- 3D transforms with perspective → Canvas 2D only
- Deform effects → Need custom implementation

**Mitigation**:
- Document unsupported features
- Fallback to SVG for effects Canvas can't handle?
- Or: Canvas is "fast path" for simple shapes only

### Risk 3: Mixed Rendering
**User might want**: SVG text + Canvas particles in same scene

**Current architecture**: One renderer per preview
**Would need**: Compositing layer or dual renderers

**Is this a requirement?** Unknown.

---

## Recommendations

### 1. Clarify Architecture (BLOCKING)

**Before writing any code**, answer:

**A)** Is Canvas a drop-in replacement for SvgRenderer?
   - YES → Option A (renderer swap)
   - NO → Need more detail

**B)** What features must Canvas support?
   - Full RenderTree parity?
   - Subset (shapes only, no effects)?
   - Canvas-specific extensions?

**C)** How will renderer be selected?
   - Hardcoded switch to Canvas?
   - User toggle in UI?
   - Auto-detect based on scene complexity?
   - Per-block choice?

### 2. Performance Baseline (RECOMMENDED)

**Before optimizing**, measure:
- Current SVG performance at 100, 500, 1000, 5000 elements
- Frame time breakdown (RAF → render → paint)
- Identify actual bottleneck (DOM updates? Layout? Paint?)

**Tools**:
- Chrome DevTools Performance panel
- Player already tracks frame times (Player.ts:366-374)
- Add logging to see actual performance

### 3. Incremental Implementation Path (If Option A)

**Phase 1**: CanvasRenderer - minimal viable
- Support: circle, rect, basic path
- Support: fill, stroke, opacity
- Support: 2D transforms (translate, rotate, scale)
- Skip: filters, 3D, deforms

**Phase 2**: PreviewPanel integration
- Conditional renderer creation (SVG vs Canvas)
- UI toggle or auto-detect

**Phase 3**: Effect parity
- Add Canvas-native implementations of:
  - Blur (ctx.filter)
  - Shadows (ctx.shadowBlur)
  - Opacity groups

**Phase 4**: Optimization
- Dirty region tracking
- Object pooling
- Batch draw calls

### 4. Testing Strategy

**Test 1**: Render parity
- Golden screenshots: same RenderTree → SVG vs Canvas → identical pixels
- Test all geometry types, styles, transforms

**Test 2**: Performance benchmark
- 1000 circles, animated phase
- Measure FPS: SVG vs Canvas
- Target: 60fps on reference hardware

**Test 3**: Hot swap compatibility
- Compile → swap to Canvas → no visual glitch
- Scrubbing works correctly
- Time controls function

---

## Verdict

⚠️ **PAUSE - Clarification Required**

**Cannot proceed with implementation until architecture is decided.**

**Critical Questions**:
1. Where does Canvas plug in? (Renderer-level or Block-level?)
2. What does "the one block" mean?
3. What features must Canvas support?
4. How is renderer selected?

**Next Step**: User answers questions above, then:
- If Option A → Implement CanvasRenderer class
- If Option B → Design block + artifact contract first

**Estimated Complexity** (once architecture is clear):
- Option A: Medium (2-3 days) - New renderer class + integration
- Option B: High (5-7 days) - New block, compiler, artifact type, player changes

---

## Appendix: Code Locations

**Rendering Pipeline**:
- `src/editor/runtime/renderTree.ts` - RenderTree types
- `src/editor/runtime/svgRenderer.ts` - SVG backend
- `src/editor/runtime/player.ts` - RAF loop, onFrame callback

**Integration**:
- `src/editor/PreviewPanel.tsx:104-168` - Renderer creation
- `src/editor/PreviewPanel.tsx:119-130` - onFrame callback

**RenderInstances2D**:
- `src/editor/blocks/domain.ts:212-263` - Block definition
- `src/editor/compiler/blocks/domain/RenderInstances2D.ts` - Compiler

**Exports**:
- `src/editor/runtime/index.ts` - Public API

---

## Summary for User

**Current**: SVG-only rendering via `RenderInstances2D` block → `RenderTree` → `SvgRenderer`

**Missing**: Canvas rendering capability

**Ambiguity**: Architecture-level decision needed:
- **Option A**: Canvas as drop-in replacement for SvgRenderer (backend swap)
- **Option B**: Canvas as new block type (RenderInstances2DCanvas)

**Your statement "it should only be the one block, right?" could mean**:
- Keep RenderInstances2D, swap renderer backend → Option A
- Add one Canvas-specific block → Option B

**Questions for you**:
1. Do you want users to choose SVG vs Canvas, or should it be invisible?
2. Should Canvas replace SVG entirely, or coexist?
3. What rendering features must Canvas support (filters, 3D transforms)?

**Once we know the answers, implementation is straightforward.**
