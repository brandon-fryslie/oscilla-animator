# Sprint Plan: Canvas 2D Renderer Implementation

**Generated**: 2025-12-24 16:56:35
**Source STATUS**: STATUS-20251224-v2.md
**Topic**: Canvas 2D Renderer
**Topic Directory**: `.agent_planning/canvas-renderer/`

---

## Executive Summary

**Current State**: 0% complete - design specs exist, no implementation started
**Target**: Working Canvas 2D renderer that can render animations alongside SVG
**Approach**: Pragmatic renderer-level implementation (Path 1 from STATUS)
**Sprint Scope**: 3 deliverables over 1 sprint
**Deferred**: IR/VM system architecture (separate future work)

### Why This Approach

The STATUS report identified 3 possible implementation paths:

1. **Path 1 (Renderer Swap)**: Canvas2DRenderer consumes existing RenderTree - minimal, works today ✅ **CHOSEN**
2. **Path 2 (IR/VM System)**: Build complete IR architecture first - 3-4 weeks, breaks universality ❌
3. **Path 3 (Hybrid Hints)**: Add optimization metadata to RenderTree - deferred optimization ⏭️

**Rationale**:
- Existing RenderTree IR is universal and works for both SVG and Canvas
- Player, BlockCompiler pattern, and DefaultSource system all ready to use
- No architectural changes needed - pure addition
- Can optimize later without breaking existing code
- Delivers working Canvas rendering immediately

---

## Backlog by Priority

### P0 (Critical) - Sprint 1 Foundation

---

## P0-1: Canvas2DRenderer Class

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: None
**Spec Reference**: `12-CanvasBackend.md` (renderer contract) • **Status Reference**: STATUS-20251224-v2.md § "What Needs to be Created" § 1

### Description

Create `Canvas2DRenderer` class that consumes the universal RenderTree IR and renders to HTMLCanvasElement. This is the core renderer implementation that translates semantic RenderTree nodes (GroupNode, ShapeNode, EffectNode) into Canvas 2D API calls.

**Architecture**: Follows SvgRenderer pattern but executes against Canvas 2D context instead of DOM.

**Key Responsibilities**:
- Own HTMLCanvasElement lifecycle (resize, DPR, viewport)
- Traverse RenderTree depth-first
- Execute geometry rendering (circles initially)
- Compose effects (opacity, transforms, filters)
- Manage Canvas state stack (save/restore balance)

**Implementation Location**: `src/editor/runtime/canvasRenderer.ts` (new file)

### Acceptance Criteria (REQUIRED)

- [ ] `Canvas2DRenderer` class exists with constructor accepting `HTMLCanvasElement`
- [ ] `setViewport(w, h, dpr)` method correctly resizes canvas and sets DPR transform
- [ ] `render(tree: RenderTree)` method traverses tree and renders all node types
- [ ] Circle geometry renders with correct position, radius, fill color, and opacity
- [ ] Group nodes recurse on children correctly
- [ ] Effect nodes (opacity, Transform2D) compose correctly via Canvas state stack
- [ ] Canvas clears properly between frames (no visual artifacts from previous frame)
- [ ] Empty domain (n=0 elements) renders without errors
- [ ] Large domain (n≥100 elements) renders without dropping frames
- [ ] Unit tests verify viewport resize, DPR scaling, and circle rendering
- [ ] E2E test verifies Canvas renderer produces visually correct output for reference patch

### Technical Notes

**RenderTree Node Types to Support** (from `runtime/renderTree.ts`):
- `ShapeNode`: Geometry + style → render primitives
  - Initially support `CircleGeom` only (matches RenderInstances2D output)
  - Future: RectGeom, PathGeom, etc.
- `GroupNode`: Container → iterate children
- `EffectNode`: Visual modifier → apply via Canvas state
  - Opacity: `ctx.globalAlpha *= effect.opacity`
  - Transform2D: `ctx.transform(...matrix)`
  - Filter: `ctx.filter = effect.filter` (if supported)
  - Clip: `ctx.clip(path)` (if needed)

**Canvas State Management**:
```typescript
ctx.save();     // Push state before group/effect
// ... apply effect, render children
ctx.restore();  // Pop state after
```

**Performance Considerations**:
- Batch same-colored circles when possible
- Minimize `ctx.fillStyle` changes (expensive)
- Cache Path2D for repeated shapes (future optimization)
- Avoid `ctx.globalCompositeOperation` changes unless necessary

**DPR Handling** (critical for Retina displays):
```typescript
canvas.width = Math.floor(w * dpr);
canvas.height = Math.floor(h * dpr);
canvas.style.width = `${w}px`;
canvas.style.height = `${h}px`;
ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
```

**Graceful Degradation**:
- If `ctx.filter` not supported (old browsers), skip filter effects
- If Transform3D encountered, log warning and skip (Canvas 2D cannot render 3D)

**Reference Implementation**: `src/editor/runtime/svgRenderer.ts` - follow same traversal pattern

---

## P0-2: PreviewPanel Renderer Selection

**Status**: Not Started
**Effort**: Small (1 day)
**Dependencies**: [P0-1]
**Spec Reference**: `13-CanvasRendererCode.md` § Integration • **Status Reference**: STATUS-20251224-v2.md § "What Needs to be Created" § 3

### Description

Add renderer selection logic to PreviewPanel so users can toggle between SVG and Canvas rendering. This involves adding a Canvas element, a UI toggle, and conditional renderer instantiation.

**User Experience**: Settings panel gains "Renderer: [SVG | Canvas]" toggle. Change takes effect immediately (no reload).

**Implementation Location**: `src/editor/PreviewPanel.tsx` (modify existing)

### Acceptance Criteria (REQUIRED)

- [ ] Canvas element exists in PreviewPanel DOM alongside SVG element
- [ ] UI toggle exists in settings panel: "Renderer: [SVG | Canvas]"
- [ ] Renderer selection persists in UIStore settings
- [ ] Player callback correctly routes RenderTree to active renderer
- [ ] Switching renderers mid-playback works without errors
- [ ] Canvas element has same dimensions as SVG viewport
- [ ] Only active renderer element is visible (CSS display/visibility toggle)
- [ ] Unit test verifies renderer switching logic
- [ ] E2E test verifies both renderers can render the same patch

### Technical Notes

**UI Store Setting**:
```typescript
interface UISettings {
  rendererType: 'svg' | 'canvas';  // New setting
  // ... existing settings
}
```

**PreviewPanel JSX** (approximate):
```typescript
const canvasRef = useRef<HTMLCanvasElement>(null);
const svgRef = useRef<SVGSVGElement>(null);
const rendererType = rootStore.uiStore.settings.rendererType;

// Renderer instantiation (useMemo or useEffect)
const renderer = useMemo(() => {
  if (rendererType === 'canvas' && canvasRef.current) {
    return new Canvas2DRenderer(canvasRef.current);
  } else if (svgRef.current) {
    return new SvgRenderer(svgRef.current);
  }
}, [rendererType, canvasRef.current, svgRef.current]);

// Player callback
const player = createPlayer(
  (tree: RenderTree, _tMs: number) => {
    renderer.render(tree);
  },
  // ... options
);

// JSX
<div className="preview-viewport">
  <svg ref={svgRef} style={{ display: rendererType === 'svg' ? 'block' : 'none' }} />
  <canvas ref={canvasRef} style={{ display: rendererType === 'canvas' ? 'block' : 'none' }} />
</div>
```

**Settings Toggle UI**:
Add to existing settings panel (gear icon menu or similar):
```typescript
<Select
  label="Renderer"
  value={uiStore.settings.rendererType}
  onChange={(val) => uiStore.updateSettings({ rendererType: val })}
  options={[
    { value: 'svg', label: 'SVG' },
    { value: 'canvas', label: 'Canvas 2D' },
  ]}
/>
```

**Viewport Sync**:
Both SVG and Canvas must resize together when viewport changes. Reuse existing viewport resize logic.

**Cleanup**:
When switching renderers, ensure previous renderer releases resources (Canvas: none needed, SVG: DOM already cleaned).

---

## P0-3: Export and Integration

**Status**: Not Started
**Effort**: Small (1 day)
**Dependencies**: [P0-1, P0-2]
**Spec Reference**: N/A (integration task) • **Status Reference**: STATUS-20251224-v2.md § "What Infrastructure Exists"

### Description

Export Canvas2DRenderer from runtime module and verify integration with existing infrastructure (Player, RenderTree, blocks). Ensure no regressions to SVG rendering.

**Validation**: Run existing patches with both renderers and verify visual parity.

**Implementation Locations**:
- `src/editor/runtime/index.ts` (export)
- `src/editor/runtime/canvasRenderer.ts` (ensure proper imports)

### Acceptance Criteria (REQUIRED)

- [ ] `Canvas2DRenderer` exported from `src/editor/runtime/index.ts`
- [ ] PreviewPanel successfully imports and instantiates Canvas2DRenderer
- [ ] Existing SVG rendering still works (no regressions)
- [ ] Reference patch ("Breathing Constellation" from `07-golden-patch.md`) renders visually correctly in both SVG and Canvas modes
- [ ] No TypeScript errors in codebase after integration
- [ ] `just check` passes (typecheck + lint + test)
- [ ] Visual regression test compares SVG vs Canvas output (same patch, same frame)
- [ ] Canvas renderer handles RenderInstances2D block output correctly

### Technical Notes

**Export from runtime/index.ts**:
```typescript
export { Canvas2DRenderer } from './canvasRenderer';
export { SvgRenderer } from './svgRenderer';
// ... existing exports
```

**Visual Parity Testing**:
For the same RenderTree input:
- SVG renderer → rasterize to image
- Canvas renderer → `canvas.toDataURL()`
- Compare pixel data (allow small tolerance for anti-aliasing differences)

**Regression Check**:
Run full test suite with `rendererType: 'svg'` to ensure SVG path unaffected.

**Known Limitations to Document**:
- Transform3D not supported in Canvas (SVG-only for now)
- CSS filter effects may differ between SVG and Canvas
- Text rendering (if added later) uses different APIs

**Success Criteria**:
User can load any existing patch, toggle renderer, and see visually equivalent output.

---

## P1 (High) - Sprint 2+ Enhancements (Deferred)

These items are explicitly OUT OF SCOPE for Sprint 1 but form the next iteration backlog.

---

## P1-1: Effect Parity (Filters, Blend Modes)

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: [P0-1]
**Spec Reference**: `12-CanvasBackend.md` § Soft Responsibilities • **Status Reference**: STATUS-20251224-v2.md § "What Needs to be Created" § 1 (Unknowns)

### Description

Extend Canvas2DRenderer to support full RenderTree effect vocabulary: filters, blend modes, clips. Some effects may have limited Canvas 2D support.

**Deferred Rationale**: Sprint 1 focuses on core rendering. Most current patches use opacity/transform only.

### Acceptance Criteria (REQUIRED)

- [ ] Filter effects render correctly (blur, drop-shadow, etc.) where Canvas 2D supports them
- [ ] Blend modes (`globalCompositeOperation`) supported for common cases (source-over, multiply, screen)
- [ ] Clip paths work for rectangular and circular clips
- [ ] Unsupported effects log warnings and degrade gracefully
- [ ] Unit tests verify each effect type
- [ ] E2E test verifies complex effect composition (nested filters + opacity + blend)

### Technical Notes

**Canvas Filter Support** (limited):
- `ctx.filter = 'blur(5px)'` works in modern browsers
- CSS filter string format (different from SVG filter elements)
- Not all SVG filters map to Canvas filters

**Blend Modes**:
- Map RenderTree blend mode strings to `GlobalCompositeOperation` values
- Common modes: `source-over`, `multiply`, `screen`, `overlay`, `darken`, `lighten`

**Clip Paths**:
- Use `ctx.clip()` with Path2D or simple rect clip
- Complex vector clips may not map 1:1 from SVG

**Graceful Degradation**:
If effect not supported, skip and log warning once per effect type.

---

## P1-2: Performance Optimization (Batching, Caching)

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: [P0-1]
**Spec Reference**: `12-CanvasBackend.md` § Batching/Instancing • **Status Reference**: N/A

### Description

Optimize Canvas2DRenderer for high element counts (1000+ circles). Implement batching (group same-colored circles), Path2D caching, and state change minimization.

**Deferred Rationale**: Sprint 1 proves correctness. Optimization follows once baseline works.

### Acceptance Criteria (REQUIRED)

- [ ] Renderer batches consecutive circles with same fill color (reduces `ctx.fillStyle` changes)
- [ ] Path2D objects cached for repeated geometries (keyed by geom hash)
- [ ] State changes (fillStyle, globalAlpha, etc.) minimized across frame
- [ ] LRU cache eviction policy for Path2D (max 1000 entries)
- [ ] Benchmark shows ≥2x speedup for n=1000 elements vs naive implementation
- [ ] Profiling shows reduced Canvas API call count
- [ ] No visual regressions from optimization

### Technical Notes

**Batching Strategy**:
Sort RenderTree nodes by fill color before rendering (if order-independent). For order-dependent rendering, batch within same z-layer.

**Path2D Caching**:
```typescript
const pathCache = new Map<string, Path2D>();
const geomKey = `circle:${r}`;
if (!pathCache.has(geomKey)) {
  const path = new Path2D();
  path.arc(0, 0, r, 0, Math.PI * 2);
  pathCache.set(geomKey, path);
}
ctx.translate(cx, cy);
ctx.fill(pathCache.get(geomKey)!);
ctx.translate(-cx, -cy);
```

**State Change Tracking**:
Track last-set fillStyle, globalAlpha, etc. Only call `ctx.fillStyle = ...` if value changed.

---

## P1-3: Additional Geometry Support

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: [P0-1]
**Spec Reference**: N/A (future capability) • **Status Reference**: N/A

### Description

Add support for additional RenderTree geometry types beyond circles: rectangles, paths, text. Enables richer visual output.

**Deferred Rationale**: RenderInstances2D currently only emits circles. Additional geometries require new blocks or field types.

### Acceptance Criteria (REQUIRED)

- [ ] RectGeom renders correctly (position, width, height, rotation)
- [ ] PathGeom renders correctly (SVG path string → Path2D → Canvas)
- [ ] TextGeom renders correctly (text, font, position, alignment)
- [ ] Unit tests verify each geometry type
- [ ] E2E test verifies mixed geometry patch (circles + rects + paths)

### Technical Notes

**RectGeom**:
```typescript
ctx.fillRect(x, y, w, h);
// or with rotation:
ctx.rotate(rot);
ctx.fillRect(-w/2, -h/2, w, h);
```

**PathGeom**:
```typescript
const path = new Path2D(svgPathString);
ctx.fill(path);
```

**TextGeom**:
```typescript
ctx.font = `${fontSize}px ${fontFamily}`;
ctx.textAlign = alignment;
ctx.fillText(text, x, y);
```

Text rendering in Canvas is expensive - consider atlas caching for repeated glyphs (future optimization).

---

## P2 (Medium) - Future Enhancements (Backlog)

These items are nice-to-have improvements beyond core functionality.

---

## P2-1: Renderer Performance Metrics

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: [P0-1]
**Spec Reference**: `12-CanvasBackend.md` § RenderStats • **Status Reference**: N/A

### Description

Add RenderStats output from Canvas2DRenderer: draw call count, state changes, frame time. Display in DevTools panel or overlay.

### Acceptance Criteria (REQUIRED)

- [ ] `render()` method returns `RenderStats` object with metrics
- [ ] Metrics include: drawCallCount, stateChangeCount, renderTimeMs
- [ ] Stats displayed in DevTools panel or debug overlay (toggle in settings)
- [ ] Stats update every frame (or at configurable interval)
- [ ] Unit test verifies stat collection accuracy

### Technical Notes

**RenderStats Interface**:
```typescript
interface RenderStats {
  drawCallCount: number;
  stateChangeCount: number;
  renderTimeMs: number;
  nodeCount: number;
  skipCount: number; // nodes skipped (culled, invisible, etc.)
}
```

**Collection**:
Instrument `render()` method with counters. Use `performance.now()` for timing.

**Display**:
Add to existing debug overlay (if exists) or create new stats panel.

---

## P2-2: Renderer Selection Persistence

**Status**: Not Started
**Effort**: Small (1 day)
**Dependencies**: [P0-2]
**Spec Reference**: N/A (UX improvement) • **Status Reference**: N/A

### Description

Persist renderer selection to localStorage so user's choice survives page reload.

### Acceptance Criteria (REQUIRED)

- [ ] Renderer selection saved to localStorage on change
- [ ] Renderer selection restored from localStorage on app load
- [ ] Fallback to 'svg' if localStorage empty or corrupt
- [ ] Unit test verifies persistence logic

### Technical Notes

**Implementation**:
```typescript
// UIStore
updateSettings(settings: Partial<UISettings>) {
  this.settings = { ...this.settings, ...settings };
  localStorage.setItem('oscilla:settings', JSON.stringify(this.settings));
}

// On init
const savedSettings = JSON.parse(localStorage.getItem('oscilla:settings') || '{}');
this.settings = { ...DEFAULT_SETTINGS, ...savedSettings };
```

---

## P2-3: Canvas Export (Image Download)

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: [P0-1]
**Spec Reference**: N/A (user feature) • **Status Reference**: N/A

### Description

Add "Export Frame" button that downloads current Canvas frame as PNG/JPEG. Useful for creating stills from animations.

### Acceptance Criteria (REQUIRED)

- [ ] "Export Frame" button exists in PreviewPanel UI
- [ ] Clicking button downloads current frame as PNG
- [ ] Exported image has correct dimensions (respects DPR)
- [ ] Export works in both SVG and Canvas modes (rasterize SVG if needed)
- [ ] Filename includes timestamp: `oscilla-frame-{timestamp}.png`
- [ ] Unit test verifies export logic (mock download)

### Technical Notes

**Canvas Export**:
```typescript
const dataUrl = canvas.toDataURL('image/png');
const link = document.createElement('a');
link.download = `oscilla-frame-${Date.now()}.png`;
link.href = dataUrl;
link.click();
```

**SVG Export** (requires rasterization):
1. Create temporary canvas
2. Serialize SVG to data URL
3. Draw SVG image to canvas
4. Export canvas as PNG

---

## P3 (Low) - Nice-to-Have (Deferred Indefinitely)

---

## P3-1: WebGL/WebGPU Renderer (Future)

**Status**: Not Started
**Effort**: XL (2+ weeks)
**Dependencies**: [P0-1, P1-2]
**Spec Reference**: `12-CanvasBackend.md` § Future Path • **Status Reference**: N/A

### Description

Add GPU-accelerated renderer using WebGL or WebGPU for extremely high element counts (10k+ circles).

**Deferred Rationale**: Canvas 2D sufficient for current use cases. WebGL/WebGPU requires shader authoring and different architecture.

### Acceptance Criteria (REQUIRED)

- [ ] WebGLRenderer consumes same RenderTree IR
- [ ] Handles ≥10k elements at 60fps
- [ ] Shader implementations for all supported geometries
- [ ] Fallback to Canvas2D if WebGL unavailable
- [ ] No visual regressions vs Canvas2D

### Technical Notes

This is a major architectural addition. Would require:
- Shader authoring (GLSL or WGSL)
- Buffer management (VBOs, attributes)
- Instanced rendering
- Different effect composition strategy

Only pursue if Canvas 2D proves insufficient for performance requirements.

---

## Dependency Graph

```
Sprint 1 (Critical Path):
P0-1 (Canvas2DRenderer) → P0-2 (PreviewPanel Integration) → P0-3 (Export & Verify)
                        ↓
                     P1-1 (Effects)
                     P1-2 (Optimization)
                     P1-3 (Geometries)
                        ↓
                     P2-* (Enhancements)
                        ↓
                     P3-* (Future)
```

**Critical Path**: P0-1 → P0-2 → P0-3 (3 tasks, sequential)
**Parallel Work**: After P0-1 completes, P1-1/P1-2/P1-3 can proceed in parallel

---

## Recommended Sprint Planning

### Sprint 1 (Current Sprint) - MVP Canvas Rendering

**Goal**: Users can toggle between SVG and Canvas rendering for existing patches

**Deliverables**:
1. Canvas2DRenderer class (P0-1)
2. PreviewPanel renderer selection (P0-2)
3. Integration and verification (P0-3)

**Success Criteria**:
- User can load "Breathing Constellation" patch
- Toggle renderer from SVG to Canvas
- See visually equivalent animation in both modes
- No errors, no performance regressions

**Effort**: 4-5 days total (assuming 1 developer)

**Out of Scope**:
- New blocks (use existing RenderInstances2D)
- IR/VM system (future architecture)
- Advanced effects (filters, blend modes)
- Performance optimization (batching, caching)
- Additional geometries (rects, paths, text)

---

### Sprint 2 (Deferred) - Effect Parity and Optimization

**Goal**: Canvas rendering matches SVG feature parity and performs well at scale

**Deliverables**:
1. Full effect support (P1-1)
2. Performance optimization (P1-2)
3. Additional geometries (P1-3)

**Success Criteria**:
- All RenderTree effects render correctly in Canvas
- 1000+ element patches run smoothly
- No visual regressions from optimization

**Effort**: 2-3 weeks

---

### Sprint 3+ (Backlog) - Enhancements

**Goal**: Polish and user-facing features

**Deliverables**:
- Performance metrics display (P2-1)
- Settings persistence (P2-2)
- Frame export (P2-3)

**Effort**: 1 week

---

## Risk Assessment

### High Risk

**Risk**: Canvas 2D performance insufficient for large element counts
**Mitigation**: Implement P1-2 (optimization) early if needed. Fallback: WebGL renderer (P3-1) if Canvas proves inadequate.
**Likelihood**: Low (Canvas 2D handles 1000+ circles adequately based on benchmarks)

**Risk**: RenderTree effects don't map cleanly to Canvas 2D
**Mitigation**: Document unsupported effects, degrade gracefully, log warnings.
**Likelihood**: Medium (known issue: Transform3D, complex filters)

### Medium Risk

**Risk**: User expects new Canvas-specific blocks (misunderstanding scope)
**Mitigation**: Clarify that Canvas is a *renderer swap*, not new block types. Same blocks work for both renderers.
**Likelihood**: Medium (spec pseudocode may mislead)

**Risk**: Visual output differs between SVG and Canvas (anti-aliasing, color space)
**Mitigation**: Accept minor differences, document known discrepancies. Focus on "visually equivalent" not "pixel-perfect".
**Likelihood**: High (expected - different rendering engines)

### Low Risk

**Risk**: Integration breaks existing SVG rendering
**Mitigation**: Comprehensive regression testing, keep SVG and Canvas paths independent.
**Likelihood**: Low (additive change, no modifications to SVG renderer)

---

## Questions and Ambiguities (from STATUS Report)

### Resolved for Sprint 1

**Q1: IR/VM system - build it or defer?**
**A**: Defer. Use existing closure-based architecture. Future refactor if needed.

**Q2: RenderCmds vs RenderTree universality?**
**A**: Preserve RenderTree universality. No new artifact types.

**Q3: What does "materialization" mean?**
**A**: Out of scope for Sprint 1. Fields evaluate fresh every frame (current behavior). Buffer pooling is P1-2 optimization.

### Unresolved (Not Blocking Sprint 1)

**Q4: Radius design - input or param?**
**Status**: Deferred. Sprint 1 uses existing RenderInstances2D block as-is. If user wants radius redesign, address in separate sprint.

---

## Implementation Notes

### File Structure

**New Files**:
- `src/editor/runtime/canvasRenderer.ts` - Canvas2DRenderer class (~300 lines)
- `src/editor/runtime/canvasRenderer.test.ts` - Unit tests (~200 lines)

**Modified Files**:
- `src/editor/runtime/index.ts` - Export Canvas2DRenderer
- `src/editor/PreviewPanel.tsx` - Add canvas element and renderer toggle
- `src/editor/stores/UIStore.ts` - Add rendererType setting
- `tests/e2e/renderer-parity.test.ts` - Visual regression test (new)

**Total LOC**: ~600 new, ~100 modified

---

### Testing Strategy

**Unit Tests** (P0-1):
- Viewport resize logic
- DPR scaling
- Circle rendering (mocked Canvas context)
- Effect composition (opacity, transform)
- Empty domain (n=0)
- State stack balance (save/restore count)

**Integration Tests** (P0-3):
- PreviewPanel instantiates correct renderer based on setting
- Renderer toggle works without errors
- Player callback routes RenderTree correctly

**E2E Tests** (P0-3):
- Load reference patch in both renderers
- Visual comparison (SVG rasterized vs Canvas output)
- Performance test (render 100 elements, measure FPS)

**Manual Testing**:
- Toggle renderer mid-playback
- Resize viewport
- Scrub timeline
- Load various patches (simple, complex, effects)

---

### Code Quality Standards

**TypeScript**:
- All public methods typed (no `any`)
- Use `readonly` for immutable data
- Prefer `const` over `let`
- Strict null checks enabled

**Performance**:
- No allocations in hot path (render loop)
- Reuse arrays/objects where possible
- Profile before optimizing

**Maintainability**:
- Follow existing codebase patterns (see SvgRenderer)
- Document non-obvious Canvas API usage
- Add comments for browser compatibility workarounds

**Testing**:
- Unit test coverage ≥80% for new code
- All edge cases covered (empty, large, degenerate)
- Visual regression test for every supported effect

---

## Success Metrics

**Sprint 1 Complete When**:
1. ✅ `just check` passes (typecheck, lint, tests)
2. ✅ User can toggle renderer in PreviewPanel settings
3. ✅ Reference patch renders visually correctly in both SVG and Canvas modes
4. ✅ No console errors or warnings during normal operation
5. ✅ Performance is ≥ SVG renderer (no frame drops for n≤100 elements)

**Long-Term Success**:
- Canvas becomes default renderer for performance-critical patches
- Users report smoother playback for large element counts
- WebGL/WebGPU renderer can be added later without breaking Canvas implementation

---

## Blockers and Questions

### Blockers

None currently. All prerequisites exist:
- ✅ RenderTree IR stable and documented
- ✅ Player integration point clear
- ✅ SvgRenderer reference implementation available
- ✅ TypeScript/React/Vite build working

### Questions for User

**Q1**: Should Canvas be the default renderer, or should SVG remain default with Canvas opt-in?
**Impact**: UX decision - affects initial user experience.
**Recommendation**: SVG default (stable, tested), Canvas opt-in (new, needs validation).

**Q2**: Should renderer selection be per-patch or global?
**Impact**: If per-patch, need to store renderer preference in patch metadata.
**Recommendation**: Global setting (simpler), can add per-patch override later.

**Q3**: What performance target (element count, FPS)?
**Impact**: Determines when optimization (P1-2) becomes critical.
**Recommendation**: 100 elements @ 60fps for Sprint 1, optimize for 1000+ in Sprint 2 if needed.

**Q4**: Should we skip unsupported effects (Transform3D, complex filters) silently or show warnings?
**Impact**: User awareness vs. console noise.
**Recommendation**: Log warning once per effect type (avoids spam), document limitations.

---

## Deferred Architectural Decisions

These are intentionally deferred to avoid scope creep:

1. **IR/VM System**: Spec describes future architecture. Not implemented in Sprint 1. Revisit if/when closure-based approach proves limiting.

2. **RenderCmds Artifact Type**: Not added. RenderTree remains universal IR. Revisit if Canvas-specific optimization requires different IR.

3. **Buffer Pooling/Materialization**: Field evaluation strategy unchanged. Revisit if GC pressure becomes performance issue.

4. **Radius Input vs Param**: Block design question deferred. Use existing RenderInstances2D as-is.

5. **WebGL/WebGPU Renderer**: Only if Canvas 2D insufficient. Requires separate RFC.

---

## References

**Design Specs**:
- `design-docs/3-Synthesized/12-CanvasBackend.md` - Renderer contract, responsibilities
- `design-docs/3-Synthesized/13-CanvasRendererCode.md` - Pseudocode (IR-based, future architecture)

**Status Reports**:
- `.agent_planning/canvas-renderer/STATUS-20251224-v2.md` - Current state analysis, gaps, recommendations

**Code References**:
- `src/editor/runtime/svgRenderer.ts` - Reference implementation (traversal pattern)
- `src/editor/runtime/player.ts` - Integration point (onFrame callback)
- `src/editor/compiler/blocks/domain/RenderInstances2D.ts` - Block pattern, RenderTree output

**Memory Files**:
- `claude_memory/01-architecture.md` - MobX stores, directory structure
- `claude_memory/02-type-system.md` - Signal, Field, TypeDesc hierarchy
- `claude_memory/07-golden-patch.md` - Reference patch for validation

---

## Conclusion

Sprint 1 delivers a working Canvas 2D renderer using the pragmatic "renderer swap" approach (Path 1 from STATUS). This avoids the 3-4 week detour of building an IR/VM system while providing immediate value: users can toggle between SVG and Canvas rendering.

Future sprints can add effect parity (P1-1), optimization (P1-2), and additional features (P2-*) based on user feedback and performance requirements.

The implementation preserves RenderTree universality, requires no new blocks, and makes no breaking changes to existing architecture. Success criteria are clear and testable.

**Next Step**: Implement P0-1 (Canvas2DRenderer class) and verify against reference implementation (SvgRenderer).
