# Status Report: Phase 6 Sprint 3 - executeNodeEval + executeRenderAssemble + Hot-swap
Generated: 2025-12-26-102151
Evaluator: status-planner
Source: Sprint 2 Completion (COMPLETION-2025-12-26-100200.md)

## Executive Summary

**Sprint Status:** Ready to begin Sprint 3
**Overall Completeness:** ~75% (ValueStore/StateBuffer/FrameCache/BusEval/Materialize complete, node eval + render assembly + hot-swap pending)
**Readiness:** GREEN - Sprint 2 complete with 71 tests (118% of target), 1795 tests passing total

Sprint 2 delivered **step executor integration** (FrameCache + executeBusEval + executeMaterialize) with 71 tests. All existing tests passing. Sprint 3 focuses on **execution completeness** - executeNodeEval implementation (if needed), executeRenderAssemble, and hot-swap state preservation semantics.

## Current State Analysis

### What Exists and Works

#### 1. Foundation Infrastructure (Sprint 1 - COMPLETE)

**ValueStore Implementation** (31 tests)
- Location: `src/editor/compiler/ir/stores.ts`
- Typed array allocation (f64, f32, i32, u32, objects)
- Single-writer-per-slot-per-frame enforcement
- write(), read(), clear() methods
- Real integration in `RuntimeState.createRuntimeState()`

**StateBuffer Implementation** (16 tests)
- Location: `src/editor/compiler/ir/stores.ts`
- Typed array allocation based on StateLayout
- initializeState() from const pool
- Support for scalar cells and ring buffers

**RuntimeState Integration** (17 tests)
- Location: `src/editor/runtime/executor/RuntimeState.ts`
- Real stores (not stubs) wired into createRuntimeState()
- extractSlotMeta() helper for slot metadata extraction
- Backward compatibility for test fixtures

#### 2. FrameCache System (Sprint 2 - COMPLETE)

**FrameCache Implementation** (41 tests)
- Location: `src/editor/runtime/executor/RuntimeState.ts` lines 77-186
- Signal cache arrays (sigValue: Float64Array, sigStamp: Uint32Array)
- Field cache arrays (fieldHandle: FieldHandle[], fieldStamp: Uint32Array)
- Buffer pool (fieldBuffers: Map<string, ArrayBufferView>)
- createFrameCache(sigCapacity, fieldCapacity) factory
- newFrame() increments frameId, clears buffer pool
- invalidate() zeros stamps, clears buffer pool
- FrameId starts at 1 to avoid collision with initial stamp values (0)

#### 3. Step Executors (Sprint 2 - COMPLETE)

**executeTimeDerive** - FUNCTIONAL (Sprint 1)
- Location: `src/editor/runtime/executor/steps/executeTimeDerive.ts`
- Resolves TimeModel (finite/cyclic/infinite)
- Writes tAbsMs, tModelMs, phase01, wrapEvent, progress01 to slots

**executeBusEval** - FUNCTIONAL (Sprint 2, 10 tests)
- Location: `src/editor/runtime/executor/steps/executeBusEval.ts`
- All combine modes: sum, average, min, max, last, product
- Silent value handling (zero, default, const from pool)
- Reads values from ValueStore, combines, writes to output slot

**executeMaterialize** - FUNCTIONAL (Sprint 2, 20 tests)
- Location: `src/editor/runtime/executor/steps/executeMaterialize.ts`
- Domain count validation (must be positive integer)
- Buffer format conversion (IR format → runtime format)
- Typed array creation (f32, f64, i32, u32, u8)
- Buffer pool caching (same field+domain+format → same buffer)
- newFrame() clears buffer pool for fresh materializations
- Stub mode for tests without field nodes

#### 4. Existing Evaluators (Phases 4-5 - COMPLETE)

**SigEvaluator** - READY FOR INTEGRATION
- Location: `src/editor/runtime/signal-expr/SigEvaluator.ts` (1200+ lines)
- Tests: 122+ passing tests
- Features:
  - Per-frame cache (sigValue, sigStamp)
  - All 12 node kinds: const, timeAbsMs, timeModelMs, phase01, wrapEvent, map, zip, select, inputSlot, busCombine, transform, stateful, closureBridge
  - Combine modes: sum, average, min, max, last
  - Transform chains: scaleBias, normalize, quantize, ease, map, slew, cast
  - Stateful ops: integrate, delayMs, delayFrames, sampleHold, slew, edgeDetectWrap, pulseDivider, envelopeAD
  - Debug sink integration

**FieldMaterializer** - READY FOR INTEGRATION
- Location: `src/editor/runtime/field/Materializer.ts`
- Tests: 63+ passing tests
- Features:
  - FieldHandle lazy evaluation system
  - Central materialization (fusion-capable)
  - BufferPool for typed array reuse
  - Broadcast (signal→field) and Reduce (field→signal)
  - Field combine modes
  - SignalBridge integration (uses SigEvaluator for broadcast)

### What's Missing for Sprint 3

#### 1. executeNodeEval Implementation - VERIFY NECESSITY FIRST

**Current State:**
- Location: `src/editor/runtime/executor/steps/executeNodeEval.ts`
- Stub returns zeros
- No opcode dispatch
- Reads input slots, writes output slots (structure exists)

**Investigation Required:**
The compiler IR defines `StepNodeEval` in the schedule spec (design-docs/12-Compiler-Final/10-Schedule-Semantics.md §12.2 Step 2), but:
- Grep search shows NO compiler passes emit `kind: "nodeEval"` steps
- Only IR type definitions exist (schedule.ts)
- Modern IR likely uses higher-level steps (BusEval, Materialize) instead

**Decision Point:**
Before implementing executeNodeEval, MUST verify:
1. Does the current compiler emit StepNodeEval steps? (Search compiler output)
2. If NO: NodeEval is legacy/unused → mark as deprecated, skip implementation
3. If YES: NodeEval is active → implement opcode dispatch using SigEvaluator

**If Implementation Required:**
- Dispatch to SigEvaluator.evalSig() for signal nodes
- Dispatch to FieldMaterializer for field nodes
- Wire inputSlots → evaluator inputs
- Wire evaluator outputs → outputSlots
- Handle stateReads/stateWrites references
- Estimated effort: 80-120 lines + 25-30 tests

**Spec Reference:**
- design-docs/12-Compiler-Final/10-Schedule-Semantics.md §12.2 Step 2 (StepNodeEval semantics)
- Lines 174-207: NodeEval reads inputSlots, executes node opcode, writes outputSlots

**Risk:**
Implementing unused infrastructure creates tech debt. VERIFY FIRST.

#### 2. executeRenderAssemble Implementation (P0)

**Current State:**
- Location: `src/editor/runtime/executor/steps/executeRenderAssemble.ts`
- Stub is complete no-op
- Comments indicate render node already writes to outSlot

**Spec Semantics (design-docs/12-Compiler-Final/10-Schedule-Semantics.md §12.2 Step 5):**
> "Typically trivial: the render node already wrote a RenderTree/RenderCmds to its output slot. This step exists so you have a single stable 'finalization' boundary for hot-swap + tracing."

**Required Implementation:**
Based on spec, executeRenderAssemble is a **finalization boundary**, NOT a transform step:
1. Read render tree from step.rootNodeIndex output slot (or step.outSlot)
2. Optional: Validate render tree structure (sanity checks)
3. Write to stable output location (step.outSlot if not already there)
4. Emit trace event for debugger (deferred to Phase 7)

**Implementation Complexity:**
- Trivial (10-20 lines) - just slot copy + validation
- Primary purpose: stable boundary for hot-swap (see §3 below)
- Tests: 8-10 tests (slot read, validation, error cases)

**Spec Reference:**
- design-docs/12-Compiler-Final/10-Schedule-Semantics.md §12.2 Step 5 lines 341-351
- StepRenderAssemble IR: src/editor/compiler/ir/schedule.ts lines 339-365

#### 3. Hot-swap State Preservation (P0)

**Current State:**
- NO hot-swap logic exists
- RuntimeState created fresh each compilation
- State/cache discarded on program swap

**Spec Requirements:**

**A) State Preservation Contract** (design-docs/12-Compiler-Final/17-Scheduler-Full.md §9.2)
- Compute StateLayoutPacked.hash for old and new programs
- Preserve state slots where (stableKey, layoutHash) match
- Initialize new slots with defaults
- Drop removed slots

**StableKey Definition (§9.2):**
- Block instance identity (blockId or stable lowered id)
- Output port identity
- Stateful node role (integrate accumulator, delay ring buffer, etc.)
- Optional user-visible name

**B) Cache Preservation Policy** (§9.3)
- Per-frame caches (FrameCache) discarded on swap (cheap to rebuild)
- Cross-frame memo cache preserved ONLY if programId matches
- Otherwise discard (no cross-program reuse)

**C) Time Continuity** (design-docs/12-Compiler-Final/02-IR-Schema.md §22)
- Runtime keeps tAbsMs across swap
- New program derives time via same timeModel kind, OR
- Topology change handled specially (no reset unless patch asks)

**D) Slot Continuity** (§22.3)
- When a node persists, output slots may be reindexed internally
- Semantic outputs must map to stable slots
- Easiest: keep ValueSlots stable for unchanged node outputs

**Implementation Requirements:**

1. **StateSwap Module** (NEW)
   - Location: `src/editor/runtime/executor/StateSwap.ts` (new file)
   - Function: `preserveState(oldRuntime, newRuntime, oldProgram, newProgram)`
   - Algorithm:
     1. Build stable key map from old state layout
     2. Build stable key map from new state layout
     3. For each matching (stableKey, layoutHash): copy state cells
     4. Initialize unmatched new cells with defaults from const pool
   - Estimated: 120-150 lines

2. **RuntimeState Swap API** (UPDATE)
   - Location: `src/editor/runtime/executor/RuntimeState.ts`
   - Add: `hotSwap(newProgram): RuntimeState` method
   - Algorithm:
     1. Create newRuntime from newProgram
     2. Preserve matching state cells (call StateSwap)
     3. Discard per-frame caches (FrameCache.invalidate())
     4. Keep tAbsMs, frameId (time continuity)
     5. Return newRuntime
   - Estimated: 30-50 lines

3. **ScheduleExecutor Integration** (UPDATE)
   - Location: `src/editor/runtime/executor/ScheduleExecutor.ts`
   - Add: `swapProgram(newProgram): void` method
   - Calls runtime.hotSwap(newProgram)
   - Updates internal program reference
   - Estimated: 10-20 lines

4. **StableKey Generation** (NEW or LOCATE)
   - Check if compiler already generates stable keys in StateLayout
   - If NO: Add stable key generation in state layout compiler pass
   - If YES: Document location and wire into StateSwap
   - Estimated: Variable (0-80 lines depending on existence)

**Test Requirements:**
- State preservation: matching keys preserved (5-8 tests)
- State initialization: new keys initialized (3-5 tests)
- State dropping: removed keys dropped (2-3 tests)
- Time continuity: tAbsMs preserved (2-3 tests)
- Cache invalidation: FrameCache cleared (2-3 tests)
- Total: 14-22 tests

**Spec References:**
- design-docs/12-Compiler-Final/17-Scheduler-Full.md §9 (lines 440-483)
- design-docs/12-Compiler-Final/02-IR-Schema.md §22 (lines 330-344)

**Critical Note:**
Hot-swap is a **non-negotiable requirement** per spec:
> "A program swap is allowed without visual jank only if..."

This is not optional optimization - it's core to live editing UX.

### Dependencies & Integration Points

#### Upstream (Complete - No Blockers)
- Phase 1-5: All complete ✓
- Sprint 1: ValueStore + StateBuffer ✓
- Sprint 2: FrameCache + BusEval + Materialize ✓

#### Downstream (Future Phases)
- Phase 7: Debug infrastructure (executeDebugProbe, trace events)
- Hot-swap debugger integration (trace event preservation)

### Known Issues & Risks

#### Issues
None - infrastructure is clean, tests passing.

#### Risks

1. **NodeEval Unnecessary Implementation** (HIGH)
   - StepNodeEval defined in spec but compiler may not emit it
   - Risk: Implement 100+ lines + 30 tests for unused code path
   - Mitigation: VERIFY compiler output BEFORE implementing
   - Detection: Search compiled IR for `kind: "nodeEval"` in test fixtures

2. **StableKey Location Uncertainty** (MEDIUM)
   - Not clear if compiler already generates stable keys for state slots
   - Risk: Need to add stable key generation (adds 2-4 hours)
   - Mitigation: Search StateLayout IR for stable key fields, check compiler passes
   - Detection: Grep for "stableKey\|stableId\|blockId" in state layout types

3. **Hot-swap Test Complexity** (MEDIUM)
   - Hot-swap requires two compiled programs (old + new)
   - Risk: Test setup overhead (fixture creation)
   - Mitigation: Create minimal test programs with known state differences
   - Detection: Use existing compiler test fixtures, modify slightly

4. **RenderAssemble Output Type Ambiguity** (LOW)
   - Not clear what type render tree is (RenderTree? RenderCmds? JSON?)
   - Risk: Need to investigate render node output schema
   - Mitigation: Check ScheduleExecutor.extractRenderOutput() stub
   - Detection: Read render node IR types, check output slot type

### Quantitative Metrics

```
Foundation Complete:      100% (ValueStore, StateBuffer, RuntimeState)
FrameCache Complete:      100% (signal/field caches, buffer pool)
Step Executors:            50% (3/6 functional)
  - executeTimeDerive:    100% (functional, Sprint 1)
  - executeBusEval:       100% (functional, Sprint 2)
  - executeMaterialize:   100% (functional, Sprint 2)
  - executeNodeEval:        0% (stub, verify necessity)
  - executeRenderAssemble:  0% (stub, P0 for Sprint 3)
  - executeDebugProbe:      0% (stub, deferred to Phase 7)

Hot-swap Infrastructure:    0% (not started)
  - StateSwap module:       0% (needs creation)
  - RuntimeState.hotSwap(): 0% (needs implementation)
  - ScheduleExecutor.swap: 0% (needs implementation)

Test Coverage:
  Sprint 1 + 2 total:    128 tests (ValueStore, StateBuffer, RuntimeState, FrameCache, BusEval, Materialize)
  Evaluators:            185+ tests (SigEvaluator, FieldMaterializer)
  Total passing:         1795 tests
```

### Files Requiring Changes (Sprint 3)

**Investigate (NodeEval):**
1. Search compiler output for `kind: "nodeEval"` step emissions
2. If found: Implement executeNodeEval.ts (~100 lines + 25-30 tests)
3. If not found: Mark executeNodeEval.ts as DEPRECATED, skip implementation

**Implement (RenderAssemble - P0):**
1. `src/editor/runtime/executor/steps/executeRenderAssemble.ts` - Real finalization
   - Read render tree from rootNodeIndex output slot
   - Optional validation (sanity checks)
   - Write to step.outSlot
   - (~10-20 lines changed)

**Add Tests (RenderAssemble):**
2. `src/editor/runtime/executor/__tests__/executeRenderAssemble.test.ts` (NEW)
   - Slot read/write
   - Validation (if implemented)
   - Error cases
   - (~8-10 tests)

**Implement (Hot-swap - P0):**
3. `src/editor/runtime/executor/StateSwap.ts` (NEW)
   - preserveState(oldRuntime, newRuntime, oldProgram, newProgram)
   - Stable key mapping
   - State cell copy logic
   - Default initialization for new slots
   - (~120-150 lines)

4. `src/editor/runtime/executor/RuntimeState.ts` (UPDATE)
   - Add hotSwap(newProgram) method
   - Call StateSwap.preserveState()
   - Invalidate FrameCache
   - Preserve tAbsMs, frameId
   - (~30-50 lines added)

5. `src/editor/runtime/executor/ScheduleExecutor.ts` (UPDATE)
   - Add swapProgram(newProgram) method
   - Call runtime.hotSwap()
   - Update program reference
   - (~10-20 lines added)

**Add Tests (Hot-swap):**
6. `src/editor/runtime/executor/__tests__/StateSwap.test.ts` (NEW)
   - State preservation (matching keys)
   - State initialization (new keys)
   - State dropping (removed keys)
   - (~10-15 tests)

7. `src/editor/runtime/executor/__tests__/hotSwap.test.ts` (NEW)
   - Time continuity (tAbsMs preserved)
   - Cache invalidation
   - End-to-end program swap
   - (~8-12 tests)

**Total Effort:** ~300-400 lines of implementation + ~250-350 lines of tests (50-60 tests)

## Recommendations for Sprint 3

### Scope

Focus on **executeRenderAssemble + hot-swap ONLY** (2 deliverables):
1. executeRenderAssemble implementation (finalization boundary)
2. Hot-swap state preservation (StateSwap + RuntimeState.hotSwap + ScheduleExecutor.swapProgram)

**Defer or verify:**
- executeNodeEval: VERIFY compiler emits NodeEval steps BEFORE implementing
  - If YES: Include as 3rd deliverable
  - If NO: Mark as DEPRECATED, document in code comments
- executeDebugProbe: Defer to Phase 7

### Success Criteria

1. executeRenderAssemble reads from rootNodeIndex output slot and writes to step.outSlot
2. StateSwap.preserveState() correctly matches state cells by stable key
3. RuntimeState.hotSwap() preserves matching state, invalidates caches, preserves time
4. ScheduleExecutor.swapProgram() performs jank-free program replacement
5. 50+ tests added (target: 50-60), all passing
6. All existing 1795 tests still pass

### Deliverable Limit

Sprint 3 delivers **2-3 deliverables maximum**:
1. executeRenderAssemble implementation (P0)
2. Hot-swap state preservation (P0 - core UX requirement per spec)
3. executeNodeEval implementation (CONDITIONAL - verify necessity first)

### Next Sprint (Sprint 4 - if needed)

- Legacy runtime removal (if not already done)
- Performance validation (benchmark new runtime vs legacy)
- Documentation updates (HANDOFF.md, CLAUDE.md memory files)
- executeDebugProbe implementation (if Phase 7 not started)

## Conclusion

Sprint 3 focuses on **execution completeness and live editing UX**. The two P0 deliverables (executeRenderAssemble + hot-swap) are non-negotiable per spec. NodeEval is contingent on verification.

**Critical Path:**
1. Verify NodeEval necessity (1 hour research)
2. Implement executeRenderAssemble (2-3 hours)
3. Implement hot-swap infrastructure (6-8 hours)
4. Write tests (4-6 hours)

**Status:** READY TO PROCEED with Sprint 3 implementation.
