# Implementation Plan: Phase 6 Sprint 3 - executeNodeEval + executeRenderAssemble + Hot-swap

**Generated:** 2025-12-26-102151
**Status Report:** STATUS-2025-12-26-102151.md
**Planner:** status-planner
**Sprint:** Phase 6 Sprint 3

---

## Executive Summary

**Sprint Goal:** Complete scheduled runtime execution infrastructure with render assembly finalization and hot-swap state preservation for jank-free live editing.

**Current State:** 75% complete - ValueStore, StateBuffer, FrameCache, executeBusEval, and executeMaterialize all functional with 1795 tests passing.

**Gap:** Missing executeRenderAssemble (finalization boundary) and hot-swap state preservation (non-negotiable per spec for live editing UX).

**Deliverables:** 2 deliverables (executeRenderAssemble + hot-swap), potentially 3 if NodeEval verification shows it's needed.

**Test Target:** 50+ new tests (8-10 render assembly, 18-27 hot-swap, 25-30 NodeEval if needed)

---

## Deliverables

### Deliverable 1: executeRenderAssemble Implementation (P0)

**Priority:** P0 (Critical)
**Status:** Not Started
**Effort:** Small (1-2 days)
**Dependencies:** None (uses existing ValueStore + FrameCache)
**Spec Reference:**
- design-docs/12-Compiler-Final/10-Schedule-Semantics.md §12.2 Step 5 (lines 341-351)
- design-docs/12-Compiler-Final/17-Scheduler-Full.md §9.4 (hot-swap finalization boundary)
**Status Reference:** STATUS-2025-12-26-102151.md §2.2 (executeRenderAssemble Implementation)

#### Description

Implement `executeRenderAssemble` as a stable finalization boundary for render tree assembly. Per spec, this step is "typically trivial" - the render node has already written the RenderTree to its output slot. This step exists to provide a single, stable boundary for hot-swap and tracing.

**Spec Semantics (§12.2 Step 5):**
> "Typically trivial: the render node already wrote a RenderTree/RenderCmds to its output slot. This step exists so you have a single stable 'finalization' boundary for hot-swap + tracing."

**Key Points:**
- NOT a transform step - just a boundary marker
- Render node already computed output (no evaluation here)
- Primary purpose: stable reference point for hot-swap
- Secondary purpose: trace event emission (deferred to Phase 7)

#### Acceptance Criteria

- [ ] executeRenderAssemble reads render tree from step.rootNodeIndex output slot (or derives from step.outSlot metadata)
- [ ] Render tree is written to step.outSlot (if not already there)
- [ ] Optional validation: render tree structure sanity checks (non-null, expected type)
- [ ] Error handling: missing rootNodeIndex or invalid slot reference throws clear error
- [ ] Integration test: ScheduleExecutor.executeStep() dispatches to executeRenderAssemble correctly
- [ ] Unit tests: 8-10 tests covering slot read, slot write, validation, error cases
- [ ] All existing 1795 tests still pass

#### Technical Notes

**Implementation Location:** `src/editor/runtime/executor/steps/executeRenderAssemble.ts`

**Algorithm:**
1. Locate render node output slot:
   - Option A: Read from runtime.values.read(nodeOutputSlot[step.rootNodeIndex])
   - Option B: step.outSlot already contains render tree (spec suggests this)
2. Optional: Validate render tree (sanity checks, non-null)
3. Write to step.outSlot (if not already written)
4. Return (no output, step is side-effect only)

**Complexity:** Trivial (10-20 lines) - mostly slot copying and validation.

**Test Strategy:**
- Mock ValueStore with pre-populated render tree value
- Call executeRenderAssemble with StepRenderAssemble fixture
- Assert step.outSlot contains expected value
- Error cases: missing slot, invalid rootNodeIndex

**Risks:**
- Render tree type ambiguity (RenderTree? RenderCmds? JSON?)
  - Mitigation: Check ScheduleExecutor.extractRenderOutput() stub for expected type
  - Fallback: Use `unknown` type initially, refine in Phase 7

---

### Deliverable 2: Hot-swap State Preservation (P0)

**Priority:** P0 (Critical - Non-negotiable UX requirement per spec)
**Status:** Not Started
**Effort:** Medium (3-5 days)
**Dependencies:**
- StateLayout IR must include stable keys (verify existence)
- RuntimeState must have state buffer infrastructure (✓ exists from Sprint 1)
**Spec Reference:**
- design-docs/12-Compiler-Final/17-Scheduler-Full.md §9 (lines 440-483)
- design-docs/12-Compiler-Final/02-IR-Schema.md §22 (lines 330-344)
**Status Reference:** STATUS-2025-12-26-102151.md §3 (Hot-swap State Preservation)

#### Description

Implement jank-free program hot-swap with state preservation across recompilation. This is a **core live editing UX requirement** per spec - program swaps must preserve state and time continuity to avoid visual jank during live edits.

**State Preservation Contract (§9.2):**
- Compute StateLayoutPacked.hash for old and new programs
- Preserve state slots where (stableKey, layoutHash) match
- Initialize new slots with defaults from const pool
- Drop removed slots

**StableKey Definition:**
- Block instance identity (blockId or stable lowered id)
- Output port identity
- Stateful node role (integrate accumulator, delay ring buffer, etc.)
- Optional user-visible name

**Cache Policy (§9.3):**
- Per-frame caches (FrameCache) discarded on swap (cheap to rebuild)
- Cross-frame memo cache preserved ONLY if programId matches

**Time Continuity (§22.1):**
- Runtime keeps tAbsMs across swap
- New program derives time via same timeModel kind

#### Acceptance Criteria

**StateSwap Module:**
- [ ] Create `src/editor/runtime/executor/StateSwap.ts` with `preserveState(oldRuntime, newRuntime, oldProgram, newProgram)` function
- [ ] Build stable key map from old StateLayout: Map<stableKey, {stateId, layoutHash, cellOffset, cellSize}>
- [ ] Build stable key map from new StateLayout with same structure
- [ ] For each matching (stableKey, layoutHash): copy state cells from old buffer to new buffer
- [ ] For unmatched new keys: initialize cells with defaults from newProgram const pool
- [ ] For removed old keys: no action (cells dropped)
- [ ] Unit tests: 10-15 tests covering matching keys, new keys, removed keys, layout hash mismatches

**RuntimeState.hotSwap():**
- [ ] Add `hotSwap(newProgram): RuntimeState` method to RuntimeState
- [ ] Create newRuntime from newProgram (call createRuntimeState)
- [ ] Call StateSwap.preserveState(this, newRuntime, oldProgram, newProgram)
- [ ] Invalidate FrameCache (call newRuntime.frameCache.invalidate())
- [ ] Preserve tAbsMs (copy from old runtime to new, if tracked)
- [ ] Preserve frameId (copy from old runtime to new)
- [ ] Return newRuntime
- [ ] Unit tests: 8-12 tests covering time continuity, cache invalidation, state preservation

**ScheduleExecutor.swapProgram():**
- [ ] Add `swapProgram(newProgram): void` method to ScheduleExecutor
- [ ] Call this.runtime.hotSwap(newProgram) (or similar API)
- [ ] Update internal this.program reference to newProgram
- [ ] Integration test: swap program mid-execution, verify state preserved across executeFrame calls
- [ ] Unit tests: 3-5 tests covering program reference update, state continuity

**StableKey Verification:**
- [ ] Verify StateLayout IR includes stable key fields (search for stableKey/blockId in IR types)
- [ ] If missing: Add stable key generation to state layout compiler pass (estimated 60-80 lines)
- [ ] If present: Document location and wire into StateSwap.preserveState()

**Overall Integration:**
- [ ] End-to-end test: compile program, execute frame, swap program, execute frame, verify state continuity
- [ ] 50+ total new tests across all hot-swap modules

#### Technical Notes

**Implementation Files:**

1. **StateSwap.ts (NEW)** - ~120-150 lines
   - `preserveState()` main algorithm
   - `buildStableKeyMap()` helper (extract from StateLayout)
   - `copyStateCells()` helper (typed array copy)
   - `initializeStateCell()` helper (default from const pool)

2. **RuntimeState.ts (UPDATE)** - ~30-50 lines added
   - Add `hotSwap(newProgram)` method
   - May need to track oldProgram reference for StateSwap call
   - May need to track tAbsMs if not already tracked

3. **ScheduleExecutor.ts (UPDATE)** - ~10-20 lines added
   - Add `swapProgram(newProgram)` method
   - Update program reference
   - Wire runtime.hotSwap()

**Algorithm (StateSwap.preserveState):**

```typescript
function preserveState(oldRuntime, newRuntime, oldProgram, newProgram) {
  // 1. Build stable key maps
  const oldKeyMap = buildStableKeyMap(oldProgram.stateLayout);
  const newKeyMap = buildStableKeyMap(newProgram.stateLayout);

  // 2. Preserve matching cells
  for (const [stableKey, newCell] of newKeyMap.entries()) {
    const oldCell = oldKeyMap.get(stableKey);

    if (oldCell && oldCell.layoutHash === newCell.layoutHash) {
      // Matching cell - copy from old to new
      copyStateCells(oldRuntime.state, newRuntime.state, oldCell, newCell);
    } else {
      // New cell or layout changed - initialize with defaults
      initializeStateCell(newRuntime.state, newCell, newProgram.constants);
    }
  }

  // 3. Removed cells (in oldKeyMap but not newKeyMap) are implicitly dropped
}
```

**StableKey Structure (from spec §9.2):**
```typescript
interface StableKey {
  blockId: string;           // Block instance identity
  portId: string;            // Output port identity
  statefulRole: string;      // "integrate", "delay", etc.
  userName?: string;         // Optional user-visible name
}
```

**Test Strategy:**

1. **State Preservation Tests:**
   - Create oldProgram with integrate node (state cell)
   - Execute frame, update integrate accumulator
   - Create newProgram with SAME integrate node (matching stableKey)
   - hotSwap(newProgram)
   - Execute frame, verify accumulator preserved

2. **State Initialization Tests:**
   - Create oldProgram with integrate node
   - Create newProgram with integrate + NEW delay node
   - hotSwap(newProgram)
   - Verify integrate preserved, delay initialized with defaults

3. **State Dropping Tests:**
   - Create oldProgram with integrate + delay nodes
   - Create newProgram with ONLY integrate (delay removed)
   - hotSwap(newProgram)
   - Verify integrate preserved, delay dropped (no error)

4. **Time Continuity Tests:**
   - Execute frame at tAbsMs = 1000
   - hotSwap(newProgram)
   - Execute frame, verify tAbsMs still 1000 (not reset to 0)

5. **Cache Invalidation Tests:**
   - Execute frame, populate FrameCache
   - hotSwap(newProgram)
   - Verify FrameCache.sigStamp all zeros (invalidated)

**Risks:**

1. **StableKey Location Uncertainty** (MEDIUM)
   - Need to verify StateLayout includes stable keys
   - If missing: add stable key generation (adds 2-4 hours)
   - Mitigation: Search IR types first, check compiler passes

2. **StateLayoutPacked.hash Not Implemented** (LOW)
   - Spec mentions layoutHash for state cells
   - May need to implement hash function (simple hash of type + size)
   - Mitigation: Use simple string hash or JSON.stringify hash

3. **Test Fixture Complexity** (MEDIUM)
   - Hot-swap tests require two compiled programs
   - Need minimal programs with known state differences
   - Mitigation: Use existing compiler test fixtures, modify slightly

---

### Deliverable 3 (CONDITIONAL): executeNodeEval Implementation

**Priority:** P1 (High - IF verified as necessary)
**Status:** Not Started (VERIFICATION REQUIRED FIRST)
**Effort:** Medium (3-5 days) IF implemented
**Dependencies:**
- SigEvaluator (✓ exists)
- FieldMaterializer (✓ exists)
- Verification: Compiler emits StepNodeEval steps
**Spec Reference:**
- design-docs/12-Compiler-Final/10-Schedule-Semantics.md §12.2 Step 2 (lines 174-207)
**Status Reference:** STATUS-2025-12-26-102151.md §1 (executeNodeEval Implementation)

#### Description

**CRITICAL: DO NOT IMPLEMENT UNTIL VERIFICATION COMPLETE.**

StepNodeEval is defined in the IR spec, but grep search shows NO compiler passes emit `kind: "nodeEval"` steps. Modern IR likely uses higher-level steps (BusEval, Materialize) instead of per-node evaluation.

**Verification Steps (REQUIRED BEFORE IMPLEMENTATION):**
1. Search compiled IR test fixtures for `kind: "nodeEval"` in schedule.steps
2. Check compiler passes (pass8-link-resolution, etc.) for NodeEval step emission
3. Review design docs for NodeEval deprecation notes

**Decision Tree:**
- IF compiler emits NodeEval steps → Implement as Deliverable 3 (see below)
- IF compiler does NOT emit NodeEval steps → Mark executeNodeEval.ts as DEPRECATED, document in comments, skip implementation

**IF IMPLEMENTATION REQUIRED:**

Implement opcode dispatch for individual node evaluation. NodeEval steps evaluate a single block/node by reading inputs, executing opcode, and writing outputs.

#### Acceptance Criteria (IF IMPLEMENTED)

- [ ] Verification COMPLETE: Confirmed compiler emits StepNodeEval steps (provide evidence)
- [ ] executeNodeEval dispatches to SigEvaluator.evalSig() for signal nodes
- [ ] executeNodeEval dispatches to FieldMaterializer for field nodes (if applicable)
- [ ] inputSlots mapped to evaluator inputs (read from ValueStore)
- [ ] Evaluator outputs mapped to outputSlots (write to ValueStore)
- [ ] stateReads/stateWrites wired to StateBuffer (if step includes state references)
- [ ] Error handling: unknown node kind, missing input slots
- [ ] Unit tests: 25-30 tests covering all opcode dispatch paths, state reads/writes, error cases
- [ ] All existing 1795 tests still pass

#### Technical Notes (IF IMPLEMENTED)

**Implementation Location:** `src/editor/runtime/executor/steps/executeNodeEval.ts`

**Algorithm:**
1. Read node metadata from program.nodes[step.nodeIndex]
2. Read input values from ValueStore (step.inputSlots)
3. Dispatch based on node kind:
   - Signal nodes: call SigEvaluator.evalSig(nodeId, env, program.signalExprs)
   - Field nodes: call FieldMaterializer (not clear if needed)
4. Wire stateReads/stateWrites to StateBuffer
5. Write outputs to ValueStore (step.outputSlots)

**Complexity:** Medium (80-120 lines) - opcode dispatch + state wiring.

**Test Strategy:**
- Create StepNodeEval fixture with known node kind
- Mock SigEvaluator to return known value
- Call executeNodeEval
- Assert outputSlots written with expected value

**Risks:**
- High risk of implementing unused code path (tech debt)
- VERIFICATION REQUIRED to mitigate this risk

---

## Dependency Graph

```
Deliverable 1: executeRenderAssemble
  ↓ (no dependencies)

Deliverable 2: Hot-swap State Preservation
  ↓ requires StableKey verification (parallel research task)
  ├─ StateSwap.ts (NEW)
  ├─ RuntimeState.hotSwap() (UPDATE)
  └─ ScheduleExecutor.swapProgram() (UPDATE)

Deliverable 3: executeNodeEval (CONDITIONAL)
  ↓ requires VERIFICATION FIRST
  └─ IF verified → implement dispatch to SigEvaluator
```

**Parallel Work:**
- Deliverable 1 (executeRenderAssemble) can be implemented in parallel with hot-swap research
- StableKey verification can be done in parallel with executeRenderAssemble implementation

---

## Recommended Sprint Planning

### Sprint 3 Iteration 1 (Days 1-2)

**Goals:**
- Complete Deliverable 1 (executeRenderAssemble)
- Verify NodeEval necessity
- Research StableKey location

**Tasks:**
1. Implement executeRenderAssemble (2-3 hours)
2. Write executeRenderAssemble tests (1-2 hours)
3. Verify NodeEval: search compiler output for `kind: "nodeEval"` (1 hour)
4. Verify StableKey: search StateLayout IR for stable key fields (1 hour)

**Outcomes:**
- executeRenderAssemble COMPLETE (8-10 tests)
- NodeEval decision: IMPLEMENT or DEPRECATE
- StableKey decision: EXISTS or ADD GENERATION

### Sprint 3 Iteration 2 (Days 3-5)

**Goals:**
- Complete Deliverable 2 (Hot-swap State Preservation)

**Tasks:**
1. Implement StateSwap.ts (4-6 hours)
   - preserveState() main algorithm
   - buildStableKeyMap() helper
   - copyStateCells() helper
2. Update RuntimeState.hotSwap() (2-3 hours)
3. Update ScheduleExecutor.swapProgram() (1-2 hours)
4. Write hot-swap tests (3-4 hours)
   - StateSwap unit tests (10-15 tests)
   - RuntimeState.hotSwap tests (8-12 tests)
   - ScheduleExecutor integration tests (3-5 tests)

**Outcomes:**
- Hot-swap COMPLETE (18-27 tests)
- State preservation verified in integration tests
- 50+ total new tests

### Sprint 3 Iteration 3 (CONDITIONAL - Days 6-8)

**Goals (IF NodeEval verified):**
- Complete Deliverable 3 (executeNodeEval)

**Tasks:**
1. Implement executeNodeEval opcode dispatch (3-4 hours)
2. Wire SigEvaluator integration (2-3 hours)
3. Wire state reads/writes (1-2 hours)
4. Write executeNodeEval tests (2-3 hours, 25-30 tests)

**Outcomes:**
- executeNodeEval COMPLETE (25-30 tests)
- 75+ total new tests for Sprint 3

**IF NodeEval NOT verified:**
- Mark executeNodeEval.ts as DEPRECATED
- Document in code comments: "StepNodeEval not emitted by current compiler"
- Sprint 3 COMPLETE with 2 deliverables (50+ tests)

---

## Risk Assessment

### High-Risk Items

1. **NodeEval Verification Uncertainty** (HIGH)
   - Risk: Implement 100+ lines + 30 tests for unused code path
   - Impact: Tech debt, maintenance burden, confusion
   - Mitigation: VERIFY compiler output BEFORE any implementation work
   - Timeline: 1 hour research (iteration 1)

2. **StableKey Missing from StateLayout** (MEDIUM)
   - Risk: Need to add stable key generation to compiler
   - Impact: +2-4 hours, additional complexity
   - Mitigation: Verify existence first, add generation if needed
   - Timeline: 1 hour verification, 2-4 hours implementation if needed

### Medium-Risk Items

3. **Hot-swap Test Fixture Complexity** (MEDIUM)
   - Risk: Creating two compiled programs for testing is time-consuming
   - Impact: +2-3 hours for test setup
   - Mitigation: Use minimal test programs, reuse existing compiler fixtures
   - Timeline: Absorbed into test writing time (iteration 2)

4. **StateLayoutPacked.hash Not Implemented** (LOW-MEDIUM)
   - Risk: Need to implement hash function for layout matching
   - Impact: +1-2 hours
   - Mitigation: Use simple hash (JSON.stringify or string hash)
   - Timeline: Absorbed into StateSwap implementation (iteration 2)

### Low-Risk Items

5. **RenderAssemble Output Type Ambiguity** (LOW)
   - Risk: Not clear what type render tree is
   - Impact: +30 min research
   - Mitigation: Check ScheduleExecutor.extractRenderOutput() stub
   - Timeline: Iteration 1

---

## Success Metrics

### Test Coverage
- **Target:** 50+ new tests (minimum)
- **Breakdown:**
  - executeRenderAssemble: 8-10 tests
  - StateSwap: 10-15 tests
  - RuntimeState.hotSwap: 8-12 tests
  - ScheduleExecutor.swapProgram: 3-5 tests
  - executeNodeEval (IF verified): 25-30 tests
- **Stretch:** 75+ tests (if NodeEval implemented)

### Code Quality
- All existing 1795 tests pass
- Zero new TypeScript errors
- Follows existing code style (see executeBusEval.ts for reference)
- Comprehensive error handling (clear error messages)

### Functional Completeness
- executeRenderAssemble acts as stable finalization boundary
- Hot-swap preserves state across program recompilation
- Time continuity maintained (tAbsMs not reset)
- Cache invalidation works correctly (FrameCache cleared)

### Documentation
- All new functions have JSDoc comments
- Hot-swap algorithm documented in StateSwap.ts
- StableKey structure documented (from spec §9.2)
- README/HANDOFF updates (if needed for hot-swap API)

---

## Next Steps (Post-Sprint 3)

After Sprint 3 completion:

1. **Legacy Runtime Removal** (if not already done)
   - Remove old closure-based runtime
   - Update all references to use ScheduleExecutor

2. **Performance Validation**
   - Benchmark new runtime vs legacy
   - Verify hot-swap performance (should be <16ms for 60fps)

3. **Phase 7 Preparation**
   - executeDebugProbe implementation
   - Trace event emission in executeRenderAssemble

4. **Documentation Updates**
   - Update HANDOFF.md with hot-swap API
   - Update CLAUDE.md memory files with hot-swap semantics
   - Update design docs if any spec deviations occurred

---

## Conclusion

Sprint 3 delivers **execution completeness and jank-free live editing**. The two P0 deliverables (executeRenderAssemble + hot-swap) are non-negotiable per spec. NodeEval is contingent on verification (VERIFY FIRST, then decide).

**Critical Path:**
1. Iteration 1: executeRenderAssemble + verification (2 days)
2. Iteration 2: Hot-swap infrastructure (3 days)
3. Iteration 3 (optional): executeNodeEval if verified (3 days)

**Total Estimated Effort:** 5-8 days (2 deliverables) or 8-11 days (3 deliverables if NodeEval verified)

**Sprint 3 is READY TO BEGIN.**
