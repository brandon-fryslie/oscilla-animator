# Definition of Done: Phase 6 Sprint 2 - FrameCache + Step Executors

**Generated:** 2025-12-26-092613
**Planner:** status-planner
**Plan:** PLAN-2025-12-26-092613.md
**Sprint:** Phase 6 Sprint 2

---

## Sprint Scope

This sprint delivers **3 deliverables**:
1. FrameCache implementation (P0)
2. executeBusEval integration (P0)
3. executeMaterialize integration (P1)

**Deferred to Sprint 3:**
- executeNodeEval (verify usage first)
- executeRenderAssemble
- Hot-swap semantics

---

## Acceptance Criteria

### Deliverable 1: FrameCache Implementation

#### FrameCache Interface

- [ ] FrameCache interface expanded in `RuntimeState.ts` with cache storage fields:
  - [ ] `sigValue: Float64Array` - Cached signal values
  - [ ] `sigStamp: Uint32Array` - Frame stamps for signal cache validation
  - [ ] `fieldHandle: FieldHandle[]` - Cached field handles (lazy recipes)
  - [ ] `fieldStamp: Uint32Array` - Frame stamps for field cache validation
  - [ ] `fieldBuffers: Map<string, ArrayBufferView>` - Materialized buffer pool
  - [ ] `frameId: number` - Current frame ID (already exists)

#### Factory Function

- [ ] `createFrameCache(sigCapacity: number, fieldCapacity: number)` implemented
  - [ ] Allocates `Float64Array(sigCapacity)` for signal values
  - [ ] Allocates `Uint32Array(sigCapacity)` for signal stamps
  - [ ] Allocates `FieldHandle[fieldCapacity]` for field handles
  - [ ] Allocates `Uint32Array(fieldCapacity)` for field stamps
  - [ ] Initializes empty `Map<string, ArrayBufferView>` for buffer pool
  - [ ] Initializes `frameId = 0`

#### Cache Methods

- [ ] `newFrame()` method implemented correctly:
  - [ ] Increments `frameId` by 1
  - [ ] Does NOT zero value arrays (stamp check invalidates stale entries)
  - [ ] Clears `fieldBuffers` Map (new frame = new materializations)
  - [ ] Does NOT clear sigValue/sigStamp arrays (stamps auto-invalidate)

- [ ] `invalidate()` method implemented correctly:
  - [ ] Zeros all stamp arrays (`sigStamp.fill(0)`, `fieldStamp.fill(0)`)
  - [ ] Clears `fieldBuffers` Map
  - [ ] Does NOT reset `frameId` (monotonic counter)

#### RuntimeState Integration

- [ ] `createRuntimeState()` updated to use real FrameCache:
  - [ ] Calls `createFrameCache(sigCapacity, fieldCapacity)`
  - [ ] Capacities derived from program SignalExprTable/FieldExprTable counts
  - [ ] FrameCache passed to step executors via RuntimeState

#### Unit Tests

- [ ] 25-30 tests in `__tests__/FrameCache.test.ts`:
  - [ ] Signal cache hit (stamp[id] === frameId → return cached value)
  - [ ] Signal cache miss (stamp[id] < frameId → recompute)
  - [ ] Field cache hit (stamp[id] === frameId → return cached handle)
  - [ ] Field cache miss (stamp[id] < frameId → recompute)
  - [ ] `newFrame()` increments frameId
  - [ ] `newFrame()` invalidates stale stamps (old frameId)
  - [ ] `newFrame()` clears buffer pool
  - [ ] `invalidate()` zeros all stamps
  - [ ] `invalidate()` clears buffer pool
  - [ ] Multiple `newFrame()` calls → monotonic frameId increment
  - [ ] Cache capacity handling (id >= capacity → throw or expand)
  - [ ] Buffer pool key collisions (same key → same buffer instance)

---

### Deliverable 2: executeBusEval Integration

#### Combine Logic

- [ ] Implement all combine modes for signal buses:

#### Transform Chains

  - [ ] Support adapter steps (scale, bias, normalize, quantize, ease)
  - [ ] Support lens steps (map, slew, cast)
  - [ ] Either call `SigEvaluator.evalTransform()` or implement inline
  - [ ] Transform chain order preserved (apply steps sequentially)

#### Silent Value Handling

  - [ ] `silent.kind === "zero"` → write 0 to outSlot
  - [ ] `silent.kind === "default"` → write type-specific default (0 for numbers)
  - [ ] `silent.kind === "const"` → read from `constPool.f64[silent.constId]`

#### ValueStore Integration

- [ ] Write combined value to `step.outSlot` using `ValueStore.write()`
- [ ] Respect single-writer invariant (write outSlot exactly once per frame)

#### Unit Tests

- [ ] 20-25 tests in `__tests__/executeBusEval.test.ts`:
  - [ ] `min` mode with various values
  - [ ] `max` mode with various values
  - [ ] Silent value handling (zero, default, const)
  - [ ] Transform chain application (scale/bias, ease, normalize)
  - [ ] Multiple transform steps in chain (composition)

---

### Deliverable 3: executeMaterialize Integration

#### Domain Count Resolution

- [ ] Read domain count from ValueStore using `step.materialization.domainSlot`:
  - [ ] Domain count is numeric value (integer N)
  - [ ] Represents number of elements in field buffer
  - [ ] If N <= 0, throw error (cannot allocate buffer)

#### MaterializationRequest Construction

- [ ] Construct `MaterializationRequest` from `StepMaterialize`:
  - [ ] `fieldId` from `step.materialization.fieldId`
  - [ ] `domainId` from `step.materialization.domainId`
  - [ ] `format` from `step.materialization.format` (f32, f64, vec2f32, etc.)
  - [ ] `layout` from `step.materialization.layout` (AoS/SoA, or default)
  - [ ] `usageTag` from `step.materialization.usageTag` (e.g. "pos", "radius", "color")

#### FieldMaterializer Integration

- [ ] Construct `FieldEnv` with:
  - [ ] Signal environment (time, const pool, cache from FrameCache)
  - [ ] Field cache from `FrameCache.fieldHandle` and `FrameCache.fieldStamp`
  - [ ] Buffer pool from `FrameCache.fieldBuffers`
  - [ ] Access to SigEvaluator for broadcast nodes (signal→field)
- [ ] Call `FieldMaterializer.materialize(request, env)` to get typed array
- [ ] Write buffer handle to `step.materialization.outBufferSlot` in ValueStore:
  - [ ] Buffer handle shape: `{ kind: "buffer", data: TypedArray, format: BufferFormat }`
  - [ ] ValueStore supports object storage (slot has `storage: "object"`)

#### Buffer Pool Caching

- [ ] Per-frame buffer pool reuse:
  - [ ] Same `(fieldId, domainId, format)` within frame → return cached buffer
  - [ ] Buffer pool key: `${fieldId}_${domainId}_${format}` (or similar)
  - [ ] FieldMaterializer checks buffer pool before materializing
- [ ] Different frames → re-materialize:
  - [ ] `newFrame()` clears buffer pool
  - [ ] Next frame materializes fresh buffers

#### Unit Tests

- [ ] 15-20 tests in `__tests__/executeMaterialize.test.ts`:
  - [ ] Basic materialization: const field → buffer of N identical values
  - [ ] Broadcast field: signal value → buffer of N copies
  - [ ] Zip field: two fields combined element-wise (Add, Mul, etc.)
  - [ ] Buffer pool reuse: same field requested twice in frame → same buffer instance
  - [ ] Different frames: `newFrame()` → re-materialize (different buffer instance)
  - [ ] Domain count from slot: various N values (1, 10, 100, 1000)
  - [ ] Format handling: f32, f64, vec2f32, rgba8, etc.
  - [ ] Layout handling: AoS, SoA (if supported)
  - [ ] Zero domain count → error thrown
  - [ ] Missing domain slot → error thrown

---

## Integration Requirements

### No Regressions

- [ ] All 1724 existing tests still pass (no regressions)
- [ ] Sprint 1 tests (ValueStore, StateBuffer, RuntimeState) still pass
- [ ] SigEvaluator tests (122+) still pass
- [ ] FieldMaterializer tests (63+) still pass

### New Test Coverage

- [ ] 60+ new tests added (target breakdown):
  - [ ] FrameCache: 25-30 tests
  - [ ] executeBusEval: 20-25 tests
  - [ ] executeMaterialize: 15-20 tests
- [ ] All new tests pass
- [ ] Total test suite: 1784+ tests passing (1724 + 60)

### Code Quality

- [ ] No TODOs in production code for delivered features (test TODOs OK)
- [ ] No `any` types in new code (fully type-safe)
- [ ] No commented-out code (clean implementation)
- [ ] Follows existing code style (ESLint/Prettier compliant)
- [ ] Clear function/variable names (self-documenting)

### Type Safety

- [ ] All function signatures have explicit types
- [ ] No implicit `any` types
- [ ] No type assertions (`as`) unless absolutely necessary
- [ ] Discriminated unions handled exhaustively (switch statements)

---

## Sprint Completion Checklist

### Implementation Complete

- [ ] `src/editor/runtime/executor/RuntimeState.ts` - FrameCache implementation
- [ ] `src/editor/runtime/executor/steps/executeBusEval.ts` - Real combine logic
- [ ] `src/editor/runtime/executor/steps/executeMaterialize.ts` - FieldMaterializer integration

### Tests Complete

- [ ] `src/editor/runtime/executor/__tests__/FrameCache.test.ts` (NEW)
- [ ] `src/editor/runtime/executor/__tests__/executeBusEval.test.ts` (NEW)
- [ ] `src/editor/runtime/executor/__tests__/executeMaterialize.test.ts` (NEW)

### Verification Complete

- [ ] `just test` passes (all 1784+ tests)
- [ ] `just typecheck` passes (zero TypeScript errors)
- [ ] `just lint` passes (zero ESLint errors)
- [ ] No console warnings in test output

---

## Success Metrics

**Sprint 2 is COMPLETE when ALL of the following are true:**

### Quantitative Metrics

- [ ] 60+ new tests added (actual count: _____)
- [ ] 1784+ total tests passing (actual count: _____)
- [ ] Zero test failures
- [ ] Zero TypeScript errors
- [ ] Step executor coverage: 50% (3/6 functional: timeDerive, BusEval, Materialize)

### Qualitative Metrics

- [ ] FrameCache is canonical - used by both SigEvaluator and FieldMaterializer
- [ ] executeBusEval implements all combine modes correctly (sum, avg, min, max, last)
- [ ] executeBusEval handles silent values correctly (zero, default, const)
- [ ] executeMaterialize produces correct typed arrays (validated by tests)
- [ ] Per-frame cache invalidation works (`newFrame()` clears stamps and buffer pool)
- [ ] No production code TODOs for delivered features
- [ ] No `any` types in new code

---

## Deferred Work (Not in Sprint 2 DOD)

These items are explicitly OUT OF SCOPE for Sprint 2:

- executeNodeEval implementation (verify usage first, likely Sprint 3)
- executeRenderAssemble implementation (Sprint 3)
- executeDebugProbe implementation (Phase 7)
- Hot-swap state preservation semantics (Sprint 3)
- Cross-frame memoization (future optimization)
- Field materialization fusion optimizations (future optimization)
- Legacy runtime removal (Sprint 3/4)

---

## Sign-Off

**Sprint 2 is COMPLETE when:**
1. All acceptance criteria above are checked ✓
2. All tests pass (1784+)
3. No regressions in existing tests
4. Code review complete (if applicable)
5. STATUS file updated with completion notes

**Ready for Sprint 3:** executeRenderAssemble, hot-swap, legacy runtime removal prep.
