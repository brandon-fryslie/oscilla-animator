# Sprint 1 Plan: ValueStore + StateBuffer Foundation
Generated: 2025-12-26-085041
Planner: status-planner
Source: STATUS-2025-12-26-085041.md

## Sprint Goal

Implement **ValueStore and StateBuffer storage systems** to enable real IR-driven frame execution. Replace stub implementations with production-ready typed array allocation, slot addressing, and single-writer enforcement.

**Sprint Scope:** 2 deliverables (ValueStore, StateBuffer)
**Deferred:** FrameCache, step executor implementations, hot-swap, integration with SigEvaluator/FieldMaterializer

## Executive Summary

### Current State
- IR schemas 100% complete
- ScheduleExecutor skeleton functional (frame loop, step dispatch)
- Factory functions exist but throw "not yet implemented"
- Stub implementations in RuntimeState.ts for basic testing
- 1660+ tests passing (Phases 1-5 complete)

### Gap
- No production ValueStore: no slot allocation, no single-writer enforcement
- No production StateBuffer: no state cell allocation, no initialization
- ScheduleExecutor runs but cannot execute real programs (stubs everywhere)

### Sprint 1 Outcome
- ValueStore allocates typed arrays, enforces single-writer, addresses slots correctly
- StateBuffer allocates state cells, initializes from const pool
- ScheduleExecutor runs with real stores (even if step executors remain stubs)
- 30+ new tests validate storage correctness

## Backlog

---

### [P0] ValueStore Implementation

**Status:** Not Started
**Effort:** Medium (3-5 days)
**Dependencies:** None
**Spec Reference:** design-docs/12-Compiler-Final/02-IR-Schema.md §18.1 • STATUS-2025-12-26-085041.md §"What's Missing for Sprint 1" → "ValueStore Implementation"

#### Description

Implement `createValueStore(slotMeta)` factory function to replace the stub. Allocate typed arrays (f64, f32, i32, u32, objects) based on slot metadata, implement slot addressing to map `ValueSlot` → (storage array, offset), and enforce single-writer-per-slot-per-frame invariant.

**Why P0:** Foundation for all frame execution. Without this, ScheduleExecutor cannot store intermediate values, and no steps can execute meaningfully.

**Current Code:**
```typescript
// src/editor/compiler/ir/stores.ts:205-208
export function createValueStore(_slotMeta: SlotMeta[]): ValueStore {
  throw new Error("createValueStore: not yet implemented");
}
```

**Target Behavior:**
```typescript
const slotMeta = [
  { slot: 0, storage: "f64", offset: 0, type: { world: "signal", domain: "number" } },
  { slot: 1, storage: "f64", offset: 1, type: { world: "signal", domain: "phase01" } },
  { slot: 2, storage: "object", offset: 0, type: { world: "field", domain: "vec2" } },
];
const store = createValueStore(slotMeta);

store.write(0, 3.14);           // OK: writes to f64[0]
store.write(0, 2.71);           // ERROR: slot 0 already written this frame
store.write(2, fieldHandle);    // OK: writes to objects[0]
store.clear();                  // Reset for next frame
store.write(0, 1.5);            // OK: new frame
```

#### Acceptance Criteria

- [ ] `createValueStore(slotMeta)` allocates typed arrays with correct sizes
  - f64 array size = max(offset+1) for slots with storage="f64"
  - f32 array size = max(offset+1) for slots with storage="f32"
  - i32 array size = max(offset+1) for slots with storage="i32"
  - u32 array size = max(offset+1) for slots with storage="u32"
  - objects array size = max(offset+1) for slots with storage="object"
- [ ] `write(slot, value)` stores value at correct (array, offset) per slotMeta[slot]
  - Numeric values go to correct typed array at correct offset
  - Non-numeric values (FieldHandles, buffers, etc.) go to objects array
- [ ] `write(slot, value)` enforces single-writer: throws error if slot written twice in same frame
  - Error message includes slot index for debugging
  - Write tracking resets on `clear()`
- [ ] `read(slot)` retrieves value from correct (array, offset) per slotMeta[slot]
  - Returns correct value type (number for typed arrays, object for object array)
- [ ] `clear()` resets write tracking for new frame
  - Write tracking set emptied
  - Values in arrays NOT cleared (optimization: old values overwritten on next write)
- [ ] Unit tests (20+):
  - Allocation from various slotMeta configurations
  - Write to each storage type (f64, f32, i32, u32, object)
  - Read after write returns correct value
  - Single-writer enforcement catches duplicate writes
  - Clear resets write tracking
  - Empty slotMeta (no slots) works without error

#### Technical Notes

**Implementation Strategy:**
1. Parse `slotMeta` array to determine max offset for each storage type
2. Allocate typed arrays with size = maxOffset + 1 (or 0 if no slots of that type)
3. Store `slotMeta` as internal reference for addressing
4. Track writes in a `Set<ValueSlot>` (cleared each frame)
5. `write()`: lookup `slotMeta[slot]`, write to appropriate array, add to write tracking set
6. `read()`: lookup `slotMeta[slot]`, read from appropriate array

**Gotchas:**
- Slot indices may have gaps (e.g., slots 0, 2, 5 exist but not 1, 3, 4)
- Must handle `slotMeta.length !== max(slot)+1` (sparse slots)
- Type coercion: ensure f64/f32 distinction respected (no implicit casting)

**File:** `src/editor/compiler/ir/stores.ts` (replace lines 205-208 with ~50 lines)

---

### [P0] StateBuffer Implementation

**Status:** Not Started
**Effort:** Small (1-2 days)
**Dependencies:** None (can be done in parallel with ValueStore)
**Spec Reference:** design-docs/12-Compiler-Final/02-IR-Schema.md §18 • design-docs/12-Compiler-Final/17-Scheduler-Full.md §1.2 • STATUS-2025-12-26-085041.md §"What's Missing for Sprint 1" → "StateBuffer Implementation"

#### Description

Implement `createStateBuffer(layout)` and `initializeState(buffer, layout, constPool)` factory functions. Allocate typed arrays for persistent state (f64, f32, i32) based on `StateLayout` total sizes. Initialize state cells with default values from `StateCellLayout.initialConstId` by looking up constants in the const pool.

**Why P0:** Required for stateful operations (Delay, Integrate, Oscillator, etc.). Without this, stateful nodes cannot persist data across frames.

**Current Code:**
```typescript
// src/editor/compiler/ir/stores.ts:218-221
export function createStateBuffer(_layout: StateLayout): StateBuffer {
  throw new Error("createStateBuffer: not yet implemented");
}

// stores.ts:232-239
export function initializeState(_buffer, _layout, _constPool): void {
  throw new Error("initializeState: not yet implemented");
}
```

**Target Behavior:**
```typescript
const layout: StateLayout = {
  cells: [
    { stateId: "integrate-1", storage: "f64", offset: 0, size: 1, nodeId: "n1", role: "accumulator" },
    { stateId: "delay-1", storage: "f64", offset: 1, size: 10, nodeId: "n2", role: "ringBuffer" },
  ],
  f64Size: 11,  // offset 0 (size 1) + offset 1 (size 10) = 11 total
  f32Size: 0,
  i32Size: 0,
};

const buffer = createStateBuffer(layout);
// buffer.f64 is Float64Array(11)

const constPool = { f64: new Float64Array([0, 1, 3.14]), /* ... */ };
initializeState(buffer, layout, constPool);
// buffer.f64[0..10] initialized to default values
```

#### Acceptance Criteria

- [ ] `createStateBuffer(layout)` allocates typed arrays with sizes from layout
  - buffer.f64 is Float64Array(layout.f64Size)
  - buffer.f32 is Float32Array(layout.f32Size)
  - buffer.i32 is Int32Array(layout.i32Size)
  - Zero-length arrays if size is 0 (no state of that type)
- [ ] `initializeState(buffer, layout, constPool)` sets initial values for all state cells
  - If `cell.initialConstId` is defined: read value from constPool, write to buffer[cell.storage][cell.offset..offset+size]
  - If `cell.initialConstId` is undefined: write zeros (default)
  - Handles scalar cells (size=1) and array cells (size>1, e.g., ring buffers)
- [ ] Correct storage type routing:
  - f64 cells write to buffer.f64
  - f32 cells write to buffer.f32
  - i32 cells write to buffer.i32
- [ ] Unit tests (10+):
  - Allocation with various layout sizes (f64Size, f32Size, i32Size)
  - Allocation with zero sizes (empty state)
  - Initialization with const pool values
  - Initialization without initialConstId (defaults to zero)
  - Ring buffer initialization (size > 1)
  - Mixed storage types in single layout

#### Technical Notes

**Implementation Strategy:**
1. `createStateBuffer()`: trivial - just allocate three typed arrays with sizes from layout
2. `initializeState()`:
   - Iterate `layout.cells`
   - For each cell: lookup `constPool[cell.storage][cell.initialConstId]` (if defined)
   - Write to `buffer[cell.storage][cell.offset]` (or fill range if size > 1)
   - Default to zero if no initialConstId

**Gotchas:**
- Const pool indexing: `constPool.f64[constId]` not `constPool.f64.get(constId)`
- Ring buffer initialization: fill all `size` elements, not just offset
- Type mismatch: ensure cell.storage matches constPool storage type

**File:** `src/editor/compiler/ir/stores.ts` (replace lines 218-221 and 232-239 with ~80 lines total)

---

### [P1] RuntimeState Integration

**Status:** Not Started
**Effort:** Small (1-2 days)
**Dependencies:** ValueStore implementation, StateBuffer implementation
**Spec Reference:** STATUS-2025-12-26-085041.md §"What's Missing for Sprint 1" → "Basic Schedule Execution Integration"

#### Description

Wire `createValueStore()` and `createStateBuffer()` into `createRuntimeState()` to replace stub implementations. Extract `slotMeta` and `stateLayout` from `CompiledProgramIR` (once compiler emits them) or use placeholders for initial testing.

**Why P1:** Integration point - enables ScheduleExecutor to use real stores instead of stubs.

**Current Code:**
```typescript
// src/editor/runtime/executor/RuntimeState.ts:91-152
export function createRuntimeState(_program): RuntimeState {
  // Stub implementation - creates fixed-size arrays
  const stubValueStore = { /* ... */ };
  const stubStateBuffer = { /* ... */ };
  return { values: stubValueStore, state: stubStateBuffer, /* ... */ };
}
```

**Target Behavior:**
```typescript
export function createRuntimeState(program: CompiledProgramIR): RuntimeState {
  // Extract metadata from program (once compiler emits it)
  const slotMeta = extractSlotMeta(program);
  const stateLayout = program.stateLayout;

  // Create real stores
  const values = createValueStore(slotMeta);
  const state = createStateBuffer(stateLayout);
  initializeState(state, stateLayout, program.constants);

  return { values, state, frameCache: createFrameCache(), frameId: 0 };
}
```

#### Acceptance Criteria

- [ ] `createRuntimeState(program)` calls `createValueStore()` with extracted slotMeta
  - If compiler doesn't emit slotMeta yet: use placeholder extraction (empty array or minimal test data)
- [ ] `createRuntimeState(program)` calls `createStateBuffer(program.stateLayout)`
  - StateLayout already exists in CompiledProgramIR schema
- [ ] `createRuntimeState(program)` calls `initializeState(state, stateLayout, program.constants)`
- [ ] Existing ScheduleExecutor tests pass with real stores (no behavioral change, just swapping implementation)
- [ ] Unit tests (5+):
  - RuntimeState creation with minimal program (empty stateLayout, empty slotMeta)
  - RuntimeState creation with non-trivial program (multiple state cells, multiple slots)
  - State initialization from program const pool

#### Technical Notes

**SlotMeta Extraction Challenge:**
- Compiler may not emit `slotMeta` array yet (Phase 3 compiler focused on IR tables, not runtime metadata)
- **Short-term solution:** Manually construct slotMeta from program.schedule.steps (extract all inputSlots/outputSlots, dedupe, assign storage types)
- **Long-term solution:** Add compiler pass to emit slotMeta in CompiledProgramIR

**FrameCache Placeholder:**
- FrameCache implementation is Sprint 2
- For Sprint 1: keep stub `createFrameCache()` that returns minimal `{ frameId: 0, newFrame() {}, invalidate() {} }`

**File:** `src/editor/runtime/executor/RuntimeState.ts` (replace lines 91-152 with ~50 lines)

---

## Dependency Graph

```
ValueStore Implementation [P0]
  └─> RuntimeState Integration [P1]

StateBuffer Implementation [P0]
  └─> RuntimeState Integration [P1]
```

**Parallelizable:** P0 items can be done in parallel (ValueStore and StateBuffer independent)

**Sequential:** P1 (RuntimeState Integration) requires both P0 items complete

---

## Recommended Sprint Planning

### Sprint 1 (This Sprint)

**Deliverables:**
1. ValueStore implementation (P0)
2. StateBuffer implementation (P0)
3. RuntimeState integration (P1)

**Total Effort:** 5-9 days (Medium sprint)

**Success Metrics:**
- 3 new implementation files modified (~200-300 lines total)
- 3 new test files added (~400-500 lines total)
- 30+ new tests passing
- ScheduleExecutor runs with real stores (existing 4 tests still pass, potentially more robust)
- No regressions in existing 1660+ tests

**Deferred to Sprint 2:**
- FrameCache system
- NodeEval/BusEval integration with SigEvaluator
- Materialize step integration with FieldMaterializer
- RenderAssemble step implementation
- Full step executor implementations

### Sprint 2 (Future)

**Planned Topics:**
- FrameCache implementation (signal value cache, field handle cache, buffer pool cache)
- NodeEval step executor with SigEvaluator integration
- BusEval step executor with combine logic
- Materialize step executor with FieldMaterializer integration

### Sprint 3 (Future)

**Planned Topics:**
- RenderAssemble step executor
- Hot-swap semantics (state preservation, cache invalidation)
- Legacy runtime comparison (run both, validate equivalence)

### Sprint 4 (Future)

**Planned Topics:**
- Determinism enforcement (stable topo sort, tie-breaking)
- Legacy runtime removal
- Performance benchmarking

---

## Risk Assessment

### Low Risk
- **ValueStore/StateBuffer implementation:** Straightforward typed array allocation, well-specified in design docs
- **Testing:** Clear contracts, easy to test in isolation

### Medium Risk
- **SlotMeta extraction:** Compiler may not emit this yet
  - **Mitigation:** Use placeholder extraction or manual construction for Sprint 1, add compiler pass in Sprint 2
- **StateLayout completeness:** Compiler may not populate all fields correctly
  - **Mitigation:** Start with empty/minimal state layouts, validate incrementally

### No High Risks
All work is foundational infrastructure with clear specs and no unknowns.

---

## Testing Strategy

### Unit Tests (ValueStore - 20+ tests)
- `ValueStore.test.ts` (NEW)
  - Allocation from slotMeta (various configurations)
  - Write to each storage type
  - Read after write
  - Single-writer enforcement (duplicate write throws)
  - Clear resets write tracking
  - Empty slotMeta edge case
  - Sparse slot indices (gaps)

### Unit Tests (StateBuffer - 10+ tests)
- `StateBuffer.test.ts` (NEW)
  - Allocation from layout (various sizes)
  - Allocation with zero sizes
  - Initialization with const pool
  - Initialization without initialConstId (zeros)
  - Ring buffer initialization (size > 1)
  - Mixed storage types

### Integration Tests (RuntimeState - 5+ tests)
- `RuntimeState.test.ts` (NEW)
  - Create from minimal program
  - Create from program with state cells
  - State initialization from const pool
  - Integration with existing ScheduleExecutor tests

### Regression Tests
- All existing 1660+ tests must still pass
- Existing ScheduleExecutor tests (4 tests) must pass with real stores

---

## Completion Criteria

**Sprint 1 is complete when:**
1. All P0 and P1 items have acceptance criteria checked off
2. 30+ new tests added and passing
3. Existing 1660+ tests still pass
4. ScheduleExecutor runs with real ValueStore and StateBuffer (verified by tests)
5. Code review completed (if applicable)
6. Documentation updated (inline comments sufficient for Sprint 1)

**NOT required for Sprint 1:**
- Full step executor implementations (stubs OK)
- FrameCache implementation
- Hot-swap semantics
- Integration with SigEvaluator/FieldMaterializer beyond existing Phase 4-5 work

---

## Next Steps

1. Implement ValueStore (`createValueStore` in stores.ts)
2. Add ValueStore unit tests
3. Implement StateBuffer (`createStateBuffer`, `initializeState` in stores.ts)
4. Add StateBuffer unit tests
5. Wire into RuntimeState (`createRuntimeState` in RuntimeState.ts)
6. Add RuntimeState integration tests
7. Verify ScheduleExecutor tests still pass
8. Run full test suite (just test)

**Estimated Total Effort:** 5-9 days for experienced developer

**Ready to Begin:** No blockers, clear path forward.
