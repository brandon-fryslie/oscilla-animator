# Status Report: Phase 6 Sprint 2 - FrameCache + Step Executors
Generated: 2025-12-26-092613
Evaluator: status-planner
Source: Sprint 1 Completion (COMPLETION-2025-12-26-091200.md)

## Executive Summary

**Sprint Status:** Ready to begin Sprint 2
**Overall Completeness:** ~40% (ValueStore/StateBuffer complete, evaluators ready, step executors stubbed)
**Readiness:** GREEN - Sprint 1 complete, SigEvaluator/FieldMaterializer operational

Sprint 1 delivered **foundation infrastructure** (ValueStore + StateBuffer) with 64 tests (183% of target). All 1724 tests passing. Sprint 2 focuses on **integration** - wiring existing evaluators into step executors and implementing FrameCache for per-frame memoization.

## Current State Analysis

### What Exists and Works

#### 1. Foundation Infrastructure (Sprint 1 - COMPLETE)

**ValueStore Implementation** (31 tests)
- Location: `src/editor/compiler/ir/stores.ts`
- Typed array allocation (f64, f32, i32, u32, objects)
- Single-writer-per-slot-per-frame enforcement
- write(), read(), clear() methods
- Real integration in `RuntimeState.createRuntimeState()`

**StateBuffer Implementation** (16 tests)
- Location: `src/editor/compiler/ir/stores.ts`
- Typed array allocation based on StateLayout
- initializeState() from const pool
- Support for scalar cells and ring buffers

**RuntimeState Integration** (17 tests)
- Location: `src/editor/runtime/executor/RuntimeState.ts`
- Real stores (not stubs) wired into createRuntimeState()
- extractSlotMeta() helper for slot metadata extraction
- Backward compatibility for test fixtures

#### 2. Existing Evaluators (Phases 4-5 - COMPLETE)

**SigEvaluator** - READY FOR INTEGRATION
- Location: `src/editor/runtime/signal-expr/SigEvaluator.ts` (1200+ lines)
- Tests: 122+ passing tests
- Features:
  - Per-frame cache (sigValue, sigStamp)
  - All 12 node kinds: const, timeAbsMs, timeModelMs, phase01, wrapEvent, map, zip, select, inputSlot, busCombine, transform, stateful, closureBridge
  - Combine modes: sum, average, min, max, last
  - Transform chains: scaleBias, normalize, quantize, ease, map, slew, cast
  - Stateful ops: integrate, delayMs, delayFrames, sampleHold, slew, edgeDetectWrap, pulseDivider, envelopeAD
  - Debug sink integration

**FieldMaterializer** - READY FOR INTEGRATION
- Location: `src/editor/runtime/field/Materializer.ts`
- Tests: 63+ passing tests
- Features:
  - FieldHandle lazy evaluation system
  - Central materialization (fusion-capable)
  - BufferPool for typed array reuse
  - Broadcast (signal→field) and Reduce (field→signal)
  - Field combine modes
  - SignalBridge integration (uses SigEvaluator for broadcast)

#### 3. Step Executor Infrastructure (Skeleton)

**Location:** `src/editor/runtime/executor/steps/`

**Implemented:**
- `executeTimeDerive.ts` - FUNCTIONAL (writes time values to slots)
  - Resolves TimeModel (finite/cyclic/infinite)
  - Writes tAbsMs, tModelMs, phase01, wrapEvent, progress01 to slots

**Stubbed (Sprint 2 targets):**
- `executeNodeEval.ts` - Returns zeros (needs SigEvaluator integration)
- `executeBusEval.ts` - Writes silent value only (needs combine logic)
- `executeMaterialize.ts` - Returns empty buffer (needs FieldMaterializer integration)
- `executeRenderAssemble.ts` - No-op (deferred to Sprint 3)
- `executeDebugProbe.ts` - No-op (deferred to Phase 7)

#### 4. FrameCache Interface (Defined, Not Implemented)

**Location:** `src/editor/runtime/executor/RuntimeState.ts` lines 55-83

**What Exists:**
```typescript
export interface FrameCache {
  frameId: number;
  newFrame(): void;
  invalidate(): void;
}
```

**Current Implementation:**
- Stub only (newFrame increments frameId, invalidate is no-op)
- No actual cache storage

**Spec Reference:**
- design-docs/12-Compiler-Final/17-Scheduler-Full.md §1.2 (FrameCache structure)
- design-docs/12-Compiler-Final/09-Caching.md (cache policy)

### What's Missing for Sprint 2

#### 1. FrameCache System (P0)

**Required:**
- Extend FrameCache interface with cache storage arrays
- Signal value cache: Float64Array + Uint32Array stamps
- Field handle cache: FieldHandle[] + Uint32Array stamps
- Field buffer pool: Map<string, ArrayBufferView>
- Invalidation logic (newFrame resets stamps, not arrays)

**Spec Reference:**
- design-docs/12-Compiler-Final/17-Scheduler-Full.md §1.2
  - Lines 64-98: FrameCache interface with sigValue, sigStamp, fieldHandle, fieldStamp, fieldBuffers
  - Lines 170-223: Signal evaluation with per-frame cache
  - Lines 254-290: Field handle evaluation with per-frame cache

**Integration Points:**
- SigEvaluator expects env.cache.frameId, env.cache.value[], env.cache.stamp[]
- FieldMaterializer expects per-frame buffer pool

**Current Gap:**
- FrameCache stub in RuntimeState.ts has no storage arrays
- SigEvaluator/FieldMaterializer use their own cache structures
- Need to unify under single FrameCache in RuntimeState

#### 2. executeBusEval Integration (P0)

**Current State:**
- No transform chain application
- No real combine logic

**Required:**
- Implement all combine modes:
  - Signal buses: sum, average, min, max, last
  - Field buses: combine field handles (not materialized arrays)
- Write combined result to outSlot

**Spec Reference:**
- design-docs/12-Compiler-Final/17-Scheduler-Full.md §7 (Bus values at runtime)
  - Lines 383-407: Buses compiled to node IDs, combine nodes in IR
- StepBusEval IR schema in `src/editor/compiler/ir/schedule.ts`

**Integration Points:**
- SigEvaluator has evalBusCombine() function (already implemented)
- Need to bridge StepBusEval → SigEvaluator.evalBusCombine()
- Transform chains already implemented in SigEvaluator.evalTransform()

**Challenge:**
- May need adapter layer or direct combine logic in executeBusEval

#### 3. executeMaterialize Integration (P1)

**Current State:**
- Stub returns empty Float32Array
- No field evaluation
- No buffer pooling

**Required:**
- Evaluate field handle from field ID (or read from cache)
- Call FieldMaterializer.materialize() with MaterializationRequest
- Write buffer handle to outBufferSlot
- Respect cache policy (per-frame reuse)

**Spec Reference:**
- design-docs/12-Compiler-Final/17-Scheduler-Full.md §5.3
  - Lines 295-347: Materialization algorithm with fusion and buffer pool

**Integration Points:**
- FieldMaterializer.materialize(req, env) already exists
- Need to construct MaterializationRequest from StepMaterialize
- Need to wire FieldMaterializer into RuntimeState or step executor context

**Deferred Decisions:**
- Domain count resolution (how to get N from domainSlot?)
- Format/layout handling (are these in StepMaterialize.materialization?)
- Buffer pool lifecycle (owned by FrameCache or separate?)

#### 4. executeNodeEval Integration (P1 - Deferred to Sprint 3)

**Current State:**
- Stub reads input slots, returns zeros
- No opcode dispatch

**Why Defer:**
- NodeEval steps are for individual signal/field nodes
- SigEvaluator already handles signal DAG evaluation via evalSig()
- FieldMaterializer already handles field DAG evaluation via evalFieldHandle()
- Modern IR likely doesn't emit NodeEval steps - it emits higher-level steps (BusEval, Materialize)
- Focus Sprint 2 on BusEval + Materialize which are actually used

**Future Work (Sprint 3):**
- Verify if NodeEval steps are emitted by current compiler
- If yes, implement opcode dispatch using SigEvaluator/FieldMaterializer
- If no, remove NodeEval step kind or document as legacy

### Dependencies & Integration Points

#### Upstream (Complete - No Blockers)
- Phase 1-5: All complete ✓
- Sprint 1: ValueStore + StateBuffer ✓

#### Downstream (Future Phases)
- Sprint 3: executeRenderAssemble, hot-swap semantics
- Phase 7: Debug infrastructure (executeDebugProbe)

### Known Issues & Risks

#### Issues
None - infrastructure is clean.

#### Risks

1. **Cache Ownership Ambiguity** (MEDIUM)
   - SigEvaluator expects SigFrameCache structure
   - FieldMaterializer expects BufferPool
   - RuntimeState FrameCache is currently a stub
   - Risk: Three different cache systems instead of one unified FrameCache
   - Mitigation: Define canonical FrameCache structure in Sprint 2, adapt evaluators to use it

2. **BusEval vs BusCombine Mismatch** (MEDIUM)
   - StepBusEval operates on slots (low-level)
   - SigEvaluator.evalBusCombine operates on SignalExpr nodes (high-level)
   - Current compiler may emit StepBusEval instead of SignalExpr busCombine nodes
   - Risk: Need to duplicate combine logic or adapt abstractions
   - Mitigation: Check compiler output, implement direct combine in executeBusEval if needed

3. **Domain Count Resolution** (LOW)
   - Materialize step needs domain count (N) to allocate buffers
   - Not clear where N comes from (domainSlot value? separate step?)
   - Mitigation: Read from ValueStore slot, validate in tests

4. **Field Handle Cache Scope** (LOW)
   - Field handles are cached per-frame in FieldMaterializer
   - Need to ensure FrameCache field handle array is used consistently
   - Mitigation: Pass FrameCache to FieldMaterializer as env parameter

### Quantitative Metrics

```
Foundation Complete:      100% (ValueStore, StateBuffer, RuntimeState)
Evaluators Ready:         100% (SigEvaluator, FieldMaterializer)
FrameCache:                 0% (interface defined, no implementation)
Step Executors:            17% (1/6 functional: timeDerive)
  - executeTimeDerive:    100% (functional)
  - executeBusEval:         0% (stub only)
  - executeMaterialize:     0% (stub only)
  - executeNodeEval:        0% (stub, deferred to Sprint 3)
  - executeRenderAssemble:  0% (stub, deferred to Sprint 3)
  - executeDebugProbe:      0% (stub, deferred to Phase 7)

Test Coverage:
  Sprint 1 foundation:   64 tests (ValueStore, StateBuffer, RuntimeState)
  Evaluators:           185+ tests (SigEvaluator, FieldMaterializer)
  Total passing:        1724 tests
```

### Files Requiring Changes (Sprint 2)

**Implement:**
1. `src/editor/runtime/executor/RuntimeState.ts` - Expand FrameCache interface and implementation
   - Add signal cache arrays (sigValue: Float64Array, sigStamp: Uint32Array)
   - Add field cache arrays (fieldHandle: FieldHandle[], fieldStamp: Uint32Array)
   - Add field buffer pool (fieldBuffers: Map)
   - Implement newFrame() invalidation logic
   - Factory function createFrameCache(capacity) (~50-80 lines)

2. `src/editor/runtime/executor/steps/executeBusEval.ts` - Real combine logic
   - Apply transform chains
   - Implement combine modes (sum, average, min, max, last)
   - Handle silent value policy
   - (~80-120 lines changed)

3. `src/editor/runtime/executor/steps/executeMaterialize.ts` - FieldMaterializer integration
   - Construct MaterializationRequest from step
   - Call FieldMaterializer.materialize()
   - Write buffer handle to slot
   - Handle domain count resolution
   - (~60-90 lines changed)

**Add Tests:**
4. `src/editor/runtime/executor/__tests__/FrameCache.test.ts` (NEW)
   - Signal cache hit/miss
   - Field cache hit/miss
   - newFrame() invalidation
   - Buffer pool reuse
   - (~25-30 tests)

5. `src/editor/runtime/executor/__tests__/executeBusEval.test.ts` (NEW)
   - All combine modes (sum, average, min, max, last)
   - Transform chain application
   - Silent value handling
   - (~20-25 tests)

6. `src/editor/runtime/executor/__tests__/executeMaterialize.test.ts` (NEW)
   - Basic field materialization
   - Buffer pool reuse
   - Domain count resolution
   - Format/layout handling
   - (~15-20 tests)

**Total Effort:** ~300-400 lines of implementation + ~250-300 lines of tests

## Recommendations for Sprint 2

### Scope
Focus on **FrameCache + BusEval + Materialize integration ONLY**. Defer:
- executeNodeEval (check if actually used, defer to Sprint 3)
- executeRenderAssemble (defer to Sprint 3)
- executeDebugProbe (defer to Phase 7)
- Hot-swap semantics (defer to Sprint 3)

### Success Criteria
1. FrameCache interface expanded with signal/field cache arrays
2. createFrameCache() allocates real cache storage
3. executeBusEval implements all combine modes
4. executeMaterialize integrates FieldMaterializer
5. 60+ tests added, all passing
6. All existing 1724 tests still pass

### Deliverable Limit
Sprint 2 should deliver **2-3 deliverables maximum**:
1. FrameCache implementation (P0)
2. executeBusEval integration (P0)
3. executeMaterialize integration (P1)

### Next Sprint (Sprint 3)
- executeNodeEval (if needed)
- executeRenderAssemble + render tree assembly
- Hot-swap state preservation
- Legacy runtime removal preparation

## Conclusion

Sprint 2 has **clear prerequisites** (Sprint 1 complete, evaluators ready) and **well-defined scope** (integrate existing evaluators into step executors). The main risk is cache ownership - need to define canonical FrameCache structure that both SigEvaluator and FieldMaterializer can use.

**Status:** READY TO PROCEED with Sprint 2 implementation.
