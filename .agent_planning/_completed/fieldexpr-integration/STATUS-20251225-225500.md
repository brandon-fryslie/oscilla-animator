# Status Report - FieldExpr + Materialization Integration

**Timestamp**: 2025-12-25-225500
**Scope**: module/fieldexpr-integration
**Confidence**: FRESH
**Git Commit**: 3dc3e2a (current HEAD on compiler_rewrite)

---

## Executive Summary

**Overall: 60% complete | Integration gaps: 4 major | Tests: 207 passing (field + passes)**

Phase 5 (FieldExpr + Materialization) has substantial standalone implementations, but the two systems are NOT YET CONNECTED:

1. **Runtime Field System** (src/editor/runtime/field/) - 63 tests passing, fully implemented
2. **Compiler IR FieldExpr** (src/editor/compiler/ir/fieldExpr.ts) - Complete schema, used by passes
3. **8-Pass Compiler** (src/editor/compiler/passes/) - 144 tests passing, passes 1-8 complete

**CRITICAL GAP**: The runtime field materialization system does NOT import or use the compiler IR types. These are parallel implementations that need integration.

---

## Evaluation Reuse

**Referenced cached knowledge**:
- `eval-cache/architecture.md` (STALE, 2 days) - Core patterns still valid
- `phase3-ir-integration/STATUS-2025-12-25-200000.md` (STALE) - Phase 3 is now further along

**Previous evaluations**:
- No prior evaluation exists for fieldexpr-integration scope

---

## What Exists [FRESH]

### 1. Runtime Field System (src/editor/runtime/field/)

| File | Lines | Tests | Purpose |
|------|-------|-------|---------|
| `types.ts` | 271 | - | TypeDesc, FieldHandle, FieldExprIR (runtime variant), BufferFormat |
| `FieldHandle.ts` | 198 | 11 | evalFieldHandle(), createFieldHandleCache() |
| `BufferPool.ts` | 135 | 9 | FieldBufferPool for typed array reuse |
| `Materializer.ts` | 560 | 18 | materialize() central function, FieldMaterializer class |
| `BroadcastReduce.ts` | 152 | 17 | Field->Signal reduce ops (sum, average, min, max) |
| `RenderSinkMaterializer.ts` | 226 | 8 | executeRenderSink(), createRenderSinkPlan() |
| **Total** | 1,542 | **63** | Complete runtime field materialization |

**Key APIs Implemented**:
- `materialize(request, env)` - Central materialization function
- `evalFieldHandle(fieldId, env, nodes)` - Handle evaluation with caching
- `FieldMaterializer.materialize(request)` - Class wrapper
- `executeRenderSink(sink, plan, env)` - Render sink execution
- `reduceSum/Average/Min/Max()` - Field reduction functions

### 2. Compiler IR FieldExpr (src/editor/compiler/ir/fieldExpr.ts)

| Node Kind | Description | In Runtime? |
|-----------|-------------|-------------|
| `const` | Constant from pool | YES (Const) |
| `broadcastSig` | Signal -> Field | YES (Broadcast) |
| `map` | Unary function | YES (Op) |
| `zip` | Binary function | YES (Zip) |
| `select` | Conditional | NO |
| `transform` | Transform chain | NO |
| `busCombine` | Bus aggregation | YES (Combine) |

**Missing in runtime**: `select`, `transform`

### 3. 8-Pass Compiler System

| Pass | File | Tests | Status |
|------|------|-------|--------|
| 1. Normalize | pass1-normalize.ts | 12 | COMPLETE |
| 2. Types | pass2-types.ts | 32 | COMPLETE |
| 3. Time | pass3-time.ts | 20 | COMPLETE |
| 4. DepGraph | pass4-depgraph.ts | 15 | COMPLETE |
| 5. SCC | pass5-scc.ts | 21 | COMPLETE |
| 6. Block Lowering | pass6-block-lowering.ts | 13 | COMPLETE |
| 7. Bus Lowering | pass7-bus-lowering.ts | 13 | COMPLETE |
| 8. Link Resolution | pass8-link-resolution.ts | 6 | COMPLETE |
| Integration | pipeline-integration.test.ts | 12 | COMPLETE |
| **Total** | | **144** | All passes working |

### 4. UnifiedCompiler FieldExpr (src/editor/compiler/unified/FieldExpr.ts)

This is a **THIRD** FieldExpr system used by the UnifiedCompiler domain blocks:
- `FieldExpr<T>` - AST-based representation (const, domain, source, map, zip, bus, adapter)
- `evaluateFieldExpr()` - Per-element evaluation
- `batchEvaluateFieldExpr()` - Batch evaluation over domain
- `FunctionRegistry` - Registered function lookup

**This is SEPARATE from both runtime/field and compiler/ir systems.**

---

## Integration Gaps [CRITICAL]

### Gap 1: Type System Divergence

**Three competing FieldExprIR definitions**:

| Location | TypeDesc | FieldExprId | CombineMode |
|----------|----------|-------------|-------------|
| `runtime/field/types.ts` | `{ kind: 'number' \| 'vec2' \| ... }` | `number` | `'sum' \| 'average' \| ...` |
| `compiler/ir/fieldExpr.ts` | `{ world, domain }` | `number` (branded) | `CombineSpec` |
| `compiler/unified/FieldExpr.ts` | N/A (uses Domain) | string (nodeId) | string |

**Impact**: Cannot directly pass IR nodes to runtime materializer.

### Gap 2: No Import Path

**runtime/field/ does NOT import from compiler/ir/**

```
Grep result: "No matches found" for imports from compiler/ir in runtime/field
```

The materialization system is completely standalone. It has its own:
- `FieldExprIR` type (similar but not identical to compiler's)
- `TypeDesc` type (simpler than compiler's)
- Evaluation algorithm (different from compiler)

### Gap 3: Signal Evaluation Stub

`Materializer.ts:97-104`:
```typescript
function evalSig(
  _sigId: SigExprId,
  _env: SigEnv,
  _nodes: SignalExprIR[]
): number {
  // TODO: Implement signal evaluation (Phase 4)
  return 0;
}
```

**Impact**: Broadcast handle (signal -> field) always returns 0. This blocks any real integration.

### Gap 4: Missing Node Kinds

Runtime field system missing:
- `select` (conditional per-element)
- `transform` (transform chain application)

These exist in compiler IR but not in runtime evaluation.

---

## Phase 5 Topics Assessment (from ROADMAP.md)

| Topic | Status | Implementation |
|-------|--------|----------------|
| field-handle-system | COMPLETE | `runtime/field/FieldHandle.ts` |
| field-materializer | COMPLETE | `runtime/field/Materializer.ts` |
| field-broadcast-reduce | PARTIAL | BroadcastReduce.ts complete, but evalSig stub |
| field-combine-nodes | COMPLETE | Materializer fillBufferCombine() |
| render-sink-materialization | COMPLETE | RenderSinkMaterializer.ts |
| block-compilers-field | NOT STARTED | Block compilers still emit closures |

**Overall Phase 5**: 75% implemented, 0% integrated

---

## Runtime Check Results

| Check | Status | Output |
|-------|--------|--------|
| `pnpm typecheck` | PASS | No errors |
| `pnpm vitest run passes` | PASS | 144/144 tests |
| `pnpm vitest run runtime/field` | PASS | 63/63 tests |
| `just check` | FAIL | Previously had errors, now fixed |

**Missing checks for integration**:
1. **Integration test** - Pass IR through all 8 passes, then materialize
2. **Signal evaluation test** - Remove evalSig stub, verify broadcast works
3. **Type compatibility test** - compiler TypeDesc <-> runtime TypeDesc
4. **End-to-end test** - Compile patch to IR, run with runtime materializer

---

## Data Flow Verification

**Traced: Compiler IR -> Runtime Materialization** (BLOCKED)

| Step | Source | Destination | Status |
|------|--------|-------------|--------|
| 1. Block compile | compileBusAware | Pass 6 blockOutputs | WORKS |
| 2. Bus lowering | Pass 6 outputs | Pass 7 busRoots | WORKS |
| 3. Link resolution | Pass 7 | Pass 8 LinkedGraphIR | WORKS |
| 4. Program build | Pass 8 | BuilderProgramIR.fieldIR | WORKS |
| 5. Field evaluation | fieldIR nodes | runtime FieldHandle | BLOCKED (no bridge) |
| 6. Materialization | FieldHandle | typed arrays | WORKS (standalone) |
| 7. Render sink | typed arrays | RenderOutput | WORKS (standalone) |

**Breakpoint**: Step 5 - No code exists to convert `FieldExprIR` (compiler) to runtime evaluation context.

---

## Ambiguities Found

| Area | Question | Impact |
|------|----------|--------|
| **Type unification** | Which TypeDesc is authoritative? | HIGH - affects all integration |
| **Evaluation strategy** | Should runtime use compiler IR directly or convert? | HIGH - architectural |
| **Signal evaluation** | Who implements evalSig? Phase 4 or Phase 5? | HIGH - blocks broadcast |
| **Domain resolution** | How does runtime get domain count from IR? | MEDIUM - needed for materialization |

**Most critical**: Signal evaluation. The runtime field system DEPENDS on Phase 4 (SignalExpr Runtime) for evalSig implementation. But Phase 4 is marked QUEUED in ROADMAP.md.

---

## Test Suite Assessment

**Test Quality Score**: 4/5 (runtime field) | 4/5 (passes)

| Question | Runtime Field | Compiler Passes |
|----------|---------------|-----------------|
| Do tests fail if implementation stubbed? | YES | YES |
| Do tests catch obvious bugs? | YES | YES |
| End-to-end user flows? | NO (standalone) | PARTIAL (integration test) |
| Real systems or mocks? | Mocks | Mocks |
| Error conditions covered? | YES | YES |

**Missing coverage**:
- Cross-system integration (compiler -> runtime)
- Real signal evaluation in field tests
- Real domain data in materialization tests

---

## LLM Blind Spot Findings

| Area | Status | Notes |
|------|--------|-------|
| Pagination | N/A | Field system handles N elements |
| Second run | UNKNOWN | No persistence tests |
| Cleanup | YES | BufferPool.releaseAll() tested |
| Error messages | PARTIAL | Errors exist but generic |
| Edge cases | PARTIAL | Empty arrays, but not unicode/special chars |

**Phase 5-specific risks**:
- Buffer overflow with large domains (untested)
- Type mismatch between compiler and runtime TypeDesc (untested)
- Signal evaluation stub masking integration bugs

---

## Implementation Red Flags

**In runtime/field/**:

1. **evalSig stub** (Materializer.ts:97-104)
   - Always returns 0
   - Masks all signal -> field broadcast bugs
   - Blocks real integration testing

2. **Type mismatch** (types.ts vs compiler/ir/types.ts)
   - Runtime: `TypeDesc = { kind: 'number' | ... }`
   - Compiler: `TypeDesc = { world, domain }`
   - No conversion function exists

3. **Hardcoded format inference** (RenderSinkMaterializer.ts:204-213)
   - `inferFormatFromUsage()` is heuristic-based
   - Should come from IR type information

**In compiler/ir/**:

4. **FieldExprIR lacks source tag** (fieldExpr.ts)
   - Runtime has `source` kind with `sourceTag`
   - Compiler has no equivalent (uses ValueSlot)

---

## Recommendations (Priority Order)

### P0: Unify Type Systems

Create adapter layer between compiler and runtime TypeDesc:

```typescript
// Location: src/editor/compiler/ir/typeAdapter.ts
export function compilerToRuntimeTypeDesc(td: CompilerTypeDesc): RuntimeTypeDesc;
export function runtimeToCompilerTypeDesc(td: RuntimeTypeDesc): CompilerTypeDesc;
```

### P1: Implement Signal Evaluation Bridge

Replace evalSig stub with real implementation:

1. **Option A**: Wait for Phase 4 (SignalExpr Runtime) to complete
2. **Option B**: Implement minimal evalSig that uses closure fallback
3. **Option C**: Pass signal values through MaterializerEnv.sigEnv

**Recommendation**: Option B for now - allows testing before Phase 4 complete.

### P2: Create Integration Test

Test full path: Patch -> 8 passes -> IR -> Materialize -> Render

```typescript
// Location: src/editor/compiler/passes/__tests__/field-materialization-integration.test.ts
describe('Field Materialization Integration', () => {
  it('compiles and materializes a simple field patch', () => {
    // 1. Create patch with field blocks
    // 2. Run passes 1-8
    // 3. Build IR
    // 4. Create MaterializerEnv from IR
    // 5. Call materialize()
    // 6. Verify typed array output
  });
});
```

### P3: Align FieldExprIR Variants

Add missing node kinds to runtime or create translation layer:
- Add `select` to runtime
- Add `transform` to runtime
- OR create IR-to-runtime translator that handles these

### P4: Wire Domain Resolution

`MaterializerEnv.getDomainCount()` needs to resolve from IR domain slots:

```typescript
getDomainCount: (domainId: number) => {
  const slot = program.valueStore.getDomainSlot(domainId);
  return slot.count;
}
```

---

## Verdict

- [x] **PAUSE** - Integration requires architectural decisions

### Clarification Needed Before Proceeding

**Question 1: Type Authority**
- **Context**: Two TypeDesc definitions exist (compiler vs runtime)
- **Options**:
  - A: Runtime adapts to compiler types (runtime imports compiler)
  - B: Compiler adapts to runtime types (compiler imports runtime)
  - C: Create shared types package both import
- **Impact**: Determines import direction and code ownership

**Question 2: Signal Evaluation Dependency**
- **Context**: Field broadcast depends on signal evaluation (evalSig stub)
- **Options**:
  - A: Block Phase 5 integration until Phase 4 complete
  - B: Create closure-based bridge for signals in Phase 5
  - C: Merge Phase 4 and 5 work into single sprint
- **Impact**: Affects timeline and whether integration testing can proceed

**Question 3: Which FieldExpr System is Authoritative?**
- **Context**: Three FieldExpr systems exist:
  1. `runtime/field/types.ts` FieldExprIR
  2. `compiler/ir/fieldExpr.ts` FieldExprIR
  3. `compiler/unified/FieldExpr.ts` FieldExpr<T>
- **Options**:
  - A: Use compiler/ir as source of truth, runtime is evaluator only
  - B: Merge all three into single system
  - C: Keep separate, create translators between them
- **Impact**: Major architectural decision affecting all field-related code

---

## Files Summary

| Category | Files | Lines | Tests | Status |
|----------|-------|-------|-------|--------|
| Runtime Field | 6 | 1,542 | 63 | COMPLETE (standalone) |
| Compiler IR Field | 1 | 126 | - | COMPLETE (types only) |
| Compiler Passes | 9 | ~1,500 | 144 | COMPLETE |
| UnifiedCompiler Field | 1 | 419 | 12+ | COMPLETE (separate system) |
| Integration | 0 | 0 | 0 | NOT STARTED |

---

## Summary

Phase 5 has two complete but disconnected implementations:

1. **Runtime Field System** - Full materialization pipeline, 63 tests passing
2. **Compiler Pass System** - 8 passes complete, IR generation working, 144 tests passing

Integration is blocked by:
- Type system divergence (no adapter)
- Signal evaluation stub (evalSig returns 0)
- No integration tests
- Unclear type authority

**Next steps require architectural decisions on type ownership and signal evaluation strategy.**
