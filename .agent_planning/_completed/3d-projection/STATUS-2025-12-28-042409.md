# Status Report - 2025-12-28-042409
Scope: RenderInstances3D Block Implementation
Confidence: FRESH
Git Commit: compiler_rewrite (f4cb96f)

## Executive Summary

**Overall Readiness: 85% ready for RenderInstances3D block implementation**

The 3D projection infrastructure is COMPLETE and the Camera block was just finished in the 3d-config-ui sprint. The runtime execution path (projection, camera eval, stores) is fully implemented and tested. Only the RenderInstances3D block definition and its lowering logic remain.

| Component | Status | Files | Notes |
|-----------|--------|-------|-------|
| Camera IR & Store | COMPLETE | types3d.ts, CameraStore.ts | 38 tests passing |
| Mesh IR & Store | COMPLETE | types3d.ts, MeshStore.ts | 51 tests passing |
| Projection executor | COMPLETE | executeInstances3DProject.ts | 12 tests passing |
| Camera block | COMPLETE | blocks/scene/Camera.ts | Just finished, lookAt→quat conversion |
| RenderInstances3D block | NOT STARTED | - | **THIS SPRINT** |
| Block lowering | NOT STARTED | - | **THIS SPRINT** |
| Default camera injection | COMPLETE | - | Via compiler pass8 |

---

## 1. Infrastructure Inventory

### [COMPLETE] 3D Runtime Infrastructure

**Projection Pipeline** (design-docs/13-Renderer/06-3d-IR-Deltas.md §3)

```
Domain + Field<vec3> positions
         ↓
   CameraEval (view-proj matrix)
         ↓
   executeInstances3DProject
         ↓
   Instance2DBufferRef
         ↓
   Existing 2D Canvas renderer
```

**Key files:**
- `src/editor/compiler/ir/types3d.ts` - CameraIR, MeshIR, Instance2DBufferRef types
- `src/editor/runtime/executor/steps/executeInstances3DProject.ts` - Projection step (605 lines)
- `src/editor/runtime/camera/CameraStore.ts` - Viewport-keyed cache
- `src/editor/runtime/mesh/MeshStore.ts` - Recipe-keyed cache

**Implementation quality:**
- Float32 math throughout (Math.fround)
- Frustum culling (behind camera, NDC bounds)
- Depth sorting with stable tie-breaking
- NaN/Inf detection
- Full StepPerfCounters

### [COMPLETE] Camera Block

**Location:** `src/editor/compiler/blocks/scene/Camera.ts` (423 lines)

**Inputs:**
- `position`: Signal<vec3>
- `target`: Signal<vec3>
- `up`: Signal<vec3>
- `projectionKind`: Scalar:string ('perspective' | 'orthographic')
- `fovYDeg`: Signal<number>
- `orthoHeight`: Signal<number>
- `near`: Signal<number>
- `far`: Signal<number>

**Output:**
- `camera`: Special<camera> (CameraRef = camera index)

**Lowering logic:**
- Converts lookAt (position, target, up) → quaternion during compilation
- Validates camera parameters (near > 0, far > near, etc.)
- Registers CameraIR in program.cameras table
- Emits camera index as special value

**Reference pattern:** This is the model for RenderInstances3D block structure.

### [COMPLETE] Compiler Passes

**Pass 6: Block Lowering** (`src/editor/compiler/passes/pass6-block-lowering.ts`)
- Calls `blockType.lower(ctx, inputs)` for each block
- Handles outputs and state declarations

**Pass 7: Bus Lowering** (`src/editor/compiler/passes/pass7-bus-lowering.ts`)
- Resolves bus connections

**Pass 8: Link Resolution** (`src/editor/compiler/passes/pass8-link-resolution.ts`)
- Injects default camera if no camera input provided (line 346-383)
- Selection semantics: explicit camera > first camera in table > default

### [PARTIAL] Existing Render Block Pattern

**RenderInstances2D** (`src/editor/compiler/blocks/domain/RenderInstances2D.ts`)

```typescript
const lowerRenderInstances2D: BlockLowerFn = ({ ctx, inputs }) => {
  const [domain, positions, radius, color, opacity] = inputs;

  // Validate inputs
  if (domain.k !== 'special' || domain.tag !== 'domain') {
    throw new Error('RenderInstances2D requires a Domain input');
  }

  // Register render sink
  const sinkInputs = {
    domain: domain.id,      // Special: id IS the slot
    positions: positions.slot,  // Field: use .slot
    radius: radius.slot,
    color: color.slot,
    opacity: opacity.slot,
  };

  ctx.b.renderSink('instances2d', sinkInputs);

  return {
    outputs: [],
    declares: {
      renderSink: { sinkId: 0 },
    },
  };
};
```

**Key patterns:**
- `domain.k === 'special'` with `domain.tag === 'domain'`
- Field inputs use `.slot` property
- Render sinks call `ctx.b.renderSink(kind, inputs)`
- Capability: `'render'`

---

## 2. Gap Analysis

### [MISSING] RenderInstances3D Block Definition

**Required:** Block type registration similar to RenderInstances2D

**Inputs needed:**
1. `domain`: Special<domain> - element identity
2. `positions3d`: Field<vec3> - 3D positions per element
3. `color`: Field<color> - per-element colors
4. `radius`: Field<number> OR Signal<number> - per-element or broadcast size
5. `opacity`: Signal<number> - global opacity
6. `camera`: Special<camera> - optional (defaults via pass8)

**Output:**
- None (render sink has no outputs)

**Lowering logic:**
- Validate domain input
- Validate positions3d is Field<vec3>
- Validate color is Field<color>
- Validate camera is Special<camera> (or undefined for default)
- Call `ctx.b.renderSink('instances3d', { domain, positions3d, color, radius, opacity, camera })`

### [MISSING] Render Sink Handler

**Location:** Needs to be added to runtime (likely in `renderPassExecutors.ts` or similar)

**Responsibility:**
- Receive sink inputs from scheduler
- Emit `StepInstances3DProjectTo2D` step with:
  - `domainSlot` from domain input
  - `cameraEvalSlot` from camera input (or default)
  - `positionSlot` from positions3d field
  - Color channel slots (colorRSlot, colorGSlot, colorBSlot, colorASlot)
  - `radiusSlot` from radius input
  - Projection options (zSort, cullMode, clipMode, sizeSpace)
  - `outSlot` for Instance2DBufferRef

**Integration point:** This is the bridge between block lowering and step execution.

---

## 3. Current State: Type System

### [COMPLETE] TypeDomain Extensions

**Location:** `src/editor/compiler/ir/types.ts`

```typescript
export type TypeDomain =
  | "number" | "boolean" | "string"
  | "vec2" | "vec3" | "vec4"
  | "quat"
  | "color" | "bounds"
  | "timeMs" | "phase01" | "unit01"
  | "trigger"
  | "domain"
  | "renderTree" | "renderCmds"
  | "mesh" | "camera" | "mat4"
  | "path" | "strokeStyle" | "filterDef"
  | "unknown";
```

**Status:** `vec3`, `camera` types already present.

### [COMPLETE] StepIR Union

**Location:** `src/editor/compiler/ir/schedule.ts`

```typescript
export type StepIR =
  | StepTimeDerive
  | StepSignalEval
  | StepNodeEval
  | StepBusEval
  | StepMaterialize
  | StepMaterializeColor
  | StepMaterializePath
  | StepMaterializeTestGeometry
  | StepCameraEval
  | StepMeshMaterialize
  | StepInstances3DProjectTo2D  // Already present
  | StepRenderAssemble
  | StepDebugProbe;
```

**Status:** 3D step types already in union.

---

## 4. Missing Pieces

### Priority 0: Block Definition

**File:** `src/editor/compiler/blocks/domain/RenderInstances3D.ts` (NEW)

**Contents:**
1. Import block lowering types
2. Define port declarations (inputs/outputs)
3. Implement `lowerRenderInstances3D` function
4. Register with `registerBlockType()`

**Estimated complexity:** Low (copy RenderInstances2D pattern, adjust for 3D)

### Priority 0: Sink Registration

**File:** TBD - likely `src/editor/compiler/ir/IRBuilderImpl.ts` or render pass code

**Missing:** The `renderSink('instances3d', ...)` handler that:
1. Allocates output slot for Instance2DBufferRef
2. Extracts camera from inputs or uses default
3. Splits color field into RGBA channels
4. Constructs `StepInstances3DProjectTo2D`
5. Registers step in schedule

**Pattern reference:** Check how 'instances2d' sink is handled.

### Priority 1: Test Coverage

**File:** `src/editor/compiler/blocks/domain/__tests__/RenderInstances3D.test.ts` (NEW)

**Test cases:**
- Block lowering with all required inputs
- Block lowering with optional camera (default injection)
- Invalid domain input (error handling)
- Invalid positions3d input (error handling)
- Field<color> color channel splitting

---

## 5. Implementation Dependencies

### External Dependencies

None - all infrastructure is in place.

### Internal Dependencies

| Dependency | Status | Notes |
|------------|--------|-------|
| Camera block | COMPLETE | Provides CameraRef output |
| CameraStore | COMPLETE | Runtime cache for cameras |
| executeInstances3DProject | COMPLETE | Step executor |
| Default camera injection | COMPLETE | Pass8 handles missing camera input |
| IRBuilder.renderSink() | UNKNOWN | Need to verify instances3d handler exists |

### Critical Path

```
1. Define RenderInstances3D block type
   ↓
2. Implement lowering function
   ↓
3. Verify renderSink('instances3d') handler
   ↓
4. Write tests
   ↓
5. End-to-end validation with Camera block
```

---

## 6. Unknowns and Ambiguities

### [MEDIUM] Render Sink Implementation Location

**Question:** Where is `ctx.b.renderSink('instances3d', ...)` handled?

**Investigation needed:**
- Search for `renderSink` method in IRBuilder/IRBuilderImpl
- Check if 'instances2d' handler exists
- Determine if new handler registration is needed

**Impact:** Medium - determines where to add 3D sink logic.

### [LOW] Color Channel Splitting

**Question:** Does the render sink handler split Field<color> into separate RGBA channel slots?

**From executeInstances3DProject.ts:**
```typescript
colorRSlot: ValueSlot;
colorGSlot: ValueSlot;
colorBSlot: ValueSlot;
colorASlot: ValueSlot;
```

**Expected:** The sink handler must materialize color field and split into 4 separate field buffers.

**Reference:** Check how RenderInstances2D handles color field.

### [LOW] Projection Options

**Question:** Should projection options (zSort, cullMode, clipMode) be:
- Block inputs (user-configurable)?
- Hardcoded defaults in lowering?
- Configurable via params?

**Recommendation:** Start with hardcoded defaults:
- `zSort: true` (enable depth sorting for 3D)
- `cullMode: 'frustum'` (standard frustum culling)
- `clipMode: 'discard'` (discard out-of-bounds)
- `sizeSpace: 'px'` (screen-space size)

Can expose as inputs later if needed.

---

## 7. Validation Checklist

### Functionality
- [ ] Block compiles with valid inputs
- [ ] Block emits correct StepInstances3DProjectTo2D step
- [ ] Camera input connects correctly
- [ ] Default camera injection works
- [ ] Color field splits into RGBA channels
- [ ] Radius field/signal handled correctly

### Integration
- [ ] Works with Camera block output
- [ ] Works with Domain outputs (DomainN, GridDomain)
- [ ] Works with Field<vec3> from spatial operators
- [ ] Works with Field<color> from color operators
- [ ] Connects to existing 2D canvas renderer

### Error Handling
- [ ] Validates domain input type
- [ ] Validates positions3d is Field<vec3>
- [ ] Validates color is Field<color>
- [ ] Validates camera is Special<camera> (if provided)
- [ ] Clear error messages for type mismatches

### Performance
- [ ] No unnecessary materializations
- [ ] Proper use of ValueSlots (not inline values)
- [ ] Efficient color channel splitting

---

## 8. References

### Design Docs
- `design-docs/13-Renderer/07-3d-Canonical.md` - Authoritative 3D spec
- `design-docs/13-Renderer/06-3d-IR-Deltas.md` - IR schema additions
- `design-docs/12-Compiler-Final/16-Block-Lowering.md` - Block lowering contract

### Implementation Files
- `src/editor/compiler/blocks/domain/RenderInstances2D.ts` - 2D render block pattern
- `src/editor/compiler/blocks/scene/Camera.ts` - Camera block reference
- `src/editor/runtime/executor/steps/executeInstances3DProject.ts` - Step executor

### Test Files
- `src/editor/runtime/executor/steps/__tests__/executeInstances3DProject.test.ts` - Step tests

---

## Recommendations

**CONTINUE** - Path is clear, implementer can proceed.

**Next steps:**
1. Locate renderSink handler implementation
2. Create RenderInstances3D block definition
3. Implement lowering function
4. Add test coverage
5. Validate end-to-end with Camera block

**Estimated effort:** 4-6 hours (including tests)
