# Implementation Plan: Signal Runtime + Stateful Ops (Workstream 4)

**Generated**: 2025-12-30-031559
**Source STATUS**: STATUS-2025-12-30-030243.md
**Topic**: Signal Runtime + Stateful Ops
**Scope**: Complete implementation of stateful signal operations and multi-component signal evaluation

---

## Executive Summary

**Current State**: ~70% complete infrastructure with critical missing pieces
**Total Work**: 5 sprints covering state resolution, bundle type system, multi-component evaluation, ColorLFO HSL mode, and integration testing
**Critical Path**: State ID resolution must complete before other work can be validated
**Estimated Timeline**: 5-8 weeks for full completion

### Key Gaps Identified

1. **CRITICAL BLOCKER**: State offset mapping missing - stateId (string) → stateOffset (number) conversion not implemented
2. **Type System**: Multi-component signals (vec2, vec3, rgba) need bundle type representation
3. **Evaluation**: InputSlot evaluation assumes single scalar, needs bundle slot reading
4. **ColorLFO**: Dynamic HSL mode blocked by bundle system

### User Decisions (Authoritative)

From user input:

1. **State ID Resolution**: Implement in `buildSchedule` (not a new pass, not runtime)
   - Canonical pattern: lowering emits symbolic StateRef, buildSchedule resolves to numeric offset
   - Deterministic ordering: sort by blockTopoIndex, localOrdinal, stateId
   - Add alignment rules (4-byte for scalars, 16-byte for buffers)
   - Compile errors for: StateDeclConflict, StateRefMissingDecl

2. **Multi-Component Signals**: N slots per component (bundle model)
   - Slots are scalar lanes (f32/u32), never store "vec2 object"
   - vec2=2 slots, vec3=3 slots, rgba=4 slots
   - ColorHSLToRGB takes 3 scalar inputs (h,s,l), outputs vec3 (r,g,b) - NO hex strings
   - Bundle is a compile-time grouping, not a runtime type

---

## Sprint 1: State ID Resolution in buildSchedule

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: None
**Priority**: P0 (Critical - blocks all stateful ops)
**Spec Reference**: `plans/SPEC-03-signal-runtime.md` • **Status Reference**: STATUS-2025-12-30-030243.md section 1

### Description

Implement the missing state offset mapping that bridges the gap between compile-time `stateId` (string) and runtime `params.stateOffset` (number). Currently, IRBuilder creates state entries with string IDs, but SigEvaluator expects numeric offsets. Tests pass because they manually set the offset, but real compilation through blocks will produce broken IR.

**Current Flow (BROKEN)**:
```
IRBuilder.allocStateId() → stateId: "pulse_0"
  ↓ (MISSING MAPPING)
SigEvaluator expects → params.stateOffset: 0
```

**Target Flow (FIXED)**:
```
IRBuilder.allocStateId() → stateId: "pulse_0"
  ↓
buildSchedule: collect StateDecls → sort deterministically → assign offsets
  ↓
Rewrite SignalExprStateful nodes → params.stateOffset: 0
```

### Implementation Steps

1. **Add StateDecl Collection During Lowering**
   - Create `LoweringContext.declareState(stateId, sizeBytes, alignment)` method
   - Call from IRBuilder when allocating state for stateful ops
   - Store in `BuilderProgramIR.stateDecls: StateDecl[]`

2. **Implement Deterministic Ordering in buildSchedule**
   - Sort StateDecls by: `(blockTopoIndex, localOrdinal, stateId)`
   - Apply alignment rules: 4-byte for scalars, 16-byte for buffers
   - Assign sequential offsets respecting alignment

3. **Rewrite SignalExprStateful Nodes**
   - Build `stateId → offset` map from sorted StateDecls
   - Walk `signalTable.nodes` and patch `SignalExprStateful` nodes
   - Add `params.stateOffset = offset` to each stateful node

4. **Add Compile Error Handling**
   - Detect `StateDeclConflict`: same stateId declared twice with different sizes
   - Detect `StateRefMissingDecl`: SignalExprStateful references unknown stateId
   - Emit actionable error messages with block context

5. **Update Test Workarounds**
   - Remove manual `params: { stateOffset: 0 }` from `SigStateful.test.ts`
   - Add integration test that compiles through full pipeline

### Acceptance Criteria

- [ ] `buildSchedule` collects StateDecls from lowering context
- [ ] StateDecl sorting is deterministic: same input → same offsets every time
- [ ] Alignment rules applied: scalars 4-byte aligned, buffers 16-byte aligned
- [ ] SignalExprStateful nodes have `params.stateOffset` set after buildSchedule
- [ ] Compile error emitted for StateDeclConflict (same ID, different size)
- [ ] Compile error emitted for StateRefMissingDecl (unknown stateId)
- [ ] Determinism test: compile same patch 10x → identical state offsets
- [ ] Local stability test: add new block → existing blocks' offsets unchanged
- [ ] Missing decl test: reference invalid stateId → compile error with block name
- [ ] Conflict test: two blocks use same stateId with different sizes → error
- [ ] All tests in `SigStateful.test.ts` pass without manual offset workarounds

### Technical Notes

**Location**: `src/editor/compiler/buildSchedule.ts` (existing file, extend state layout logic)

**Data Structures**:
```typescript
interface StateDecl {
  stateId: StateId;           // "pulse_0"
  sizeBytes: number;          // 4 for single f32, 8 for delayFrames index+ptr
  alignment: number;          // 4 or 16
  blockTopoIndex?: number;    // For deterministic sorting
  localOrdinal?: number;      // For deterministic sorting within block
}
```

**Pseudo-code**:
```typescript
// In buildSchedule.ts
function resolveStateOffsets(stateDecls: StateDecl[]): Map<StateId, number> {
  // 1. Sort deterministically
  const sorted = [...stateDecls].sort((a, b) => {
    if (a.blockTopoIndex !== b.blockTopoIndex)
      return a.blockTopoIndex - b.blockTopoIndex;
    if (a.localOrdinal !== b.localOrdinal)
      return a.localOrdinal - b.localOrdinal;
    return a.stateId.localeCompare(b.stateId);
  });

  // 2. Assign aligned offsets
  const offsets = new Map<StateId, number>();
  let currentOffset = 0;
  for (const decl of sorted) {
    // Align to required boundary
    currentOffset = Math.ceil(currentOffset / decl.alignment) * decl.alignment;
    offsets.set(decl.stateId, currentOffset);
    currentOffset += decl.sizeBytes;
  }

  return offsets;
}

// 3. Patch SignalExprStateful nodes
for (const node of signalTable.nodes) {
  if (node.kind === 'stateful') {
    const offset = stateOffsets.get(node.stateId);
    if (offset === undefined) {
      throw new CompileError(`StateRefMissingDecl: ${node.stateId}`);
    }
    node.params = { ...node.params, stateOffset: offset };
  }
}
```

**Gotchas**:
- Alignment must happen BEFORE adding size, not after
- LocalOrdinal should increment per state allocation within a block
- Error messages should include block name/ID for debuggability

---

## Sprint 2: Bundle Type System

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: None (parallel with Sprint 1)
**Priority**: P0 (Critical - required for multi-component signals)
**Spec Reference**: `plans/SPEC-06-type-system.md` • **Status Reference**: STATUS-2025-12-30-030243.md section 3

### Description

Extend the type system to represent multi-component signals as bundles of scalar slots. Currently, `TypeDesc` and `TypeWorld` treat all signals as single values. The bundle model makes vec2/vec3/rgba explicit as N scalar lanes, enabling proper slot allocation and evaluation.

**Key Principle**: Bundles are compile-time groupings, not runtime types. At runtime, everything is scalar slots (f32/u32). A vec2 is just "2 consecutive slots", not an object.

### Implementation Steps

1. **Extend TypeDesc with BundleKind**
   - Add `BundleKind` enum: `Scalar | Vec2 | Vec3 | RGBA | Mat4`
   - Add `bundleArity: number` to TypeDesc (1 for scalar, 2 for vec2, etc.)
   - Update `TypeDesc` creation to infer bundle kind from domain

2. **Add Port Typing: PortScalar vs PortBundle**
   - Split `PortType` into `PortScalar` (single slot) and `PortBundle` (N slots)
   - Update block definitions to declare bundle ports where appropriate
   - Add compile-time validation: connecting bundle to scalar is an error

3. **Update Slot Allocation Logic**
   - Modify `ValueSlot` allocation in IRBuilder to respect bundleArity
   - Allocate N consecutive slots for bundle types
   - Ensure slot indices are contiguous (vec2 at slot 5 → slots 5,6)

4. **Implement Bundle Split/Merge Wiring Sugar**
   - Add `bundleSplit(vec3) → [x, y, z]` operation (compile-time only)
   - Add `bundleMerge([h, s, l]) → vec3` operation (compile-time only)
   - These are wiring helpers, not runtime ops

### Acceptance Criteria

- [ ] `BundleKind` enum defined with Scalar, Vec2, Vec3, RGBA, Mat4
- [ ] `TypeDesc` includes `bundleArity: number` field
- [ ] TypeDesc creation automatically infers bundleArity from domain
- [ ] Port definitions support `PortScalar` vs `PortBundle` types
- [ ] Compile error emitted when connecting bundle port to scalar port
- [ ] ValueSlot allocation increments by bundleArity (vec2 consumes 2 slots)
- [ ] Slots are contiguous: bundle at slot N uses slots [N, N+bundleArity)
- [ ] bundleSplit operation extracts components from bundle
- [ ] bundleMerge operation constructs bundle from components
- [ ] Integration test: vec2 signal wire → verify 2 consecutive slots allocated

### Technical Notes

**Location**:
- `src/editor/compiler/ir/types.ts` (TypeDesc extension)
- `src/editor/blocks/portTypes.ts` (Port typing)
- `src/editor/compiler/ir/IRBuilderImpl.ts` (Slot allocation)

**Type System Changes**:
```typescript
// Before (STATUS shows single-value assumption)
interface TypeDesc {
  domain: TypeDomain;  // "number" | "vec2" | "color"
}

// After (bundle model)
interface TypeDesc {
  domain: TypeDomain;
  bundleKind: BundleKind;  // Scalar | Vec2 | Vec3 | RGBA
  bundleArity: number;     // 1, 2, 3, 4
}

enum BundleKind {
  Scalar = "scalar",  // arity=1
  Vec2 = "vec2",      // arity=2
  Vec3 = "vec3",      // arity=3
  RGBA = "rgba",      // arity=4
  Mat4 = "mat4",      // arity=16
}
```

**Slot Allocation Example**:
```typescript
// Scalar signal (hue) - 1 slot
allocValueSlot("hue", TypeDesc.scalar) → slot 0

// Vec3 signal (rgb) - 3 slots
allocValueSlot("rgb", TypeDesc.vec3) → slots 1, 2, 3

// Scalar signal (alpha) - 1 slot
allocValueSlot("alpha", TypeDesc.scalar) → slot 4
```

**Gotchas**:
- Don't create "vec2 object" at runtime - always decompose to scalar lanes
- Bundle wiring sugar must happen during lowering, before IR finalization
- Arity mismatch errors need clear messages: "Cannot connect Vec3 output to Scalar input"

---

## Sprint 3: Multi-Component Slot Evaluation

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: Sprint 2 (Bundle Type System)
**Priority**: P1 (High - enables bundle signal evaluation)
**Spec Reference**: `plans/SPEC-03-signal-runtime.md` • **Status Reference**: STATUS-2025-12-30-030243.md section 3

### Description

Update `SigEvaluator.evalInputSlot()` to handle multi-component bundle reading. Currently, it only reads single numbers via `env.slotValues.readNumber(node.slot)`. With the bundle type system from Sprint 2, we need to read N consecutive slots for bundle types.

**Current (BROKEN)**:
```typescript
// STATUS shows single-value assumption
function evalInputSlot(node, env): number {
  return env.slotValues.readNumber(node.slot);  // Always 1 value
}
```

**Target (FIXED)**:
```typescript
function evalInputSlot(node, env): number | number[] {
  if (node.bundleArity === 1) {
    return env.slotValues.readNumber(node.slot);
  } else {
    // Read N consecutive slots
    return Array.from({ length: node.bundleArity }, (_, i) =>
      env.slotValues.readNumber(node.slot + i)
    );
  }
}
```

### Implementation Steps

1. **Add BundleArity to SignalExprIR InputSlot Nodes**
   - Extend `SignalExprIR` inputSlot nodes with `bundleArity: number`
   - Populate during IR building from TypeDesc

2. **Update evalInputSlot to Handle Bundles**
   - Check `node.bundleArity` to determine scalar vs bundle
   - For bundles, read N consecutive slots
   - Return `number` for scalar, `number[]` for bundle

3. **Update Downstream Evaluators**
   - Kernels expecting bundle inputs must handle `number[]`
   - Example: `ColorHSLToRGB(h, s, l)` receives 3 separate scalars, not array

4. **Add Slot Bounds Checking**
   - Validate that `slot + bundleArity <= slotCount`
   - Emit runtime error if bundle read exceeds slot buffer

### Acceptance Criteria

- [ ] `SignalExprIR` inputSlot nodes include `bundleArity: number` field
- [ ] `evalInputSlot()` returns single number for scalar (arity=1)
- [ ] `evalInputSlot()` reads N consecutive slots for bundles (arity>1)
- [ ] Vec2 input slot reads slots [N, N+1] correctly
- [ ] Vec3 input slot reads slots [N, N+1, N+2] correctly
- [ ] RGBA input slot reads slots [N, N+1, N+2, N+3] correctly
- [ ] Runtime error emitted if bundle read exceeds slot buffer bounds
- [ ] ColorHSLToRGB kernel receives 3 scalar values (not array)
- [ ] Integration test: vec2 signal → evalInputSlot → verify [x, y] components
- [ ] Integration test: vec3 signal → evalInputSlot → verify [r, g, b] components

### Technical Notes

**Location**: `src/editor/runtime/signal-expr/SigEvaluator.ts:306-311`

**Implementation Pattern**:
```typescript
// In SignalExprIR definition
interface SignalExprInputSlot {
  kind: "inputSlot";
  slot: number;        // Starting slot index
  bundleArity: number; // How many slots to read (1 for scalar, N for bundle)
}

// In SigEvaluator.ts
function evalInputSlot(
  node: Extract<SignalExprIR, { kind: "inputSlot" }>,
  env: SigEnv
): number | number[] {
  if (node.bundleArity === 1) {
    return env.slotValues.readNumber(node.slot);
  }

  // Read N consecutive slots
  const values: number[] = [];
  for (let i = 0; i < node.bundleArity; i++) {
    values.push(env.slotValues.readNumber(node.slot + i));
  }
  return values;
}
```

**Kernel Wiring**:
```typescript
// ColorHSLToRGB kernel expects 3 separate scalars
// Wiring layer decomposes bundle into individual inputs:
const hslBundle = evalInputSlot(hslNode, env); // [h, s, l]
const [h, s, l] = hslBundle as number[];
const rgb = colorHSLToRGB(h, s, l); // vec3 result
```

**Gotchas**:
- Don't pass arrays to kernels that expect separate arguments
- Bundle decomposition happens at call site, not inside evalInputSlot
- Slot bounds checking must account for bundle arity, not just base slot

---

## Sprint 4: ColorLFO Dynamic HSL Mode

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: Sprint 2 (Bundle Type System), Sprint 3 (Multi-Component Evaluation)
**Priority**: P2 (Medium - feature enhancement)
**Spec Reference**: `plans/SPEC-03-signal-runtime.md` • **Status Reference**: STATUS-2025-12-30-030243.md section 4

### Description

Enable ColorLFO to use the `ColorHSLToRGB` kernel with dynamic Saturation and Lightness inputs, not just Hue rotation. Currently, ColorLFO bakes S/L into the base color and only animates Hue via `ColorShiftHue` (2-input op). The full `ColorHSLToRGB` kernel exists but isn't used because it needs 3 separate signal inputs (H, S, L).

**Current (LIMITED)**:
```typescript
// ColorLFO.ts:120
// Note: sat and light parameters from config are baked into the base color.
// Future enhancement: use OpCode.ColorHSLToRGB with a 3-input zip when available.
return ir.opcode(OpCode.ColorShiftHue, h, baseColorSignal); // Only animates hue
```

**Target (FULL HSL)**:
```typescript
// H, S, L as 3 separate signal inputs (all can be animated)
const h = ir.sigInputSlot(...);  // Hue signal
const s = ir.sigInputSlot(...);  // Saturation signal
const l = ir.sigInputSlot(...);  // Lightness signal

// Merge into vec3 bundle
const hsl = ir.bundleMerge([h, s, l]);

// Convert HSL → RGB
const rgb = ir.opcode(OpCode.ColorHSLToRGB, hsl); // 3-input, vec3 output
```

### Implementation Steps

1. **Update ColorLFO Lowering to Use Bundle Model**
   - Add Saturation and Lightness input ports (optional, default to config values)
   - Lower H, S, L as 3 separate signals
   - Use `bundleMerge([h, s, l])` to create vec3 input

2. **Wire ColorHSLToRGB Kernel**
   - Connect merged HSL bundle to ColorHSLToRGB kernel
   - Kernel signature: `(h: number, s: number, l: number) => vec3`
   - Output is vec3 (r, g, b) bundle

3. **Remove Legacy ColorShiftHue Path**
   - Delete fallback comment "Future enhancement..."
   - Remove baked S/L limitation from documentation

4. **Add UI Controls for S/L Inputs**
   - Optional: Add Saturation/Lightness input ports to ColorLFO block
   - If not connected, use config defaults (backward compatible)

### Acceptance Criteria

- [ ] ColorLFO block has optional Saturation and Lightness input ports
- [ ] ColorLFO lowering emits 3 separate signals (H, S, L)
- [ ] H, S, L signals merged into vec3 bundle via bundleMerge
- [ ] ColorHSLToRGB kernel receives 3 scalar inputs (h, s, l)
- [ ] ColorHSLToRGB outputs vec3 (r, g, b) bundle
- [ ] Legacy ColorShiftHue code path removed from ColorLFO
- [ ] Documentation updated: S/L are now dynamic, not baked
- [ ] Backward compatibility: unconnected S/L use config defaults
- [ ] Chrome DevTools validation: animate H, S, L independently → verify color changes
- [ ] Integration test: ColorLFO with dynamic S/L → verify RGB output

### Technical Notes

**Location**: `src/editor/compiler/blocks/signal/ColorLFO.ts:119-148`

**Kernel Signature** (already implemented in `kernels/color.ts:22-67`):
```typescript
function colorHSLToRGB(h: number, s: number, l: number): [number, number, number] {
  // Returns RGB components as separate values
  // h: [0, 360], s: [0, 1], l: [0, 1]
  // Returns: [r, g, b] where each in [0, 1]
}
```

**Lowering Pattern**:
```typescript
// In ColorLFO.ts lowerToIR()
function lowerColorLFO(ctx: LoweringContext, block: ColorLFOBlock) {
  const ir = ctx.builder;

  // Get H signal (already exists)
  const hue = ir.sigInputSlot(block.inputs.hue, TypeDesc.scalar);

  // Get S, L signals (new - optional inputs)
  const sat = block.inputs.saturation
    ? ir.sigInputSlot(block.inputs.saturation, TypeDesc.scalar)
    : ir.sigConstant(block.config.saturation); // Default from config

  const light = block.inputs.lightness
    ? ir.sigInputSlot(block.inputs.lightness, TypeDesc.scalar)
    : ir.sigConstant(block.config.lightness); // Default from config

  // Merge into vec3 bundle
  const hsl = ir.bundleMerge([hue, sat, light]);

  // Convert HSL → RGB
  const rgb = ir.opcode(OpCode.ColorHSLToRGB, hsl);

  // Output RGB bundle
  ir.output(block.outputs.color, rgb);
}
```

**Gotchas**:
- HSL values have different ranges: H=[0,360], S/L=[0,1]
- RGB output is [0,1], may need scaling for display
- Backward compatibility: existing patches without S/L inputs should still work

---

## Sprint 5: Integration Testing & Validation

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: Sprints 1, 2, 3, 4 (all previous work)
**Priority**: P1 (High - validates entire workstream)
**Spec Reference**: `plans/SPEC-03-signal-runtime.md` • **Status Reference**: STATUS-2025-12-30-030243.md validation section

### Description

End-to-end testing and validation of all stateful ops and multi-component signals through the full compiler pipeline. Current tests bypass the compiler by manually setting state offsets, so they don't catch integration issues. This sprint adds integration tests and Chrome DevTools validation to ensure everything works correctly in real patches.

**Validation Strategy**:
1. **Unit Tests**: Already exist, will be updated to remove workarounds
2. **Integration Tests**: Compile patches through full pipeline, verify IR correctness
3. **Runtime Validation**: Chrome DevTools MCP to execute patches and verify behavior

### Implementation Steps

1. **End-to-End Stateful Ops Tests**
   - Create test patches with PulseDivider, EnvelopeAD, Integrate, DelayFrames
   - Compile through full pipeline (not just IRBuilder)
   - Verify IR has correct `params.stateOffset` (not manually set)
   - Verify state layout has correct sizes and alignment

2. **Chrome DevTools Validation: Stateful Timing**
   - Run patch with PulseDivider (divisions=4)
   - Verify pulse output triggers at correct intervals
   - Run patch with EnvelopeAD (attack=0.1s, decay=0.5s)
   - Verify envelope shape matches expected curve

3. **Chrome DevTools Validation: ColorLFO HSL**
   - Run patch with ColorLFO using dynamic H, S, L inputs
   - Verify color output changes correctly
   - Verify no legacy ColorShiftHue fallback is used
   - Verify RGB output values match expected HSL conversion

4. **Bundle Type System Tests**
   - Create patch with vec2/vec3 signals
   - Verify slot allocation: vec2 uses 2 slots, vec3 uses 3 slots
   - Verify slot reads: vec2 reads [slot, slot+1], vec3 reads [slot, slot+1, slot+2]

5. **State Offset Determinism Tests**
   - Compile same patch 10 times, verify identical state offsets
   - Add new stateful block to patch, verify existing offsets unchanged
   - Verify state offset ordering matches (blockTopoIndex, localOrdinal, stateId)

6. **Error Handling Tests**
   - StateDeclConflict: same stateId, different sizes → compile error
   - StateRefMissingDecl: reference unknown stateId → compile error
   - Bundle type mismatch: connect vec3 to scalar → compile error

### Acceptance Criteria

- [ ] Integration test: PulseDivider block → compile → IR has params.stateOffset
- [ ] Integration test: EnvelopeAD block → compile → IR has params.stateOffset
- [ ] Integration test: Integrate block → compile → IR has params.stateOffset
- [ ] Integration test: DelayFrames block → compile → state layout correct size
- [ ] Chrome DevTools: PulseDivider (divisions=4) → pulse every 0.25 phase
- [ ] Chrome DevTools: EnvelopeAD (attack=0.1s) → envelope rises in 0.1s
- [ ] Chrome DevTools: EnvelopeAD (decay=0.5s) → envelope falls in 0.5s
- [ ] Chrome DevTools: ColorLFO HSL → color output matches expected RGB
- [ ] Chrome DevTools: ColorLFO HSL → no legacy ColorShiftHue used
- [ ] Integration test: vec2 signal → 2 consecutive slots allocated
- [ ] Integration test: vec3 signal → 3 consecutive slots allocated
- [ ] Integration test: vec2 read → returns [x, y] components
- [ ] Integration test: vec3 read → returns [r, g, b] components
- [ ] Determinism test: compile 10x → identical state offsets
- [ ] Local stability test: add block → existing offsets unchanged
- [ ] Error test: StateDeclConflict → compile error with clear message
- [ ] Error test: StateRefMissingDecl → compile error with block name
- [ ] Error test: bundle type mismatch → compile error
- [ ] All tests in `SigStateful.test.ts` pass without manual workarounds
- [ ] Build passes: `just check` succeeds with no errors

### Technical Notes

**Test Locations**:
- Unit tests: `src/editor/runtime/signal-expr/SigStateful.test.ts` (existing, update)
- Integration tests: `src/editor/compiler/__tests__/stateful-integration.test.ts` (new)
- Chrome DevTools validation: Manual testing via MCP

**Integration Test Pattern**:
```typescript
// stateful-integration.test.ts
describe("Stateful Ops Integration", () => {
  it("PulseDivider compiles with correct state offset", () => {
    // 1. Create patch with PulseDivider block
    const patch = createTestPatch({
      blocks: [
        { type: "PulseDivider", config: { divisions: 4 } }
      ]
    });

    // 2. Compile through full pipeline
    const compiled = compilePatch(patch);

    // 3. Verify IR
    const pulseDividerNode = findNodeByOp(compiled.signalTable, "pulseDivider");
    expect(pulseDividerNode.params.stateOffset).toBeDefined();
    expect(pulseDividerNode.params.stateOffset).toBeGreaterThanOrEqual(0);

    // 4. Verify state layout
    const stateCell = compiled.stateLayout.cells.find(
      c => c.stateId === pulseDividerNode.stateId
    );
    expect(stateCell).toBeDefined();
    expect(stateCell.sizeBytes).toBe(8); // i32 + f32 = 8 bytes
  });
});
```

**Chrome DevTools Validation**:
```bash
# 1. Start dev server
just dev

# 2. Open Chrome DevTools MCP
# 3. Create patch with PulseDivider (divisions=4)
# 4. Run player for 1 second
# 5. Verify pulse output: expect 4 pulses in 1 second (one every 0.25s)
```

**Gotchas**:
- Integration tests need full patch setup (not just IR builder)
- Chrome DevTools validation requires visual inspection of output
- Determinism tests must run in clean environment (no state pollution)

---

## Dependency Graph

```
Sprint 1: State ID Resolution
  └─→ Sprint 5: Integration Testing (validation)

Sprint 2: Bundle Type System
  └─→ Sprint 3: Multi-Component Slot Evaluation
    └─→ Sprint 4: ColorLFO Dynamic HSL Mode
      └─→ Sprint 5: Integration Testing (validation)
```

**Critical Path**: Sprint 1 → Sprint 5 (state resolution must work for validation)
**Parallel Work**: Sprint 1 and Sprint 2 can be done simultaneously
**Sequential Work**: Sprint 2 → 3 → 4 must be sequential (each depends on previous)

---

## Risk Assessment

### High Risk Items

1. **State Offset Mapping Complexity**
   - **Risk**: Deterministic ordering may not be stable across refactors
   - **Mitigation**: Add determinism tests early, document ordering rules clearly
   - **Impact**: If unstable, state offsets will change between compilations

2. **Bundle Type System Breaking Changes**
   - **Risk**: Extending TypeDesc may break existing code
   - **Mitigation**: Add bundleArity with default=1 for backward compatibility
   - **Impact**: Large refactor if not done carefully

3. **Chrome DevTools Validation Dependencies**
   - **Risk**: Requires running dev server, manual testing, visual inspection
   - **Mitigation**: Document validation procedures clearly
   - **Impact**: Validation may be skipped if too manual

### Medium Risk Items

1. **ColorLFO Backward Compatibility**
   - **Risk**: Existing patches may break if S/L inputs required
   - **Mitigation**: Make S/L inputs optional, use config defaults
   - **Impact**: Limited - existing patches continue working

2. **Test Suite Dependencies**
   - **Risk**: STATUS shows "tsc: command not found" - tests can't run
   - **Mitigation**: Fix test environment first (install deps)
   - **Impact**: Can't validate changes without working tests

### Low Risk Items

1. **Alignment Rules**
   - **Risk**: 4-byte vs 16-byte alignment may waste memory
   - **Mitigation**: Use smallest alignment that works
   - **Impact**: Minimal - state buffers are small

---

## Recommended Sprint Order

### Phase 1: Critical Infrastructure (Weeks 1-2)
1. **Sprint 1**: State ID Resolution (BLOCKER - must complete first)
2. **Sprint 2**: Bundle Type System (parallel with Sprint 1)

### Phase 2: Signal Evaluation (Weeks 3-4)
3. **Sprint 3**: Multi-Component Slot Evaluation (depends on Sprint 2)
4. **Sprint 4**: ColorLFO Dynamic HSL Mode (depends on Sprint 3)

### Phase 3: Validation (Weeks 5-6)
5. **Sprint 5**: Integration Testing & Validation (depends on all previous)

**Total Duration**: 5-6 weeks (assuming 1 sprint per week)

---

## Success Metrics

### Sprint 1 Success
- [ ] Stateful ops work in real patches (not just tests)
- [ ] No manual `params.stateOffset` workarounds needed
- [ ] State offsets are deterministic and stable

### Sprint 2 Success
- [ ] Multi-component signals have explicit type representation
- [ ] Slot allocation respects bundle arity
- [ ] Type system prevents invalid connections

### Sprint 3 Success
- [ ] evalInputSlot handles bundles correctly
- [ ] Vec2/Vec3 signals read multiple slots
- [ ] No runtime errors from bundle reads

### Sprint 4 Success
- [ ] ColorLFO animates H, S, L independently
- [ ] No legacy fallback code paths
- [ ] RGB output matches expected values

### Sprint 5 Success
- [ ] All integration tests pass
- [ ] Chrome DevTools validation confirms correct behavior
- [ ] `just check` passes with no errors
- [ ] No manual workarounds in test suite

---

## Blockers and Questions

None identified. User decisions provide clear direction for all implementation details.

---

## References

- **STATUS Report**: STATUS-2025-12-30-030243.md
- **Workstream Plan**: plans/ir-compiler-backlog-streams/04-signal-runtime-stateful.md
- **Spec**: plans/SPEC-03-signal-runtime.md, plans/SPEC-06-type-system.md
- **Key Files**:
  - `src/editor/compiler/buildSchedule.ts` (state resolution)
  - `src/editor/compiler/ir/types.ts` (bundle types)
  - `src/editor/runtime/signal-expr/SigEvaluator.ts` (evaluation)
  - `src/editor/compiler/blocks/signal/ColorLFO.ts` (ColorLFO lowering)
