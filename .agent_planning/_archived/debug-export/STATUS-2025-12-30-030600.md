# Status Report - Debug + Export Workstream (Workstream 7)

**Timestamp**: 2025-12-30-030600
**Scope**: flow/debug-export-workstream
**Confidence**: FRESH
**Git Commit**: 5e2ffbc

---

## Executive Summary

**Overall**: 40% complete - Debug infrastructure exists but DebugDisplay IR lowering blocked. Export pipeline does not exist.

**Critical Findings**:
- ✅ **Debug infrastructure COMPLETE**: StepDebugProbe type exists, executeDebugProbe implemented, TraceController working
- ❌ **DebugDisplay IR lowering BLOCKED**: Explicitly throws error (line 34-39 of DebugDisplay.ts)
- ❌ **Export pipeline MISSING**: No export code exists (image sequence, video, GIF, standalone)
- ⚠️ **Determinism PARTIAL**: Seeded PRNG exists (core/rand.ts) but Math.random() still used in 3 places
- ✅ **Tests PASSING**: 2425/2445 tests pass (129/131 test files)

**Test Quality**: 4/5 - Comprehensive debug tests exist, runtime stable, but no export tests (export not implemented)

---

## Runtime Check Results

| Check | Status | Output Summary |
|-------|--------|----------------|
| `pnpm test -- --run` | PASS | 2425 passed, 10 skipped, 10 todo (41.76s) |
| `just typecheck` | NOT_RUN | Would verify TypeScript compilation |
| `just check` | NOT_RUN | Would run full check suite |

**Missing Checks** (implementer should create):
1. DebugDisplay IR integration test - Verify DebugDisplay emits StepDebugProbe and updates TraceController
2. Export image sequence test - Verify frame export produces correct number of PNG files
3. Deterministic replay test - Verify same seed produces bit-identical output

---

## What Exists (Infrastructure Complete)

### Area 1: Debug Infrastructure (75% Complete)

#### ✅ StepDebugProbe Type (COMPLETE)
**File**: `src/editor/compiler/ir/schedule.ts:682-710`

```typescript
export interface StepDebugProbe extends StepBase {
  kind: "debugProbe";
  probe: DebugProbeIR;
}

export interface DebugProbeIR {
  id: string;
  slots: ValueSlot[];
  mode: "value" | "trace" | "breakpoint";
}
```

**Evidence**: Type defined with full structure, includes probe ID, slot tracking, and mode selection.

#### ✅ executeDebugProbe Implementation (COMPLETE)
**File**: `src/editor/runtime/executor/steps/executeDebugProbe.ts:38-74`

**Functionality**:
- Zero overhead when TraceController.mode === 'off' (early return)
- Reads slot values from RuntimeState
- Converts TypeDesc to artifact kind for summarization
- Encodes values to ValueRecord32 format
- Writes to TraceController ring buffers

**Evidence**: 156 lines of implementation with type conversion, encoding, and integration with TraceController.

#### ✅ ScheduleExecutor Integration (COMPLETE)
**File**: `src/editor/runtime/executor/ScheduleExecutor.ts:31,224-225`

```typescript
import { executeDebugProbe } from "./steps/executeDebugProbe";
// ...
case "debugProbe":
  executeDebugProbe(step, runtime);
```

**Evidence**: executeDebugProbe imported and dispatched in step execution switch.

#### ✅ TraceController + Ring Buffers (COMPLETE)
**Files**:
- `src/editor/debug/TraceController.ts` (125 lines, mode switching)
- `src/editor/debug/ValueRing.ts` (156 lines, value records)
- `src/editor/debug/SpanRing.ts` (179 lines, span records)
- `src/editor/debug/ValueRecord.ts` (374 lines, encoding for scalar/vec2/color/FieldStats)
- `src/editor/debug/DebugIndex.ts` (200 lines, string interning)

**Test Coverage**: 121 tests across 8 test files in `debug/__tests__/`

**Evidence**: Complete debug infrastructure with passing tests. Previous status report (2025-12-25-232500) confirmed 75% complete with core files working.

#### ✅ Debug UI Components (COMPLETE)
**Files**:
- `src/editor/debug-ui/DebugDrawer.tsx` - Main debug drawer
- `src/editor/debug-ui/DebugHUD.tsx` - Heads-up display
- `src/editor/debug-ui/IRTab.tsx` - IR visualization (19870 bytes)
- `src/editor/debug-ui/ScheduleTab.tsx` - Schedule visualization
- `src/editor/debug-ui/ProbeCard.tsx` - Probe value display
- `src/editor/debug-ui/BusValueMeter.tsx` - Bus value meters
- `src/editor/components/DebugReplPanel.tsx` - REPL interface

**Evidence**: 18 files in debug-ui/ directory, components exist and are integrated.

#### ✅ DebugStore (COMPLETE)
**File**: `src/editor/stores/DebugStore.ts`

**Functionality**:
- Probe management (blocks, buses, bindings)
- Console output (REPL interface)
- Command execution

**Evidence**: MobX store with probe registry and REPL integration.

### Area 2: DebugDisplay IR Lowering (BLOCKED)

#### ❌ DebugDisplay IR Lowering (BLOCKED - Explicitly Throws Error)
**File**: `src/editor/compiler/blocks/debug/DebugDisplay.ts:33-39`

**Current State**:
```typescript
const lowerDebugDisplay: BlockLowerFn = ({ ctx }) => {
  throw new Error(
    `DebugDisplay block (${ctx.instanceId}) cannot be lowered to IR yet.\n` +
    `Reason: DebugDisplay has side-effects (updates DebugStore) that don't fit the pure IR model.\n` +
    `Workaround: DebugDisplay continues to use the legacy closure compiler.\n` +
    `Future: Will be implemented as a debug sink or closure bridge.`
  );
};
```

**Impact**: DebugDisplay blocks CANNOT work in IR mode. This is a **CRITICAL GAP**.

**Why This Matters**:
- Users cannot debug IR-compiled patches
- DebugDisplay only works in legacy closure mode
- Blocks the ability to visualize signal/field values during IR execution

**What Needs to Happen**:
1. Replace error throw with IR emission
2. Emit StepDebugProbe for each connected input (signal/phase/domain/field)
3. Assign probe IDs and labels from block params
4. Connect to existing TraceController infrastructure (already working)

**Complexity**: LOW - Infrastructure exists, just needs wiring.

### Area 3: Canvas Renderer (COMPLETE)

#### ✅ Canvas2DRenderer (COMPLETE)
**File**: `src/editor/runtime/canvasRenderer.ts:189-234`

**Functionality**:
- `renderFrame(frame: RenderFrameIR, valueStore: ValueStore): RenderStats`
- Clear canvas based on clear spec
- Sort passes by z-order
- Execute render passes (instances2d, paths2d)
- Returns render stats (draw calls, state changes, timing)

**Evidence**: Complete implementation with frame rendering, pass sorting, and stats tracking. Ready for export pipeline to use.

### Area 4: Deterministic Replay (PARTIAL)

#### ✅ Seeded PRNG (COMPLETE)
**File**: `src/core/rand.ts:26-75`

**Implementation**: Mulberry32 algorithm with seed support

**Features**:
- `createPRNG(seed: Seed): PRNG`
- Same seed → same sequence
- Fast and statistically sound
- Fork support for derived PRNGs

**Evidence**: 80+ lines of PRNG implementation with fork(), range(), int(), pick(), vary() methods.

#### ⚠️ Math.random() Usage (RISK)
**Locations**:
1. `src/editor/pathLibrary/index.ts` - User path ID generation
2. `src/editor/stores/DefaultSourceStore.ts` - Default source ID generation
3. `src/editor/controlSurface/store.ts` - Random seed generation (ironically!)

**Impact**:
- ID generation randomness is OK (compile-time, doesn't affect frame output)
- ControlSurface random seed generation needs to use deterministic source for export
- Overall risk is LOW for export (IDs don't affect rendering)

**Action Required**:
- Audit controlSurface/store.ts seed generation before export implementation
- Consider making patch seed explicit in export config

### Area 5: Export Pipeline (NOT STARTED)

#### ❌ Image Sequence Export (MISSING)
**Expected Location**: `src/editor/export/ImageSequenceExporter.ts`

**Status**: Does not exist

**What's Needed** (from SPEC-10):
- OffscreenCanvas rendering at custom resolution
- Frame-by-frame rendering loop
- Blob conversion (PNG/WebP/JPEG)
- File naming pattern support
- Progress callback

**Dependencies**:
- ✅ Canvas2DRenderer.renderFrame() exists and works
- ✅ OffscreenCanvas API available in modern browsers
- ❌ State serialization not implemented yet

#### ❌ Video Export (MISSING)
**Expected Location**: `src/editor/export/VideoExporter.ts`

**Status**: Does not exist

**What's Needed** (from SPEC-10):
- WebCodecs VideoEncoder integration
- Muxer for MP4/WebM container
- Codec configuration (H.264, VP9, AV1)
- Frame-to-VideoFrame conversion
- Bitrate and quality controls

**Complexity**: HIGH - Requires WebCodecs API knowledge and muxing library integration

#### ❌ GIF Export (MISSING)
**Expected Location**: `src/editor/export/GifExporter.ts`

**Status**: Does not exist

**What's Needed** (from SPEC-10):
- GIF library integration (gif.js or similar)
- Palette optimization
- Dithering options
- Web worker support for encoding

**Complexity**: MEDIUM - Third-party library handles complexity

#### ❌ Standalone Player Export (MISSING)
**Expected Location**: `src/editor/export/StandaloneExporter.ts`

**Status**: Does not exist

**What's Needed** (from SPEC-10):
- HTML template generation
- IR program serialization
- Runtime bundling (inline or CDN)
- Optional playback controls

**Complexity**: MEDIUM - Requires runtime bundling strategy

---

## Gaps and Missing Pieces

### Gap 1: DebugDisplay IR Lowering (HIGH PRIORITY)

**What's Missing**:
- lowerDebugDisplay() implementation (currently throws error)
- Probe ID assignment logic
- Input → slot mapping for StepDebugProbe emission

**Why This Matters**:
- Blocks all debugging in IR mode
- Users cannot visualize signal/field values
- Critical for iterative development workflow

**Recommended Approach**:
1. Replace error throw in lowerDebugDisplay()
2. For each connected input (signal/phase/domain/field):
   - Allocate probe ID: `${ctx.instanceId}:${portId}`
   - Emit StepDebugProbe with slot reference
   - Set probe mode to "value"
3. Register block type with probe metadata
4. Test with simple patch containing DebugDisplay + Sine

**Complexity**: LOW (infrastructure exists)
**Effort**: 2-4 hours
**Risk**: LOW (isolated change, tests exist)

### Gap 2: Signal History Buffer (MEDIUM PRIORITY)

**Current State**: TraceController records values to ring buffers but no waveform visualization

**What's Missing** (from SPEC-11):
- SignalHistoryBuffer class (ring buffer for time-series data)
- SignalGraph React component (canvas-based waveform)
- Auto-scaling logic for min/max bounds
- Sample rate management (60fps assumed)

**Why This Matters**:
- Users cannot see signal behavior over time
- Hard to debug oscillating signals (e.g., Sine, LFO)
- Visualization is key to understanding phase relationships

**Recommended Approach**:
1. Create `src/editor/debug/SignalHistoryBuffer.ts`
2. Integrate with TraceController (record on each probe write)
3. Create `src/editor/debug-ui/SignalGraph.tsx` (canvas renderer)
4. Add to DebugDrawer as new tab or probe card enhancement

**Complexity**: MEDIUM (canvas rendering + ring buffer math)
**Effort**: 4-8 hours
**Risk**: LOW (additive feature)

### Gap 3: Field Visualization (MEDIUM PRIORITY)

**Current State**: ProbeCard displays field sample (first 5 values) as text

**What's Missing** (from SPEC-11):
- Field stats computation (min/max/mean/stdDev)
- Heatmap visualization (grid layout with colormap)
- Histogram mode
- Scatter plot mode

**Why This Matters**:
- Users cannot see field patterns visually
- Text display of 5 values is insufficient for 100+ element domains
- Heatmaps reveal spatial patterns instantly

**Recommended Approach**:
1. Create `src/editor/debug/FieldStats.ts` - compute statistics
2. Create `src/editor/debug-ui/FieldHeatmap.tsx` - canvas heatmap renderer
3. Add mode selector to ProbeCard (text | heatmap | histogram)
4. Use existing colormapLookup utilities

**Complexity**: MEDIUM (statistics + canvas rendering)
**Effort**: 6-10 hours
**Risk**: LOW (additive feature)

### Gap 4: Runtime State Inspector (LOW PRIORITY)

**Current State**: No way to inspect ValueStore slots or StateBuffer

**What's Missing** (from SPEC-11):
- captureRuntimeSnapshot() function
- RuntimeStateTree UI component
- Slot metadata display
- State buffer visualization

**Why This Matters**:
- Deep debugging of compiler output
- Understanding slot allocation
- Inspecting stateful operation state

**Complexity**: MEDIUM (snapshot capture + tree UI)
**Effort**: 4-6 hours
**Risk**: LOW (diagnostic tool, not user-facing)

### Gap 5: Export Infrastructure (HIGH PRIORITY)

**What's Missing**:
- Image sequence exporter (PNG/WebP)
- Video exporter (MP4/WebM)
- GIF exporter
- Standalone player exporter
- Export UI/controls

**Why This Matters**:
- Users cannot save animations to disk
- No way to share animations outside editor
- Export is a CORE USER FEATURE

**Recommended Order** (from SPEC-10):
1. **Deterministic replay FIRST** - Ensure reproducibility
2. **Image sequence** - Simplest export, tests infrastructure
3. **Video export** - Most requested format
4. **GIF export** - Social sharing
5. **Standalone player** - Self-contained sharing

**Critical Dependency**: Deterministic replay must be verified before any export implementation.

**Complexity**: HIGH (entire subsystem)
**Effort**: 20-40 hours
**Risk**: MEDIUM (WebCodecs browser support, muxing complexity)

---

## Data Flow Verification

### Debug Data Flow

| Flow | Input | Process | Store | Retrieve | Display |
|------|-------|---------|-------|----------|---------|
| **DebugDisplay (Legacy)** | ✅ Signal/Field | ✅ Sample values | ✅ DebugStore | ✅ MobX observe | ✅ ProbeCard UI |
| **DebugProbe (IR)** | ✅ ValueSlot | ✅ executeDebugProbe | ✅ TraceController | ✅ Ring buffers | ❌ UI not connected |
| **Signal History** | ❌ No history | ❌ Not recorded | ❌ No buffer | N/A | ❌ No viz |

**Critical Gap**: DebugProbe infrastructure works but UI is not connected to TraceController output.

### Export Data Flow (Theoretical - Not Implemented)

| Flow | Input | Process | Store | Retrieve | Display |
|------|-------|---------|-------|----------|---------|
| **Frame Render** | ✅ RenderFrameIR | ✅ Canvas2DRenderer | ✅ Canvas pixels | ✅ convertToBlob | ❌ No export |
| **Image Sequence** | N/A | ❌ Not implemented | N/A | N/A | N/A |
| **Video** | N/A | ❌ Not implemented | N/A | N/A | N/A |

---

## Ambiguities Requiring Resolution

### A1: DebugDisplay IR Side-Effects Strategy

**Question**: How should DebugDisplay integrate with IR's pure model?

**Context**: DebugDisplay updates MobX stores (DebugStore) which is a side-effect. IR is designed to be pure.

**Options**:
1. **Emit StepDebugProbe + keep DebugStore separate** - Debug probes write to TraceController, UI reads from TraceController instead of DebugStore
2. **Create ClosureBridge for DebugStore updates** - Allow side-effects via closure escape hatch
3. **Make DebugStore read from TraceController** - Bridge the two systems at store level

**Current Implementation Guess**: Code throws error, no decision made.

**Recommended Choice**: **Option 1** - Emit StepDebugProbe, migrate UI to read from TraceController.

**Rationale**:
- TraceController infrastructure already exists and works
- Keeps IR pure
- Allows debug probes to work with zero overhead when disabled
- DebugStore can be deprecated over time

**Impact of Wrong Choice**: Continuing to rely on DebugStore means debug only works in legacy mode.

### A2: Export UI Integration Point

**Question**: Where should export controls live in the UI?

**Options**:
1. **File menu** - "Export" submenu with format options
2. **Dedicated export panel** - Drawer/modal with settings
3. **Player controls** - Export button next to play/pause
4. **Right-click on canvas** - Context menu

**Current Implementation Guess**: No UI exists, no decision made.

**Recommended Choice**: Needs user input - UI/UX decision.

**Impact**: Determines export workflow and discoverability.

### A3: Export Determinism Guarantee

**Question**: What level of determinism guarantee should export provide?

**Context**: Math.random() is used in 3 places, seed randomness exists but not universally applied.

**Options**:
1. **Strict determinism** - Same patch + seed → bit-identical output (requires fixing all Math.random())
2. **Best-effort determinism** - Works for most patches, warn if non-deterministic blocks used
3. **No guarantee** - Export "what you see" but may vary

**Current Implementation Guess**: PRNG exists but not enforced.

**Recommended Choice**: **Option 1** - Strict determinism for export.

**Rationale**:
- Export is for final output, must be reproducible
- Audit shows only 3 Math.random() uses, easy to fix
- controlSurface/store.ts seed generation can use explicit seed
- Enables render farm parallelization in future

**Impact of Wrong Choice**: Users get different output each export, breaks trust.

### A4: Video Export Codec Selection

**Question**: Which video codecs should be supported?

**Context**: WebCodecs supports H.264, VP9, AV1 but browser support varies.

**Options**:
1. **H.264 only** - Widest compatibility, works everywhere
2. **H.264 + VP9** - Modern browsers, better quality
3. **H.264 + VP9 + AV1** - Future-proof, best compression

**Current Implementation Guess**: Not implemented.

**Recommended Choice**: **Option 2** - H.264 (default) + VP9 (advanced option).

**Rationale**:
- H.264 works in all browsers with WebCodecs
- VP9 provides better quality/size for users who need it
- AV1 encoder support still limited in browsers (2025)

**Impact**: Determines export quality and browser compatibility.

---

## Dependencies and Risks

### Dependencies

1. **DebugDisplay IR → TraceController integration**
   - StepDebugProbe ✅ (exists)
   - executeDebugProbe ✅ (exists)
   - lowerDebugDisplay ❌ (blocked)

2. **Export → Deterministic Replay**
   - Seeded PRNG ✅ (exists)
   - Math.random() audit ⚠️ (3 uses found)
   - State serialization ❌ (not implemented)

3. **Export → Canvas Renderer**
   - renderFrame() ✅ (exists)
   - OffscreenCanvas ✅ (browser API)

4. **Video Export → WebCodecs**
   - Browser support ⚠️ (Chrome/Edge yes, Firefox/Safari partial)
   - Muxing library ❌ (needs selection)

### Risks

| Risk | Severity | Likelihood | Mitigation |
|------|----------|------------|------------|
| **DebugDisplay IR throws error** | HIGH | CERTAIN | Implement lowerDebugDisplay (2-4 hours) |
| **Export determinism varies** | HIGH | LIKELY | Audit and fix Math.random() uses (2 hours) |
| **WebCodecs browser support** | MEDIUM | LIKELY | Detect support, fallback to image sequence |
| **Video muxing complexity** | MEDIUM | MEDIUM | Use existing library (MP4Box.js or similar) |
| **Export performance** | LOW | MEDIUM | Use OffscreenCanvas, Web Workers for encoding |
| **Signal history memory** | LOW | LOW | Ring buffer limits size (1000 samples default) |

---

## Test Suite Assessment

### Existing Tests

**Quality Score**: 4/5

| Question | Yes | No | Notes |
|----------|-----|-----|-------|
| If I delete implementation, do tests fail? | ✅ | | Debug tests exercise real logic |
| If I introduce bug, do tests catch it? | ✅ | | NaN/Inf detection, ring wrap, encoding roundtrips |
| Do tests exercise real user flows end-to-end? | | ❌ | Tests mock RuntimeCtx, no actual compiler/runtime |
| Do tests use real systems or mock everything? | | ❌ | Mock RuntimeCtx, isolated unit tests |
| Do tests cover error conditions? | ✅ | | Invalid indices, overwrites, mode switches |

**Test Coverage**:
- ✅ Debug infrastructure: 121 tests across 8 files
- ✅ Runtime executor: Tests for executeDebugProbe step
- ❌ DebugDisplay IR integration: NO TESTS (blocked by throw)
- ❌ Export pipeline: NO TESTS (not implemented)

**Missing Tests** (implementer should create):
1. **DebugDisplay IR lowering test** - Verify StepDebugProbe emission
2. **End-to-end debug flow test** - Patch with DebugDisplay → TraceController → UI display
3. **Image export determinism test** - Same seed → same PNG bytes
4. **Frame sequence correctness test** - Export 60 frames at 60fps = 1 second duration

---

## LLM Blind Spot Findings

### Pagination & Lists
- ✅ **Ring buffers**: Handle wrap-around correctly (tested)
- ❌ **Field visualization**: No handling for >1000 element domains (will need pagination/virtualization)

### State & Persistence
- ✅ **TraceController mode**: Persists across frames
- ❌ **Export state**: No serialization for pause/resume export

### Cleanup & Resources
- ✅ **Ring buffers**: Fixed size, no memory leaks
- ❌ **Export**: No cleanup for OffscreenCanvas, VideoEncoder resources (not implemented)

### Error Messages
- ✅ **DebugDisplay error**: Clear, explains workaround
- ⚠️ **Export errors**: Not implemented, unknown quality

### Edge Cases
- ✅ **TraceController off mode**: Zero overhead (tested)
- ❌ **Export at 0fps**: Not handled (not implemented)
- ❌ **Export with no frames**: Not handled (not implemented)

---

## Recommendations (Prioritized)

### Immediate (Do First)

1. **Implement DebugDisplay IR lowering** (2-4 hours)
   - Replace error throw with StepDebugProbe emission
   - Map inputs (signal/phase/domain/field) to slots
   - Assign probe IDs: `${instanceId}:${portId}`
   - Test with simple patch (Sine → DebugDisplay)

2. **Verify deterministic replay** (2 hours)
   - Audit Math.random() usage (3 locations found)
   - Fix controlSurface/store.ts seed generation
   - Create determinism test: same seed → same frames

3. **Connect DebugProbe UI** (3-4 hours)
   - Update ProbeCard to read from TraceController instead of DebugStore
   - Add probe toggle to enable/disable specific probes
   - Test with IR-compiled patch

### Short Term (Next Sprint)

4. **Implement image sequence export** (8-12 hours)
   - Create ImageSequenceExporter class
   - OffscreenCanvas rendering loop
   - PNG/WebP blob generation
   - File download or File System Access API
   - Progress callback + cancellation

5. **Add signal history visualization** (6-8 hours)
   - SignalHistoryBuffer (ring buffer for time-series)
   - SignalGraph component (canvas waveform)
   - Auto-scaling, grid rendering
   - Integration with ProbeCard

### Medium Term

6. **Implement video export** (12-16 hours)
   - Research muxing library options (MP4Box.js vs alternatives)
   - VideoExporter class with WebCodecs integration
   - Codec configuration (H.264, VP9)
   - Browser support detection + fallback

7. **Add field visualization** (8-10 hours)
   - FieldStats computation
   - FieldHeatmap component (canvas grid)
   - Colormap integration
   - Mode selection (text | heatmap | histogram)

### Long Term

8. **GIF export** (6-8 hours)
   - Select GIF library (gif.js or alternative)
   - Palette optimization
   - Dithering options
   - Web Worker integration

9. **Standalone player export** (8-10 hours)
   - HTML template generation
   - Runtime bundling strategy (inline vs CDN)
   - IR program serialization
   - Optional controls

10. **Runtime state inspector** (6-8 hours)
    - Snapshot capture function
    - RuntimeStateTree UI component
    - Slot metadata display
    - State buffer visualization

---

## Workflow Recommendation

**Status**: ✅ **CONTINUE** - Gaps are clear, implementer can proceed

**Next Actions**:
1. Implement DebugDisplay IR lowering (unblocks IR debugging)
2. Verify deterministic replay (prerequisite for export)
3. Implement image sequence export (validates export infrastructure)
4. Then proceed to video/GIF/standalone based on user priority

**Blocked Items**: None - all dependencies exist or are implementable

**Clarification Needed**:
- A2: Export UI integration point (user preference)
- A4: Video codec selection (H.264 only vs H.264+VP9)

---

## Files to Modify (Actionable List)

### DebugDisplay IR Lowering
1. `src/editor/compiler/blocks/debug/DebugDisplay.ts:33-39` - Replace throw with IR emission
2. `src/editor/compiler/ir/lowerTypes.ts` - May need probe ID helper
3. Tests: Create `src/editor/compiler/blocks/debug/__tests__/DebugDisplay.test.ts`

### Deterministic Replay Audit
1. `src/editor/controlSurface/store.ts` - Fix random seed generation
2. Tests: Create `src/editor/export/__tests__/determinism.test.ts`

### Image Sequence Export (New Files)
1. `src/editor/export/ImageSequenceExporter.ts` (new)
2. `src/editor/export/types.ts` (new)
3. `src/editor/components/ExportDialog.tsx` (new)
4. Tests: `src/editor/export/__tests__/ImageSequenceExporter.test.ts`

### Signal History
1. `src/editor/debug/SignalHistoryBuffer.ts` (new)
2. `src/editor/debug-ui/SignalGraph.tsx` (new)
3. `src/editor/debug/TraceController.ts` - Add history recording
4. Tests: `src/editor/debug/__tests__/SignalHistoryBuffer.test.ts`

---

## Summary

**Workstream 7 is 40% complete**:
- ✅ Debug infrastructure (75% done - infrastructure exists, needs IR integration)
- ❌ Export pipeline (0% done - not started)

**Critical Path**:
1. DebugDisplay IR lowering (2-4 hours) → unblocks IR debugging
2. Deterministic replay verification (2 hours) → prerequisite for export
3. Image sequence export (8-12 hours) → first export feature
4. Video export (12-16 hours) → most requested format

**Total Estimated Effort**: 60-80 hours for complete workstream

**Confidence in Estimates**: HIGH - Infrastructure exists, clear implementation path, tests exist for existing features.
