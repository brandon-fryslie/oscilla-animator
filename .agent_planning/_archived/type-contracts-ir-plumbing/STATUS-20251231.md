# Status Report - Type Contracts + IR Plumbing
**Date:** 2025-12-31
**Scope:** project/type-contracts-ir-plumbing
**Confidence:** FRESH

## Executive Summary

**Overall Status:** 50% complete | Critical TypeDesc unification gap remaining | Tests have minor failures (missing debugProbes field)

### Deliverable Status

| Deliverable | Status | Evidence |
|------------|--------|----------|
| 1. Unify TypeDesc | **NOT STARTED** | Two separate definitions exist with incompatible fields |
| 2. Adapter/Lens in Pass 6 | **COMPLETE** | Implemented in pass8 (commit e4143af) |
| 3. DefaultSource materialization | **PARTIAL** | Pass6 handles signal/field/scalar, Pass8 aligned |
| 4. Harden Pass 8 link resolution | **PARTIAL** | Error emission present, but not exhaustive |

## Recent Work Reuse

No previous evaluation found for this topic.

Recent relevant commits (last 2 weeks):
- `e4143af` (Dec 30): **Adapter/lens IR compilation** - Added `applyAdapterChain()` and `applyLensStack()` to pass8
- `6cd57ec` (Dec 30): **Bundle type system** - Extended IR TypeDesc with bundleKind/bundleArity
- `840c210` (Dec 28): **DefaultSource core types** - Added allowlist and type system

## Runtime Check Results

**Build Status:**
```
just check → FAIL
  - typecheck: FAIL (6 test files missing debugProbes field in BuilderProgramIR)
  - lint: Not run (blocked by typecheck)
  - test: Not run (blocked by typecheck)
```

**Typecheck Errors:**
- `src/editor/compiler/ir/__tests__/state-offset-resolution.test.ts` - 6 occurrences of missing `debugProbes` field

## Missing Checks

The plan specifies validation using Chrome DevTools MCP, but this is not a persistent check. Implementer should create:

1. **Type unification validation** - Script to verify TypeDesc fields match across editor and compiler
2. **Adapter/lens IR test** - Test that verifies adapters/lenses produce correct IR nodes
3. **DefaultSource IR test** - Test that verifies all three worlds (signal/field/scalar) materialize correctly

## Findings

### [FRESH] 1. TypeDesc Unification - NOT STARTED

**Status:** NOT_STARTED
**Evidence:**
- Editor TypeDesc: `/Users/bmf/code/oscilla-animator_codex/.worktrees/ir-backlog-01-type-contracts/src/editor/types.ts:148-166`
- Compiler IR TypeDesc: `/Users/bmf/code/oscilla-animator_codex/.worktrees/ir-backlog-01-type-contracts/src/editor/compiler/ir/types.ts:171-206`

**Critical Incompatibilities:**

| Field | Editor TypeDesc | Compiler IR TypeDesc | Impact |
|-------|----------------|---------------------|---------|
| `world` | `'signal' \| 'event' \| 'field' \| 'scalar' \| 'config'` | `"signal" \| "field" \| "scalar" \| "event" \| "special"` | **BREAKING** - Different union members |
| `domain` | `Domain` (46+ values) | `TypeDomain` (25+ values) | **DRIFT** - Different domain vocabularies |
| `category` | Required (`'core' \| 'internal'`) | **Missing** | **INCOMPATIBLE** - Not in IR TypeDesc |
| `busEligible` | Required (boolean) | **Missing** | **INCOMPATIBLE** - Not in IR TypeDesc |
| `bundleKind` | **Missing** | Optional (BundleKind) | **DRIFT** - IR-specific extension |
| `bundleArity` | Optional (number) | **Missing** | **DRIFT** - IR-specific extension |
| Mutability | All fields `readonly` | All fields mutable | **STYLE** - Different mutability contracts |

**Why This Matters:**
- Code importing from different locations gets incompatible types
- Adapters/lenses may fail type checks when crossing boundaries
- Bus eligibility checks fail in compiler (field not present)
- Bundle types (vec2/vec3/color) work differently in editor vs compiler

**Missing from Plan:**
The plan says "re-export TypeDesc from `src/editor/types.ts`" but doesn't address the fundamental incompatibility. These are **different type contracts** - not just duplicates. We need a migration strategy:

**Option A:** Make IR TypeDesc extend Editor TypeDesc
- Add `category`, `busEligible` to IR TypeDesc
- Keep `bundleKind`/`bundleArity` as IR-specific extensions
- Align `world` and `domain` unions

**Option B:** Create unified TypeDesc in shared location
- New file: `src/core/types.ts` or `src/shared/types.ts`
- Both editor and compiler import from there
- Requires migrating both definitions

**Option C:** Keep separate, add explicit conversion functions
- Accept that editor and compiler have different type contracts
- Add `editorTypeToIR(t: EditorTypeDesc): IRTypeDesc`
- Add `irTypeToEditor(t: IRTypeDesc): EditorTypeDesc`

**Recommendation:** PAUSE - This ambiguity blocks implementation. Need to clarify:
1. Should bundles be in the unified TypeDesc or IR-only?
2. Should busEligible/category be in compiler TypeDesc?
3. Which world union is authoritative (`config` vs `special`)?

### [FRESH] 2. Adapter + Lens Application - COMPLETE

**Status:** COMPLETE
**Evidence:** `src/editor/compiler/passes/pass8-link-resolution.ts:390-670`

**Implementation Details:**
- `applyAdapterChain()` - Lines 398-450
  - Iterates adapter chain
  - Calls `adapterDef.compileToIR(valueRef, irCtx)`
  - Emits `UnsupportedAdapterInIRMode` errors for missing implementations
  - Returns transformed ValueRefPacked

- `applyLensStack()` - Lines 460-520
  - Iterates lens stack
  - Converts literal params to scalarConst ValueRefs
  - Calls `lensDef.compileToIR(valueRef, paramsMap, irCtx)`
  - Emits `UnsupportedLensInIRMode` errors for missing implementations
  - Returns transformed ValueRefPacked

**Applied in two locations:**
1. Wire resolution (lines 599-620) - adapter chain → lens stack

**Limitations (documented in code):**
- Only literal lens params supported (line 501 TODO: bus/wire bindings)
- Adapters/lenses without `compileToIR` emit errors (graceful degradation)

**Assessment:** ✅ COMPLETE - Matches plan requirements. The TODO is a future enhancement, not a gap.

### [FRESH] 3. DefaultSource Materialization - PARTIAL

**Status:** PARTIAL
**Evidence:**
- Pass6: `src/editor/compiler/passes/pass6-block-lowering.ts:308-342`
- Pass8: `src/editor/compiler/passes/pass8-link-resolution.ts:155-185`

**Pass6 Implementation (during block lowering):**

```typescript
// Lines 308-342: defaultSource handling in pass6
if (portDecl?.defaultSource !== undefined) {
  const type = portDecl.type;
  const value = portDecl.defaultSource.value;

  if (type.world === 'signal') {
    // Signal: sigConst + allocValueSlot + registerSigSlot
    const numValue = typeof value === 'number' ? value : ...;
    const sigId = builder.sigConst(numValue, type);
    const slot = builder.allocValueSlot(type);
    builder.registerSigSlot(sigId, slot);
    return { k: "sig", id: sigId, slot };
  } else if (type.world === 'field') {
    // Field: fieldConst + allocValueSlot + registerFieldSlot
    const fieldId = builder.fieldConst(value as number, type);
    const slot = builder.allocValueSlot(type);
    builder.registerFieldSlot(fieldId, slot);
    return { k: "field", id: fieldId, slot };
  } else if (type.world === 'scalar') {
    // Scalar: allocConstId
    const constId = builder.allocConstId(value);
    return { k: "scalarConst", constId };
  } else if (type.world === 'special' && type.domain === 'domain') {
    // Special handling for domain
    const count = typeof value === 'number' ? value : Number(value);
    const safeCount = Number.isFinite(count) ? Math.max(0, Math.floor(count)) : 0;
    const domainSlot = builder.domainFromN(safeCount);
    return { k: "special", tag: "domain", id: domainSlot };
  }
}
```

**Pass8 Implementation (createDefaultRef helper):**

```typescript
// Lines 155-185: createDefaultRef in pass8
function createDefaultRef(
  builder: IRBuilder,
  type: TypeDesc,
  defaultValue: unknown
): ValueRefPacked | null {
  if (type.world === "signal") {
    if (typeof defaultValue !== "number") {
      // Non-number signal values → constant pool
      const constId = builder.allocConstId(defaultValue);
      return { k: "scalarConst", constId };
    }
    const sigId = builder.sigConst(defaultValue, type);
    const slot = builder.allocValueSlot(type);
    builder.registerSigSlot(sigId, slot);
    return { k: "sig", id: sigId, slot };
  }

  if (type.world === "field") {
    const fieldId = builder.fieldConst(defaultValue, type);
    const slot = builder.allocValueSlot(type);
    builder.registerFieldSlot(fieldId, slot);
    return { k: "field", id: fieldId, slot };
  }

  if (type.world === "scalar") {
    const constId = builder.allocConstId(defaultValue);
    return { k: "scalarConst", constId };
  }

  return null; // Unsupported world
}
```

**Consistency Analysis:**

| World | Pass6 | Pass8 | Aligned? |
|-------|-------|-------|----------|
| Signal (number) | sigConst + slot | sigConst + slot | ✅ YES |
| Signal (non-number) | Coerce to number | Use const pool | ⚠️ **DIFFERENT** |
| Field | fieldConst + slot | fieldConst + slot | ✅ YES |
| Scalar | allocConstId | allocConstId | ✅ YES |
| Special/domain | domainFromN | Not supported | ⚠️ **DIFFERENT** |

**Issues:**

1. **Signal non-numeric handling differs:**
   - Pass6: Coerces `value` to number (lines 316), could lose information
   - Pass8: Uses const pool for non-numeric (lines 164-167), preserves value
   - **Recommendation:** Align on const pool approach for consistency

2. **Special/domain only in Pass6:**
   - Pass6 has special case for `world === 'special' && domain === 'domain'` (lines 335-341)
   - Pass8's `createDefaultRef` returns `null` for special types (line 186)
   - **Impact:** Domain defaults only work if resolved in Pass6, not Pass8
   - **Recommendation:** Add special/domain case to Pass8 or document why it's Pass6-only

3. **Shared helper not implemented:**
   - Plan step 3 says "Add a single shared helper used by both pass6 and pass8"
   - Current state: Two separate implementations with slight differences
   - **Recommendation:** Extract to `src/editor/compiler/ir/defaultSourceUtils.ts`

**Assessment:** ⚠️ PARTIAL - Works for most cases but has inconsistencies. Not following plan's "shared helper" recommendation.

### [FRESH] 4. Harden Pass 8 Link Resolution - PARTIAL

**Status:** PARTIAL
**Evidence:** `src/editor/compiler/passes/pass8-link-resolution.ts:586-729`

**Error Detection Present:**

| Error Case | Detected? | Error Code | Location |
|-----------|-----------|------------|----------|
| Wire to unknown block | ✅ YES | `DanglingConnection` | Line 588-592 |
| Missing required input (no wire/bus/default) | ✅ YES | `MissingInput` | Line 725-729 |
| Render block missing input | ✅ YES | `MissingInput` | Line 246-250, 324-330 |

**Error Metadata Quality:**

All errors include:
- `code`: Diagnostic error code (string)
- `message`: Human-readable explanation
- `where`: Context object with `blockId` and sometimes `port`

**Gaps:**

1. **Output slot validation missing:**
   - Plan says "Output slots missing registrations"
   - Current: No validation that outputs are properly registered
   - **Evidence:** No grep matches for "output.*missing.*registration" or similar
   - **Impact:** Downstream blocks could reference unregistered outputs and fail silently

2. **Bus root validation missing:**
   - Current: Bus roots are created but not validated
   - **Evidence:** No validation in `pass7-bus-lowering.ts` or pass8

3. **Null/undefined ValueRef validation:**
   - Plan says "Inputs that resolve to null/undefined ValueRefs"
   - Current: Wires check for `undefined` (line 625-628), but this is NOT an error
   - **Evidence:** Comment says "expected for non-IR types (Domain, Event, etc.) - NOT an error"
   - **Ambiguity:** Is this intentional or should some nulls be errors?

**Assessment:** ⚠️ PARTIAL - Basic error detection works, but missing validation for:
- Output registration
- Distinguishing intentional null (non-IR types) from problematic null (missing data)

## Data Flow Verification

**Not applicable** - This workstream is about type contracts and IR plumbing, not end-to-end data flows.

## Ambiguities Found

| Area | Question | How It Was Guessed | Impact |
|------|----------|-------------------|--------|
| **TypeDesc unification** | Which TypeDesc definition is authoritative? Should bundles be unified or IR-only? | Two separate definitions evolved independently | Type incompatibility across compiler boundaries |
| **Signal non-numeric defaults** | Should non-numeric signal defaults coerce to 0 or use const pool? | Pass6 coerces, Pass8 uses const pool | Inconsistent default materialization |
| **Special/domain defaults** | Should createDefaultRef support special/domain types? | Only Pass6 handles it | Domain defaults might fail in Pass8 resolution path |
| **Null outputs** | Are null/undefined outputs always an error or sometimes expected? | Code comment says "expected for non-IR types" | Unclear when to emit errors vs silently skip |

## Test Suite Assessment

**Cannot assess** - Tests fail typecheck due to missing `debugProbes` field. Once fixed, tests should verify:
- Adapter/lens IR compilation (likely already covered by recent work)
- DefaultSource materialization across all three worlds
- Error emission for missing inputs/outputs

## Recommendations

### Priority 1: PAUSE for TypeDesc Clarification (BLOCKING)

**Why:** Two incompatible TypeDesc definitions exist. Cannot proceed with unification without deciding:
1. Which `world` union is correct (`config` vs `special`)?
2. Should `bundleKind`/`bundleArity` be in unified TypeDesc or remain IR-only?
3. Should `category`/`busEligible` exist in compiler TypeDesc?

**Options:**
- **A:** Extend IR TypeDesc with editor fields (add category, busEligible)
- **B:** Create new shared TypeDesc in `src/core/types.ts`
- **C:** Keep separate, add explicit conversion functions

**Recommendation:** Option B (shared location) is cleanest but requires most migration work.

### Priority 2: Fix test failures (UNBLOCKING)

**Action:** Add `debugProbes` field to test mocks in `state-offset-resolution.test.ts`
**Impact:** Unblocks typecheck → lint → test pipeline
**Estimate:** 10 minutes

### Priority 3: Align defaultSource implementations

**Action:** Extract shared helper to `src/editor/compiler/ir/defaultSourceUtils.ts`:
```typescript
export function materializeDefaultSource(
  builder: IRBuilder,
  type: TypeDesc,
  value: unknown
): ValueRefPacked | null {
  // Unified implementation for pass6 and pass8
}
```

**Changes needed:**
- Align signal non-numeric handling (use const pool, not coercion)
- Add special/domain support to pass8 path (or document why it's Pass6-only)

### Priority 4: Complete Pass 8 validation

**Action:** Add missing validations:
1. Validate output slots are registered (iterate blockOutputRoots, check registrations)
3. Document when null ValueRefs are expected vs errors

## Workflow Recommendation

**⚠️ PAUSE** - TypeDesc unification ambiguity needs resolution before implementation can proceed safely.

**Questions for User:**

1. **TypeDesc unification strategy** - Which option (A/B/C) should we pursue?
2. **Bundle types** - Should `bundleKind`/`bundleArity` be in the unified TypeDesc or remain IR-specific?
3. **Bus metadata** - Should `category`/`busEligible` exist in the compiler's TypeDesc?
4. **World union** - Is `config` (editor) or `special` (compiler) the correct world type? Or both?

Once clarified, implementation can proceed:
1. Fix test failures (Priority 2) - quick unblock
2. Implement TypeDesc unification (Deliverable 1)
3. Align defaultSource (Priority 3)
4. Complete Pass 8 validation (Priority 4)

---

**Agent:** project-evaluator | 2025-12-31
**Evaluation Cache:** No cache updates (fresh evaluation)
