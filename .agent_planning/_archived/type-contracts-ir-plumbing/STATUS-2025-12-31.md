# Status Report - Type Contracts + IR Plumbing
Timestamp: 2025-12-31-01:45:00
Scope: module/type-contracts-ir-plumbing
Confidence: FRESH
Git Commit: 455d9be
Files in Scope: 8 files

## Executive Summary
Overall: **40% complete** | Critical issues: **3** | Tests reliable: **partial (5 type errors)**

**Key Finding**: Type system divergence is WORSE than plan describes. Not just world naming ('config' vs 'special'), but ENTIRE TypeDesc structure is different between editor and IR.

## Critical Type Divergence Issues

### Issue 1: Dual TypeDesc Definitions (BLOCKING)

**Editor TypeDesc** (`src/editor/types.ts:148-166`):
```typescript
interface TypeDesc {
  world: 'signal' | 'event' | 'field' | 'scalar' | 'config';
  domain: Domain; // CoreDomain | InternalDomain
  category: 'core' | 'internal';
  busEligible: boolean;
  semantics?: string;
  unit?: string;
}
```

**IR TypeDesc** (`src/editor/compiler/ir/types.ts:171-206`):
```typescript
interface TypeDesc {
  world: 'signal' | 'field' | 'scalar' | 'event' | 'special';
  domain: TypeDomain; // Different enum entirely
  bundleKind?: BundleKind;  // NOT in editor version
  bundleArity?: number;     // NOT in editor version
  semantics?: string;
  unit?: string;
}
```

**Incompatibilities**:
1. ❌ `world` has different values: editor has 'config', IR has 'special'
2. ❌ `domain` uses completely different enums:
   - Editor: 90+ domains including 'expression', 'waveform', 'phaseSample', 'cameraRef'
   - IR: ~30 domains including 'timeMs', 'unknown', 'mesh', 'camera', 'quat', 'mat4'
3. ❌ Editor has `category` and `busEligible` fields - IR lacks them
4. ❌ IR has `bundleKind` and `bundleArity` - editor lacks them
5. ❌ Different domain values: editor has 'time', IR has 'timeMs'

**Evidence**:
- `src/editor/adapters/AdapterRegistry.ts:6` imports BOTH: `import type { TypeDesc as IRTypeDesc } from '../compiler/ir/types'`
- 19 files in compiler/ir import TypeDesc from local ir/types.ts
- Bridge code exists using separate imports, proving incompatibility

**Impact**: Adapters can't work correctly because they need to match types across the boundary.

### Issue 2: TypeWorld Mismatch Creates Silent Bugs

**Where 'config' is used** (editor):
```
src/editor/ir/types/typeConversion.ts:60-75 (12 usages)
  'Domain': { world: 'config', domain: 'domain' }
  'PhaseMachine': { world: 'config', domain: 'phaseMachine' }
  'TargetScene': { world: 'config', domain: 'sceneTargets' }
  ...
```

**Where 'special' is used** (IR):
```
src/editor/compiler/ir/types.ts:25: world: "special"
src/editor/compiler/passes/pass6-block-lowering.ts:335: type.world === 'special'
src/editor/compiler/passes/pass8-link-resolution.ts:187: type.world === "special"
```

**Silent Bug**:
When pass6 checks `type.world === 'special'` for domain defaults, it WILL NOT MATCH editor types that have `world: 'config'`. This means defaultSource materialization is **broken for config-world types**.

**Evidence**:
- `pass6-block-lowering.ts:335-341` handles 'special' + 'domain', but incoming types from editor have 'config' + 'domain'
- No compiler errors because TypeScript sees them as compatible (structural typing)
- Runtime: defaults fail silently or use wrong fallback

### Issue 3: Domain Enum Incompatibility

**Editor domains NOT in IR**:
- 'expression', 'waveform', 'phaseSample', 'phaseMachine', 'wobble', 'spiral', 'wave', 'jitter'
- 'sceneTargets', 'sceneStrokes', 'elementCount', 'cameraRef', 'spec'

**IR domains NOT in Editor**:
- 'timeMs' (editor uses 'time'), 'unknown', 'mesh', 'camera', 'quat', 'mat4', 'vec4'

**Impact**: Type matching in adapters will fail. Types cross the boundary incorrectly.

## Deliverable Status

### 1) Unify TypeDesc ❌ NOT STARTED

**Status**: NOT_STARTED
**Blocker**: WORSE than plan assumed - not just naming, but STRUCTURE incompatibility

**What Plan Said**:
> Update `src/editor/compiler/ir/types.ts:16-84` to re-export TypeDesc from `src/editor/types.ts`

**Reality**:
- Can't just re-export - the types have incompatible fields
- Bundle system (bundleKind/bundleArity) only exists in IR
- Editor has category/busEligible, IR doesn't
- Must choose: extend editor type or migrate IR to use editor's

**Options**:
1. **Extend editor TypeDesc** to include bundleKind/bundleArity (optional fields)
2. **Dual-phase migration**: Keep separate types, create explicit conversion utilities
3. **Unify to IR version**: Remove category/busEligible from editor, add bundleKind everywhere

**Missing from Plan**:
- Domain enum unification strategy
- Migration path for existing code using IR TypeDesc
- How to handle bundle types in editor layer

### 2) Enforce adapter + lens application in Pass 6 ⚠️ PARTIAL

**Status**: PARTIAL
**Evidence**: Pass 8 applies them, Pass 6 does NOT

**Pass 8 (WORKING)**: `pass8-link-resolution.ts:598-618`
```typescript
if (ref !== undefined) {
  // Apply adapter chain if present
  if (wire.adapterChain !== undefined && wire.adapterChain.length > 0) {
    ref = applyAdapterChain(ref, wire.adapterChain, builder, errors, context);
  }
  // Apply lens stack if present
  if (wire.lensStack !== undefined && wire.lensStack.length > 0) {
    ref = applyLensStack(ref, wire.lensStack, builder, errors, context);
  }
  refs[flatIdx] = ref;
}
```

**Pass 6 (MISSING)**: `pass6-block-lowering.ts:296-351`
- No adapter application code
- No lens application code
- Only defaultSource materialization

**Gap**: Pass 6 creates initial ValueRefs for block inputs from compiledPortMap (artifact-based). These ValueRefs should have adapters/lenses applied BEFORE being passed to block lowering functions, but they don't.

**Why This Matters**:
- Block lowering sees raw upstream types, not adapted types
- Type mismatches aren't caught at lowering time
- Adapters only apply at link resolution (pass 8), too late for block compilers

**What Needs to Happen**:
1. In `pass6-block-lowering.ts:296-306`, after getting artifact from compiledPortMap
2. Check if wire has adapterChain/lensStack
3. Apply transformations before calling artifactToValueRef
4. Or: apply transformations after artifactToValueRef but before passing to block lowering

**Blocker**: Need wire information in Pass 6 (currently only in Pass 8)

### 3) DefaultSource materialization consistency ⚠️ PARTIAL

**Status**: PARTIAL (works for numeric signal/field/scalar, broken for 'config'/'special' types)

**Pass 6 Implementation**: `pass6-block-lowering.ts:308-343`
```typescript
const portDecl = blockType.inputs[portIndex];
if (portDecl?.defaultSource !== undefined) {
  const type = portDecl.type;
  const value = portDecl.defaultSource.value;

  if (type.world === 'signal') {
    // ✅ Creates sigConst, allocates slot, registers
  } else if (type.world === 'field') {
    // ✅ Creates fieldConst, allocates slot, registers
  } else if (type.world === 'scalar') {
    // ✅ Allocates const pool entry
  } else if (type.world === 'special' && type.domain === 'domain') {
    // ⚠️ Handles domain type
  }
}
```

**Pass 8 Implementation**: `pass8-link-resolution.ts:155-197` (createDefaultRef)
```typescript
function createDefaultRef(builder, type, defaultValue) {
  if (type.world === "signal") { /* matches pass6 */ }
  if (type.world === "field") { /* matches pass6 */ }
  if (type.world === "scalar") { /* matches pass6 */ }
  if (type.world === "special" && type.domain === "domain") { /* matches pass6 */ }
  return null; // ❌ Other types unhandled
}
```

**✅ What Works**:
- Signal defaults (numeric): sigConst + slot registration
- Field defaults (numeric): fieldConst + slot registration
- Scalar defaults: const pool allocation
- Domain defaults: domainFromN with count validation

**❌ What Breaks**:
- **'config' world types**: Pass 6 checks for `world === 'special'`, editor types have `world === 'config'`
- **Non-numeric signal defaults**: Pass 6 coerces to number (line 316), losing type information
- **Special domains other than 'domain'**: No handling for renderTree, program, etc.

**Evidence of Breakage**:
- `pass6-block-lowering.ts:335`: Explicitly checks `type.world === 'special'`
- Editor blocks define defaults with `world: 'config'` (typeConversion.ts:60-75)
- Result: These defaults fall through to error case (line 345)

**Consistency Issue**:
- Pass 6 and Pass 8 logic is duplicated (not shared helper)
- Different error handling: Pass 6 throws, Pass 8 returns null
- No test coverage for edge cases (non-numeric signals, config types)

### 4) Harden Pass 8 link resolution ✅ COMPLETE

**Status**: COMPLETE
**Evidence**: Strong error handling exists

**Validation for unresolved inputs**: `pass8-link-resolution.ts:679-700`
```typescript
// After all resolution attempts, check for missing inputs
if (refs[flatIdx] === undefined) {
  const portDecl = blockDecl?.inputs[portIdx];

  // If port has no default source, it's a hard error
  if (portDecl?.defaultSource === undefined) {
    errors.push({
      code: "MissingInput",
      where: { blockId: block.id, portId: input.id },
    });
  } else {
    // Create default ref
    const defaultRef = createDefaultRef(builder, portDecl.type, portDecl.defaultSource.value);
    if (defaultRef !== null) {
      refs[flatIdx] = defaultRef;
    } else {
      // Default source failed to materialize
      errors.push({
        code: "InvalidDefaultSource",
        message: `Default source for ${block.type}.${input.id} could not be materialized to IR`,
        where: { blockId: block.id, portId: input.id },
      });
    }
  }
}
```

**✅ Strong points**:
- Unresolved inputs → compile error with blockId/portId
- Default source failures → explicit error
- Dangling connections → error (line 588-592)
- Missing upstream blocks → error

**⚠️ Weak points**:
- Output slot validation: NOT checked (assumes pass6 registered correctly)
- Bus roots validation: NOT checked (assumes pass7 created correctly)
- Adapter/lens failures: Continue with original value (lines 428, 447, 514) - should this be harder error?

**Verdict**: Core requirement met, but could be stricter.

## Runtime Check Results

### Existing Checks

| Check | Status | Output Summary |
|-------|--------|----------------|
| `just check` | **FAIL** | 6 type errors in state-offset-resolution.test.ts |
| `just typecheck` | **FAIL** | Missing `debugProbes` field in test fixtures |
| `just lint` | **NOT RUN** | (blocked by typecheck) |
| `just test` | **NOT RUN** | (blocked by typecheck) |

**Test Failures** (`state-offset-resolution.test.ts`):
```
Lines 84, 143, 206, 249, 307, 371:
  Property 'debugProbes' is missing in type '{ signalIR: ..., fieldIR: ..., ... }'
  but required in type 'BuilderProgramIR'
```

**NOT related to type contracts** - this is a test fixture issue from adding debugProbes to IR schema.

### Missing Checks

**Per plan validation** (plan section "Validation (No Tests)"):
> Use Chrome DevTools MCP to load a patch with:
> - An adapted wire (number -> phase01)
> - A lens on a wire (scale/bias)
> - Unconnected optional inputs with defaultSource

**Status**: ❌ NOT CREATED

No persistent runtime checks exist for:
1. Adapter application verification (does number→phase01 adapter work?)
2. Lens application verification (does scale lens work?)
3. DefaultSource materialization (do unconnected inputs get defaults?)
4. Type world mismatch detection (config vs special)

**Implementer Should Create**:
1. **Adapter smoke test**: Create patch with number→vec2 adapter, verify IR has correct transform node
2. **Lens smoke test**: Create patch with scale lens, verify IR has sigScale node
3. **DefaultSource test**: Create patch with unconnected optional input, verify IR has sigConst/fieldConst
4. **Type boundary test**: Create block with 'config' type default, verify it materializes (catches world mismatch)

## Data Flow Verification

### Type Boundary Crossing

| Flow | Editor → IR | IR Internal | IR → Runtime |
|------|-------------|-------------|--------------|
| **TypeDesc propagation** | ❌ BROKEN | ✅ OK | ⚠️ RISKY |
| **Adapter lookup** | ❌ BROKEN | N/A | N/A |
| **DefaultSource** | ❌ BROKEN | ✅ OK | ⚠️ RISKY |

**Editor → IR (BROKEN)**:
- Editor creates TypeDesc with 'config' world
- IR expects 'special' world
- No conversion happens
- Silent type mismatch

**IR Internal (OK)**:
- IR consistently uses its own TypeDesc
- Bundle types work correctly
- Type propagation through passes works

**IR → Runtime (RISKY)**:
- Runtime assumes TypeDesc is correct
- If wrong type reaches runtime, behavior undefined
- No runtime validation of type correctness

### Adapter Application Flow

| Step | Pass 6 | Pass 8 | Status |
|------|--------|--------|--------|
| **Wire adapters** | ❌ Not applied | ✅ Applied | GAP |
| **Lens transforms** | ❌ Not applied | ✅ Applied | GAP |
| **Bus adapters** | N/A | ✅ Applied | OK |
| **Error handling** | N/A | ⚠️ Warns, continues | WEAK |

**Gap**: Adapters only apply in Pass 8, after block lowering. Block compilers see unadapted types.

## Ambiguities Found

| Area | Question | How LLM Guessed | Impact |
|------|----------|-----------------|--------|
| **TypeDesc unification** | Should editor or IR TypeDesc be canonical? | Plan assumes IR re-exports editor, but they're incompatible | Can't proceed with unification without decision |
| **Bundle types** | Should editor layer know about bundles? | IR added bundleKind/bundleArity, editor doesn't have them | Type matching breaks at boundary |
| **'config' vs 'special'** | Are these the same concept or different? | Treated as equivalent in some places, different in others | Silent bugs in defaultSource |
| **Domain unification** | Which domain values should exist? | IR has ~30, editor has 90+, overlap is partial | Type conversions will fail |
| **Adapter timing** | Should adapters apply in Pass 6 or Pass 8? | Plan says Pass 6, implementation has Pass 8 | Type errors caught late |

## Recommendations

### Critical Path (Must Do First)

1. **DECIDE: TypeDesc canonical source**
   - Option A: Extend editor TypeDesc with optional bundle fields, IR imports it
   - Option B: Keep separate, create explicit TypeDesc conversion utilities
   - Option C: Unify domain enums first, then tackle structure
   - **Blocker**: Can't unify until this is decided

2. **FIX: 'config' vs 'special' world**
   - Immediate: Add type conversion at editor/IR boundary
   - OR: Change all editor 'config' to 'special' (breaking change)
   - OR: Change all IR 'special' to 'config' (less breaking)
   - **Impact**: Fixes defaultSource materialization

3. **CREATE: Type boundary tests**
   - Test that proves config→special conversion works
   - Test that proves domains match across boundary
   - Test that proves adapters see correct types
   - **Why**: Catch silent type mismatches early

### Implementation Order (After Critical Path)

4. **Pass 6 adapter application** (Deliverable 2)
   - Requires: wire information in Pass 6 context
   - Add applyAdapterChain/applyLensStack calls in Pass 6
   - Ensure block lowering sees adapted types

5. **Shared defaultSource helper** (Deliverable 3)
   - Extract common logic from Pass 6 and Pass 8
   - Handle all type worlds consistently
   - Test with non-numeric types

6. **Stricter Pass 8 validation** (Deliverable 4)
   - Add output slot registration checks
   - Add bus root validation
   - Consider making adapter/lens failures hard errors

### Non-Blocking Improvements

7. **Fix test fixtures** (debugProbes field)
8. **Domain enum audit** - document which domains should exist
9. **Bundle type documentation** - explain when bundleKind is needed

## Workflow Recommendation

**❌ PAUSE** - Ambiguities need clarification before proceeding

### Questions Needing Answers

**Question 1: TypeDesc unification strategy**
**Context**: Editor and IR have incompatible TypeDesc structures
**Options**:
- **Option A**: Extend editor TypeDesc
  - Add `bundleKind?: BundleKind` and `bundleArity?: number` as optional fields
  - IR imports from editor, sets bundle fields
  - PROS: Single source of truth, editor controls schema
  - CONS: Editor layer gains bundle knowledge it may not need

- **Option B**: Separate with conversion
  - Keep editor TypeDesc and IR TypeDesc separate
  - Create explicit `toIRTypeDesc(editorType)` and `toEditorTypeDesc(irType)` functions
  - PROS: Clean separation, no layer violation
  - CONS: Conversion overhead, two schemas to maintain

- **Option C**: IR TypeDesc is canonical
  - Remove editor TypeDesc, everything uses IR version
  - Add `category` and `busEligible` to IR TypeDesc
  - PROS: Compiler-first design, bundle types everywhere
  - CONS: Editor layer depends on compiler types (architectural violation)

**Impact of wrong choice**:
- Option A chosen but bundle types leak into editor UI → confusing UX
- Option B chosen but conversions missed → silent type bugs
- Option C chosen → circular dependencies, editor can't run without compiler

**Question 2: 'config' vs 'special' world**
**Context**: Same semantic concept has two different names
**Options**:
- **Option A**: 'config' is canonical, change IR
- **Option B**: 'special' is canonical, change editor
- **Option C**: They're different - 'config' = compile-time only, 'special' = runtime resource

**Impact**: Affects 60+ type definitions, defaultSource materialization, adapter matching

**Question 3: Adapter application timing**
**Context**: Plan says Pass 6, implementation has Pass 8
**Options**:
- **Option A**: Move to Pass 6 (plan wins)
  - PROS: Block compilers see adapted types
  - CONS: Needs wire data in Pass 6

- **Option B**: Keep in Pass 8 (status quo)
  - PROS: Works now, wire data available
  - CONS: Block compilers can't rely on adapted types

**Impact**: Affects when type mismatches are caught, adapter test strategy

---

## Files Requiring Changes

### Unification (Deliverable 1)
- `src/editor/types.ts` - Canonical TypeDesc (if Option A/B)
- `src/editor/compiler/ir/types.ts` - Import or convert (if Option A/B)
- `src/editor/ir/types/TypeDesc.ts` - Another editor TypeDesc? (needs investigation)
- `src/editor/adapters/AdapterRegistry.ts:6` - Remove dual import
- ~19 files in `src/editor/compiler/ir/` importing TypeDesc

### Adapter Application (Deliverable 2)
- `src/editor/compiler/passes/pass6-block-lowering.ts:296-351` - Add adapter/lens application

### DefaultSource Consistency (Deliverable 3)
- `src/editor/compiler/passes/pass6-block-lowering.ts:308-343` - Extract to shared helper
- `src/editor/compiler/passes/pass8-link-resolution.ts:155-197` - Use shared helper
- Create `src/editor/compiler/ir/defaultSourceHelpers.ts` (new file)

### Link Resolution Hardening (Deliverable 4)
- `src/editor/compiler/passes/pass8-link-resolution.ts` - Add output/bus validation (optional - already strong)

---

## Eval Cache Updates

Created:
- `type-contracts-divergence.md` - Documents the dual TypeDesc problem
- `adapter-application-status.md` - Documents Pass 6 vs Pass 8 gap
- Updated INDEX.md

Confidence: HIGH (based on direct file inspection)

---

## Next Action

**REQUIRED: User decision on 3 questions above before implementation can proceed**

After decisions made:
1. Create type boundary conversion (if needed)
2. Fix 'config'/'special' mismatch
3. Add adapter application to Pass 6
4. Extract shared defaultSource helper
5. Create runtime validation tests
