# Phase 0 Architecture Refactoring - Status Report

**Date**: 2025-12-31
**Evaluator**: project-evaluator
**Scope**: All 4 Phase 0 topics (unify-connections-edge, unify-default-sources-blocks, v2-adapter-implementation, unify-lenses-adapters)
**Confidence**: FRESH (evaluated 2025-12-31)
**Git Commit**: 4df9c1f

---

## Executive Summary

**Overall Status**: NOT STARTED (0% complete)
**Critical Issues**: 4 major refactors needed before IR compiler can be functional
**Test Quality**: 302 test files exist, but none specifically for Phase 0 refactors
**Workflow Recommendation**: **CONTINUE** - Requirements are clear, implementation can proceed


---

## Topic 1: unify-connections-edge [NOT STARTED]

### Current State (The Problem)

**Three separate types handling connections:**

```typescript
// src/editor/types.ts:576-594
interface Connection {
  readonly id: string;
  readonly from: PortRef;           // block output
  readonly to: PortRef;             // block input
  readonly lensStack?: LensInstance[];
  readonly adapterChain?: AdapterStep[];
  readonly enabled?: boolean;
}

// src/editor/types.ts:207-231
  readonly id: string;
  readonly busId: string;           // target bus
  readonly from: PortRef;           // block output
  readonly adapterChain?: AdapterStep[];
  readonly lensStack?: LensInstance[];
  readonly weight?: number;
  enabled: boolean;
  sortKey: number;
}

// src/editor/types.ts:236-254
  readonly id: string;
  readonly busId: string;           // source bus
  readonly to: PortRef;             // block input
  readonly adapterChain?: AdapterStep[];
  readonly lensStack?: LensInstance[];
  enabled: boolean;
}
```

**Evidence location**: `src/editor/types.ts` lines 207-254, 576-594

### Compiler Pass Complexity

Every compiler pass has to handle three connection types separately:

**Pass 2 (Type Graph)**: `src/editor/compiler/passes/pass2-types.ts`
- Different code paths for each connection type

**Pass 6 (Block Lowering)**: `src/editor/compiler/passes/pass6-block-lowering.ts`
- Three-way logic duplicated throughout

**Pass 7 (Bus Lowering)**: `src/editor/compiler/passes/pass7-bus-lowering.ts`

**Pass 8 (Link Resolution)**: `src/editor/compiler/passes/pass8-link-resolution.ts`
- Connects IR fragments from all three sources
- Separate resolution paths

### Patch Storage

**PatchStore manages three arrays:**
```typescript
// src/editor/stores/PatchStore.ts:48-49
connections: Connection[] = [];
```

### Target State

**Unified Edge type (from spec):**
```typescript
type Endpoint =
  | { kind: 'port'; blockId: string; slotId: string }
  | { kind: 'bus'; busId: string };

interface Edge {
  readonly id: string;
  readonly from: Endpoint;
  readonly to: Endpoint;
  readonly transforms?: TransformStep[];
  readonly enabled: boolean;
  readonly sortKey?: number;     // for deterministic ordering
}
```

### Files to Modify

| File | Changes | Lines Affected |
|------|---------|---------------|
| `src/editor/types.ts` | Add Edge, Endpoint types | New definitions |
| `src/editor/compiler/passes/pass2-types.ts` | Unified edge type-checking | Entire pass |
| `src/editor/compiler/passes/pass6-block-lowering.ts` | Unified input resolution | Input resolution sections |
| `src/editor/compiler/passes/pass7-bus-lowering.ts` | Simplify to edge filtering | Lines 1-100 |
| `src/editor/compiler/passes/pass8-link-resolution.ts` | Unified wiring | Entire pass |

### Risks & Complexity

**Risk Level**: MEDIUM
- **Estimated Effort**: 2-3 days
- **Breaking Changes**: Yes (serialization format change)
- **Migration Path**: Clear (helper functions in spec)
- **Test Coverage**: 302 test files exist, none specific to this refactor yet

**Key Challenges**:
1. Maintaining backward compatibility during transition
2. Updating all compiler passes simultaneously
3. UI components that render connections

### Dependencies

**Blocks**: None - this is foundational
**Blocked By**: unify-default-sources-blocks, v2-adapter-implementation

---

## Topic 2: unify-default-sources-blocks [NOT STARTED]

### Current State (The Problem)

**Default sources are metadata attached to input slots:**

```typescript
// src/editor/types.ts:376-403
interface DefaultSource {
  readonly value: unknown;
  readonly uiHint?: UIControlHint;
  readonly world: SlotWorld;
  readonly defaultBus?: string;
}

// Stored separately in Patch
interface Patch {
  blocks: Block[];
  connections: Connection[];
  defaultSources: DefaultSourceState[];           // ← separate array
  defaultSourceAttachments: DefaultSourceAttachment[];  // ← links to providers
}
```

**Evidence location**: `src/editor/types.ts` lines 376-403, 691-694

### Input Resolution Special Cases

```typescript
// Pseudocode from compiler (pass6-block-lowering.ts)
function resolveInput(blockId, slotId) {
  // Check 1: Direct wire?
  const wire = connections.find(c => c.to.blockId === blockId && c.to.slotId === slotId);
  if (wire) return resolveWire(wire);


  // Check 3: Default source? ← SPECIAL CASE
  const ds = defaultSources.find(d => d.targetBlockId === blockId && d.targetSlotId === slotId);
  if (ds) return compileDefaultSource(ds);

  // Error: unconnected input
}
```

**Evidence location**: Logic exists in `src/editor/compiler/passes/pass6-block-lowering.ts`

### Default Source Provider Blocks Exist But Not Integrated

**Provider blocks defined** in `src/editor/blocks/default-source-providers.ts`:
- DSConstSignalFloat
- DSConstFieldFloat
- DSConstSignalVec2
- DSConstSignalColor
- And more...

**But they are NOT used for default sources** - they're treated as hidden blocks for other purposes

### Target State

**Every unconnected input implicitly connected to a hidden provider block:**

```typescript
// When an input has no explicit edge:
// 1. Create hidden DSConst* block with the default value
// 2. Create edge from that block's output to the input
// 3. Store UI hints on the hidden block's params

// Result: ALL inputs are connected via edges
// No special-case resolution needed
```

**Data model changes:**
```typescript
interface Patch {
  blocks: Block[];      // includes hidden DSConst* blocks
  edges: Edge[];        // ALL connections, including defaults

  // REMOVED: defaultSources, defaultSourceAttachments
  // UI hints now stored on hidden block params
}

interface Block {
  // ...existing fields
  readonly hidden?: boolean;        // Don't render on canvas
  readonly role?: 'defaultSourceProvider' | 'internal';
}
```

### Implementation Steps

1. **Create `materializeDefaultSources()` function** (from spec)
2. **Call at start of compilation** (pass 0 or start of pass 1)
3. **Update UI** to hide provider blocks, show inline editors
4. **Remove special-case code** from passes 2, 6, 7, 8

### Files to Modify

| File | Changes | Lines Affected |
|------|---------|---------------|
| `src/editor/types.ts` | Remove DefaultSourceState, DefaultSourceAttachment | 376-403, 691-694 |
| `src/editor/compiler/passes/pass1-normalize.ts` | Add materializeDefaultSources() | New function |
| `src/editor/compiler/passes/pass6-block-lowering.ts` | Remove default source handling | Input resolution logic |
| `src/editor/stores/PatchStore.ts` | Update to manage hidden blocks | Various methods |
| `src/ui/components/Inspector/` | Update default value editors | TBD |

### Risks & Complexity

**Risk Level**: MEDIUM-HIGH
- **Estimated Effort**: 2-3 days
- **Breaking Changes**: Yes (serialization format change)
- **Hidden Providers Work**: Note that 18 sprints of "hidden providers" work has already been done (see workstream-alignment.md), but for a different purpose (allowlist-based provider blocks for advanced features)
- **Confusion Risk**: Two different "hidden provider" systems may exist

**Key Challenges**:
1. Hidden providers for defaults vs. hidden providers for advanced features
2. Serialization format migration
3. UI integration for editing hidden block params
4. Potential conflicts with existing hidden provider system

### Dependencies

**Blocks**: unify-connections-edge (needs Edge type)
**Blocked By**: v2-adapter-implementation

---

## Topic 3: v2-adapter-implementation [NOT STARTED]

### Current State (Stub Implementation)

**V2 adapter is a complete stub:**

```typescript
// src/editor/compiler/v2adapter.ts
export function adaptV2Compiler(v2Compiler: BlockCompilerV2): BlockCompiler {
  return {
    type: v2Compiler.type,
    inputs: v2Compiler.inputs,
    outputs: v2Compiler.outputs,

    compile(_compileArgs) {
      // STUB IMPLEMENTATION for Phase 4, Sprint 8
      // This is a minimal stub to get the infrastructure wired up.

      // For now, just create Error artifacts
      const errorArtifact: Artifact = {
        kind: 'Error',
        message: `V2 adapter not yet fully implemented for ${v2Compiler.type}`,
      };

      const outputs: Record<string, Artifact> = {};
      for (const output of v2Compiler.outputs) {
        outputs[output.name] = errorArtifact;
      }
      return outputs;
    },
  };
}
```

**Evidence location**: `src/editor/compiler/v2adapter.ts` lines 63-92

### What's Needed (From Spec)

The adapter must:
1. Create a `SignalExprBuilder` for the block
2. Convert input `Artifact` values to `SigExprId` references
3. Call `v2Compiler.compileV2()` to get output `SigExprId`s
4. Wrap outputs as closures that call `evalSig()` at runtime

### Target Implementation (From Spec)

```typescript
export function adaptV2Compiler(v2Compiler: BlockCompilerV2): BlockCompiler {
  return {
    compile(args: BlockCompileArgs): Record<string, Artifact> {
      const { id, params, inputs, ctx } = args;

      // 1. Create builder
      const builder = new SignalExprBuilder();

      // 2. Convert inputs to SigExprIds
      const inputIds: Record<string, SigExprId> = {};
      for (const [name, artifact] of Object.entries(inputs)) {
        inputIds[name] = artifactToSigExprId(artifact, builder, ctx);
      }

      // 3. Compile block
      const outputIds = v2Compiler.compileV2({
        id,
        params,
        inputs: inputIds,
        builder,
      });

      // 4. Build IR and create closures
      const ir = builder.build();
      const outputs: Record<string, Artifact> = {};

      for (const [name, sigExprId] of Object.entries(outputIds)) {
        outputs[name] = {
          world: 'signal',
          value: (frameCtx: FrameContext) => {
            return evalSig(ir, sigExprId, frameCtx);
          }
        };
      }

      return outputs;
    }
  };
}
```

### Key Challenge: Mixing V1 Closures with V2 IR

**The `closureNode` approach** embeds a V1 closure as a leaf in the V2 expression tree:

```typescript
// In IR evaluation
function evalSig(ir: SignalIR, id: SigExprId, ctx: FrameContext): number {
  const node = ir.nodes[id];

  switch (node.kind) {
    case 'const':
      return ir.constPool[node.constId];

    case 'closure':  // V1 bridge
      return node.closureFn(ctx);

    case 'map':
      const src = evalSig(ir, node.src, ctx);
      return applyKernel(node.fn, src);

    // ... other cases
  }
}
```

### Files to Modify

| File | Changes | Lines Affected |
|------|---------|---------------|
| `src/editor/compiler/v2adapter.ts` | Full implementation | 63-92 (replace stub) |
| `src/editor/compiler/ir/types.ts` | Add `SignalExprClosure` node type | New type |
| `src/editor/runtime/executor/evalSig.ts` | Handle closure nodes | Add closure case |

### Risks & Complexity

**Risk Level**: MEDIUM
- **Estimated Effort**: 3-5 days
- **Breaking Changes**: No (additive)
- **Runtime Integration**: Requires careful testing with mixed V1/V2 blocks
- **Test Coverage**: No tests for V2 adapter yet

**Key Challenges**:
1. Mixing V1 closures with V2 IR safely
2. Ensuring evalSig can handle closure nodes
3. Testing all block types compile correctly
4. Memory management for IR vs. closures

### Dependencies

**Blocks**: unify-connections-edge, unify-default-sources-blocks (needs input resolution to work)
**Blocked By**: None (can start immediately)

---

## Topic 4: unify-lenses-adapters [NOT STARTED - LOWER PRIORITY]

### Current State (Two Separate Registries)

**LensRegistry** (`src/editor/lenses/LensRegistry.ts`):
```typescript
interface LensDef {
  id: string;
  label: string;
  domain: CoreDomain;
  params: Record<string, LensParamSpec>;
  apply?: (value, params) => value;
  compileToIR?: (input, params, ctx) => ValueRefPacked;
}
```

**AdapterRegistry** (`src/editor/adapters/AdapterRegistry.ts`):
```typescript
interface AdapterDef {
  id: string;
  label: string;
  from: TypeDesc;
  to: TypeDesc;
  policy: AdapterPolicy;
  cost: AdapterCost;
  apply?: (artifact, params, ctx) => Artifact;
  compileToIR?: (input, ctx) => ValueRefPacked;
}
```

**Evidence locations**:
- Lenses: `src/editor/lenses/LensRegistry.ts` lines 1-954
- Adapters: `src/editor/adapters/AdapterRegistry.ts` lines 1-474

### Key Differences

| Aspect | Lenses | Adapters |
|--------|--------|----------|
| Type signature | `T → T` | `T₁ → T₂` |
| Parameters | Yes (user-editable) | No |
| Stateful | Sometimes | Never |
| Auto-insert | No | Yes (based on policy) |
| Registry size | ~30 lenses | ~20 adapters |

### The Insight

Both are "transform steps" applied to values flowing through edges. The differences are:
1. **Type preservation** (lens) vs **type conversion** (adapter)
2. **User-configurable** (lens) vs **automatic** (adapter)

### Target State (From Spec)

```typescript
interface TransformStep {
  readonly id: string;
  readonly kind: 'lens' | 'adapter';
  readonly params?: Record<string, unknown>;  // only for lenses
}

// Registry lookup determines behavior
interface TransformDef {
  id: string;
  label: string;
  kind: 'lens' | 'adapter';

  // Type info
  inputType: TypeDesc | 'same';   // 'same' means preserves type
  outputType: TypeDesc | 'same';

  // Lens-specific
  params?: Record<string, ParamSpec>;

  // Adapter-specific
  policy?: 'auto' | 'suggest' | 'explicit';
  cost?: number;

  // Shared
  apply?: (value, params, ctx) => value;
  compileToIR?: (input, params, ctx) => ValueRefPacked;
}
```

### Implementation Steps

1. **Create TransformStep type** in `src/editor/types.ts`
2. **Create unified TransformRegistry**
3. **Update Edge type** to use `transforms: TransformStep[]`
4. **Update compiler** to apply transforms uniformly
5. **Keep old registries** as facades during migration

### Files to Modify

| File | Changes | Lines Affected |
|------|---------|---------------|
| `src/editor/types.ts` | Add TransformStep, TransformDef types | New definitions |
| `src/editor/transforms/TransformRegistry.ts` | Create unified registry | New file |
| `src/editor/compiler/passes/pass6-block-lowering.ts` | Use unified transforms | Transform application |
| `src/editor/compiler/passes/pass8-link-resolution.ts` | Use unified transforms | Transform application |
| `src/editor/lenses/LensRegistry.ts` | Deprecate or use as facade | Entire file |
| `src/editor/adapters/AdapterRegistry.ts` | Deprecate or use as facade | Entire file |

### Risks & Complexity

**Risk Level**: LOW-MEDIUM
- **Estimated Effort**: 2-3 days
- **Breaking Changes**: No (can use facades)
- **Priority**: LOWER - nice cleanup but not blocking
- **Test Coverage**: Both registries have tests, need migration

**Key Challenges**:
1. Ensuring all existing lenses/adapters work with unified system
2. Maintaining compileToIR support
3. UI updates for transform configuration

### Dependencies

**Blocks**: unify-connections-edge (uses transforms in Edge type)
**Blocked By**: None (can defer until after other topics)

---

## Cross-Topic Dependencies

```
unify-connections-edge (foundational)
         ↓
         ├──→ unify-default-sources-blocks (needs Edge type)
         │              ↓
         │              └──→ v2-adapter-implementation (needs input resolution)
         │
         └──→ unify-lenses-adapters (uses transforms in Edge)
```

**Critical Path**:
1. unify-connections-edge (required first)
2. unify-default-sources-blocks (required second)
3. v2-adapter-implementation (required third)
4. unify-lenses-adapters (optional cleanup)

---

## Test Strategy

### Existing Test Infrastructure

**302 test files exist** in the codebase:
- Vitest framework
- Tests passing with minor warnings (no Domain const provider)
- No tests specifically for Phase 0 refactors yet

### Required Tests for Each Topic

**Topic 1 (Connections → Edge):**
```typescript
describe('Edge type', () => {
  it('converts Connection to Edge', () => { ... });
  it('validates bus→bus is invalid', () => { ... });
});
```

**Topic 2 (Default Sources → Blocks):**
```typescript
describe('materializeDefaultSources', () => {
  it('creates hidden blocks for unconnected inputs', () => { ... });
  it('preserves existing connections', () => { ... });
  it('handles multiple inputs correctly', () => { ... });
});
```

**Topic 3 (V2 Adapter):**
```typescript
describe('V2 Adapter', () => {
  it('compiles V2 block with V1 inputs', () => { ... });
  it('handles closure nodes in IR', () => { ... });
  it('mixes V1 and V2 blocks correctly', () => { ... });
});
```

**Topic 4 (Transforms):**
```typescript
describe('TransformRegistry', () => {
  it('unifies lenses and adapters', () => { ... });
  it('applies transforms in order', () => { ... });
  it('compiles to IR correctly', () => { ... });
});
```

---

## Completion Gate (From ROADMAP.md)

Before moving to Phase 6 completion or other work:
- [ ] All edges use unified Edge type
- [ ] All inputs connected via edges (no special default source handling)
- [ ] V2 adapter compiles legacy bridge blocks
- [ ] Golden patch compiles and runs with new structure

---

## Risk Assessment

### High-Risk Items

1. **Serialization format changes** (Topics 1 & 2)
   - **Impact**: All saved patches need migration
   - **Mitigation**: Write migration helpers, version bump

2. **V2 Adapter runtime safety** (Topic 3)
   - **Impact**: Mixed V1/V2 execution could fail silently
   - **Mitigation**: Comprehensive tests, gradual rollout

3. **Confusion between two "hidden provider" systems** (Topic 2)
   - **Impact**: The 18-sprint hidden providers work may conflict
   - **Mitigation**: Review workstream-alignment.md, clarify intent

### Medium-Risk Items

1. **Compiler pass refactoring** (Topics 1 & 2)
   - **Impact**: Multiple passes need simultaneous updates
   - **Mitigation**: Incremental migration, backward compat shims

2. **UI updates** (All topics)
   - **Impact**: Connection rendering, inspector panels need changes
   - **Mitigation**: UI follows data model, relatively straightforward

### Low-Risk Items

1. **Transform unification** (Topic 4)
   - **Impact**: Facades can maintain compatibility
   - **Mitigation**: Lower priority, can defer

---

## Recommended Implementation Sequence (From Spec)

### Phase 1: Foundation (Do First)

**Week 1:**
1. **Unify Connections → Edge type** (2-3 days)
   - Estimated effort: 2-3 days
   - Unblocks: Simpler compiler passes
   - Risk: Low (mostly type changes)

2. **Unify Default Sources with Blocks** (2-3 days)
   - Estimated effort: 2-3 days
   - Unblocks: No special-case input resolution
   - Risk: Medium (affects serialization)

### Phase 2: Compiler Completion

**Week 2:**
3. **Implement V2 Adapter** (3-5 days)
   - Estimated effort: 3-5 days
   - Unblocks: Legacy blocks in new runtime
   - Risk: Medium (runtime integration)

4. **Test with legacy bridge blocks** (1-2 days)
   - Verify all block types compile and run

### Phase 3: Polish (Can Defer)

5. **Unify Lenses and Adapters** (2-3 days)
   - Estimated effort: 2-3 days
   - Nice cleanup but not blocking
   - Risk: Low

**Total Estimated Effort**: 10-16 days (2-3 weeks)

---

## Cached Knowledge Reused

From `.agent_planning/eval-cache/`:
- **workstream-alignment.md** (HIGH confidence): 18 sprints of hidden providers work for different purpose
- **type-contracts-divergence.md** (HIGH confidence): TypeDesc incompatibilities
- **adapter-application-status.md** (HIGH confidence): Adapter/lens application in Pass 8

---

## Appendix: File Reference

### Core Types
- `src/core/types.ts` - Canonical TypeDesc (DO NOT DUPLICATE)
- `src/editor/types.ts` - Editor types, re-exports TypeDesc

### Connections (to unify)
- `src/editor/types.ts:576-594` - Connection

### Default Sources (to unify)
- `src/editor/types.ts:376-403` - DefaultSource
- `src/editor/defaultSources/types.ts` - DefaultSourceAttachment
- `src/editor/blocks/default-source-providers.ts` - DSConst* blocks

### Lenses and Adapters (to unify)
- `src/editor/lenses/LensRegistry.ts` - Lens definitions
- `src/editor/adapters/AdapterRegistry.ts` - Adapter definitions

### Compiler
- `src/editor/compiler/compile.ts` - Entry point
- `src/editor/compiler/passes/` - 8-pass pipeline
- `src/editor/compiler/v2adapter.ts` - V2 bridge (stub)
- `src/editor/compiler/ir/` - IR types and builders

### Block Registry
- `src/editor/blocks/registry.ts` - Single source of truth

---

## Verdict

**Phase 0 Status**: NOT STARTED (0% complete)
**Workflow**: **CONTINUE** - Requirements are clear, implementation can proceed
**Critical Path**: Follow 1→2→3→4 sequence in spec
**Estimated Timeline**: 2-3 weeks for full completion

**Next Steps**:
1. Start with unify-connections-edge (Topic 1)
2. Write tests FIRST for edge type conversions
3. Implement migration helpers
4. Update compiler passes incrementally
5. Verify with golden patch tests

**Blockers**: None - all prerequisites are in place
**Open Questions**:
- Relationship between this "default sources as blocks" and the 18-sprint hidden providers work
- User approval for serialization format changes
