# Implementation Plan: IR Primitives Complete
**Generated**: 2025-12-30-162500
**Source**: STATUS-2025-12-30-023127.md
**Topic**: ir-primitives-complete
**Total Sprints**: 20
**Estimated Duration**: 71-90 days (14-18 weeks)

---

## Executive Summary

This plan addresses 74 documented gaps across 11 SPEC files to bring the Oscilla IR system from ~30% complete to full production readiness. The work is organized into 20 sprints across 6 phases:

- **Phase 1 (Sprints 1-6)**: Critical path - Make IR execute basic patches (22-27 days)
- **Phase 2 (Sprints 7-10)**: Complete core features - Stateful signals, color/vec2 support (15-19 days)
- **Phase 3 (Sprints 11-14)**: Polish rendering pipeline - Z-order, PostFX, clipping (12-16 days)
- **Phase 4 (Sprints 15-16)**: Compiler improvements - Better diagnostics, placeholder elimination (7-9 days)
- **Phase 5 (Sprints 17-18)**: Export & determinism - Reproducible output, export pipeline (9-11 days)
- **Phase 6 (Sprints 19-20)**: Debug system - IR-compatible debugging tools (6-8 days)

**Critical Dependencies**: Sprints 1-6 MUST be sequential. After Sprint 6, work can be parallelized by stream (stateful ops, field ops, rendering, export/debug).

---

# Phase 1: Make IR Execute (Sprints 1-6)

## Sprint 1: Time Architecture Foundation

### Goal
Extract TimeRoot configuration during compilation and enable proper TimeModel usage in IR execution.

### SPEC References
- **SPEC-05** (Time Architecture): Gap 1 (TimeModel hardcoded), Gap 2 (Wrap detection), Gap 6 (TimeRoot extraction)
- **SPEC-09** (Compiler Passes): Gap 4 (Pass 3 implementation)
- **STATUS Reference**: Section "Tier 0: Core Execution Broken", Gap #1

### Priority
**P0 (Critical)** - Blocks all cyclic/finite time functionality

### Effort
3-4 days

### Dependencies
None (first sprint)

### Technical Approach

**Pass 3 Implementation (TimeRoot Extraction)**:
1. Add Pass 3 to compiler pipeline in `src/editor/compiler/passes/`
2. Scan patch for TimeRoot blocks (FiniteTimeRoot, InfiniteTimeRoot)
3. Validate exactly one TimeRoot exists (compile error if 0 or >1)
4. Extract TimeModel from TimeRoot:
   - FiniteTimeRoot → `{ kind: 'finite', durationMs: <value> }`
   - InfiniteTimeRoot → `{ kind: 'infinite' }`
5. Store TimeModel in CompilerContext for later passes

**TimeModel Threading**:
1. Update `IRBuilderImpl` to receive TimeModel from Pass 3 output
2. Pass TimeModel to schedule builder (already partially done per STATUS)
3. Update `Schedule` type to include `timeModel: TimeModel` field

**Wrap Detection with Delta**:
1. In Time Console cycle lane evaluation:
   - Compute `prevPhase` and `currentPhase`
   - Detect wrap: `currentPhase < prevPhase && dt > 0`
   - Emit wrap event with actual delta (not assumed)
2. Update signal evaluators to use TimeModel for phase wrapping calculations
3. Remove hardcoded infinite assumptions

### Files to Modify
- `src/editor/compiler/passes/pass3-timeroot.ts` (NEW)
- `src/editor/compiler/pipeline.ts`
- `src/editor/compiler/context.ts`
- `src/editor/compiler/IRBuilderImpl.ts`
- `src/editor/runtime/schedule.ts`
- `src/editor/runtime/executor.ts`
- `src/editor/compiler/blocks/time/FiniteTimeRoot.ts`
- `src/editor/compiler/blocks/time/InfiniteTimeRoot.ts`

### Tests to Add
- `pass3-timeroot.test.ts`: TimeRoot extraction validation
- `time-model-finite.test.ts`: Finite duration handling
- `time-model-infinite.test.ts`: Infinite time handling
- `wrap-detection.test.ts`: Wrap event emission with actual delta

### Risks
**MEDIUM** - TimeModel may be threaded but not actually consumed in runtime. Must trace actual usage in executor and verify wrap detection uses it.

### Success Criteria
- [ ] Pass 3 successfully extracts TimeRoot and produces TimeModel
- [ ] Compile error if 0 or >1 TimeRoot in patch
- [ ] TimeModel available in IRBuilder and Schedule
- [ ] Wrap events emitted with correct delta (not hardcoded)
- [ ] Tests verify finite vs infinite time behavior differs correctly

---

## Sprint 2: Default Sources & TimeModel Integration

### Goal
Materialize default source values when optional inputs are unwired, and ensure TimeModel is used in block lowering.

### SPEC References
- **SPEC-08** (Default Sources): Gap 1 (materialization), Gap 2 (dynamic defaults), Gap 3 (domain-aware), Gap 4 (validation), Gap 5 (optional port semantics)
- **SPEC-09** (Compiler Passes): Gap 1 (signal placeholders - partial, time-based blocks only)
- **STATUS Reference**: Section "Tier 0: Core Execution Broken", Gap #3

### Priority
**P0 (Critical)** - Blocks optional input functionality

### Effort
3-4 days

### Dependencies
- Sprint 1 complete (TimeModel available)

### Technical Approach

**Default Source Materialization**:
1. Update `IRBuilderImpl.emitDefaultSource()` to:
   - Check if port has `defaultSource` metadata
   - If scalar: emit `SignalExprConst` or `FieldExprConst`
   - If domain-dependent: emit field with domain reference
   - If dynamic (e.g., "use TimeModel duration"): compute from context
2. Handle different default types:
   - Numeric constants (most common)
   - Vec2/Vec3 constants
   - Color constants
   - Domain-dependent fields (e.g., index/count)

**Default Source Validation**:
1. In Pass 4 (dependency analysis), verify:
   - Default sources don't create cycles
   - Default sources match port type
   - Domain-aware defaults have valid domain
2. Emit compile warnings for suspicious defaults

**TimeModel in Block Lowering**:
1. Update block compilers to receive TimeModel from IRBuilder
2. For time-based blocks (SawOsc, TriOsc, etc.):
   - Use TimeModel to determine if wrapping is needed
   - Emit actual time calculations instead of `sigTimeAbsMs()` placeholder
3. Remove placeholders from time-based signal blocks only (full audit in Sprint 16)

### Files to Modify
- `src/editor/compiler/IRBuilderImpl.ts`
- `src/editor/compiler/blocks/time/SawOsc.ts`
- `src/editor/compiler/blocks/time/TriOsc.ts`
- `src/editor/compiler/blocks/time/SinOsc.ts`
- `src/editor/compiler/passes/pass4-dependencies.ts`
- `src/editor/blocks/metadata/defaultSources.ts`
- `src/editor/ir/signalExpr.ts`
- `src/editor/ir/fieldExpr.ts`

### Tests to Add
- `default-sources.test.ts`: Various default source types
- `default-source-validation.test.ts`: Type/domain validation
- `dynamic-defaults.test.ts`: TimeModel-dependent defaults
- `optional-ports.test.ts`: Unwired optional inputs work correctly

### Risks
**LOW** - Straightforward implementation, well-scoped.

### Success Criteria
- [ ] Unwired optional ports use default sources instead of failing
- [ ] Scalar, vec2, vec3, color default constants work
- [ ] Domain-aware defaults (index, count) materialize correctly
- [ ] TimeModel duration used for dynamic defaults where applicable
- [ ] Compile errors for invalid defaults (type/domain mismatch)
- [ ] Time-based signal blocks emit real IR (no `sigTimeAbsMs()` placeholders)

---

## Sprint 3: Bus System Revival

### Goal
Emit busEval steps in schedule so bus evaluation actually runs, and support non-numeric bus combine operations.

### SPEC References
- **SPEC-07** (Bus System): Gap 1 (busEval not emitted), Gap 3 (non-numeric combine)
- **SPEC-09** (Compiler Passes): Gap 3 (Pass 8 link resolution completion)
- **STATUS Reference**: Section "Tier 0: Core Execution Broken", Gap #2

### Priority
**P0 (Critical)** - Blocks any bus functionality

### Effort
4-5 days

### Dependencies
- Sprint 2 complete

### Technical Approach

**Emit BusEval Steps**:
1. Investigate current state in `buildSchedule.ts`:
   - Types exist: `StepBusEval`, `StepEventBusEval`
   - Comment at line 14 says "NOT emitted" - verify if stale
2. Update schedule builder to:
   - Detect signal buses in IR
   - For each bus, emit `StepBusEval` step before first consumer
   - Emit `StepEventBusEval` for event buses (partial - full in Sprint 10)
   - Respect bus ordering/dependencies
3. Update executor to handle busEval steps:
   - Apply combine rule (sum, multiply, last)
   - Write result to bus slot

**Non-Numeric Bus Combine**:
1. Extend `BusCombineMode` to support vec2/vec3/color types
2. Implement combine operations:
   - Vec2: component-wise sum, multiply, last
   - Vec3: component-wise sum, multiply, last
   - Color: blend modes (alpha composite, multiply, additive, last)
3. Update bus metadata to include value type

**Pass 8 Link Resolution**:
1. Ensure bus links are fully resolved:
   - Bus references in field expressions
2. Validate bus consistency (no orphaned references)

### Files to Modify
- `src/editor/compiler/buildSchedule.ts`
- `src/editor/runtime/executor.ts`
- `src/editor/runtime/schedule.ts`
- `src/editor/stores/BusStore.ts`
- `src/editor/compiler/passes/pass8-links.ts`
- `src/editor/ir/types.ts`

### Tests to Add
- `bus-eval-emission.test.ts`: BusEval steps present in schedule
- `bus-combine-numeric.test.ts`: Sum/multiply/last for numbers
- `bus-combine-vec2.test.ts`: Vec2 combine operations
- `bus-combine-color.test.ts`: Color blend modes
- `bus-execution.test.ts`: End-to-end bus publish/subscribe

### Risks
**MEDIUM** - Types exist but emission logic may have gaps. Need to trace full path from patch to execution.

### Success Criteria
- [ ] Schedule contains `StepBusEval` entries for all signal buses
- [ ] Executor evaluates bus steps and writes to value store
- [ ] Numeric buses (sum/multiply/last) work
- [ ] Vec2 buses with component-wise combine work
- [ ] Color buses with blend modes work
- [ ] Bus consumers read correct combined values
- [ ] Pass 8 validates all bus links are resolved

---

## Sprint 4: Field-Signal Combination Primitives

### Goal
Implement FieldExprZipSig and FieldExprMapIndexed nodes to enable field expressions that combine with signals and indexed operations.

### SPEC References
- **SPEC-01** (Field-Signal Combination): Gap 1 (FieldExprZipSig), Gap 2 (FieldExprMapIndexed), Gap 3 (kernel library), Gap 4 (vec2 opcodes)
- **STATUS Reference**: Section "Tier 1a: Core Features Non-Functional", Gap #6, #7

### Priority
**P1 (High)** - Enables JitterVec2, FieldMapVec2, FieldHueGradient

### Effort
4-5 days

### Dependencies
- Sprint 3 complete

### Technical Approach

**FieldExprZipSig Node**:
1. Add `FieldExprZipSig` IR node type:
   ```typescript
   interface FieldExprZipSig {
     kind: 'zipSig'
     field: FieldExpr
     signals: SignalExpr[]
     kernel: KernelId
   }
   ```
2. Implement evaluator in `Materializer.ts`:
   - Evaluate field for each element
   - Evaluate signals once per frame
   - Call kernel function with (fieldValue, ...signalValues) per element
3. Add to IRBuilder API

**FieldExprMapIndexed Node**:
1. Add `FieldExprMapIndexed` IR node type:
   ```typescript
   interface FieldExprMapIndexed {
     kind: 'mapIndexed'
     field: FieldExpr
     kernel: KernelId
   }
   ```
2. Implement evaluator:
   - Materialize domain to get count
   - For each element, call kernel with (index, count, fieldValue)
   - Return transformed values
3. Add to IRBuilder API

**Kernel Library Extension**:
1. Add kernels for common operations:
   - `jitterVec2`: (pos: Vec2, amount: number, seed: number) => Vec2
   - `fieldMapVec2`: (base: Vec2, offsetX: number, offsetY: number) => Vec2
   - `hueGradient`: (index: number, count: number, hue: number) => Color
2. Register kernels in kernel table
3. Add TypeScript type signatures for type checking

**Vec2 Field Opcodes**:
1. Add vec2 field operations:
   - `fieldVec2Add`, `fieldVec2Sub`, `fieldVec2Mul`, `fieldVec2Div`
   - `fieldVec2Dot`, `fieldVec2Length`, `fieldVec2Normalize`
2. Implement evaluators for each opcode

### Files to Modify
- `src/editor/ir/fieldExpr.ts`
- `src/editor/runtime/Materializer.ts`
- `src/editor/compiler/IRBuilderImpl.ts`
- `src/editor/runtime/kernels.ts`
- `src/editor/compiler/blocks/fields/JitterVec2.ts`
- `src/editor/compiler/blocks/fields/FieldMapVec2.ts`
- `src/editor/compiler/blocks/fields/FieldHueGradient.ts`

### Tests to Add
- `field-expr-zip-sig.test.ts`: FieldExprZipSig evaluation
- `field-expr-map-indexed.test.ts`: Indexed field operations
- `kernel-library.test.ts`: All kernels work correctly
- `vec2-field-ops.test.ts`: Vec2 field arithmetic
- `jitter-vec2-block.test.ts`: JitterVec2 compiles and works
- `field-hue-gradient-block.test.ts`: FieldHueGradient compiles and works

### Risks
**LOW** - Well-defined primitives with clear semantics.

### Success Criteria
- [ ] FieldExprZipSig node evaluates correctly
- [ ] FieldExprMapIndexed node evaluates correctly
- [ ] JitterVec2 block compiles to FieldExprZipSig and works
- [ ] FieldMapVec2 block works
- [ ] FieldHueGradient block works with indexed color gradients
- [ ] Vec2 field opcodes (add/sub/mul/div/dot/length/normalize) work
- [ ] All kernels have tests and type signatures

---

## Sprint 5: Transform Chains & Field Reduce

### Goal
Implement transform chain evaluation (adapters/lenses) and actual field reduce operations.

### SPEC References
- **SPEC-02** (Field Runtime): Gap 1 (transform chains), Gap 2 (field reduce)
- **SPEC-09** (Compiler Passes): Gap 2 (field placeholders - blocks using above)
- **STATUS Reference**: Section "Tier 0: Core Execution Broken", Gap #4; Section "Tier 1a", Gap #9

### Priority
**P0 (Critical)** - Blocks field adapters/lenses

### Effort
4-5 days

### Dependencies
- Sprint 4 complete

### Technical Approach

**Transform Chain Evaluation**:
1. Update `Materializer.ts` line 1145-1179:
   - Replace throw with actual implementation
   - Support transform step types: scaleBias, map, clamp, wrap, quantize
2. For each transform step:
   - Apply transformation element-wise
   - Chain multiple steps (compose right-to-left)
3. Handle both scalar and vec2/vec3/color transforms
4. Optimize: detect identity transforms, fold constant chains

**Transform Step Types**:
- `scaleBias`: `(x) => x * scale + bias`
- `map`: `(x) => lerp(inMin, inMax, outMin, outMax, x)`
- `clamp`: `(x) => clamp(x, min, max)`
- `wrap`: `(x) => wrap(x, min, max)`
- `quantize`: `(x) => round(x / step) * step`

**Field Reduce Implementation**:
1. Update `IRBuilderImpl.ts` line 537-557:
   - Remove placeholder logic
   - Actually evaluate field to array
   - Apply reduce operation (sum, avg, min, max, product)
2. Implement reduce evaluators:
   - Materialize field completely
   - Fold with reduce function
   - Return signal value
3. Support different reduce modes per type (numeric, vec2, color)

**Remove Field Placeholders**:
1. Audit blocks that use transform chains or reduce
2. Replace `fieldConst(0)` placeholders with actual IR
3. Update block compilers to emit transform nodes

### Files to Modify
- `src/editor/runtime/Materializer.ts`
- `src/editor/compiler/IRBuilderImpl.ts`
- `src/editor/ir/fieldExpr.ts`
- `src/editor/compiler/blocks/fields/FieldScaleBias.ts`
- `src/editor/compiler/blocks/fields/FieldMap.ts`
- `src/editor/compiler/blocks/fields/FieldReduce.ts`

### Tests to Add
- `transform-chain-scalar.test.ts`: ScaleBias, map, clamp, wrap
- `transform-chain-vec2.test.ts`: Vec2 transform chains
- `transform-chain-compose.test.ts`: Multiple chained transforms
- `field-reduce-sum.test.ts`: Reduce field to sum signal
- `field-reduce-avg.test.ts`: Reduce field to average signal
- `field-reduce-minmax.test.ts`: Min/max reduce operations

### Risks
**MEDIUM** - Transform chain may have many step types, need to prioritize common ones and add others incrementally.

### Success Criteria
- [ ] Transform chains no longer throw errors
- [ ] ScaleBias transform works on numeric fields
- [ ] Map transform with in/out ranges works
- [ ] Clamp and wrap transforms work
- [ ] Transform chains compose correctly (multiple steps)
- [ ] Field reduce (sum/avg/min/max) produces correct signal values
- [ ] No `fieldConst(0)` placeholders in transform/reduce blocks
- [ ] Vec2 transform chains work

---

## Sprint 6: Type System Unification

### Goal
Unify duplicate TypeDesc definitions, apply adapters and lenses during IR lowering, and implement world promotion rules.

### SPEC References
- **SPEC-06** (Type System): Gap 1 (duplicate TypeDesc), Gap 2 (adapters), Gap 3 (lenses), Gap 5 (world promotion), Gap 6 (validation)
- **STATUS Reference**: Section "Tier 1a: Core Features Non-Functional", Gap #10, #11

### Priority
**P1 (High)** - Critical for type consistency and auto-coercion

### Effort
3-4 days

### Dependencies
- Sprint 5 complete

### Technical Approach

**TypeDesc Unification**:
1. Identify duplicate definitions:
   - `compiler/ir/types.ts`
   - `editor/ir/types/TypeDesc.ts`
2. Consolidate to single canonical definition
3. Update all imports
4. Ensure single source of truth for type metadata

**Apply Adapters During Lowering**:
1. When lowering wires, check for type mismatches
2. Consult adapter table for conversion path
3. Insert adapter nodes in IR:
   - Signal adapters: wrap in SignalExprTransform
   - Field adapters: wrap in FieldExprTransform
4. Common adapters:
   - number → vec2 (broadcast)
   - vec2 → number (magnitude)
   - number → color (grayscale)
   - HSL → RGB

**Apply Lenses During Lowering**:
1. When wire has lens metadata, insert lens transform
2. Lenses are typed transforms (e.g., `Vec2.x`, `Color.hue`)
3. Implement lens evaluators:
   - Extractors: `Vec2.x`, `Vec2.y`, `Color.r`, `Color.hue`
   - Constructors: `Vec2(x, y)`, `Color.rgb(r, g, b)`

**World Promotion Rules**:
1. Define promotion lattice:
   - Scalar < Signal < Field
   - Scalar can promote to Signal (constant signal)
   - Scalar can promote to Field (constant field)
   - Signal can promote to Field (broadcast to all elements)
2. Implement auto-promotion in IRBuilder
3. Validate no illegal demotions (Field → Signal requires explicit reduce)

**Type Validation**:
1. In Pass 4, validate all wire types match or have valid adapter
2. Emit clear compile errors for type mismatches:
   - Show expected vs actual type
   - Suggest available adapters
   - Show wire source and destination

### Files to Modify
- `src/editor/ir/types.ts` (canonical TypeDesc)
- `src/editor/ir/types/TypeDesc.ts` (DELETE or merge)
- `src/editor/compiler/IRBuilderImpl.ts`
- `src/editor/compiler/adapters.ts`
- `src/editor/compiler/lenses.ts`
- `src/editor/compiler/passes/pass4-dependencies.ts`
- All files importing TypeDesc

### Tests to Add
- `type-desc-unified.test.ts`: Single TypeDesc definition used everywhere
- `adapter-auto-apply.test.ts`: Adapters inserted on type mismatch
- `lens-extract.test.ts`: Vec2.x, Color.hue extraction
- `lens-construct.test.ts`: Vec2(x,y), Color.rgb(r,g,b)
- `world-promotion.test.ts`: Scalar→Signal, Scalar→Field, Signal→Field
- `type-validation.test.ts`: Clear errors for invalid wires

### Risks
**LOW** - Well-understood type system concepts.

### Success Criteria
- [ ] Only one TypeDesc definition exists
- [ ] All imports updated to use canonical TypeDesc
- [ ] Adapters automatically inserted for number→vec2, HSL→RGB, etc.
- [ ] Lenses work for Vec2 and Color component extraction
- [ ] Scalar values auto-promote to Signal/Field where needed
- [ ] Signal values auto-promote to Field (broadcast)
- [ ] Compile errors for Field→Signal without explicit reduce
- [ ] Clear type mismatch errors with suggested adapters

---

# Phase 2: Complete Core Features (Sprints 7-10)

## Sprint 7: Stateful Signal Evaluators

### Goal
Implement stateful signal evaluators (delays, pulse dividers, envelopes) with proper state allocation and management.

### SPEC References
- **SPEC-03** (Signal Runtime): Gap 1 (stateful evaluators), Gap 2 (time derivation)
- **STATUS Reference**: Section "Tier 1b: Complete Existing Features", Gap #12, #13

### Priority
**P1 (High)** - Enables PulseDivider, EnvelopeAD, delays

### Effort
5-6 days

### Dependencies
- Sprint 6 complete

### Technical Approach

**State Allocation in Compiler**:
1. During IR building, identify stateful signal blocks
2. Allocate StateId for each stateful node
3. Declare state schema (type, initial value)
4. Include state allocation in Program IR

**Stateful Evaluators**:
1. **DelayFrames**:
   - State: circular buffer of size N
   - On eval: write current value, read value from N frames ago
2. **PulseDivider**:
   - State: counter (int)
   - On pulse: increment counter, emit pulse if counter % divisor == 0
3. **EnvelopeAD**:
   - State: phase ('attack' | 'decay' | 'idle'), elapsedMs
   - On trigger: enter attack phase
   - On eval: compute envelope value based on phase and elapsed time

**State Buffer Management**:
1. Executor maintains StateBuffer alongside ValueStore
2. StateBuffer indexed by StateId
3. State persists across frames
4. State migration on hot-swap (if StateId + type match)

**Time Derivation Fixes**:
1. Ensure `tAbsMs` is writable in signal evaluators (not read-only)
2. Update time-based stateful blocks to write derived time correctly
3. Fix wrap detection using actual delta (from Sprint 1)

### Files to Modify
- `src/editor/compiler/IRBuilderImpl.ts`
- `src/editor/runtime/executor.ts`
- `src/editor/runtime/stateBuffer.ts` (NEW)
- `src/editor/ir/program.ts`
- `src/editor/compiler/blocks/signals/DelayFrames.ts`
- `src/editor/compiler/blocks/signals/PulseDivider.ts`
- `src/editor/compiler/blocks/signals/EnvelopeAD.ts`
- `src/editor/compiler/blocks/signals/Integrate.ts`

### Tests to Add
- `delay-frames.test.ts`: Signal delay by N frames
- `pulse-divider.test.ts`: Divide pulse rate
- `envelope-ad.test.ts`: Attack/decay envelope
- `integrate.test.ts`: Integration over time
- `state-buffer.test.ts`: State allocation and persistence
- `state-migration.test.ts`: Hot-swap state carryover

### Risks
**MEDIUM** - State management adds complexity, need careful testing for edge cases (hot-swap, state reset).

### Success Criteria
- [ ] DelayFrames block delays signal by N frames
- [ ] PulseDivider emits pulse every Nth input pulse
- [ ] EnvelopeAD generates attack/decay envelope on trigger
- [ ] Integrate block accumulates value over time
- [ ] State persists correctly across frames
- [ ] State migrates on hot-swap when StateId + type match
- [ ] State resets when StateId or type changes

---

## Sprint 8: Non-Numeric Signal & Field Support

### Goal
Support vec2, vec3, and color types in signal slots and field combine operations.

### SPEC References
- **SPEC-03** (Signal Runtime): Gap 3 (non-numeric signals), Gap 5 (ColorHSLToRGB kernel)
- **SPEC-02** (Field Runtime): Gap 4 (non-numeric field combine)
- **STATUS Reference**: Section "Tier 1b: Complete Existing Features", Gap #14, #16

### Priority
**P1 (High)** - Enables color/vec2 signals and fields

### Effort
3-4 days

### Dependencies
- Sprint 7 complete

### Technical Approach

**Non-Numeric Signal Slots**:
1. Extend ValueStore to support typed slots:
   - Number slots (existing)
   - Vec2 slots (2 consecutive floats)
   - Vec3 slots (3 consecutive floats)
   - Color slots (4 floats: r, g, b, a)
2. Update SlotId allocation to track slot type and size
3. Update evaluators to read/write multi-slot values

**ColorHSLToRGB Kernel**:
1. Implement HSL → RGB conversion kernel
2. Add to kernel library
3. Update ColorLFO block to emit:
   - HSL signal expression
   - ColorHSLToRGB transform
   - RGB output

**Non-Numeric Field Combine**:
1. Extend field combine operations:
   - Vec2: component-wise combine (add, multiply, etc.)
   - Vec3: component-wise combine
   - Color: alpha blend, multiply, additive
2. Update FieldExprCombine evaluator for multi-component types
3. Handle domain alignment for combined fields

### Files to Modify
- `src/editor/runtime/ValueStore.ts`
- `src/editor/runtime/SlotAllocator.ts`
- `src/editor/runtime/kernels.ts`
- `src/editor/runtime/Materializer.ts`
- `src/editor/ir/types.ts`
- `src/editor/compiler/blocks/signals/ColorLFO.ts`
- `src/editor/compiler/IRBuilderImpl.ts`

### Tests to Add
- `signal-vec2.test.ts`: Vec2 signals in ValueStore
- `signal-color.test.ts`: Color signals in ValueStore
- `color-hsl-to-rgb.test.ts`: HSL→RGB conversion
- `color-lfo.test.ts`: ColorLFO block emits HSL + convert
- `field-combine-vec2.test.ts`: Vec2 field combine
- `field-combine-color.test.ts`: Color field combine

### Risks
**LOW** - Extends existing infrastructure in straightforward way.

### Success Criteria
- [ ] Vec2 signals can be stored and evaluated
- [ ] Vec3 signals can be stored and evaluated
- [ ] Color signals can be stored and evaluated
- [ ] ColorHSLToRGB kernel converts HSL to RGB correctly
- [ ] ColorLFO block produces color signals
- [ ] Vec2 fields can be combined component-wise
- [ ] Color fields can be blended (alpha, multiply, additive)

---

## Sprint 9: Path Fields & Dynamic Operations

### Goal
Enable dynamic path field evaluation and path transform operations.

### SPEC References
- **SPEC-02** (Field Runtime): Gap 3 (dynamic path fields), Gap 7 (path transforms)
- **STATUS Reference**: Section "Tier 1b: Complete Existing Features", Gap #15

### Priority
**P1 (High)** - Enables path animations

### Effort
4-5 days

### Dependencies
- Sprint 8 complete

### Technical Approach

**Dynamic Path Field Evaluation**:
1. Current limitation: path fields are constant only
2. Extend to support signal-driven paths:
   - Path field with signal-based control points
   - Path field with signal-based radius/angle
3. Implement evaluator:
   - Evaluate signal inputs per frame
   - Rebuild path geometry if signals changed
   - Cache path if signals stable

**Path Transform Operations**:
1. Add path-specific transforms:
   - Translate: offset all points by vec2
   - Rotate: rotate all points around center
   - Scale: scale all points from center
   - Morph: interpolate between two paths
2. Implement as field transforms on Path type
3. Support chaining path transforms

**Path Field Types**:
- Circle: `(center: Vec2, radius: Signal<number>)`
- Line: `(start: Vec2, end: Vec2)`
- Polygon: `(points: Vec2[])`
- Custom: `(pathData: string)`

### Files to Modify
- `src/editor/runtime/Materializer.ts`
- `src/editor/ir/fieldExpr.ts`
- `src/editor/compiler/blocks/fields/CirclePath.ts`
- `src/editor/compiler/blocks/fields/LinePath.ts`
- `src/editor/compiler/blocks/fields/PolygonPath.ts`
- `src/core/types/Path.ts`

### Tests to Add
- `path-field-circle.test.ts`: Circle with signal radius
- `path-field-line.test.ts`: Line with signal endpoints
- `path-transform-translate.test.ts`: Translate path field
- `path-transform-rotate.test.ts`: Rotate path field
- `path-transform-scale.test.ts`: Scale path field
- `path-morph.test.ts`: Morph between two paths

### Risks
**MEDIUM** - Path geometry can be expensive to rebuild, need caching strategy.

### Success Criteria
- [ ] Circle path field accepts signal radius
- [ ] Line path field accepts signal endpoints
- [ ] Path fields rebuild when signal inputs change
- [ ] Path fields cached when signal inputs stable
- [ ] Path translate transform works
- [ ] Path rotate transform works
- [ ] Path scale transform works
- [ ] Path transforms can be chained

---

## Sprint 10: Event System & Discrete Signals

### Goal
Clean event semantics with wrap events as discrete triggers and event buses with edge detection.

### SPEC References
- **SPEC-03** (Signal Runtime): Gap 4 (wrap event semantics)
- **SPEC-07** (Bus System): Gap 2 (event buses)
- **SPEC-05** (Time Architecture): Gap 4 (time-driven events)
- **STATUS Reference**: Section "Tier 1b: Complete Existing Features", Gap #17; Section "Tier 2", Event buses

### Priority
**P1 (High)** - Clean event semantics required for many blocks

### Effort
3-4 days

### Dependencies
- Sprint 9 complete

### Technical Approach

**Event Store Separation**:
1. Separate event values from continuous values
2. Add EventStore alongside ValueStore
3. Events are frame-latched (cleared each frame)
4. Events have trigger time within frame

**Wrap Event as Discrete Trigger**:
1. Time Console Cycle lane detects wrap (from Sprint 1)
2. Emit event to EventStore (not ValueStore)
3. Event consumers check EventStore for triggers
4. Wrap event includes metadata: direction, delta

**Event Buses with Edge Detection**:
1. Add `StepEventBusEval` support (types exist from Sprint 3)
2. Event bus combine: collect all events in frame
3. Edge detection: rising edge, falling edge, any edge
4. Emit combined event set to subscribers

**Time-Driven Events**:
1. PulseDivider emits events
2. EnvelopeAD emits events (attack complete, decay complete)
3. Threshold crossing emits event
4. Events propagate through event buses

### Files to Modify
- `src/editor/runtime/EventStore.ts` (NEW)
- `src/editor/runtime/executor.ts`
- `src/editor/runtime/schedule.ts`
- `src/editor/compiler/blocks/time/CycleLane.ts`
- `src/editor/compiler/blocks/signals/PulseDivider.ts`
- `src/editor/compiler/blocks/signals/EnvelopeAD.ts`
- `src/editor/compiler/blocks/signals/ThresholdCross.ts`

### Tests to Add
- `event-store.test.ts`: Event storage and retrieval
- `wrap-event.test.ts`: Wrap events emitted and received
- `event-bus.test.ts`: Event bus combine and propagate
- `edge-detection.test.ts`: Rising/falling edge detection
- `pulse-divider-event.test.ts`: PulseDivider emits events
- `threshold-cross-event.test.ts`: Threshold crossing events

### Risks
**LOW** - Well-scoped event system addition.

### Success Criteria
- [ ] EventStore exists and manages discrete events
- [ ] Wrap events emitted to EventStore (not ValueStore)
- [ ] Wrap events include direction and delta metadata
- [ ] Event buses collect and combine events
- [ ] Edge detection (rising, falling, any) works
- [ ] PulseDivider emits discrete pulse events
- [ ] EnvelopeAD emits attack/decay complete events
- [ ] ThresholdCross emits edge events

---

# Phase 3: Polish & Render Pipeline (Sprints 11-14)

## Sprint 11: Render Ordering & Attributes

### Goal
Implement z-order rendering and extended per-instance attributes (rotation, scale).

### SPEC References
- **SPEC-04** (Render Pipeline): Gap 1 (z-order), Gap 3 (extended attributes), Gap 7 (attribute buffer assembly)
- **STATUS Reference**: Section "Tier 2: Polish & Edge Cases"

### Priority
**P2 (Medium)** - Polish feature, improves render quality

### Effort
2-3 days

### Dependencies
- Sprint 6 complete (can start after Phase 1)

### Technical Approach

**Z-Order Wire-Through**:
1. Add z-order field to render instances:
   - Static z-order (scalar)
   - Dynamic z-order (field or signal)
2. Update schedule builder to include z-order in render steps
3. Update renderer to:
   - Sort instances by z-order before drawing
   - Handle z-order from field (per-element) or signal (per-frame)

**Extended Per-Instance Attributes**:
1. Current: position, color
2. Add: rotation, scale, opacity
3. Update instance buffer structure:
   ```typescript
   interface Instance {
     position: Vec2
     color: Color
     rotation: number  // NEW
     scale: Vec2       // NEW
     opacity: number   // NEW
     zOrder: number    // NEW
   }
   ```
4. Update renderer to apply rotation/scale transforms

**Attribute Buffer Assembly**:
1. Efficiently pack attributes into typed arrays
2. Support optional attributes (use defaults if not provided)
3. Optimize for common case (position + color only)

### Files to Modify
- `src/editor/ir/renderCommand.ts`
- `src/editor/runtime/renderer.ts`
- `src/editor/runtime/instanceBuffer.ts`
- `src/editor/compiler/blocks/render/DrawCircles.ts`
- `src/editor/compiler/blocks/render/DrawLines.ts`

### Tests to Add
- `z-order-static.test.ts`: Static z-order sorting
- `z-order-field.test.ts`: Per-element z-order
- `rotation-attribute.test.ts`: Rotation per instance
- `scale-attribute.test.ts`: Scale per instance
- `opacity-attribute.test.ts`: Opacity per instance
- `attribute-buffer.test.ts`: Efficient attribute packing

### Risks
**LOW** - Straightforward renderer enhancement.

### Success Criteria
- [ ] Instances render in z-order (low to high)
- [ ] Static z-order works
- [ ] Per-element z-order from field works
- [ ] Per-frame z-order from signal works
- [ ] Rotation attribute rotates instances correctly
- [ ] Scale attribute scales instances correctly
- [ ] Opacity attribute controls instance transparency
- [ ] Attribute buffer efficiently packed

---

## Sprint 12: Advanced Rendering

### Goal
Implement curve flattening (bezier → lines) and clipping/masking passes.

### SPEC References
- **SPEC-04** (Render Pipeline): Gap 6 (curve flattening), Gap 4 (clipping/masking), Gap 9 (clip region IR)
- **STATUS Reference**: Section "Tier 2: Polish & Edge Cases"

### Priority
**P2 (Medium)** - Enables bezier paths and masking

### Effort
3-4 days

### Dependencies
- Sprint 11 complete

### Technical Approach

**Curve Flattening**:
1. Bezier path → polyline approximation
2. Adaptive tessellation:
   - Subdivide until curvature below threshold
   - Use flatness test to determine subdivision
3. Cache flattened paths (invalidate on path change)
4. Support quadratic and cubic beziers

**Clipping/Masking Passes**:
1. Add clip region IR:
   ```typescript
   interface ClipRegion {
     shape: 'rect' | 'circle' | 'path'
     bounds: Rect | Circle | Path
     mode: 'clip' | 'mask'
   }
   ```
2. Implement clip stack:
   - Push clip region
   - Render instances (clipped)
   - Pop clip region
3. Use Canvas2D clip API or manual clip testing

**Clip Region IR**:
1. Add StepPushClip, StepPopClip to schedule
2. Executor maintains clip stack
3. Renderer applies clip before drawing

### Files to Modify
- `src/editor/runtime/renderer.ts`
- `src/editor/runtime/pathFlattener.ts` (NEW)
- `src/editor/ir/renderCommand.ts`
- `src/editor/runtime/schedule.ts`
- `src/editor/compiler/blocks/render/ClipRect.ts`
- `src/editor/compiler/blocks/render/ClipCircle.ts`

### Tests to Add
- `curve-flatten-quadratic.test.ts`: Quadratic bezier flattening
- `curve-flatten-cubic.test.ts`: Cubic bezier flattening
- `curve-flatten-adaptive.test.ts`: Adaptive subdivision
- `clip-rect.test.ts`: Rectangular clipping
- `clip-circle.test.ts`: Circular clipping
- `clip-stack.test.ts`: Nested clipping regions

### Risks
**LOW** - Canvas2D has good clip support.

### Success Criteria
- [ ] Quadratic bezier curves flatten to polylines
- [ ] Cubic bezier curves flatten to polylines
- [ ] Adaptive tessellation produces smooth curves
- [ ] Flattened paths cached and reused
- [ ] Rectangular clip regions work
- [ ] Circular clip regions work
- [ ] Path-based clip regions work
- [ ] Clip regions can be nested (stack)

---

## Sprint 13: PostFX & Materials

### Goal
Implement post-processing effects (blur, bloom) and material system expansion (gradients).

### SPEC References
- **SPEC-04** (Render Pipeline): Gap 2 (PostFX), Gap 5 (materials), Gap 8 (PostFX pass types), Gap 10 (material IR)
- **STATUS Reference**: Section "Tier 2: Polish & Edge Cases"

### Priority
**P2 (Medium)** - Visual polish features

### Effort
4-5 days

### Dependencies
- Sprint 12 complete

### Technical Approach

**PostFX Implementation**:
1. Add PostFX IR nodes:
   ```typescript
   interface PostFXPass {
     type: 'blur' | 'bloom' | 'sharpen' | 'colorGrade'
     params: Record<string, number>
   }
   ```
2. Render pipeline:
   - Render to offscreen canvas
   - Apply PostFX passes sequentially
   - Composite to main canvas
3. PostFX types:
   - Blur: Gaussian blur with radius
   - Bloom: Threshold + blur + additive blend
   - Sharpen: Unsharp mask
   - Color grade: Curves, levels, saturation

**Material System Expansion**:
1. Current: solid color fills
2. Add gradient fills:
   - Linear gradient
   - Radial gradient
   - Conic gradient
3. Add material IR:
   ```typescript
   interface Material {
     type: 'solid' | 'linearGradient' | 'radialGradient'
     params: MaterialParams
   }
   ```
4. Renderer applies materials when drawing

**PostFX Pass Types**:
1. Blur: Canvas2D filter or custom shader
2. Bloom: multi-pass (threshold, blur, composite)
3. Sharpen: convolution filter
4. Color grade: pixel manipulation

### Files to Modify
- `src/editor/runtime/renderer.ts`
- `src/editor/runtime/postfx.ts` (NEW)
- `src/editor/ir/renderCommand.ts`
- `src/editor/ir/material.ts` (NEW)
- `src/editor/compiler/blocks/postfx/Blur.ts`
- `src/editor/compiler/blocks/postfx/Bloom.ts`
- `src/editor/compiler/blocks/materials/LinearGradient.ts`
- `src/editor/compiler/blocks/materials/RadialGradient.ts`

### Tests to Add
- `postfx-blur.test.ts`: Blur effect
- `postfx-bloom.test.ts`: Bloom effect
- `postfx-sharpen.test.ts`: Sharpen effect
- `postfx-color-grade.test.ts`: Color grading
- `material-linear-gradient.test.ts`: Linear gradient fill
- `material-radial-gradient.test.ts`: Radial gradient fill

### Risks
**MEDIUM** - Canvas2D filter support varies, may need WebGL fallback.

### Success Criteria
- [ ] Blur PostFX works with configurable radius
- [ ] Bloom PostFX works with threshold and intensity
- [ ] Sharpen PostFX works
- [ ] Color grade PostFX works (curves, saturation)
- [ ] Linear gradient materials work
- [ ] Radial gradient materials work
- [ ] PostFX passes compose correctly
- [ ] Offscreen rendering for PostFX works

---

## Sprint 14: Field Runtime Polish

### Goal
Cache invalidation on schema change, domain element ID propagation, complete coercion graph, field buses.

### SPEC References
- **SPEC-02** (Field Runtime): Gap 5 (cache invalidation), Gap 6 (domain element IDs)
- **SPEC-06** (Type System): Gap 4 (coercion paths)
- **SPEC-07** (Bus System): Gap 4 (field buses), Gap 5 (bus ordering)
- **STATUS Reference**: Section "Tier 2: Polish & Edge Cases"

### Priority
**P2 (Medium)** - Stability and completeness

### Effort
3-4 days

### Dependencies
- Sprint 13 complete

### Technical Approach

**Cache Invalidation on Schema Change**:
1. Track field cache keys with schema version
2. On hot-swap, detect schema changes:
   - Domain count changed
   - Field expression changed
   - Input slots changed
3. Invalidate affected cache entries
4. Re-materialize fields on next render

**Domain Element ID Propagation**:
1. Domains have stable IDs per element
2. Field expressions preserve element IDs
3. Render instances tagged with element ID
4. Enables:
   - Selection by ID
   - Per-element history/trails
   - Partial updates

**Complete Coercion Graph**:
1. Add missing coercion paths:
   - Vec3 ↔ Color (RGB mapping)
   - Number ↔ Boolean (threshold)
   - String ↔ Number (parse)
2. Build coercion graph with shortest paths
3. Auto-insert coercion chains when needed

**Field Buses**:
1. Extend bus system to support field values
2. Field bus combine:
   - Element-wise combine (requires matching domains)
   - Domain mismatch is compile error
3. Use cases:
   - Multiple sources publishing to position field bus
   - Layered field effects

**Bus Ordering/Priority**:
3. Enables deterministic last-wins semantics

### Files to Modify
- `src/editor/runtime/Materializer.ts`
- `src/editor/runtime/fieldCache.ts`
- `src/editor/compiler/passes/pass4-dependencies.ts`
- `src/editor/compiler/coercion.ts`
- `src/editor/stores/BusStore.ts`
- `src/editor/runtime/schedule.ts`
- `src/core/types/Domain.ts`

### Tests to Add
- `cache-invalidation-hotswap.test.ts`: Cache invalidated on schema change
- `domain-element-id.test.ts`: Element IDs stable and propagate
- `coercion-vec3-color.test.ts`: Vec3 ↔ Color coercion
- `coercion-number-bool.test.ts`: Number ↔ Boolean coercion
- `field-bus.test.ts`: Field buses with element-wise combine

### Risks
**LOW** - Mostly polish and edge case handling.

### Success Criteria
- [ ] Field cache invalidated on hot-swap schema change
- [ ] Field cache reused when schema unchanged
- [ ] Domain element IDs stable across frames
- [ ] Element IDs propagate through field expressions
- [ ] Vec3 ↔ Color coercion works
- [ ] Number ↔ Boolean coercion works
- [ ] Field buses combine element-wise
- [ ] Domain mismatch in field bus is compile error

---

# Phase 4: Compiler Improvements (Sprints 15-16)

## Sprint 15: Compiler Pass Improvements

### Goal
Enhanced dependency graph, SCC analysis with feedback validation, PhaseClock semantics, scrub handling.

### SPEC References
- **SPEC-09** (Compiler Passes): Gap 5 (dependency graph), Gap 6 (SCC analysis), Gap 7 (pass timing)
- **SPEC-05** (Time Architecture): Gap 3 (PhaseClock semantics), Gap 5 (scrub handling)
- **STATUS Reference**: Section "Tier 3: New Features" (Compiler)

### Priority
**P2 (Medium)** - Better compile errors and validation

### Effort
3-4 days

### Dependencies
- Sprint 6 complete (can start after Phase 1)

### Technical Approach

**Enhanced Dependency Graph**:
1. Current: basic node dependencies
2. Add edge types:
   - Time edge: derives from time source
   - Bus edge: depends on bus value
   - State edge: depends on previous frame state
   - Memory edge: breaks cycle (stateful)
3. Visualize dependency graph for debugging
4. Detect illegal cycles (no memory edge)

**SCC Analysis with Feedback Validation**:
1. Strongly connected component detection
2. For each SCC:
   - Validate at least one memory edge (stateful node)
   - Emit clear error if pure cycle detected
   - Show cycle path and suggest fixes
3. Schedule SCCs in topological order

**PhaseClock Semantic Alignment**:
1. PhaseClock derives from TimeModel
2. Ensure phase calculation uses TimeModel
3. Validate PhaseClock usage in blocks

**Scrub/Seek Handling**:
1. When time jumps (scrub):
   - Mark discontinuity in TimeCtx
   - Stateful nodes handle discontinuity (reset or interpolate)
   - Event detection skips false edges
2. Add `scrubbed: boolean` to TimeCtx

**Pass Timing Diagnostics**:
1. Instrument each compiler pass
2. Report pass timing in compile output
3. Identify slow passes for optimization

### Files to Modify
- `src/editor/compiler/passes/pass4-dependencies.ts`
- `src/editor/compiler/passes/pass5-scc.ts`
- `src/editor/compiler/pipeline.ts`
- `src/editor/runtime/executor.ts`
- `src/core/types/TimeCtx.ts`
- `src/editor/compiler/diagnostics.ts`

### Tests to Add
- `dependency-graph-edges.test.ts`: Time/bus/state edges
- `scc-valid-feedback.test.ts`: Valid cycle with memory edge
- `scc-invalid-cycle.test.ts`: Illegal cycle detected
- `phase-clock-timemodel.test.ts`: PhaseClock uses TimeModel
- `scrub-discontinuity.test.ts`: Scrub handling
- `pass-timing.test.ts`: Pass timing diagnostics

### Risks
**LOW** - Mostly diagnostics and validation improvements.

### Success Criteria
- [ ] Dependency graph includes time/bus/state edge types
- [ ] SCC analysis detects cycles correctly
- [ ] Cycles without memory edge emit clear compile error
- [ ] Cycle error shows path and suggests fixes (add delay)
- [ ] PhaseClock calculation uses TimeModel
- [ ] Scrub/seek sets discontinuity flag in TimeCtx
- [ ] Stateful nodes handle scrub discontinuity
- [ ] Pass timing reported in compile diagnostics

---

## Sprint 16: Placeholder Elimination

### Goal
Audit and fix all signal and field placeholder emissions across all block compilers.

### SPEC References
- **SPEC-09** (Compiler Passes): Gap 1 (signal placeholders), Gap 2 (field placeholders)
- **STATUS Reference**: Section "Tier 0" (Gap #5 - partial); Section "Tier 3" (full audit)

### Priority
**P1 (High)** - Ensures all blocks emit real IR

### Effort
4-5 days

### Dependencies
- Sprint 15 complete

### Technical Approach

**Comprehensive Placeholder Audit**:
1. Search codebase for placeholders:
   - `grep -r "sigTimeAbsMs()" src/editor/compiler/blocks/`
   - `grep -r "fieldConst(0)" src/editor/compiler/blocks/`
   - `grep -r "TODO" src/editor/compiler/blocks/`
2. Create complete list of blocks with placeholders
3. Categorize by reason (time-based fixed in Sprint 2, others now)

**Fix Signal Placeholders**:
1. For each block emitting signal placeholders:
   - Implement actual signal expression
   - Use kernels, operators, transforms
   - Add unit test verifying real IR
2. Common patterns:
   - Random: use seeded PRNG (Sprint 17 foundation)
   - Time: already fixed in Sprint 2
   - Math: use signal operators

**Fix Field Placeholders**:
1. For each block emitting field placeholders:
   - Implement actual field expression
   - Use field operators, combinators, transforms
   - Add unit test verifying real IR
2. Common patterns:
   - Position: use domain index mapping
   - Color: use gradients or indexed colors
   - Geometry: use field expressions

**Comprehensive Block Lowering Tests**:
1. For each block, test:
   - Compiles without errors
   - Emits non-placeholder IR
   - IR evaluates correctly
   - Output matches expected type

### Files to Modify
- Many files in `src/editor/compiler/blocks/` (identified by grep)
- Specific blocks depend on audit results
- Test files for each fixed block

### Tests to Add
- `placeholder-audit.test.ts`: Assert no placeholders in production
- Individual block tests (TBD based on audit)

### Risks
**HIGH** - May discover many blocks emit placeholders, audit is large scope.

### Success Criteria
- [ ] Comprehensive grep finds all placeholder usages
- [ ] All identified placeholders categorized and prioritized
- [ ] All P0/P1 placeholders fixed with real IR
- [ ] All fixed blocks have unit tests
- [ ] No `sigTimeAbsMs()` placeholders except in stubs
- [ ] No `fieldConst(0)` placeholders except in stubs
- [ ] Placeholder audit test passes (no production placeholders)

---

# Phase 5: Export & Determinism (Sprints 17-18)

## Sprint 17: Deterministic Replay Foundation

### Goal
Seeded PRNG system, replace all Math.random() usage, state serialization/deserialization for reproducible output.

### SPEC References
- **SPEC-10** (Export Pipeline): Gap 5 (deterministic replay), Gap 6 (state serialization)
- **STATUS Reference**: Section "Tier 3: New Features" (Export)

### Priority
**P1 (High)** - CRITICAL for export, required before Sprint 18

### Effort
4-5 days

### Dependencies
- Sprint 6 complete (can start after Phase 1)

### Technical Approach

**Seeded PRNG System**:
1. Implement seeded PRNG (e.g., xorshift128+, PCG)
2. Add PRNG to TimeCtx:
   ```typescript
   interface TimeCtx {
     t: number
     dt: number
     seed: number
     prng: PRNG  // NEW
   }
   ```
3. Blocks needing randomness consume from TimeCtx.prng
4. PRNG state advances deterministically each frame

**Replace Math.random() Usage**:
1. Grep for `Math.random()` in codebase
2. Replace each usage with TimeCtx.prng
3. For compile-time randomness (e.g., initial values):
   - Use seeded PRNG from patch seed
   - Store seed in patch metadata
4. Ensure no non-deterministic randomness remains

**State Serialization/Deserialization**:
1. Implement StateBuffer serialization:
   - Export all state slots to JSON
   - Include StateId, type, value
2. Implement deserialization:
   - Restore state from JSON
   - Migrate state on schema change (if possible)
3. Use cases:
   - Save animation state
   - Restore state for exact replay
   - Debugging (capture state at crash)

**Determinism Validation**:
1. Add determinism test harness:
   - Run patch twice with same seed
   - Verify identical output each frame
2. Test various scenarios:
   - Random values
   - Stateful nodes
   - Complex patches

### Files to Modify
- `src/core/types/TimeCtx.ts`
- `src/editor/runtime/prng.ts` (NEW)
- `src/editor/runtime/executor.ts`
- `src/editor/runtime/stateBuffer.ts`
- All files using `Math.random()` (identified by grep)

### Tests to Add
- `prng-deterministic.test.ts`: PRNG produces same sequence
- `determinism-validation.test.ts`: Patch output deterministic
- `state-serialization.test.ts`: Serialize and deserialize state
- `state-migration.test.ts`: State migrates on schema change
- `no-math-random.test.ts`: Assert no Math.random() in production

### Risks
**MEDIUM** - Math.random() may be scattered throughout codebase.

### Success Criteria
- [ ] Seeded PRNG implemented and tested
- [ ] PRNG integrated into TimeCtx
- [ ] All `Math.random()` usage replaced with TimeCtx.prng
- [ ] Compile-time randomness uses patch seed
- [ ] StateBuffer serialization to JSON works
- [ ] StateBuffer deserialization from JSON works
- [ ] Determinism test passes (identical output with same seed)
- [ ] No Math.random() in production code (grep test passes)

---

## Sprint 18: Export Pipeline Implementation

### Goal
Image sequence export, video export, GIF export, standalone HTML player.

### SPEC References
- **SPEC-10** (Export Pipeline): Gap 1 (image sequence), Gap 2 (video), Gap 3 (GIF), Gap 4 (standalone player)
- **STATUS Reference**: Section "Tier 3: New Features" (Export)

### Priority
**P1 (High)** - Enables content creation use cases

### Effort
5-6 days

### Dependencies
- Sprint 17 complete (determinism required)

### Technical Approach

**Image Sequence Export (PNG/WebP)**:
1. Render each frame to canvas
2. Export canvas to blob (PNG or WebP)
3. Download or zip sequence
4. Options:
   - Frame range (start, end)
   - Frame rate (fps)
   - Resolution
   - Format (PNG, WebP)

**Video Export (WebCodecs)**:
1. Use WebCodecs API for video encoding
2. Render frames sequentially
3. Encode to video stream (H.264 or VP9)
4. Export as .mp4 or .webm
5. Fallback: if WebCodecs unavailable, image sequence only
6. Options:
   - Duration, fps, resolution
   - Codec, bitrate

**GIF Export**:
1. Render frames to canvas
2. Quantize colors (GIF 256 color limit)
3. Encode to GIF using library (e.g., gif.js)
4. Options:
   - Duration, fps, resolution
   - Dither, quality

**Standalone HTML Player**:
1. Bundle patch IR + player runtime
2. Generate standalone HTML file
3. Player runs in browser without editor
4. Options:
   - Autoplay, loop
   - Controls (play/pause, scrub)

**Export UI**:
1. Export dialog with options
2. Progress bar during export
3. Cancel/pause export
4. Preview before export

### Files to Modify
- `src/editor/export/imageSequence.ts` (NEW)
- `src/editor/export/videoExport.ts` (NEW)
- `src/editor/export/gifExport.ts` (NEW)
- `src/editor/export/standalonePlayer.ts` (NEW)
- `src/editor/components/ExportDialog.tsx` (NEW)
- `src/editor/runtime/renderer.ts`

### Tests to Add
- `export-image-sequence.test.ts`: PNG/WebP sequence export
- `export-video.test.ts`: Video export (if WebCodecs available)
- `export-gif.test.ts`: GIF export
- `export-standalone.test.ts`: Standalone player generation
- `export-determinism.test.ts`: Exported output is deterministic

### Risks
**MEDIUM** - WebCodecs API not universally supported, need fallback.

### Success Criteria
- [ ] Image sequence export (PNG) works
- [ ] Image sequence export (WebP) works
- [ ] Video export works (if WebCodecs available)
- [ ] GIF export works with color quantization
- [ ] Standalone HTML player bundles patch and runs
- [ ] Export dialog UI functional
- [ ] Progress bar shows export progress
- [ ] Exported output is deterministic (same seed = same output)
- [ ] Clear browser requirements documented

---

# Phase 6: Debug System (Sprints 19-20)

## Sprint 19: IR-Compatible Debugging

### Goal
DebugDisplay IR lowering, debug probe registry, and StepDebugProbe execution.

### SPEC References
- **SPEC-11** (Debug System): Gap 1 (DebugDisplay IR), Gap 6 (debug probe registry)
- **STATUS Reference**: Section "Tier 3: New Features" (Debug)

### Priority
**P2 (Medium)** - Improves developer experience

### Effort
2-3 days

### Dependencies
- Sprint 6 complete (can start after Phase 1)

### Technical Approach

**DebugDisplay IR Lowering**:
1. DebugDisplay block compiles to IR:
   - Read signal/field value
   - Write to debug probe registry
   - Continue normal execution (non-intrusive)
2. Debug probes have stable IDs
3. Debug values accessible via debug API

**Debug Probe Registry**:
1. Global registry of debug probes:
   - ProbeId → { name, type, source }
2. Executor writes debug values each frame
3. UI reads debug values from registry
4. Debug values shown in inspector panel

**StepDebugProbe Execution**:
1. Add `StepDebugProbe` to schedule
2. Executor reads slot, writes to debug registry
3. Non-intrusive (no impact on normal execution)
4. Debug probes can be toggled on/off

**Debug API**:
```typescript
interface DebugAPI {
  getProbes(): DebugProbe[]
  getProbeValue(probeId: ProbeId): any
  subscribe(probeId: ProbeId, callback: (value: any) => void): void
}
```

### Files to Modify
- `src/editor/compiler/blocks/debug/DebugDisplay.ts`
- `src/editor/runtime/debugRegistry.ts` (NEW)
- `src/editor/runtime/schedule.ts`
- `src/editor/runtime/executor.ts`
- `src/editor/components/DebugInspector.tsx` (NEW)

### Tests to Add
- `debug-display-lowering.test.ts`: DebugDisplay compiles to IR
- `debug-probe-registry.test.ts`: Probe registration and lookup
- `debug-probe-execution.test.ts`: Probes write values
- `debug-api.test.ts`: Debug API reads values

### Risks
**LOW** - Straightforward debugging infrastructure.

### Success Criteria
- [ ] DebugDisplay block compiles to IR
- [ ] StepDebugProbe steps emitted in schedule
- [ ] Executor writes debug values to registry
- [ ] Debug API provides access to probe values
- [ ] Debug inspector UI shows probe values
- [ ] Debug probes non-intrusive (no perf impact)
- [ ] Debug probes can be toggled on/off

---

## Sprint 20: Advanced Visualization & Diagnostics

### Goal
Signal history buffer, waveform visualization, field visualization (heatmap/histogram), runtime state inspector, compile diagnostics output.

### SPEC References
- **SPEC-11** (Debug System): Gap 2 (signal viz), Gap 3 (field viz), Gap 4 (runtime inspector), Gap 5 (compile diagnostics)
- **SPEC-09** (Compiler Passes): Gap 8 (pass diagnostics)
- **STATUS Reference**: Section "Tier 3: New Features" (Debug)

### Priority
**P2 (Medium)** - Comprehensive debugging tools

### Effort
4-5 days

### Dependencies
- Sprint 19 complete

### Technical Approach

**Signal History Buffer + Waveform Viz**:
1. Maintain circular buffer of signal values:
   - Configurable depth (e.g., last 500 frames)
   - Per debug probe
2. Waveform visualization:
   - Mini canvas with signal plot
   - Auto-scale or fixed range
   - Scrub to see historical values

**Field Visualization**:
1. Heatmap mode:
   - Render field values as color gradient
   - Map value range to color scale
2. Histogram mode:
   - Show distribution of field values
   - Buckets configurable
3. Field inspector:
   - Show per-element values in table
   - Filter/sort elements

**Runtime State Inspector**:
1. Show all state slots:
   - StateId, type, current value
   - History graph for stateful nodes
2. State controls:
   - Reset individual state slots
   - Export state to JSON
   - Import state from JSON

**Compile Diagnostics Output**:
1. Structured compile output:
   - Pass timings (from Sprint 15)
   - Node count, schedule size
   - Warnings (unused nodes, etc.)
   - Optimization suggestions
2. Export diagnostics to JSON
3. Diagnostics viewer UI

### Files to Modify
- `src/editor/runtime/debugRegistry.ts`
- `src/editor/components/WaveformView.tsx` (NEW)
- `src/editor/components/FieldHeatmap.tsx` (NEW)
- `src/editor/components/FieldHistogram.tsx` (NEW)
- `src/editor/components/StateInspector.tsx` (NEW)
- `src/editor/components/DiagnosticsView.tsx` (NEW)
- `src/editor/compiler/diagnostics.ts`

### Tests to Add
- `signal-history.test.ts`: History buffer maintains values
- `waveform-viz.test.ts`: Waveform rendering
- `field-heatmap.test.ts`: Heatmap visualization
- `field-histogram.test.ts`: Histogram computation
- `state-inspector.test.ts`: State inspection API
- `compile-diagnostics.test.ts`: Diagnostics output

### Risks
**LOW** - UI features, low impact on core system.

### Success Criteria
- [ ] Signal history buffer maintains last N frames
- [ ] Waveform view shows signal over time
- [ ] Field heatmap visualizes value distribution spatially
- [ ] Field histogram shows value distribution statistically
- [ ] State inspector shows all state slots
- [ ] State can be reset, exported, imported
- [ ] Compile diagnostics include pass timings
- [ ] Compile diagnostics include warnings/suggestions
- [ ] Diagnostics viewer UI displays structured output

---

## Summary Tables

### Sprint Dependency Matrix

| Sprint | Depends On | Can Parallelize With |
|--------|------------|---------------------|
| 1 | None | None (first) |
| 2 | 1 | None |
| 3 | 2 | None |
| 4 | 3 | None |
| 5 | 4 | None |
| 6 | 5 | None |
| 7 | 6 | 8, 9, 10, 11, 15, 19 |
| 8 | 6 | 7, 9, 10, 11, 15, 19 |
| 9 | 6 | 7, 8, 10, 11, 15, 19 |
| 10 | 6 | 7, 8, 9, 11, 15, 19 |
| 11 | 6 | 7, 8, 9, 10, 12, 15, 19 |
| 12 | 11 | 13, 15, 19 |
| 13 | 12 | 14, 15, 19 |
| 14 | 6 | 7, 8, 9, 10, 11, 12, 13, 15, 19 |
| 15 | 6 | 7, 8, 9, 10, 11, 12, 13, 14, 16, 19 |
| 16 | 15 | 17, 19 |
| 17 | 6 | 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 19 |
| 18 | 17 | 19, 20 |
| 19 | 6 | 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 |
| 20 | 19 | None (dependent) |

### Phase Summary

| Phase | Sprints | Days | Priority | Description |
|-------|---------|------|----------|-------------|
| 1 | 1-6 | 22-27 | P0 | Make IR execute - critical path |
| 2 | 7-10 | 15-19 | P1 | Complete core features |
| 3 | 11-14 | 12-16 | P2 | Polish rendering pipeline |
| 4 | 15-16 | 7-9 | P2 | Compiler improvements |
| 5 | 17-18 | 9-11 | P1 | Export & determinism |
| 6 | 19-20 | 6-8 | P2 | Debug system |

### Gap Coverage by Sprint

| SPEC | Total Gaps | Covered Sprints |
|------|-----------|-----------------|
| SPEC-01 | 4 | Sprint 4 |
| SPEC-02 | 7 | Sprints 5, 8, 9, 14 |
| SPEC-03 | 5 | Sprints 7, 8, 10 |
| SPEC-04 | 10 | Sprints 11, 12, 13 |
| SPEC-05 | 6 | Sprints 1, 10, 15 |
| SPEC-06 | 6 | Sprints 6, 14 |
| SPEC-07 | 5 | Sprints 3, 10, 14 |
| SPEC-08 | 5 | Sprint 2 |
| SPEC-09 | 8 | Sprints 1, 2, 3, 5, 15, 16, 20 |
| SPEC-10 | 6 | Sprints 17, 18 |
| SPEC-11 | 6 | Sprints 19, 20 |

---

## Recommended Execution Strategy

### Critical Path (Sequential)
Execute Sprints 1-6 sequentially. These are the foundation and cannot be parallelized.

**Estimated Time**: 22-27 days (4.5-5.5 weeks)

### After Sprint 6: Choose Your Path

**Option A: Completeness First**
- Execute Sprints 7-16 to achieve feature parity
- Then Sprints 17-20 for export and debug
- **Total**: 71-90 days

**Option B: Export-Focused**
- After Sprint 6, do Sprints 17-18 (export)
- Then fill in Sprints 7-16, 19-20 as needed
- Enables content creation sooner

**Option C: Debug-Focused**
- After Sprint 6, do Sprints 19-20 (debug)
- Then Sprints 7-18 for features/export
- Improves developer experience early

### Parallel Execution (If Team Size Allows)

After Sprint 6, work can proceed in parallel streams:
- **Stream A**: Sprints 7, 10 (stateful ops, events)
- **Stream B**: Sprints 8, 9, 14 (field ops, non-numeric)
- **Stream C**: Sprints 11, 12, 13 (rendering)
- **Stream D**: Sprints 15, 16 (compiler)
- **Stream E**: Sprints 17, 18 (export)
- **Stream F**: Sprints 19, 20 (debug)

This could reduce Phase 2-6 time from ~48-63 days to ~20-30 days with adequate parallelization.

---

## Next Steps

1. **Confirm Sprint 1 readiness** - Verify no blockers
2. **Review and approve plan** - User confirms approach
3. **Begin Sprint 1** - Time Architecture Foundation
4. **After Phase 1** - User decides priority: completeness, export, or debug
5. **Iterate through phases** - Track progress, adjust as needed

This plan provides a comprehensive roadmap to 100% IR implementation completeness.
