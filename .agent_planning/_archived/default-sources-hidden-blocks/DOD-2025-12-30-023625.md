# Definition of Done: Default Sources as Hidden Blocks
Generated: 2025-12-30-023625
Plan: PLAN-2025-12-30-023625.md
Source: STATUS-2025-12-30-022454.md

---

## Sprint 1: Fix TypeScript Compilation

### Deliverable: Fix bus-compilation test syntax error

- [ ] Syntax error on line 27 is identified and fixed
- [ ] `just typecheck` completes without errors
- [ ] `just test` runs without compilation failures
- [ ] No new errors introduced

**Manual Verification:**
- [ ] Run `just typecheck` - confirms no TS errors
- [ ] Run `just test` - confirms tests execute
- [ ] Run `just build` - confirms production build works

---

## Sprint 2: Deterministic IDs Foundation

### Deliverable: Implement deterministic ID generation

- [ ] `createDefaultSourcesForBlock()` uses `ds:input:${blockId}:${slotId}` pattern
- [ ] Future provider IDs use `dsprov:${blockId}:${slotId}` pattern
- [ ] Future provider input defaults use `ds:prov:${providerId}:${inputId}` pattern
- [ ] Helper function `targetKey(blockId, slotId)` returns deterministic key
- [ ] All existing DefaultSource creation uses new IDs

### Deliverable: Backward compatibility loader

- [ ] If DefaultSource.id doesn't match deterministic pattern, regenerate it deterministically
- [ ] Log warning when regenerating IDs (for debugging)
- [ ] No data loss during load
- [ ] After save, patch uses only deterministic IDs

**Manual Verification:**
- [ ] Run `just dev`
- [ ] Create new block with default source
- [ ] Check stored patch JSON - IDs should be `ds:input:blockId:slotId` format
- [ ] Save and reload patch
- [ ] Verify IDs remain stable across save/load cycles
- [ ] Check console - no ID regeneration warnings

---

## Sprint 3: Core Type System and Allowlist

### Deliverable: Create default source type system

- [ ] File `src/editor/defaultSources/types.ts` exists
- [ ] `DefaultSourceTarget` type defined (blockId + slotId)
- [ ] `DefaultSourceProvider` type defined (providerId, blockType, outputPortId, editableInputSourceIds)
- [ ] `DefaultSourceAttachment` type defined (target + provider)
- [ ] All types are readonly (use `Readonly<>` wrapper)
- [ ] Types export correctly

### Deliverable: Create const provider infrastructure

- [ ] File `src/editor/defaultSources/constProviders.ts` exists
- [ ] `CONST_PROVIDER_MAPPING` maps SlotType patterns to block types
- [ ] `DEFAULT_CONST_PROVIDER_BLOCKS` array of provider specs
- [ ] Covers all common slot types (9+ types): Signal<float/int/color/vec2>, Field<float/vec2/color>, Scalar<string/waveform>
- [ ] Each entry specifies: blockType, label, outputPortId, editableInputs: ['value']

### Deliverable: Create allowlist infrastructure

- [ ] File `src/editor/defaultSources/allowlist.ts` exists
- [ ] `DefaultSourceProviderBlockSpec` type defined (blockType, label, outputPortId, editableInputs, busInputs)
- [ ] `DEFAULT_SOURCE_PROVIDER_BLOCKS` array exported
- [ ] Spreads `...DEFAULT_CONST_PROVIDER_BLOCKS` from constProviders.ts
- [ ] No hardcoded Oscillator yet (added in Sprint 15)

### Deliverable: Add Patch.defaultSourceAttachments field

- [ ] File `src/editor/types.ts` modified
- [ ] `Patch` interface has new field: `defaultSourceAttachments?: DefaultSourceAttachment[]`
- [ ] Import `DefaultSourceAttachment` from `./defaultSources/types`
- [ ] TypeScript compiles without errors

**Manual Verification:**
- [ ] Run `just typecheck` - confirms types compile
- [ ] Check imports resolve correctly
- [ ] New types appear in IDE autocomplete

---

## Sprint 4: First Const Provider Block (DSConstSignalFloat)

### Deliverable: Create DSConstSignalFloat editor block

- [ ] File `src/editor/blocks/default-source-providers.ts` created
- [ ] `DSConstSignalFloat` block definition exported
- [ ] Block has input slot: `value` (Signal<float>, with defaultSource metadata)
- [ ] Block has output slot: `out` (Signal<float>)
- [ ] Block tagged: `tags: { role: 'defaultSourceProvider', hidden: true }`
- [ ] Block has friendly label: "Constant (Signal<float>)"

### Deliverable: Create DSConstSignalFloat compiler block

- [ ] Directory `src/editor/compiler/blocks/defaultSources/` created
- [ ] File `DSConstSignalFloat.ts` created
- [ ] Compiler exports block compiler function
- [ ] Compiler implementation: output artifact = input artifact (pass-through)
- [ ] Registered in `src/editor/compiler/blocks/index.ts`

### Deliverable: Register DSConstSignalFloat in registry

- [ ] File `src/editor/blocks/registry.ts` imports default-source-providers module
- [ ] DSConstSignalFloat included in `ALL_INDIVIDUAL_BLOCKS` array
- [ ] `getBlockTags(definition)` recognizes `hidden: true` tag
- [ ] Block appears in `BLOCK_DEFS_BY_TYPE` map

**Manual Verification:**
- [ ] Run `just dev`
- [ ] Open DevTools console
- [ ] Check block registry: DSConstSignalFloat should be registered
- [ ] Verify block has correct tags
- [ ] Block WILL appear in palette (filtering not yet implemented - that's Sprint 6)

---

## Sprint 5: Complete Const Provider Family

### Deliverable: Create remaining const provider editor blocks

- [ ] `DSConstSignalInt` block defined (Signal<int> input/output)
- [ ] `DSConstSignalColor` block defined (Signal<color> input/output)
- [ ] `DSConstSignalVec2` block defined (Signal<vec2> input/output)
- [ ] `DSConstFieldFloat` block defined (Field<float> input/output)
- [ ] `DSConstFieldVec2` block defined (Field<vec2> input/output)
- [ ] `DSConstFieldColor` block defined (Field<color> input/output)
- [ ] `DSConstScalarString` block defined (Scalar:string input/output)
- [ ] `DSConstScalarWaveform` block defined (Scalar:waveform input/output)
- [ ] All blocks in `src/editor/blocks/default-source-providers.ts`
- [ ] All blocks tagged hidden
- [ ] All blocks have `value` input with defaultSource metadata

### Deliverable: Create remaining const provider compiler blocks

- [ ] 8 compiler files in `src/editor/compiler/blocks/defaultSources/`: DSConstSignalInt.ts, DSConstSignalColor.ts, DSConstSignalVec2.ts, DSConstFieldFloat.ts, DSConstFieldVec2.ts, DSConstFieldColor.ts, DSConstScalarString.ts, DSConstScalarWaveform.ts
- [ ] All implement pass-through: `outputs.out = inputs.value`
- [ ] All registered in `src/editor/compiler/blocks/index.ts`

### Deliverable: Register all const providers in registry

- [ ] All 9 DSConst* blocks imported in registry.ts
- [ ] All 9 included in ALL_INDIVIDUAL_BLOCKS
- [ ] All 9 appear in BLOCK_DEFS_BY_TYPE map
- [ ] All 9 have `hidden: true` tag
- [ ] TypeScript compiles without errors

**Manual Verification:**
- [ ] Run `just dev`
- [ ] Check DevTools: all 9 DSConst* blocks registered
- [ ] Verify tags: all have `hidden: true`
- [ ] Note: blocks WILL appear in palette (filtering Sprint 6)

---

## Sprint 6: Hide Provider Blocks from UI

### Deliverable: Create centralized hidden block filter

- [ ] Helper function `isBlockHidden(definition: BlockDefinition): boolean` exists
- [ ] Returns `true` if `getBlockTags(def).hidden === true`
- [ ] Location: `src/editor/blocks/registry.ts` or new `src/editor/blocks/utils.ts`
- [ ] Exported for use throughout codebase

### Deliverable: Filter BlockLibrary

- [ ] File `src/editor/BlockLibrary.tsx` modified
- [ ] `groupBlocksByForm()` function filters hidden blocks
- [ ] Uses `isBlockHidden(def)` helper
- [ ] Hidden blocks do not appear in any category
- [ ] Non-hidden blocks unaffected

### Deliverable: Audit and filter other block lists

- [ ] Grep for block list/iteration patterns: `BLOCK_DEFS_BY_TYPE`, `ALL_INDIVIDUAL_BLOCKS`, `getBlockDefinition()`
- [ ] Identify all UI locations that show block lists
- [ ] Apply `isBlockHidden()` filter to each
- [ ] Document any locations where hidden blocks SHOULD be visible (e.g., diagnostics for debugging)
- [ ] No hidden blocks appear in user-facing UI

**Manual Verification:**
- [ ] Run `just dev`
- [ ] Check block palette - no DSConst* blocks visible
- [ ] Right-click in PatchBay - check context menus
- [ ] Search for "const" in block search (if exists)
- [ ] Verify no DSConst* blocks in any user-facing lists

---

## Sprint 7: Store Refactoring for Attachments

### Deliverable: Add attachment storage to DefaultSourceStore

- [ ] File `src/editor/stores/DefaultSourceStore.ts` modified
- [ ] New field: `attachmentsByTarget: Map<string, DefaultSourceAttachment>`
- [ ] Helper: `private targetKey(blockId: string, slotId: string): string`
- [ ] Method: `getAttachmentForInput(blockId, slotId): DefaultSourceAttachment | undefined`
- [ ] Method: `setAttachmentForInput(blockId, slotId, attachment): void`
- [ ] Method: `removeAttachmentForInput(blockId, slotId): void`
- [ ] All methods are MobX actions
- [ ] Map is MobX observable

### Deliverable: Create attachment factory helpers

- [ ] Method: `createDefaultAttachmentForSlot(blockId, slotId, slotType): DefaultSourceAttachment`
- [ ] Uses deterministic provider ID: `dsprov:${blockId}:${slotId}`
- [ ] Selects appropriate Const provider block type based on slotType
- [ ] Uses `CONST_PROVIDER_MAPPING` from constProviders.ts
- [ ] Creates provider with correct output port ('out')
- [ ] Creates editableInputSourceIds map for provider's 'value' input
- [ ] Returns complete DefaultSourceAttachment object

### Deliverable: Refactor createDefaultSourcesForBlock

- [ ] `createDefaultSourcesForBlock()` creates both DefaultSourceState AND DefaultSourceAttachment
- [ ] For each input with slot.defaultSource metadata: Creates deterministic DefaultSourceState (id: `ds:input:${blockId}:${slotId}`), Creates DefaultSourceAttachment with Const provider, Stores both in respective maps
- [ ] No random IDs generated
- [ ] Backward compat: if called for existing block, updates attachments

**Manual Verification:**
- [ ] Run `just dev`
- [ ] Add block with default sources (e.g., Circle with radius input)
- [ ] Check store state in DevTools MobX inspector
- [ ] Verify DefaultSourceState has deterministic ID
- [ ] Verify DefaultSourceAttachment exists with Const provider
- [ ] Check provider ID is deterministic

---

## Sprint 8: Patch Persistence

### Deliverable: Serialize attachments in toJSON()

- [ ] File `src/editor/stores/RootStore.ts` modified
- [ ] `toJSON()` method includes `defaultSourceAttachments` field
- [ ] Converts `attachmentsByTarget` map to array
- [ ] Serialized format matches Patch type
- [ ] Existing fields (defaultSources, blocks, etc.) unaffected

### Deliverable: Deserialize attachments in loadPatch()

- [ ] File `src/editor/stores/RootStore.ts` modified
- [ ] `loadPatch()` method loads `defaultSourceAttachments` if present
- [ ] Populates `DefaultSourceStore.attachmentsByTarget` map
- [ ] Loads defaultSources (existing behavior preserved)
- [ ] If `defaultSourceAttachments` missing, triggers backward compat rebuild

### Deliverable: Implement backward compatibility rebuild

- [ ] Method: `DefaultSourceStore.rebuildAttachmentsFromBlocks()`
- [ ] Iterates through all blocks in patch
- [ ] For each input with slot.defaultSource metadata: Creates DefaultSourceAttachment with appropriate Const provider, Uses existing DefaultSourceState value if present
- [ ] Logs info message about rebuild (for debugging)
- [ ] No data loss - existing defaults preserved

**Manual Verification:**
- [ ] Run `just dev`
- [ ] Create patch with multiple blocks and defaults
- [ ] Save patch (inspect JSON - should have attachments)
- [ ] Manually delete `defaultSourceAttachments` from saved JSON
- [ ] Load patch
- [ ] Verify attachments rebuilt automatically
- [ ] Verify defaults still work
- [ ] Check console for rebuild message

---

## Sprint 9: Compiler Injection Infrastructure

### Deliverable: Create injection function skeleton

- [ ] File `src/editor/compiler/integration.ts` modified
- [ ] Function: `injectDefaultSourceProviders(store: RootStore, patch: CompilerPatch): CompilerPatch`
- [ ] Returns new CompilerPatch with injected primitives
- [ ] Does NOT mutate input patch (pure function)
- [ ] Skeleton handles empty attachments gracefully

### Deliverable: Detect undriven inputs

- [ ] Helper: `isInputUndriven(blockId: string, slotId: string, patch: CompilerPatch): boolean`
- [ ] Checks for wire: `patch.connections.some(c => c.to.blockId === blockId && c.to.slotId === slotId)`
- [ ] Returns true only if BOTH checks are false
- [ ] Handles edge cases (missing fields, etc.)

### Deliverable: Generate stable IDs for injected primitives

- [ ] Helper: `makeProviderWireId(providerId: string, targetBlockId: string, targetSlotId: string): string`
- [ ] Returns: `wire:ds:${providerId}->${targetBlockId}:${targetSlotId}`
- [ ] Returns: `lis:ds:${busId}->${providerId}:${inputId}`
- [ ] Provider block ID already deterministic: `dsprov:${blockId}:${slotId}` (from Sprint 2)

**Manual Verification:**
- [ ] Run `just dev`
- [ ] Create block with undriven input
- [ ] Set up attachment (const provider)
- [ ] Compile patch (trigger via UI)
- [ ] Check compiled CompilerPatch in debugger
- [ ] Verify no injection yet (that's Sprint 10)

---

## Sprint 10: Inject Provider Blocks and Wires

### Deliverable: Inject provider blocks

- [ ] For each attachment where input is undriven: Add provider block to `CompilerPatch.blocks` (if not already added), Block ID: attachment.provider.providerId, Block type: attachment.provider.blockType
- [ ] Deduplication: track added providers, don't add twice
- [ ] Provider blocks have no position (x/y = 0) - they're hidden
- [ ] Provider blocks have no user-editable fields except those in editableInputSourceIds

### Deliverable: Inject provider wires

- [ ] For each attachment where input is undriven: Create wire: `{ id, from: { blockId: providerId, slotId: provider.outputPortId }, to: { blockId, slotId } }`, Wire ID: use `makeProviderWireId()` helper
- [ ] Add wire to `patch.connections` array
- [ ] Wire makes input appear "driven" to downstream compilation

### Deliverable: Extend defaultSourceValues map

- [ ] For each injected provider: For each editableInputSourceId: Look up DefaultSourceState value, Add to `defaultSourceValues[\"${providerId}:${inputId}\"]`
- [ ] Const provider 'value' inputs become resolvable
- [ ] Legacy compiler can resolve provider internal defaults

**Manual Verification:**
- [ ] Run `just dev`
- [ ] Create Circle block (has radius input with default)
- [ ] Leave radius unwired
- [ ] Verify circle renders with default radius
- [ ] Check CompilerPatch in debugger: DSConstSignalFloat provider block exists, Wire from provider to Circle.radius exists, defaultSourceValues has provider value entry
- [ ] Change radius default value
- [ ] Verify circle size updates

---



- [ ] Handles missing bus per user directive: FAIL COMPILATION with clear error

### Deliverable: Handle missing bus error case

- [ ] If bus not found, throw error (don't return null/undefined)
- [ ] Error message is clear and actionable: Identifies which provider needs the bus, Names the missing bus, Suggests creating the bus or choosing different provider
- [ ] Error follows CLAUDE.md principle: "Fail fast with clear messages"
- [ ] Error appears in diagnostic panel (if hooked up) or console

### Deliverable: Integrate injection into editorToPatch()

- [ ] File `src/editor/compiler/integration.ts` modified
- [ ] In `editorToPatch()` function, after building initial CompilerPatch: Call: `patch = injectDefaultSourceProviders(store, patch)`
- [ ] Injection happens before returning CompilerPatch
- [ ] Both legacy and IR compilers see injected graph

**Manual Verification:**
- [ ] Run `just dev`
- [ ] Create block with undriven input that has default
- [ ] Open DevTools, set breakpoint in `injectDefaultSourceProviders()`
- [ ] Trigger compilation (change something in patch)
- [ ] Verify injection runs
- [ ] Step through: check provider blocks, wires added
- [ ] Continue execution
- [ ] Verify output renders correctly

---

## Sprint 12: Basic Provider Selection UI

### Deliverable: Add provider type dropdown

- [ ] File `src/editor/Inspector.tsx` modified
- [ ] DefaultSourcesSection shows dropdown per input: "Provider Type"
- [ ] Dropdown options: ["Constant"] (only one option for now)
- [ ] Selection is wired to DefaultSourceStore
- [ ] Changing selection updates attachment
- [ ] Default selection: "Constant"

### Deliverable: Wire selection to attachment updates

- [ ] Dropdown onChange handler calls `store.setAttachmentForInput()`
- [ ] Creates new attachment with selected provider type
- [ ] Preserves existing default value (if compatible)
- [ ] Triggers recompilation
- [ ] UI updates to reflect new provider

### Deliverable: Preserve constant value editing

- [ ] When provider is Const type: Show existing DefaultSourceControl component, Control edits provider 'value' input, UI identical to pre-refactor behavior
- [ ] No visual regression
- [ ] Editing works same as before

**Manual Verification:**
- [ ] Run `just dev`
- [ ] Add block with numeric input default (e.g., Circle radius)
- [ ] Check Inspector: "Provider Type: Constant" dropdown visible, Value slider/input visible (same as before)
- [ ] Edit value - verify circle updates
- [ ] Save and reload - verify value persists
- [ ] Compare to pre-refactor screenshots - should look identical

---

## Sprint 13: Provider Config Panel UI

### Deliverable: Add provider config panel component

- [ ] New component: `ProviderConfigPanel` (or similar)
- [ ] Props: `attachment: DefaultSourceAttachment, blockId: string, slotId: string`
- [ ] Renders provider type header: "Default Source: {providerLabel}"
- [ ] For Const providers: shows only value control (same as Sprint 12)
- [ ] For future non-Const providers: shows bus feeds + editable inputs
- [ ] Component is reusable, well-structured

### Deliverable: Display bus-fed inputs as read-only

- [ ] Get provider spec from allowlist
- [ ] For each entry in spec.busInputs: Render row: "{inputLabel} ← bus {busName}", Row is read-only (no editing), Use grayed-out or distinct styling
- [ ] If no busInputs, this section is hidden

### Deliverable: Display editable inputs with controls

- [ ] Get provider spec from allowlist
- [ ] For each entry in spec.editableInputs: Get provider input default source, Render DefaultSourceControl, Control edits provider internal input
- [ ] Controls work same as block input defaults
- [ ] Changes trigger recompilation

**Manual Verification:**
- [ ] Run `just dev`
- [ ] Add block with default (Circle radius)
- [ ] Check Inspector: Provider Type: Constant, Provider config panel shows, Only "value" control visible (Const provider)
- [ ] UI should look clean and organized
- [ ] No errors in console

---

## Sprint 14: Driven Input UI Polish

### Deliverable: Detect driven vs undriven inputs

- [ ] Helper: `isInputDriven(blockId: string, slotId: string): boolean`
- [ ] Checks for wire: `store.connectionStore.connections.some(...)`
- [ ] Returns true if EITHER exists
- [ ] Used to control UI read-only state

### Deliverable: Show driven inputs as read-only

- [ ] When `isInputDriven()` returns true: Provider type dropdown disabled, Provider config controls disabled/read-only, "Overridden" indicator shown
- [ ] When false: controls are editable
- [ ] Visual distinction: grayed out or labeled "overridden"

### Deliverable: Test wire/disconnect behavior

- [ ] Wire input → provider config becomes read-only
- [ ] Output follows wire (not provider)
- [ ] Disconnect wire → provider config becomes editable
- [ ] Output returns to provider behavior
- [ ] No visual glitches or state inconsistencies

**Manual Verification:**
- [ ] Run `just dev`
- [ ] Add Circle block (radius input)
- [ ] Set radius default to 50
- [ ] Verify circle size reflects default, Inspector shows editable provider config
- [ ] Wire another block to radius input
- [ ] Verify circle size follows wire, Inspector shows read-only provider config with "overridden" label
- [ ] Disconnect wire
- [ ] Verify circle size returns to default (50), Inspector shows editable provider config again

---

## Sprint 15: Add Oscillator Provider

### Deliverable: Add Oscillator to allowlist

- [ ] File `src/editor/defaultSources/allowlist.ts` modified
- [ ] Oscillator entry added to DEFAULT_SOURCE_PROVIDER_BLOCKS with blockType, label, outputPortId, editableInputs, busInputs
- [ ] Oscillator requires 'phaseA' bus (standard time bus)
- [ ] Oscillator output is Signal<float>

### Deliverable: Update provider dropdown to show Oscillator

- [ ] File `src/editor/Inspector.tsx` modified
- [ ] Dropdown options generated from DEFAULT_SOURCE_PROVIDER_BLOCKS
- [ ] Filter providers by output type compatibility with target slot type
- [ ] Signal<float> input shows: "Constant", "Oscillator (Sine/LFO)"
- [ ] Dropdown enabled (was disabled in Sprint 12)
- [ ] Selection updates attachment with chosen provider

### Deliverable: Test Oscillator as default source

- [ ] Select Oscillator provider for Signal<float> input
- [ ] Provider config shows: Bus feed: "phase ← bus phaseA" (read-only), Editable: shape, amplitude, bias controls
- [ ] Changing shape/amplitude/bias updates output
- [ ] Output animates over time (sine wave)

**Manual Verification:**
- [ ] Run `just dev`
- [ ] Add Circle block (radius input)
- [ ] Set radius provider to "Oscillator (Sine/LFO)"
- [ ] Inspector shows: Provider Type: Oscillator, "phase ← bus phaseA" (read-only), shape/amplitude/bias controls
- [ ] Set amplitude=20, bias=30
- [ ] Verify circle pulses: radius oscillates 30±20
- [ ] Change shape to triangle
- [ ] Verify motion changes to triangle wave
- [ ] No errors in console

---

## Sprint 16: Type Compatibility Validation

### Deliverable: Create validation module infrastructure

- [ ] File `src/editor/defaultSources/validate.ts` created
- [ ] Function: `validateDefaultSourceAttachments(rootStore: RootStore): Diagnostic[]`
- [ ] Returns array of Diagnostic objects (errors/warnings)
- [ ] Diagnostic structure matches existing diagnostic system
- [ ] Module is pure - no side effects

### Deliverable: Validate output type compatibility

- [ ] For each attachment: Get target block/slot, Get provider block/output slot, Check semantic type compatibility, If incompatible: emit error diagnostic
- [ ] Diagnostic message is clear: "Provider {providerType} output type {outputType} incompatible with {BlockName}.{inputName} type {inputType}"
- [ ] Use existing semantic type compatibility checker (if exists)

### Deliverable: Test type mismatch detection

- [ ] Create attachment with incompatible types (e.g., Oscillator → Field<float> input)
- [ ] Run validation
- [ ] Diagnostic error appears
- [ ] Error message is clear and actionable

**Manual Verification:**
- [ ] Run `just dev`
- [ ] Manually edit patch JSON to create type mismatch: Provider: Oscillator (Signal<float>), Target: Field<float> input
- [ ] Load patch
- [ ] Run validation (via console or integrated diagnostic)
- [ ] Verify error diagnostic appears
- [ ] Check error message clarity

---

## Sprint 17: Allowlist and Bus Validation

### Deliverable: Validate provider is allowlisted

- [ ] For each attachment: Check provider exists in DEFAULT_SOURCE_PROVIDER_BLOCKS, If false: emit error diagnostic
- [ ] Error message: "Provider block type {blockType} is not allowlisted. Only certain blocks may be used as default source providers."
- [ ] List allowed types in error (helpful)

### Deliverable: Validate required buses exist

- [ ] For each attachment: Get provider spec, For each busInput: check bus exists, If not found: emit error diagnostic
- [ ] Error message: "Default provider for {BlockName}.{inputName} requires bus '{busName}' which does not exist. Create the bus or select a different provider."
- [ ] Diagnostic is ERROR level (blocks compilation)

### Deliverable: Integrate validation into diagnostic system

- [ ] Validation runs automatically during compilation or semantic validation pass
- [ ] Diagnostics appear in diagnostic panel UI (if exists)
- [ ] Diagnostics appear in console (minimum)
- [ ] Validation errors prevent compilation (if severity: error)
- [ ] No duplicate validation runs

**Manual Verification:**
- [ ] Run `just dev`
- [ ] Create attachment with missing bus (Oscillator without phaseA)
- [ ] Check diagnostic panel/console
- [ ] Verify error appears with clear message
- [ ] Create the bus (phaseA)
- [ ] Verify error disappears
- [ ] Test with non-allowlisted provider (manually edit JSON)
- [ ] Verify allowlist error appears

---

## Sprint 18: Cycle Detection and Final Polish

### Deliverable: Implement cycle detection

- [ ] Diagnostic message: "Potential feedback cycle: provider reads bus {busName} but target block {BlockName} publishes to same bus"
- [ ] Severity: WARNING (not blocking)

### Deliverable: Add final edge case validations

- [ ] Validate provider output port exists (spec.outputPortId)
- [ ] Validate all editableInputs exist in provider definition
- [ ] Validate all editableInputs have defaultSource metadata
- [ ] Validate provider has no other required inputs besides busInputs and editableInputs
- [ ] Emit error diagnostic for each violation

### Deliverable: Comprehensive manual verification

- [ ] Scenario 1: Constant default still works (no regressions)
- [ ] Scenario 2: Oscillator default works and animates
- [ ] Scenario 3: Wire override/disconnect behavior correct
- [ ] Scenario 4: No provider leakage in bus UI
- [ ] All acceptance criteria from plan met
- [ ] No errors in console during any scenario

**Manual Verification:**
- [ ] **Scenario 1: Constant default unchanged** - Add block, leave unwired, edit value, verify output changes, no regressions
- [ ] **Scenario 2: Oscillator default animates** - Set Oscillator provider, UI shows controls, change shape, verify animated output changes
- [ ] **Scenario 3: Wire override/disconnect** - Wire input, verify read-only + follows wire, disconnect, verify returns to provider
- [ ] **Save/load** - Create patch with providers, save, reload, verify persistence and behavior

### Deliverable: Update documentation (OPTIONAL)

- [ ] If user requests: update architecture docs
- [ ] If user requests: add examples to docs
- [ ] If user requests: update CLAUDE.md with new patterns
- [ ] Otherwise: skip (per CLAUDE.md: "NEVER proactively create documentation files")

---

## Final Acceptance Criteria (Overall Feature)

- [ ] Default source can be set to Oscillator for compatible input
- [ ] Provider not visible as block in PatchBay
- [ ] Provider cannot be wired like normal block
- [ ] Provider only reads from global buses/time + internal constants
- [ ] Compiler behavior is consistent (both legacy and IR)
- [ ] All provider types live in one allowlist file

---

## Sprint Scope Summary

This plan delivers the complete Default Sources as Hidden Blocks feature in 18 sprints:

**Sprint 1-2**: Blockers & Foundation (2 deliverables)
**Sprint 3**: Type System & Allowlist (4 deliverables)
**Sprint 4-6**: Const Provider Blocks (8 deliverables)
**Sprint 7-8**: Store & Persistence (6 deliverables)
**Sprint 9-11**: Compiler Injection (9 deliverables)
**Sprint 12-14**: UI (9 deliverables)
**Sprint 15-18**: Advanced Providers & Validation (12 deliverables)

**Total**: 50 deliverables across 18 sprints
**Estimated duration**: 11 weeks
**Complexity**: High (architectural changes across multiple systems)
**Risk level**: High (mitigated by incremental approach)

Deferred to future work: Additional provider types beyond Oscillator, performance optimizations, advanced cycle detection.
