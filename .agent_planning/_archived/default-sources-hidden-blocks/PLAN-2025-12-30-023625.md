# Implementation Plan: Default Sources as Hidden Blocks
Generated: 2025-12-30-023625
Source: STATUS-2025-12-30-022454.md
Topic: Default Sources as Hidden, Allowlisted Blocks

---

## Executive Summary

**Current State**: This is a greenfield feature with 0% completion. The existing default source infrastructure handles only constant values. TypeScript compilation is currently broken due to a test file syntax error.

**Total Gap**: Complete transformation of default source system from simple constants to hidden provider blocks, requiring:
- New type system and allowlist infrastructure
- Comprehensive const provider block family (9+ block types)
- Store refactoring with deterministic IDs
- Compiler injection system
- UI overhaul for provider selection/configuration
- Validation infrastructure

**Recommended Focus**:
1. Fix TypeScript compilation blocker
2. Implement deterministic IDs first (foundation for persistence)
3. Build const provider infrastructure (enables "all defaults are blocks")
4. Implement compiler injection (enables runtime behavior)
5. Add UI for provider selection (enables user-facing functionality)
6. Add advanced providers (Oscillator, etc.)

**Sprint Breakdown**: 18 sprints organized into 6 phases
- Phase 0: Blockers & Foundation (Sprints 1-2)
- Phase A: Type System & Allowlist (Sprint 3)
- Phase B: Const Provider Blocks (Sprints 4-6)
- Phase C: Store & Persistence (Sprints 7-8)
- Phase D: Compiler Injection (Sprints 9-11)
- Phase E: UI (Sprints 12-14)
- Phase F: Advanced Providers & Validation (Sprints 15-18)

**Risk Assessment**:
- HIGH: ID migration strategy (mitigated by deterministic IDs upfront)
- HIGH: Compiler injection complexity (mitigated by incremental testing)
- MEDIUM: UI complexity (mitigated by phased rollout)
- MEDIUM: Hidden block leakage (mitigated by centralized filtering)

---

## Dependency Graph

```
Sprint 1 (Fix TS compilation)
  ↓
Sprint 2 (Deterministic IDs)
  ↓
Sprint 3 (Type system + Allowlist)
  ↓
Sprint 4-6 (Const provider blocks)
  ↓
Sprint 7-8 (Store + Persistence)
  ↓
Sprint 9-11 (Compiler injection)
  ↓
Sprint 12-14 (UI)
  ↓
Sprint 15-18 (Advanced providers + Validation)
```

---

## Phase 0: Blockers & Foundation

### Sprint 1: Fix TypeScript Compilation

**Sprint Goal**: Unblock development by fixing compilation error in test file

**In Scope**:
- Fix syntax error in `src/editor/__tests__/bus-compilation.test.ts:27`
- Verify TypeScript compilation succeeds
- Verify existing tests pass

**Work Items**:

#### P0: Fix bus-compilation test syntax error

**Status**: Not Started
**Effort**: Small (1 hour)
**Dependencies**: None
**Spec Reference**: N/A • **Status Reference**: STATUS-2025-12-30-022454.md (lines 12-13)

**Description**:
TypeScript compilation is currently broken due to a syntax error on line 27 of the bus compilation test file. This blocks all development work.

**Acceptance Criteria**:
- [ ] Syntax error on line 27 is identified and fixed
- [ ] `just typecheck` completes without errors
- [ ] `just test` runs without compilation failures
- [ ] No new errors introduced

**Technical Notes**:
- File: `src/editor/__tests__/bus-compilation.test.ts`
- Line 27 contains the syntax error
- May be a missing/extra bracket, quote, or comma
- Use `just typecheck` to verify fix

**Manual Verification**:
- [ ] Run `just typecheck` - confirms no TS errors
- [ ] Run `just test` - confirms tests execute
- [ ] Run `just build` - confirms production build works

**Dependencies**: None

---

### Sprint 2: Deterministic IDs Foundation

**Sprint Goal**: Replace random ID generation with deterministic IDs for default sources

**In Scope**:
- Refactor DefaultSourceStore to use deterministic IDs
- Implement backward compatibility for loading old patches
- Document ID schema

**Work Items**:

#### P0: Implement deterministic ID generation

**Status**: Not Started
**Effort**: Small (2-3 days)
**Dependencies**: Sprint 1
**Spec Reference**: PLAN Section 5.2 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 221-231)

**Description**:
Replace `root.generateId('ds')` with deterministic ID generation scheme. Current random IDs prevent stable persistence and make debugging impossible. New scheme enables stable references and future provider block injection.

**Acceptance Criteria**:
- [ ] `createDefaultSourcesForBlock()` uses `ds:input:${blockId}:${slotId}` pattern
- [ ] Future provider IDs use `dsprov:${blockId}:${slotId}` pattern
- [ ] Future provider input defaults use `ds:prov:${providerId}:${inputId}` pattern
- [ ] Helper function `targetKey(blockId, slotId)` returns deterministic key
- [ ] All existing DefaultSource creation uses new IDs

**Technical Notes**:
- File: `src/editor/stores/DefaultSourceStore.ts`
- Current line 191: `root.generateId('ds')` - REMOVE THIS
- Add helper: `private targetKey(blockId: string, slotId: string): string { return `${blockId}:${slotId}`; }`
- ID patterns:
  - Input default: `ds:input:${blockId}:${slotId}`
  - Provider block: `dsprov:${blockId}:${slotId}`
  - Provider input: `ds:prov:${providerId}:${inputId}`

#### P1: Backward compatibility loader

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 5.3 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 234-239)

**Description**:
OLD patches use random `ds-*` IDs. NEW patches use deterministic IDs. We need NO backward compatibility (user confirmed: no existing patches to worry about). However, we still need to handle missing IDs gracefully.

**Acceptance Criteria**:
- [ ] If DefaultSource.id doesn't match deterministic pattern, regenerate it deterministically
- [ ] Log warning when regenerating IDs (for debugging)
- [ ] No data loss during load
- [ ] After save, patch uses only deterministic IDs

**Technical Notes**:
- File: `src/editor/stores/RootStore.ts` - `loadPatch()` method
- Check pattern: `/^ds:input:/` for new-style IDs
- If old-style (random): regenerate using `ds:input:${blockId}:${slotId}`
- This is defensive coding - user says no old patches exist, but handle gracefully anyway

**Manual Verification**:
- [ ] Run `just dev`
- [ ] Create new block with default source
- [ ] Check stored patch JSON - IDs should be `ds:input:blockId:slotId` format
- [ ] Save and reload patch
- [ ] Verify IDs remain stable across save/load cycles
- [ ] Check console - no ID regeneration warnings

**Dependencies**: Sprint 1 complete

---

## Phase A: Type System & Allowlist

### Sprint 3: Core Type System and Allowlist

**Sprint Goal**: Establish type system for default source attachments and create allowlist infrastructure

**In Scope**:
- Create types.ts with DefaultSourceAttachment types
- Create allowlist.ts with provider spec infrastructure
- Create constProviders.ts with const provider mapping
- Add defaultSourceAttachments field to Patch type

**Work Items**:

#### P0: Create default source type system

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: Sprint 2
**Spec Reference**: PLAN Section 3 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 172-177)

**Description**:
Create new module `src/editor/defaultSources/types.ts` with all core types for the attachment system. This defines the authoring-time data model for provider attachments.

**Acceptance Criteria**:
- [ ] File `src/editor/defaultSources/types.ts` exists
- [ ] `DefaultSourceTarget` type defined (blockId + slotId)
- [ ] `DefaultSourceProvider` type defined (providerId, blockType, outputPortId, editableInputSourceIds)
- [ ] `DefaultSourceAttachment` type defined (target + provider)
- [ ] All types are readonly (use `Readonly<>` wrapper)
- [ ] Types export correctly

**Technical Notes**:
- Create new directory: `src/editor/defaultSources/`
- Exact types from PLAN Section 3.1, 3.2, 3.3
- Use `Readonly<{ ... }>` for immutability
- No implementation logic - just types

#### P0: Create const provider infrastructure

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 4.3, Section 4.3.2 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 183-186)

**Description**:
Create `src/editor/defaultSources/constProviders.ts` with comprehensive mapping of slot types to const provider block types. This enables "all defaults are blocks" by ensuring every slot type has a matching const provider.

**Acceptance Criteria**:
- [ ] File `src/editor/defaultSources/constProviders.ts` exists
- [ ] `CONST_PROVIDER_MAPPING` maps SlotType patterns to block types
- [ ] `DEFAULT_CONST_PROVIDER_BLOCKS` array of provider specs
- [ ] Covers all common slot types (9+ types):
  - Signal<float> → DSConstSignalFloat
  - Signal<int> → DSConstSignalInt
  - Signal<color> → DSConstSignalColor
  - Signal<vec2> → DSConstSignalVec2
  - Field<float> → DSConstFieldFloat
  - Field<vec2> → DSConstFieldVec2
  - Field<color> → DSConstFieldColor
  - Scalar:string → DSConstScalarString
  - Scalar:waveform → DSConstScalarWaveform
- [ ] Each entry specifies: blockType, label, outputPortId, editableInputs: ['value']

**Technical Notes**:
- This is the foundation for "Constant" provider option in UI
- Each const provider will be trivial: one input `value`, one output `out`
- Comprehensive set created upfront (user directive: "COMPREHENSIVE SET UPFRONT")

#### P0: Create allowlist infrastructure

**Status**: Not Started
**Effort**: Small (1 day)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 4.1 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 179-183)

**Description**:
Create `src/editor/defaultSources/allowlist.ts` as the single source of truth for which block types can be default source providers. Initially contains only const providers; Oscillator added in later sprint.

**Acceptance Criteria**:
- [ ] File `src/editor/defaultSources/allowlist.ts` exists
- [ ] `DefaultSourceProviderBlockSpec` type defined (blockType, label, outputPortId, editableInputs, busInputs)
- [ ] `DEFAULT_SOURCE_PROVIDER_BLOCKS` array exported
- [ ] Spreads `...DEFAULT_CONST_PROVIDER_BLOCKS` from constProviders.ts
- [ ] No hardcoded Oscillator yet (added in Sprint 15)

**Technical Notes**:
- Import from `./constProviders`
- This file is the ONLY place to declare allowed providers (centralized control)
- Later sprints will add more providers by adding entries to this array

#### P1: Add Patch.defaultSourceAttachments field

**Status**: Not Started
**Effort**: Small (1 day)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 3.4 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 187-189)

**Description**:
Extend Patch interface to include new attachments field. This separates the "attachments" concept from the existing "constants table" (defaultSources).

**Acceptance Criteria**:
- [ ] File `src/editor/types.ts` modified
- [ ] `Patch` interface (around line 726) has new field: `defaultSourceAttachments: DefaultSourceAttachment[]`
- [ ] Field is optional (for backward compat): `defaultSourceAttachments?: DefaultSourceAttachment[]`
- [ ] Import `DefaultSourceAttachment` from `./defaultSources/types`
- [ ] TypeScript compiles without errors

**Technical Notes**:
- File: `src/editor/types.ts`
- Add near line 746 (after existing defaultSources field)
- Keep existing `defaultSources: DefaultSourceState[]` unchanged
- Separation rationale: defaultSources = constants table, defaultSourceAttachments = provider graph

**Manual Verification**:
- [ ] Run `just typecheck` - confirms types compile
- [ ] Check imports resolve correctly
- [ ] New types appear in IDE autocomplete

**Dependencies**: Sprint 2 complete

---

## Phase B: Const Provider Blocks

### Sprint 4: First Const Provider Block (DSConstSignalFloat)

**Sprint Goal**: Implement one complete const provider block as reference implementation

**In Scope**:
- Create DSConstSignalFloat editor block definition
- Create DSConstSignalFloat compiler block
- Register block in registry
- Tag as hidden

**Work Items**:

#### P0: Create DSConstSignalFloat editor block

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: Sprint 3
**Spec Reference**: PLAN Section 4.3.3 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 195-199)

**Description**:
Create first const provider block definition. This serves as reference implementation for remaining const providers. Block has one input (value) and one output (out), acting as pure pass-through.

**Acceptance Criteria**:
- [ ] File `src/editor/blocks/default-source-providers.ts` created
- [ ] `DSConstSignalFloat` block definition exported
- [ ] Block has input slot: `value` (Signal<float>, with defaultSource metadata)
- [ ] Block has output slot: `out` (Signal<float>)
- [ ] Block tagged: `tags: { role: 'defaultSourceProvider', hidden: true }`
- [ ] Block has friendly label: "Constant (Signal<float>)"

**Technical Notes**:
- New file: `src/editor/blocks/default-source-providers.ts`
- Input `value` MUST have `defaultSource` metadata (enables UI controls)
- Tag structure enables filtering in BlockLibrary
- This is a HIDDEN block - never shown in palette

#### P0: Create DSConstSignalFloat compiler block

**Status**: Not Started
**Effort**: Small (1 day)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 4.3.3 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 200-204)

**Description**:
Implement compiler for DSConstSignalFloat. This is a trivial pass-through: output = input. Serves as template for other const provider compilers.

**Acceptance Criteria**:
- [ ] Directory `src/editor/compiler/blocks/defaultSources/` created
- [ ] File `DSConstSignalFloat.ts` created
- [ ] Compiler exports block compiler function
- [ ] Compiler implementation: output artifact = input artifact (pass-through)
- [ ] Registered in `src/editor/compiler/blocks/index.ts`

**Technical Notes**:
- Location: `src/editor/compiler/blocks/defaultSources/DSConstSignalFloat.ts`
- Implementation: `outputs.out = inputs.value` (trivial pass-through)
- Register in compiler block index so both legacy and IR compilers recognize it
- Consider creating helper function for generating pass-through compilers (reusable for other const providers)

#### P1: Register DSConstSignalFloat in registry

**Status**: Not Started
**Effort**: Small (1 day)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 4.3.3 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 137-145)

**Description**:
Import DSConstSignalFloat into block registry so it's recognized by the system. Verify tag-based filtering would hide it from UI (though filtering not yet implemented).

**Acceptance Criteria**:
- [ ] File `src/editor/blocks/registry.ts` imports default-source-providers module
- [ ] DSConstSignalFloat included in `ALL_INDIVIDUAL_BLOCKS` array
- [ ] `getBlockTags(definition)` recognizes `hidden: true` tag
- [ ] Block appears in `BLOCK_DEFS_BY_TYPE` map

**Technical Notes**:
- File: `src/editor/blocks/registry.ts`
- Import: `import { DSConstSignalFloat } from './default-source-providers';`
- Add to ALL_INDIVIDUAL_BLOCKS spread
- No filtering yet - that's Sprint 6

**Manual Verification**:
- [ ] Run `just dev`
- [ ] Open DevTools console
- [ ] Check block registry: DSConstSignalFloat should be registered
- [ ] Verify block has correct tags
- [ ] Block WILL appear in palette (filtering not yet implemented - that's Sprint 6)

**Dependencies**: Sprint 3 complete

---

### Sprint 5: Complete Const Provider Family

**Sprint Goal**: Implement remaining 8 const provider blocks using reference pattern

**In Scope**:
- Create 8 additional const provider editor blocks
- Create 8 additional const provider compiler blocks
- Register all in registry

**Work Items**:

#### P0: Create remaining const provider editor blocks

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: Sprint 4
**Spec Reference**: PLAN Section 4.3.2 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 195-207)

**Description**:
Create 8 more const provider blocks following DSConstSignalFloat pattern. Each is a trivial pass-through with appropriate types.

**Acceptance Criteria**:
- [ ] `DSConstSignalInt` block defined (Signal<int> input/output)
- [ ] `DSConstSignalColor` block defined (Signal<color> input/output)
- [ ] `DSConstSignalVec2` block defined (Signal<vec2> input/output)
- [ ] `DSConstFieldFloat` block defined (Field<float> input/output)
- [ ] `DSConstFieldVec2` block defined (Field<vec2> input/output)
- [ ] `DSConstFieldColor` block defined (Field<color> input/output)
- [ ] `DSConstScalarString` block defined (Scalar:string input/output)
- [ ] `DSConstScalarWaveform` block defined (Scalar:waveform input/output)
- [ ] All blocks in `src/editor/blocks/default-source-providers.ts`
- [ ] All blocks tagged hidden
- [ ] All blocks have `value` input with defaultSource metadata

**Technical Notes**:
- File: `src/editor/blocks/default-source-providers.ts`
- Copy DSConstSignalFloat pattern 8 times
- Change only: block name, slot types, label
- Keep structure identical: input `value`, output `out`, tags hidden

#### P0: Create remaining const provider compiler blocks

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 4.3.3 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 200-204)

**Description**:
Create compiler blocks for all 8 remaining const providers. All are identical pass-throughs; consider creating helper function to reduce duplication.

**Acceptance Criteria**:
- [ ] 8 compiler files in `src/editor/compiler/blocks/defaultSources/`:
  - DSConstSignalInt.ts
  - DSConstSignalColor.ts
  - DSConstSignalVec2.ts
  - DSConstFieldFloat.ts
  - DSConstFieldVec2.ts
  - DSConstFieldColor.ts
  - DSConstScalarString.ts
  - DSConstScalarWaveform.ts
- [ ] All implement pass-through: `outputs.out = inputs.value`
- [ ] All registered in `src/editor/compiler/blocks/index.ts`
- [ ] Consider: create `createConstProviderCompiler(blockType)` helper

**Technical Notes**:
- Directory: `src/editor/compiler/blocks/defaultSources/`
- All are identical except for name
- Opportunity to DRY: create helper function that generates compiler from type
- Must register in compiler block index

#### P1: Register all const providers in registry

**Status**: Not Started
**Effort**: Small (1 day)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 4.3.3 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 137-145)

**Description**:
Import and register all 9 const provider blocks in registry. Verify all are tagged hidden.

**Acceptance Criteria**:
- [ ] All 9 DSConst* blocks imported in registry.ts
- [ ] All 9 included in ALL_INDIVIDUAL_BLOCKS
- [ ] All 9 appear in BLOCK_DEFS_BY_TYPE map
- [ ] All 9 have `hidden: true` tag
- [ ] TypeScript compiles without errors

**Technical Notes**:
- File: `src/editor/blocks/registry.ts`
- Import all from `./default-source-providers`
- Can import as object and spread: `import * as DSProviders from './default-source-providers'; ... Object.values(DSProviders)`

**Manual Verification**:
- [ ] Run `just dev`
- [ ] Check DevTools: all 9 DSConst* blocks registered
- [ ] Verify tags: all have `hidden: true`
- [ ] Note: blocks WILL appear in palette (filtering Sprint 6)

**Dependencies**: Sprint 4 complete

---

### Sprint 6: Hide Provider Blocks from UI

**Sprint Goal**: Filter hidden blocks from BlockLibrary and other UIs

**In Scope**:
- Add centralized `isBlockHidden()` helper
- Filter BlockLibrary
- Audit and filter other block lists (context menus, search, etc.)

**Work Items**:

#### P0: Create centralized hidden block filter

**Status**: Not Started
**Effort**: Small (1 day)
**Dependencies**: Sprint 5
**Spec Reference**: PLAN Section 4.3.4 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 206-209)

**Description**:
Create helper function to check if block should be hidden from UI. Prevents scattered `if (type.startsWith('DSConst'))` checks throughout codebase.

**Acceptance Criteria**:
- [ ] Helper function `isBlockHidden(definition: BlockDefinition): boolean` exists
- [ ] Returns `true` if `getBlockTags(def).hidden === true`
- [ ] Location: `src/editor/blocks/registry.ts` or new `src/editor/blocks/utils.ts`
- [ ] Exported for use throughout codebase

**Technical Notes**:
- Use existing `getBlockTags()` function
- Check `tags.hidden === true`
- Centralized = consistent filtering everywhere

#### P0: Filter BlockLibrary

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 4.3.4 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 147-154)

**Description**:
Update BlockLibrary component to filter out hidden blocks. Provider blocks must not appear in block palette.

**Acceptance Criteria**:
- [ ] File `src/editor/BlockLibrary.tsx` modified
- [ ] `groupBlocksByForm()` function (around lines 46-85) filters hidden blocks
- [ ] Uses `isBlockHidden(def)` helper
- [ ] Hidden blocks do not appear in any category
- [ ] Non-hidden blocks unaffected

**Technical Notes**:
- File: `src/editor/BlockLibrary.tsx`
- Function: `groupBlocksByForm()`
- Add filter: `.filter(def => !isBlockHidden(def))` before grouping logic
- Verify with `just dev` that DSConst* blocks disappear from palette

#### P1: Audit and filter other block lists

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 4.3.4 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 476-486)

**Description**:
Search for other locations that list/display blocks and apply hidden filter. Prevents provider block leakage in context menus, search, diagnostics, etc.

**Acceptance Criteria**:
- [ ] Grep for block list/iteration patterns: `BLOCK_DEFS_BY_TYPE`, `ALL_INDIVIDUAL_BLOCKS`, `getBlockDefinition()`
- [ ] Identify all UI locations that show block lists
- [ ] Apply `isBlockHidden()` filter to each
- [ ] Document any locations where hidden blocks SHOULD be visible (e.g., diagnostics for debugging)
- [ ] No hidden blocks appear in user-facing UI

**Technical Notes**:
- Use `Grep` tool to find block iteration patterns
- Common locations: context menus, search/filter UIs, block inspectors
- Some diagnostic/debug UIs may intentionally show hidden blocks - document these
- Error messages should use friendly names (user directive: "FRIENDLY NAMES like 'Default provider for BlockName.inputName'")

**Manual Verification**:
- [ ] Run `just dev`
- [ ] Check block palette - no DSConst* blocks visible
- [ ] Right-click in PatchBay - check context menus
- [ ] Search for "const" in block search (if exists)
- [ ] Verify no DSConst* blocks in any user-facing lists

**Dependencies**: Sprint 5 complete

---

## Phase C: Store & Persistence

### Sprint 7: Store Refactoring for Attachments

**Sprint Goal**: Extend DefaultSourceStore to manage attachments using deterministic IDs

**In Scope**:
- Add attachmentsByTarget map
- Add helpers for creating/updating attachments
- Refactor to use deterministic IDs from Sprint 2
- Ensure MobX observability

**Work Items**:

#### P0: Add attachment storage to DefaultSourceStore

**Status**: Not Started
**Effort**: Medium (3-4 days)
**Dependencies**: Sprint 3, Sprint 6
**Spec Reference**: PLAN Section 5.1 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 220-231)

**Description**:
Extend DefaultSourceStore to store DefaultSourceAttachment objects indexed by target input. Use deterministic IDs from Sprint 2.

**Acceptance Criteria**:
- [ ] File `src/editor/stores/DefaultSourceStore.ts` modified
- [ ] New field: `attachmentsByTarget: Map<string, DefaultSourceAttachment>`
- [ ] Helper: `private targetKey(blockId: string, slotId: string): string`
- [ ] Method: `getAttachmentForInput(blockId, slotId): DefaultSourceAttachment | undefined`
- [ ] Method: `setAttachmentForInput(blockId, slotId, attachment): void`
- [ ] Method: `removeAttachmentForInput(blockId, slotId): void`
- [ ] All methods are MobX actions
- [ ] Map is MobX observable

**Technical Notes**:
- File: `src/editor/stores/DefaultSourceStore.ts`
- Import `DefaultSourceAttachment` from `../defaultSources/types`
- Use `makeObservable(this, { attachmentsByTarget: observable })` in constructor
- targetKey format: `${blockId}:${slotId}` (simple concat, no prefix needed)

#### P0: Create attachment factory helpers

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 5.1, 5.2 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 221-231)

**Description**:
Add methods to create attachments with correct deterministic IDs and default Const provider selection based on slot type.

**Acceptance Criteria**:
- [ ] Method: `createDefaultAttachmentForSlot(blockId, slotId, slotType): DefaultSourceAttachment`
- [ ] Uses deterministic provider ID: `dsprov:${blockId}:${slotId}`
- [ ] Selects appropriate Const provider block type based on slotType
- [ ] Uses `CONST_PROVIDER_MAPPING` from constProviders.ts
- [ ] Creates provider with correct output port ('out')
- [ ] Creates editableInputSourceIds map for provider's 'value' input
- [ ] Returns complete DefaultSourceAttachment object

**Technical Notes**:
- Import `CONST_PROVIDER_MAPPING` from `../defaultSources/constProviders`
- Provider ID format: `dsprov:${blockId}:${slotId}`
- Provider input default ID format: `ds:prov:${providerId}:value`
- Fall back to DSConstSignalFloat if slot type not in mapping (log warning)

#### P1: Refactor createDefaultSourcesForBlock

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 5.1, 5.2 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 44-53, 221-231)

**Description**:
Update `createDefaultSourcesForBlock()` to create attachments in addition to default source values. This bridges old constant-only system with new attachment system.

**Acceptance Criteria**:
- [ ] `createDefaultSourcesForBlock()` creates both DefaultSourceState AND DefaultSourceAttachment
- [ ] For each input with slot.defaultSource metadata:
  - Creates deterministic DefaultSourceState (id: `ds:input:${blockId}:${slotId}`)
  - Creates DefaultSourceAttachment with Const provider
  - Stores both in respective maps
- [ ] No random IDs generated
- [ ] Backward compat: if called for existing block, updates attachments

**Technical Notes**:
- File: `src/editor/stores/DefaultSourceStore.ts`
- Function: `createDefaultSourcesForBlock()`
- Current line 191: REMOVE `root.generateId('ds')`
- Replace with deterministic ID generation
- Call `createDefaultAttachmentForSlot()` for each input

**Manual Verification**:
- [ ] Run `just dev`
- [ ] Add block with default sources (e.g., Circle with radius input)
- [ ] Check store state in DevTools MobX inspector
- [ ] Verify DefaultSourceState has deterministic ID
- [ ] Verify DefaultSourceAttachment exists with Const provider
- [ ] Check provider ID is deterministic

**Dependencies**: Sprint 6 complete

---

### Sprint 8: Patch Persistence

**Sprint Goal**: Save/load attachments with backward compatibility

**In Scope**:
- Update Patch serialization to include attachments
- Update RootStore.toJSON() to save attachments
- Update RootStore.loadPatch() to load attachments
- Implement backward compat: rebuild attachments if missing

**Work Items**:

#### P0: Serialize attachments in toJSON()

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: Sprint 7
**Spec Reference**: PLAN Section 5.3 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 232-239)

**Description**:
Update RootStore.toJSON() to include defaultSourceAttachments array in serialized patch.

**Acceptance Criteria**:
- [ ] File `src/editor/stores/RootStore.ts` modified
- [ ] `toJSON()` method includes `defaultSourceAttachments` field
- [ ] Converts `attachmentsByTarget` map to array
- [ ] Serialized format matches Patch type
- [ ] Existing fields (defaultSources, blocks, etc.) unaffected

**Technical Notes**:
- File: `src/editor/stores/RootStore.ts`
- In `toJSON()` method, add:
  ```typescript
  defaultSourceAttachments: Array.from(
    this.defaultSourceStore.attachmentsByTarget.values()
  )
  ```
- Add after existing `defaultSources` serialization

#### P0: Deserialize attachments in loadPatch()

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 5.3 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 232-239)

**Description**:
Update RootStore.loadPatch() to load defaultSourceAttachments and populate DefaultSourceStore. Handle missing field for backward compatibility.

**Acceptance Criteria**:
- [ ] File `src/editor/stores/RootStore.ts` modified
- [ ] `loadPatch()` method loads `defaultSourceAttachments` if present
- [ ] Populates `DefaultSourceStore.attachmentsByTarget` map
- [ ] Loads defaultSources (existing behavior preserved)
- [ ] If `defaultSourceAttachments` missing, triggers backward compat rebuild

**Technical Notes**:
- File: `src/editor/stores/RootStore.ts`
- In `loadPatch()` method, after loading defaultSources:
  ```typescript
  if (patch.defaultSourceAttachments) {
    for (const attachment of patch.defaultSourceAttachments) {
      this.defaultSourceStore.setAttachmentForInput(
        attachment.target.blockId,
        attachment.target.slotId,
        attachment
      );
    }
  } else {
    // Backward compat - rebuild attachments
    this.defaultSourceStore.rebuildAttachmentsFromBlocks();
  }
  ```

#### P1: Implement backward compatibility rebuild

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 5.3 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 234-239)

**Description**:
Implement `rebuildAttachmentsFromBlocks()` to create Const provider attachments for old patches that lack attachment data. User confirmed NO backward compatibility needed for existing patches, but implement defensively anyway.

**Acceptance Criteria**:
- [ ] Method: `DefaultSourceStore.rebuildAttachmentsFromBlocks()`
- [ ] Iterates through all blocks in patch
- [ ] For each input with slot.defaultSource metadata:
  - Creates DefaultSourceAttachment with appropriate Const provider
  - Uses existing DefaultSourceState value if present
- [ ] Logs info message about rebuild (for debugging)
- [ ] No data loss - existing defaults preserved

**Technical Notes**:
- File: `src/editor/stores/DefaultSourceStore.ts`
- Method: `rebuildAttachmentsFromBlocks(): void`
- Iterate blocks via `this.root.blockStore.blocks`
- Get block definition via `getBlockDefinition(block.type)`
- Check each input slot for `slot.defaultSource` metadata
- Create attachment using `createDefaultAttachmentForSlot()`

**Manual Verification**:
- [ ] Run `just dev`
- [ ] Create patch with multiple blocks and defaults
- [ ] Save patch (inspect JSON - should have attachments)
- [ ] Manually delete `defaultSourceAttachments` from saved JSON
- [ ] Load patch
- [ ] Verify attachments rebuilt automatically
- [ ] Verify defaults still work
- [ ] Check console for rebuild message

**Dependencies**: Sprint 7 complete

---

## Phase D: Compiler Injection

### Sprint 9: Compiler Injection Infrastructure

**Sprint Goal**: Create injection system that converts attachments to hidden graph primitives

**In Scope**:
- Create injectDefaultSourceProviders() function
- Integrate into editorToPatch()
- Handle undriven input detection
- Generate stable IDs for injected primitives

**Work Items**:

#### P0: Create injection function skeleton

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: Sprint 8
**Spec Reference**: PLAN Section 6.1, 6.2 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 239-252)

**Description**:

**Acceptance Criteria**:
- [ ] File `src/editor/compiler/integration.ts` modified
- [ ] Function: `injectDefaultSourceProviders(store: RootStore, patch: CompilerPatch): CompilerPatch`
- [ ] Returns new CompilerPatch with injected primitives
- [ ] Does NOT mutate input patch (pure function)
- [ ] Skeleton handles empty attachments gracefully

**Technical Notes**:
- File: `src/editor/compiler/integration.ts`
- Add near `editorToPatch()` function
- Pure function - create new objects, don't mutate
- Initial implementation: return patch unchanged (no injection yet)
- This sprint focuses on infrastructure; actual injection in Sprint 10

#### P0: Detect undriven inputs

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 6.2 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 243-252)

**Description**:

**Acceptance Criteria**:
- [ ] Helper: `isInputUndriven(blockId: string, slotId: string, patch: CompilerPatch): boolean`
- [ ] Checks for wire: `patch.connections.some(c => c.to.blockId === blockId && c.to.slotId === slotId)`
- [ ] Returns true only if BOTH checks are false
- [ ] Handles edge cases (missing fields, etc.)

**Technical Notes**:
- File: `src/editor/compiler/integration.ts`
- Helper function used by injection logic
- Only undriven inputs need provider injection

#### P1: Generate stable IDs for injected primitives

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 6.3 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 268-275)

**Description**:

**Acceptance Criteria**:
- [ ] Helper: `makeProviderWireId(providerId: string, targetBlockId: string, targetSlotId: string): string`
- [ ] Returns: `wire:ds:${providerId}->${targetBlockId}:${targetSlotId}`
- [ ] Returns: `lis:ds:${busId}->${providerId}:${inputId}`
- [ ] Provider block ID already deterministic: `dsprov:${blockId}:${slotId}` (from Sprint 2)

**Technical Notes**:
- File: `src/editor/compiler/integration.ts`
- These IDs appear only in CompilerPatch (not persisted)
- Deterministic = easier debugging, reproducible compilation

**Manual Verification**:
- [ ] Run `just dev`
- [ ] Create block with undriven input
- [ ] Set up attachment (const provider)
- [ ] Compile patch (trigger via UI)
- [ ] Check compiled CompilerPatch in debugger
- [ ] Verify no injection yet (that's Sprint 10)

**Dependencies**: Sprint 8 complete

---

### Sprint 10: Inject Provider Blocks and Wires

**Sprint Goal**: Implement actual injection of provider blocks and wires into CompilerPatch

**In Scope**:
- Inject provider block instances
- Inject wires from provider output to target input
- Handle multiple inputs using same provider
- Extend defaultSourceValues map

**Work Items**:

#### P0: Inject provider blocks

**Status**: Not Started
**Effort**: Medium (3-4 days)
**Dependencies**: Sprint 9
**Spec Reference**: PLAN Section 6.2 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 243-252)

**Description**:
For each undriven input with attachment, inject the provider block into CompilerPatch.blocks array. Handle deduplication - same provider may serve multiple inputs.

**Acceptance Criteria**:
- [ ] For each attachment where input is undriven:
  - Add provider block to `CompilerPatch.blocks` (if not already added)
  - Block ID: attachment.provider.providerId (deterministic from Sprint 2)
  - Block type: attachment.provider.blockType
- [ ] Deduplication: track added providers, don't add twice
- [ ] Provider blocks have no position (x/y = 0) - they're hidden
- [ ] Provider blocks have no user-editable fields except those in editableInputSourceIds

**Technical Notes**:
- File: `src/editor/compiler/integration.ts`
- Function: `injectDefaultSourceProviders()`
- Use Set to track added provider IDs
- Create block object matching CompilerPatch.Block schema
- Add to `patch.blocks` array

#### P0: Inject provider wires

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 6.2 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 243-252)

**Description**:
For each injected provider, create wire from provider output to target input. Use stable wire IDs.

**Acceptance Criteria**:
- [ ] For each attachment where input is undriven:
  - Create wire: `{ id, from: { blockId: providerId, slotId: provider.outputPortId }, to: { blockId, slotId } }`
  - Wire ID: use `makeProviderWireId()` helper
- [ ] Add wire to `patch.connections` array
- [ ] Wire makes input appear "driven" to downstream compilation

**Technical Notes**:
- File: `src/editor/compiler/integration.ts`
- Function: `injectDefaultSourceProviders()`
- Wire connects: provider.outputPortId → target.slotId
- Stable ID format: `wire:ds:${providerId}->${blockId}:${slotId}`
- After injection, `isInputUndriven()` should return false for this input

#### P1: Extend defaultSourceValues map

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 6.2 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 243-252, 260-265)

**Description**:
Add provider internal editable input defaults to `defaultSourceValues` map so compiler can resolve them. This enables const providers to read their 'value' input.

**Acceptance Criteria**:
- [ ] For each injected provider:
  - For each editableInputSourceId in provider.editableInputSourceIds:
    - Look up DefaultSourceState value via sourceId
    - Add to `defaultSourceValues[\"${providerId}:${inputId}\"]`
- [ ] Const provider 'value' inputs become resolvable
- [ ] Legacy compiler can resolve provider internal defaults

**Technical Notes**:
- File: `src/editor/compiler/integration.ts`
- Function: `injectDefaultSourceProviders()`
- Lookup: `store.defaultSourceStore.sources.get(sourceId)`
- Map key format: `${providerId}:${inputId}`
- This makes provider internal inputs work like normal defaults

**Manual Verification**:
- [ ] Run `just dev`
- [ ] Create Circle block (has radius input with default)
- [ ] Leave radius unwired
- [ ] Verify circle renders with default radius
- [ ] Check CompilerPatch in debugger:
  - DSConstSignalFloat provider block exists
  - Wire from provider to Circle.radius exists
  - defaultSourceValues has provider value entry
- [ ] Change radius default value
- [ ] Verify circle size updates

**Dependencies**: Sprint 9 complete

---


**Sprint Goal**: Wire provider blocks to global buses when required

**In Scope**:
- Convert busName to busId
- Handle missing bus error case
- Integrate injection into editorToPatch() call

**Work Items**:


**Status**: Not Started
**Effort**: Medium (3-4 days)
**Dependencies**: Sprint 10
**Spec Reference**: PLAN Section 6.2 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 243-252, 256-260)

**Description**:

**Acceptance Criteria**:
- [ ] For each injected provider:
  - Get provider spec from allowlist
  - For each entry in spec.busInputs (inputSlotId → busName):
    - Look up bus by name in store.busStore.buses
- [ ] Handles missing bus per user directive: FAIL COMPILATION with clear error

**Technical Notes**:
- File: `src/editor/compiler/integration.ts`
- Function: `injectDefaultSourceProviders()`
- Import `DEFAULT_SOURCE_PROVIDER_BLOCKS` from `../defaultSources/allowlist`
- Lookup: `store.busStore.buses.find(b => b.name === busName)`
- If bus not found: throw compilation error with message:
  - "Default source provider {providerType} requires bus '{busName}' which does not exist. Create the bus or choose a different provider."

#### P0: Handle missing bus error case

**Status**: Not Started
**Effort**: Small (1 day)
**Dependencies**: P0 of this sprint
**Spec Reference**: User directive • **Status Reference**: STATUS-2025-12-30-022454.md (lines 341-352)

**Description**:
Implement clear error handling when required bus doesn't exist. Per user directive: fail compilation with actionable message (don't fall back silently).

**Acceptance Criteria**:
- [ ] If bus not found, throw error (don't return null/undefined)
- [ ] Error message is clear and actionable:
  - Identifies which provider needs the bus
  - Names the missing bus
  - Suggests creating the bus or choosing different provider
- [ ] Error follows CLAUDE.md principle: "Fail fast with clear messages"
- [ ] Error appears in diagnostic panel (if hooked up) or console

**Technical Notes**:
- File: `src/editor/compiler/integration.ts`
- Error message format (user directive: FRIENDLY NAMES):
  ```
  Default provider for {BlockName}.{inputName} requires bus '{busName}' which does not exist.
  Provider type: {providerType}
  Create bus '{busName}' or select a different default source provider.
  ```
- Don't paper over the problem - CLAUDE.md: "Silent failures are worse than loud ones"

#### P1: Integrate injection into editorToPatch()

**Status**: Not Started
**Effort**: Small (1 day)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 6.1 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 239-252)

**Description**:
Call `injectDefaultSourceProviders()` from `editorToPatch()` so injection happens on every compilation.

**Acceptance Criteria**:
- [ ] File `src/editor/compiler/integration.ts` modified
- [ ] In `editorToPatch()` function, after building initial CompilerPatch:
  - Call: `patch = injectDefaultSourceProviders(store, patch)`
- [ ] Injection happens before returning CompilerPatch
- [ ] Both legacy and IR compilers see injected graph

**Technical Notes**:
- File: `src/editor/compiler/integration.ts`
- Function: `editorToPatch()` (around lines 401-425)
- Add call after line 412 (after defaultSourceValues map is built)
- Injection is pure - returns new patch
- Both compiler paths use this function, so both get injection

**Manual Verification**:
- [ ] Run `just dev`
- [ ] Create block with undriven input that has default
- [ ] Open DevTools, set breakpoint in `injectDefaultSourceProviders()`
- [ ] Trigger compilation (change something in patch)
- [ ] Verify injection runs
- [ ] Step through: check provider blocks, wires added
- [ ] Continue execution
- [ ] Verify output renders correctly

**Dependencies**: Sprint 10 complete

---

## Phase E: UI

### Sprint 12: Basic Provider Selection UI

**Sprint Goal**: Add dropdown to select provider type (Constant only for now)

**In Scope**:
- Add provider type selector to DefaultSourcesSection
- Show "Constant" option only (no advanced providers yet)
- Wire selection to store (create/update attachment)
- Preserve existing constant value editing

**Work Items**:

#### P0: Add provider type dropdown

**Status**: Not Started
**Effort**: Medium (3-4 days)
**Dependencies**: Sprint 11
**Spec Reference**: PLAN Section 7.1 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 253-260)

**Description**:
Update Inspector DefaultSourcesSection to show provider type selector. Initially only "Constant" option (advanced providers in Sprint 15).

**Acceptance Criteria**:
- [ ] File `src/editor/Inspector.tsx` modified
- [ ] DefaultSourcesSection shows dropdown per input: "Provider Type"
- [ ] Dropdown options: ["Constant"] (only one option for now)
- [ ] Selection is wired to DefaultSourceStore
- [ ] Changing selection updates attachment
- [ ] Default selection: "Constant"

**Technical Notes**:
- File: `src/editor/Inspector.tsx`
- Component: `DefaultSourcesSection` (around lines 1301-1388)
- Add dropdown before existing value control
- For now: dropdown is disabled (only one option) - enables in Sprint 15
- Use existing UI patterns (MobX observer, etc.)

#### P0: Wire selection to attachment updates

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 7.1 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 253-260)

**Description**:
Connect dropdown selection to DefaultSourceStore.setAttachmentForInput(). When user changes provider type, update attachment.

**Acceptance Criteria**:
- [ ] Dropdown onChange handler calls `store.setAttachmentForInput()`
- [ ] Creates new attachment with selected provider type
- [ ] Preserves existing default value (if compatible)
- [ ] Triggers recompilation
- [ ] UI updates to reflect new provider

**Technical Notes**:
- File: `src/editor/Inspector.tsx`
- On change: create new DefaultSourceAttachment with appropriate Const provider
- Use `DefaultSourceStore.createDefaultAttachmentForSlot()` helper
- MobX will trigger re-render automatically

#### P1: Preserve constant value editing

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 7.2 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 261-267)

**Description**:
Ensure existing default value controls still work. When provider is Const, show same controls as before (slider, number input, color picker, etc.).

**Acceptance Criteria**:
- [ ] When provider is Const type:
  - Show existing DefaultSourceControl component
  - Control edits provider 'value' input
  - UI identical to pre-refactor behavior
- [ ] No visual regression
- [ ] Editing works same as before

**Technical Notes**:
- File: `src/editor/Inspector.tsx`
- Re-use existing `DefaultSourceControl` component
- Pass provider internal 'value' input default source
- Should be transparent - looks same as before

**Manual Verification**:
- [ ] Run `just dev`
- [ ] Add block with numeric input default (e.g., Circle radius)
- [ ] Check Inspector:
  - "Provider Type: Constant" dropdown visible
  - Value slider/input visible (same as before)
- [ ] Edit value - verify circle updates
- [ ] Save and reload - verify value persists
- [ ] Compare to pre-refactor screenshots - should look identical

**Dependencies**: Sprint 11 complete

---

### Sprint 13: Provider Config Panel UI

**Sprint Goal**: Add UI to show provider internal configuration (bus feeds, editable inputs)

**In Scope**:
- Show provider config header when non-Const provider selected
- Display bus-fed inputs as read-only
- Display editable inputs with controls
- Prepare for Oscillator provider (Sprint 15)

**Work Items**:

#### P0: Add provider config panel component

**Status**: Not Started
**Effort**: Medium (3-4 days)
**Dependencies**: Sprint 12
**Spec Reference**: PLAN Section 7.2 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 261-267)

**Description**:
Create reusable component to display provider configuration. Shows provider type header, bus feeds, and editable inputs.

**Acceptance Criteria**:
- [ ] New component: `ProviderConfigPanel` (or similar)
- [ ] Props: `attachment: DefaultSourceAttachment, blockId: string, slotId: string`
- [ ] Renders provider type header: "Default Source: {providerLabel}"
- [ ] For Const providers: shows only value control (same as Sprint 12)
- [ ] For future non-Const providers: shows bus feeds + editable inputs
- [ ] Component is reusable, well-structured

**Technical Notes**:
- File: `src/editor/Inspector.tsx` (or new file if large)
- Component structure:
  - Header: provider type label
  - Bus feeds section (if any)
  - Editable inputs section (if any)
- Use MobX observer pattern
- Initially only renders Const providers (Oscillator in Sprint 15)

#### P0: Display bus-fed inputs as read-only

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 7.2 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 261-267)

**Description**:
For providers with busInputs (none yet, but prepares for Oscillator), show which inputs are fed by buses. Read-only display.

**Acceptance Criteria**:
- [ ] Get provider spec from allowlist
- [ ] For each entry in spec.busInputs:
  - Render row: "{inputLabel} ← bus {busName}"
  - Row is read-only (no editing)
  - Use grayed-out or distinct styling
- [ ] If no busInputs, this section is hidden

**Technical Notes**:
- File: `src/editor/Inspector.tsx`
- Import `DEFAULT_SOURCE_PROVIDER_BLOCKS` from allowlist
- Find provider spec by blockType
- Iterate spec.busInputs
- Display format (user directive: FRIENDLY NAMES): "phase ← bus phaseA"

#### P1: Display editable inputs with controls

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 7.2 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 261-267)

**Description**:
For editable provider inputs (e.g., Oscillator shape/amplitude/bias), show controls. Re-use existing DefaultSourceControl component.

**Acceptance Criteria**:
- [ ] Get provider spec from allowlist
- [ ] For each entry in spec.editableInputs:
  - Get provider input default source via editableInputSourceIds
  - Render DefaultSourceControl for that default source
  - Control edits provider internal input
- [ ] Controls work same as block input defaults
- [ ] Changes trigger recompilation

**Technical Notes**:
- File: `src/editor/Inspector.tsx`
- Lookup: `attachment.provider.editableInputSourceIds[inputId]` → sourceId
- Lookup: `store.defaultSourceStore.sources.get(sourceId)` → DefaultSourceState
- Render: `<DefaultSourceControl source={source} />`
- Re-uses existing component = consistent UI

**Manual Verification**:
- [ ] Run `just dev`
- [ ] Add block with default (Circle radius)
- [ ] Check Inspector:
  - Provider Type: Constant
  - Provider config panel shows
  - Only "value" control visible (Const provider)
- [ ] UI should look clean and organized
- [ ] No errors in console

**Dependencies**: Sprint 12 complete

---

### Sprint 14: Driven Input UI Polish

**Sprint Goal**: Ensure driven inputs show correct read-only state

**In Scope**:
- Show provider config as read-only/collapsed
- Preserve existing "overridden" indicator
- Test wire/disconnect behavior

**Work Items**:

#### P0: Detect driven vs undriven inputs

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: Sprint 13
**Spec Reference**: PLAN Section 7.3 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 268-275, 357-367)

**Description**:
Add helper to detect if input is currently driven. Driven inputs show default source as "overridden" (existing behavior).

**Acceptance Criteria**:
- [ ] Helper: `isInputDriven(blockId: string, slotId: string): boolean`
- [ ] Checks for wire: `store.connectionStore.connections.some(...)`
- [ ] Returns true if EITHER exists
- [ ] Used to control UI read-only state

**Technical Notes**:
- File: `src/editor/Inspector.tsx`
- Similar logic to compiler `isInputUndriven()` but uses editor stores
- This determines "overridden" state in UI

#### P0: Show driven inputs as read-only

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 7.3 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 268-275)

**Description**:
When input is driven, show provider config as read-only. Preserve existing "overridden" indicator. Per user directive: "show provider config as read-only" (not hidden).

**Acceptance Criteria**:
- [ ] When `isInputDriven()` returns true:
  - Provider type dropdown disabled
  - Provider config controls disabled/read-only
  - "Overridden" indicator shown (existing pattern)
- [ ] When false: controls are editable
- [ ] Visual distinction: grayed out or labeled "overridden"

**Technical Notes**:
- File: `src/editor/Inspector.tsx`
- Existing code already handles this for constant defaults
- Extend to cover provider config panel
- Use disabled prop on controls
- Preserve existing "overridden by wire/bus" messaging

#### P1: Test wire/disconnect behavior

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 10 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 360-376)

**Description**:
Verify that wiring/unwiring inputs correctly toggles between driven and provider-driven states. This is manual verification scenario #3 from the plan.

**Acceptance Criteria**:
- [ ] Wire input → provider config becomes read-only
- [ ] Output follows wire (not provider)
- [ ] Disconnect wire → provider config becomes editable
- [ ] Output returns to provider behavior
- [ ] No visual glitches or state inconsistencies

**Technical Notes**:
- This is a manual testing task, not code changes
- Verifies UI state transitions correctly

**Manual Verification**:
- [ ] Run `just dev`
- [ ] Add Circle block (radius input)
- [ ] Set radius default to 50
- [ ] Verify circle size reflects default
- [ ] Inspector shows editable provider config
- [ ] Wire another block to radius input
- [ ] Verify circle size follows wire
- [ ] Inspector shows read-only provider config with "overridden" label
- [ ] Disconnect wire
- [ ] Verify circle size returns to default (50)
- [ ] Inspector shows editable provider config again

**Dependencies**: Sprint 13 complete

---

## Phase F: Advanced Providers & Validation

### Sprint 15: Add Oscillator Provider

**Sprint Goal**: Add Oscillator as allowlisted default source provider

**In Scope**:
- Add Oscillator to allowlist with busInputs
- Update UI to show Oscillator in provider dropdown
- Test Oscillator as default source

**Work Items**:

#### P0: Add Oscillator to allowlist

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: Sprint 14
**Spec Reference**: PLAN Section 4.1 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 179-183)

**Description**:
Add Oscillator block spec to DEFAULT_SOURCE_PROVIDER_BLOCKS array. This makes Oscillator selectable as default source provider for Signal<float> inputs.

**Acceptance Criteria**:
- [ ] File `src/editor/defaultSources/allowlist.ts` modified
- [ ] Oscillator entry added to DEFAULT_SOURCE_PROVIDER_BLOCKS:
  ```typescript
  {
    blockType: 'Oscillator',
    label: 'Oscillator (Sine/LFO)',
    outputPortId: 'out',
    editableInputs: ['shape', 'amplitude', 'bias'],
    busInputs: { phase: 'phaseA' },
  }
  ```
- [ ] Oscillator requires 'phaseA' bus (standard time bus)
- [ ] Oscillator output is Signal<float>

**Technical Notes**:
- File: `src/editor/defaultSources/allowlist.ts`
- Add after const providers spread
- Oscillator block already exists in codebase - just allowlist it
- busInputs: 'phase' input fed by 'phaseA' bus

#### P0: Update provider dropdown to show Oscillator

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 7.1 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 253-260)

**Description**:
Update Inspector provider type dropdown to list compatible providers from allowlist. For Signal<float> inputs: show "Constant" and "Oscillator".

**Acceptance Criteria**:
- [ ] File `src/editor/Inspector.tsx` modified
- [ ] Dropdown options generated from DEFAULT_SOURCE_PROVIDER_BLOCKS
- [ ] Filter providers by output type compatibility with target slot type
- [ ] Signal<float> input shows: "Constant", "Oscillator (Sine/LFO)"
- [ ] Dropdown enabled (was disabled in Sprint 12)
- [ ] Selection updates attachment with chosen provider

**Technical Notes**:
- File: `src/editor/Inspector.tsx`
- Import `DEFAULT_SOURCE_PROVIDER_BLOCKS` from allowlist
- Filter: check provider output type matches slot type (semantic type compatibility)
- Dropdown options: `spec.label`
- On change: create attachment with selected provider blockType

#### P1: Test Oscillator as default source

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 10 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 360-376)

**Description**:
Manual verification that Oscillator works as default source. This is scenario #2 from plan. Verifies entire pipeline: UI → Store → Compiler → Runtime.

**Acceptance Criteria**:
- [ ] Select Oscillator provider for Signal<float> input
- [ ] Provider config shows:
  - Bus feed: "phase ← bus phaseA" (read-only)
  - Editable: shape, amplitude, bias controls
- [ ] Changing shape/amplitude/bias updates output
- [ ] Output animates over time (sine wave)

**Technical Notes**:
- This is comprehensive manual testing

**Manual Verification**:
- [ ] Run `just dev`
- [ ] Add Circle block (radius input)
- [ ] Set radius provider to "Oscillator (Sine/LFO)"
- [ ] Inspector shows:
  - Provider Type: Oscillator (Sine/LFO)
  - "phase ← bus phaseA" (read-only)
  - shape: dropdown (sine, triangle, square, etc.)
  - amplitude: slider
  - bias: slider
- [ ] Set amplitude=20, bias=30
- [ ] Verify circle pulses: radius oscillates 30±20
- [ ] Change shape to triangle
- [ ] Verify motion changes to triangle wave
- [ ] Open DevTools, check CompilerPatch:
  - Oscillator provider block exists
  - Wire from provider to Circle.radius
- [ ] No errors in console

**Dependencies**: Sprint 14 complete

---

### Sprint 16: Type Compatibility Validation

**Sprint Goal**: Validate provider output types match target input types

**In Scope**:
- Create validation module
- Check provider output type vs target slot type
- Show diagnostics for type mismatches
- Test with mismatched types

**Work Items**:

#### P0: Create validation module infrastructure

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: Sprint 15
**Spec Reference**: PLAN Section 8 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 263-276)

**Description**:
Create validation module that checks DefaultSourceAttachments for errors. Initial focus: type compatibility. More validations added in Sprint 17.

**Acceptance Criteria**:
- [ ] File `src/editor/defaultSources/validate.ts` created
- [ ] Function: `validateDefaultSourceAttachments(rootStore: RootStore): Diagnostic[]`
- [ ] Returns array of Diagnostic objects (errors/warnings)
- [ ] Diagnostic structure matches existing diagnostic system
- [ ] Module is pure - no side effects

**Technical Notes**:
- New file: `src/editor/defaultSources/validate.ts`
- Import Diagnostic type from existing diagnostic system
- Function is pure: takes store, returns diagnostics
- Integration into diagnostic hub: Sprint 17

#### P0: Validate output type compatibility

**Status**: Not Started
**Effort**: Medium (3-4 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 8 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 266-270)

**Description**:
Check that provider output type matches target input slot type. Emit error diagnostic if incompatible.

**Acceptance Criteria**:
- [ ] For each attachment:
  - Get target block definition and slot
  - Get provider block definition and output slot
  - Check semantic type compatibility
  - If incompatible: emit error diagnostic
- [ ] Diagnostic message is clear:
  - "Provider {providerType} output type {outputType} incompatible with {BlockName}.{inputName} type {inputType}"
- [ ] Use existing semantic type compatibility checker (if exists)

**Technical Notes**:
- File: `src/editor/defaultSources/validate.ts`
- Get block definition: `getBlockDefinition(blockType)`
- Get slot: `definition.slots.find(s => s.id === slotId)`
- Check: `isTypeCompatible(providerOutputType, targetInputType)`
- May need to implement semantic type comparison if not exists

#### P1: Test type mismatch detection

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 8 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 266-270)

**Description**:
Manually create type mismatch and verify diagnostic appears. Ensures validation catches errors.

**Acceptance Criteria**:
- [ ] Create attachment with incompatible types (e.g., Oscillator → Field<float> input)
- [ ] Run validation
- [ ] Diagnostic error appears
- [ ] Error message is clear and actionable

**Technical Notes**:
- This is manual testing
- May need to temporarily bypass UI type filtering to create mismatch
- Verify validation catches the error

**Manual Verification**:
- [ ] Run `just dev`
- [ ] Manually edit patch JSON to create type mismatch:
  - Provider: Oscillator (Signal<float> output)
  - Target: Field<float> input
- [ ] Load patch
- [ ] Run validation (via console or integrated diagnostic)
- [ ] Verify error diagnostic appears
- [ ] Check error message clarity

**Dependencies**: Sprint 15 complete

---

### Sprint 17: Allowlist and Bus Validation

**Sprint Goal**: Validate provider is allowlisted and required buses exist

**In Scope**:
- Check provider blockType is in allowlist
- Check required buses exist
- Emit clear error diagnostics
- Integrate validation into compilation

**Work Items**:

#### P0: Validate provider is allowlisted

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: Sprint 16
**Spec Reference**: PLAN Section 8 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 263-270)

**Description**:
Check that provider blockType exists in DEFAULT_SOURCE_PROVIDER_BLOCKS allowlist. Emit error if not allowed.

**Acceptance Criteria**:
- [ ] For each attachment:
  - Check `DEFAULT_SOURCE_PROVIDER_BLOCKS.some(spec => spec.blockType === provider.blockType)`
  - If false: emit error diagnostic
- [ ] Error message: "Provider block type {blockType} is not allowlisted. Only certain blocks may be used as default source providers."
- [ ] List allowed types in error (helpful)

**Technical Notes**:
- File: `src/editor/defaultSources/validate.ts`
- Import `DEFAULT_SOURCE_PROVIDER_BLOCKS` from allowlist
- This prevents users from manually editing JSON to use disallowed blocks
- Error should suggest consulting allowlist

#### P0: Validate required buses exist

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 8 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 266-270, 341-352)

**Description**:
Check that all buses referenced in provider spec.busInputs exist in BusStore. Emit error if missing. This duplicates the compiler check but provides earlier feedback.

**Acceptance Criteria**:
- [ ] For each attachment:
  - Get provider spec from allowlist
  - For each entry in spec.busInputs: check bus exists
  - If bus not found: emit error diagnostic
- [ ] Error message matches compiler error (user directive):
  - "Default provider for {BlockName}.{inputName} requires bus '{busName}' which does not exist. Create the bus or select a different provider."
- [ ] Diagnostic is ERROR level (blocks compilation)

**Technical Notes**:
- File: `src/editor/defaultSources/validate.ts`
- Lookup: `rootStore.busStore.buses.find(b => b.name === busName)`
- If not found: create Diagnostic with severity: 'error'
- This prevents compilation failure with friendlier early error

#### P1: Integrate validation into diagnostic system

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 8 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 270-275)

**Description**:
Hook validation into semantic validator or compilation diagnostic hub so diagnostics appear in UI.

**Acceptance Criteria**:
- [ ] Validation runs automatically during compilation or semantic validation pass
- [ ] Diagnostics appear in diagnostic panel UI (if exists)
- [ ] Diagnostics appear in console (minimum)
- [ ] Validation errors prevent compilation (if severity: error)
- [ ] No duplicate validation runs

**Technical Notes**:
- Hook into existing validator infrastructure
- Call `validateDefaultSourceAttachments(rootStore)`
- Merge returned diagnostics into diagnostic list
- May need to find/create diagnostic hub integration point

**Manual Verification**:
- [ ] Run `just dev`
- [ ] Create attachment with missing bus (Oscillator without phaseA)
- [ ] Check diagnostic panel/console
- [ ] Verify error appears with clear message
- [ ] Create the bus (phaseA)
- [ ] Verify error disappears
- [ ] Test with non-allowlisted provider (manually edit JSON)
- [ ] Verify allowlist error appears

**Dependencies**: Sprint 16 complete

---

### Sprint 18: Cycle Detection and Final Polish

**Sprint Goal**: Prevent feedback cycles, final polish, comprehensive testing

**In Scope**:
- Detect provider → target → bus → provider cycles
- Add final edge case validations
- Comprehensive manual verification
- Update documentation

**Work Items**:

#### P0: Implement cycle detection

**Status**: Not Started
**Effort**: Medium (3-4 days)
**Dependencies**: Sprint 17
**Spec Reference**: PLAN Section 8 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 266-270)

**Description**:
Detect cycles where provider reads from bus X and target block publishes to bus X. This creates feedback loop.

**Acceptance Criteria**:
- [ ] For each attachment:
  - Get provider spec busInputs (buses provider reads)
  - If overlap exists: emit warning or error
- [ ] Diagnostic message: "Potential feedback cycle: provider reads bus {busName} but target block {BlockName} publishes to same bus"
- [ ] Severity: WARNING (not blocking, but suspicious)

**Technical Notes**:
- File: `src/editor/defaultSources/validate.ts`
- Get provider bus inputs from spec
- Intersection = potential cycle
- May be intentional (delay feedback) so WARNING not ERROR

#### P0: Add final edge case validations

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 8 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 266-270)

**Description**:
Add remaining validations: editable inputs exist, output port exists, provider inputs satisfiable.

**Acceptance Criteria**:
- [ ] Validate provider output port exists (spec.outputPortId)
- [ ] Validate all editableInputs exist in provider definition
- [ ] Validate all editableInputs have defaultSource metadata
- [ ] Validate provider has no other required inputs besides busInputs and editableInputs
- [ ] Emit error diagnostic for each violation

**Technical Notes**:
- File: `src/editor/defaultSources/validate.ts`
- Get provider definition: `getBlockDefinition(provider.blockType)`
- Check slots exist
- Check required inputs are all satisfied
- Comprehensive validation prevents runtime errors

#### P1: Comprehensive manual verification

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: P0 of this sprint
**Spec Reference**: PLAN Section 10 • **Status Reference**: STATUS-2025-12-30-022454.md (lines 360-376)

**Description**:
Run all manual verification scenarios from plan. This is final acceptance testing before feature complete.

**Acceptance Criteria**:
- [ ] Scenario 1: Constant default still works (no regressions)
- [ ] Scenario 2: Oscillator default works and animates
- [ ] Scenario 3: Wire override/disconnect behavior correct
- [ ] Scenario 4: No provider leakage in bus UI
- [ ] All acceptance criteria from plan met
- [ ] No errors in console during any scenario

**Technical Notes**:
- This is comprehensive testing pass
- Follow exact scenarios from PLAN Section 10
- Document any issues found
- Verify both legacy and IR compiler paths

**Manual Verification**:
- [ ] **Scenario 1: Constant default unchanged**
  - Add block with numeric input (Circle radius)
  - Leave unwired
  - Edit default value
  - Verify output changes
  - No regressions from original behavior
- [ ] **Scenario 2: Oscillator default animates**
  - Set Signal<float> input to Oscillator provider
  - UI shows editable shape/amplitude/bias
  - UI shows read-only "phase ← phaseA"
  - Change shape to triangle
  - Verify animated output changes to triangle wave
- [ ] **Scenario 3: Wire override/disconnect**
  - Wire input
  - Verify provider config becomes read-only
  - Verify output follows wire (not provider)
  - Disconnect wire
  - Verify output returns to provider behavior
  - Verify provider config becomes editable
- [ ] **Scenario 4: No provider leakage**
  - Check PatchBay: no provider blocks visible
  - Check BlockLibrary: no DSConst* blocks
  - Check diagnostics: friendly error messages (no technical IDs)
- [ ] **Save/load**
  - Create patch with various providers
  - Save patch
  - Reload
  - Verify all providers persist correctly
  - Verify behavior unchanged after reload

#### P2: Update documentation

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P1 of this sprint
**Spec Reference**: N/A • **Status Reference**: N/A

**Description**:
Update relevant documentation to reflect new default source provider system. This is OPTIONAL - only if explicitly requested by user per CLAUDE.md.

**Acceptance Criteria**:
- [ ] If user requests: update architecture docs
- [ ] If user requests: add examples to docs
- [ ] If user requests: update CLAUDE.md with new patterns
- [ ] Otherwise: skip (per CLAUDE.md: "NEVER proactively create documentation files")

**Technical Notes**:
- Per CLAUDE.md: do NOT create docs unless user requests
- If requested: focus on architecture impact, examples, gotchas
- Keep docs aligned with code

**Dependencies**: Sprint 17 complete

---

## Recommended Sprint Grouping

### Phase 0: Blockers (Week 1)
- Sprint 1: Fix compilation
- Sprint 2: Deterministic IDs

### Phase A: Foundation (Week 2)
- Sprint 3: Type system & allowlist

### Phase B: Provider Blocks (Weeks 3-4)
- Sprint 4: First const provider
- Sprint 5: Complete const family
- Sprint 6: Hide from UI

### Phase C: Persistence (Week 5)
- Sprint 7: Store refactoring
- Sprint 8: Patch persistence

### Phase D: Compiler (Weeks 6-7)
- Sprint 9: Injection infrastructure
- Sprint 10: Inject blocks/wires

### Phase E: UI (Weeks 8-9)
- Sprint 12: Basic provider selection
- Sprint 13: Provider config panel
- Sprint 14: Driven input polish

### Phase F: Advanced (Weeks 10-11)
- Sprint 15: Oscillator provider
- Sprint 16: Type validation
- Sprint 17: Allowlist/bus validation
- Sprint 18: Cycle detection & polish

**Total estimated duration**: 11 weeks for 18 sprints

---

## Risk Mitigation Summary

**HIGH RISK: ID Migration** → MITIGATED
- Sprint 2 implements deterministic IDs upfront
- Backward compat loader handles old patches gracefully
- User confirmed no existing patches to worry about

**HIGH RISK: Compiler Injection Complexity** → MITIGATED
- Manual verification after each sprint
- Both compiler paths tested

**MEDIUM RISK: UI Complexity** → MITIGATED
- Sprint 12-14 phased rollout: dropdown → config panel → polish
- Re-uses existing components (DefaultSourceControl)
- Preserves existing patterns

**MEDIUM RISK: Hidden Block Leakage** → MITIGATED
- Sprint 6 centralized filtering with `isBlockHidden()` helper
- Audit all block list locations
- Friendly error messages hide implementation details

**LOW RISK: Performance** → ACCEPTABLE
- Injection only for undriven inputs (minimal)
- No runtime performance impact (compile-time only)

---

## Final Acceptance Criteria (from original plan)

- [ ] Default source can be set to Oscillator for compatible input (Sprint 15)
- [ ] Provider not visible as block in PatchBay (Sprint 6)
- [ ] Provider cannot be wired like normal block (inherent - hidden blocks)
- [ ] Provider only reads from global buses/time + internal constants (enforced by allowlist + validation, Sprint 17)
- [ ] Compiler behavior is consistent (Sprint 11 integration into editorToPatch)
- [ ] All provider types live in one allowlist file (Sprint 3)

**Overall completion**: After Sprint 18, all 6 acceptance criteria will be met.
