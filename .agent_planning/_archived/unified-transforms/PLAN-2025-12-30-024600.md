# Unified Transforms Sprint Plan
**Generated**: 2025-12-30-024600
**Source STATUS**: STATUS-20251230.md
**Source Specs**:
- `plans/PLAN-UNIFIED-TRANSFORMS-LENSES-ADAPTERS.md`
- `plans/PLAN-UNIFIED-TRANSFORMS-LENSES-ADAPTERS-CHECKLIST.md`

**User Decisions (Authoritative)**:
1. **Lens UI components**: Copy from `.worktrees/` if they exist, or create new ones. Don't skip Phase 5.
2. **IR compiler strategy**: Implement **FULL** transform support in IR mode (not just rejection)
3. **Wire lens scope**: Allow ALL publisher+listener lenses on wires (most flexible)

---

## Executive Summary

**Current State**: Adapters and lenses exist but are **fragmented** across multiple systems:
- Registry has metadata only; execution lives in 250-line switch statement
- Lens scope supports only `publisher|listener` but wires already use lenses (mismatch)
- IR compiler rejects adapters, ignores lenses silently
- UI components missing from main branch (likely in worktrees)

**Total Effort**: 6 phases across 5 sprints, estimated 18-24 days total

**Phases**:
0. Stabilize build (already done per STATUS)
1. Create transform facade modules (3 days)
2. Unify adapter execution (4 days)
3. Unify lens scope + legality (3 days)
4. Centralize transform application (4 days)
5. Registry-driven lens UI (3 days)
6. IR compiler FULL transform support (4-6 days)

**Risk Level**: High (touches compilation core, requires IR AST extensions)

---

## Sprint 1: Foundation & Adapter Unification
**Duration**: 5-6 days
**Phases**: 1, 2
**Goal**: Unified adapter execution with transform facade in place

### Deliverable 1: Transform Facade Modules (Phase 1)
**Effort**: 3 days
**Status**: Not Started
**Dependencies**: None
**Spec Reference**: §4, §10 Phase 1 • **Status Reference**: STATUS-20251230.md "Phase 1: Add Transform Modules"

#### Description
Create `src/editor/transforms/` directory with 5 new modules that provide a normalized, non-optional "stack" view over the fragmented `{ adapterChain?, lensStack? }` storage. This is pure facade work—no behavior changes to existing compilation.

**Key principle**: The normalized view is always explicit (no optionals). Storage layer (`Connection`, `Publisher`, `Listener`) remains unchanged for backwards compatibility.

#### Files to Create
1. **`types.ts`** (~50 lines)
   - `TransformScope = 'wire' | 'publisher' | 'listener' | 'lensParam'`
   - `TransformStep = { kind: 'adapter'|'lens', enabled: boolean, ... }`
   - `TransformStack = ReadonlyArray<TransformStep>`

2. **`normalize.ts`** (~80 lines)
   - `normalizeTransformStack(input: { adapterChain?, lensStack? }): TransformStack`
   - `splitTransformStack(stack: TransformStack): { adapterChain?, lensStack? }`
   - Handles: `undefined → []`, missing `enabled → true`

3. **`catalog.ts`** (~60 lines)
   - `listAdapters(): AdapterDef[]` (from AdapterRegistry)
   - `listLenses(): LensDef[]` (from LensRegistry)
   - `listLensesFor(scope: TransformScope, typeDesc): LensDef[]`

4. **`validate.ts`** (~150 lines)
   - Scope legality checks (lens `allowedScopes`, adapter policies per scope)
   - Type legality checks (lens compatible with endpoint semantics)
   - Structural legality (no lens param cycles, depth limits enforced)
   - Placeholder for IR mode validator (implement in Sprint 5)

5. **`apply.ts`** (~100 lines initially)
   - Wrapper functions that delegate to existing logic
   - `applyAdapterChain()` - wraps `compileBusAware.applyAdapterChain()`
   - `applyLensStack()` - wraps `compileBusAware.applyLensStack()`
   - `applyTransformStack()` - unified entrypoint

#### Acceptance Criteria
- [ ] All 5 files created in `src/editor/transforms/` with documented exports
- [ ] `normalizeTransformStack()` round-trips correctly (empty arrays, enabled defaults)
- [ ] `listLensesFor()` filters by domain correctly
- [ ] `validate.ts` exports placeholder validators (can return empty errors for now)
- [ ] `apply.ts` wrappers call existing compiler logic (no behavior change)
- [ ] `just check` passes with no new errors
- [ ] Unit tests cover normalization and catalog functions

#### Technical Notes
- Do NOT modify existing compiler code in this deliverable
- All functions are pure/side-effect-free where possible
- Import from `AdapterRegistry` and `LensRegistry` but don't modify them yet

---

### Deliverable 2: Unified Adapter Execution (Phase 2)
**Effort**: 2 days
**Status**: Not Started
**Dependencies**: Deliverable 1 (transform facade exists)
**Spec Reference**: §5, §10 Phase 2 • **Status Reference**: STATUS-20251230.md "Phase 2: Unify Adapter Execution"

#### Description
Eliminate the 112-line switch statement in `compileBusAware.applyAdapterStep()` by moving execution logic into `AdapterRegistry`. This makes the registry the **single source of truth** for both metadata and behavior.

**Current problem**: Adding/changing an adapter requires editing two separate files (registry for metadata, compiler for execution). Missing adapters (`ReduceFieldToSignal`, `NumberToDurationMs`, etc.) exist in registry but have no execution path.

#### Files to Modify
1. **`src/editor/adapters/AdapterRegistry.ts`**
   - Add `apply?: (artifact, params, ctx) => Artifact` to `AdapterDef`
   - Move logic from `compileBusAware.applyAdapterStep()` switch cases into adapter defs
   - Register all 18 adapters with execution logic (currently only 8 have implementations)

2. **`src/editor/compiler/compileBusAware.ts`**
   - Replace `applyAdapterStep()` switch (lines 1109-1220) with registry lookup:
     ```typescript
     function applyAdapterStep(artifact, step, ctx) {
       const def = adapterRegistry.get(step.adapterId);
       if (!def?.apply) return { kind: 'Error', message: `No implementation for ${step.adapterId}` };
       return def.apply(artifact, step.params, ctx);
     }
     ```
   - Delete 112 lines of switch logic

#### Acceptance Criteria
- [ ] All 18 adapters have `apply` implementations in registry
- [ ] `applyAdapterStep()` is replaced with registry lookup (< 10 lines)
- [ ] Missing adapters now error explicitly (not silent "default" case)
- [ ] All existing bus compilation tests pass
- [ ] Manual test: Wire with `ConstToSignal` adapter compiles correctly
- [ ] Manual test: Publisher with `BroadcastScalarToField` adapter works
- [ ] `just check` passes

#### Technical Notes
- Test each adapter implementation as you move it (avoid batch refactor)
- Keep error reporting consistent (use same error types as before)
- Adapters that were missing implementations should error clearly

---

### Sprint 1 Summary
**Total Effort**: 5-6 days
**Deliverables**: 2
**Risk**: Medium (refactors working compiler code)

**Critical Path**:
1. Day 1-3: Create transform facade modules (standalone, low risk)
2. Day 4-6: Move adapter execution to registry (requires careful testing)

**Verification**:
- `just check` passes
- All existing tests pass (900+ tests)
- Manual smoke test in `just dev`: Create wire with adapter, verify compilation
- Compare: Same patch compiles identically before/after Sprint 1

---

## Sprint 2: Lens Scope Unification
**Duration**: 4-5 days
**Phases**: 3
**Goal**: Consistent lens scope enforcement with wire support

### Deliverable 3: Expand LensScope to Include Wires (Phase 3)
**Effort**: 4 days
**Status**: Not Started
**Dependencies**: Sprint 1 complete (transform facade exists)
**Spec Reference**: §6.1, §10 Phase 3 • **Status Reference**: STATUS-20251230.md "Phase 3: Unify Lens Scope + Legality"

#### Description
Fix the scope mismatch where wires (`Connection`) already have `lensStack` and UI edits wire lenses, but `LensRegistry` only recognizes `'publisher' | 'listener'` scopes. This deliverable makes wire lenses **explicitly legal** rather than special-cased.

**User Decision**: Wire lens scope = publisher ∪ listener allowed scopes (most flexible option).

#### Files to Modify
1. **`src/editor/lenses/LensRegistry.ts`**
   - Change `LensScope = 'publisher' | 'listener'` to include `'wire' | 'lensParam'` (line 11)
   - Update all 27 lens definitions to declare scope compatibility explicitly:
     - **Most lenses** (scale, clamp, polarity, phaseOffset, rotate2d, etc.): `allowedScopes: ['wire', 'publisher', 'listener']`
     - **Listener-only lenses** (ease, mapRange, hysteresis): `allowedScopes: ['listener']`
     - **Phase-specific lenses** (phaseWindow, pingPong): Scope + semantic requirements (may need numeric registry from optional Phase 9)
   - Add helper: `isLensAllowedInScope(lensId: string, scope: LensScope): boolean`

2. **`src/editor/transforms/validate.ts`** (from Sprint 1)
   - Implement scope validation using registry `allowedScopes`:
     ```typescript
     export function validateLensScope(
       lensId: string,
       scope: TransformScope,
       errors: CompileError[]
     ): void {
       const def = getLens(lensId);
       if (!def) { errors.push({ ... }); return; }
       if (!def.allowedScopes.includes(scope)) {
         errors.push({
           message: `Lens '${def.label}' is not allowed in scope '${scope}'`,
           allowedScopes: def.allowedScopes
         });
       }
     }
     ```
   - Call from compiler early to reject invalid combinations

#### Acceptance Criteria
- [ ] `LensScope` type includes all 4 scopes: `'wire' | 'publisher' | 'listener' | 'lensParam'`
- [ ] All 27 lens definitions have explicit `allowedScopes` arrays (no undefined)
- [ ] Wire lenses (majority) explicitly allow `'wire'` scope
- [ ] Listener-only lenses (ease, mapRange, hysteresis) explicitly exclude `'wire'` scope
- [ ] Scope validator rejects illegal lens usage with clear error messages
- [ ] Compiler calls scope validator before applying lens stacks
- [ ] All existing lens tests pass
- [ ] Manual test: Apply scale lens to wire (allowed)
- [ ] Manual test: Apply ease lens to wire (rejected with error)
- [ ] `just check` passes

#### Technical Notes
- This is an **additive change** (existing wire lenses already work, now explicitly legal)
- Lens param bindings (`lensParam` scope) may have more restrictions (depth limits enforced separately)
- Phase-specific lenses may need semantic validation (see optional Sprint 4 work)

---

### Sprint 2 Summary
**Total Effort**: 4-5 days
**Deliverables**: 1
**Risk**: Low (additive change, makes existing behavior explicit)

**Critical Path**:
- Day 1: Expand `LensScope` enum and update type definitions
- Day 2-3: Update all 27 lens definitions with `allowedScopes`
- Day 4: Implement and integrate scope validator

**Verification**:
- `just check` passes
- All existing tests pass
- Manual test in `just dev`: Create wire with various lenses, verify scope enforcement
- Compare: Patches with legal wire lenses compile identically; illegal lenses now error explicitly

---

## Sprint 3: Centralized Transform Application
**Duration**: 4-5 days
**Phases**: 4
**Goal**: One canonical transform engine used everywhere

### Deliverable 4: Move Transform Logic to Facade (Phase 4)
**Effort**: 4 days
**Status**: Not Started
**Dependencies**: Sprint 1 (facade exists), Sprint 2 (scope validation exists)
**Spec Reference**: §7, §10 Phase 4 • **Status Reference**: STATUS-20251230.md "Phase 4: Centralize Transform Application"

#### Description
Replace scattered transform application logic with a single canonical engine in `transforms/apply.ts`. Currently, adapter and lens application logic lives in `compileBusAware.ts` and `lensResolution.ts` with hidden special cases for different scopes.

**Goal**: One code path for applying transforms, with scope-specific behavior centralized and explicit.

#### Files to Modify
1. **`src/editor/transforms/apply.ts`** (from Sprint 1)
   - Replace wrappers with actual implementations
   - Move `applyAdapterChain()` from `compileBusAware.ts`:
     ```typescript
     export function applyAdapterChain(
       artifact: Artifact,
       chain: AdapterStep[],
       scope: TransformScope,
       ctx: CompileCtx,
       errors: CompileError[]
     ): Artifact {
       let current = artifact;
       for (const step of chain) {
         if (!step.enabled) continue;
         current = applyAdapterStep(current, step, scope, ctx, errors);
       }
       return current;
     }
     ```
   - Move `applyLensStack()` from `compileBusAware.ts`:
     ```typescript
     export function applyLensStack(
       artifact: Artifact,
       stack: LensInstance[],
       scope: TransformScope,
       resolveParam: ParamResolver,
       errors: CompileError[]
     ): Artifact {
       let current = artifact;
       for (const lens of stack) {
         if (!lens.enabled) continue;
         validateLensScope(lens.id, scope, errors);
         if (errors.length > 0) break;
         current = applyLensStep(current, lens, scope, resolveParam, errors);
       }
       return current;
     }
     ```
   - Export unified entrypoint:
     ```typescript
     export function applyTransformStack(
       artifact: Artifact,
       stack: TransformStack,
       scope: TransformScope,
       ctx: CompileCtx,
       resolveParam: ParamResolver,
       errors: CompileError[]
     ): Artifact
     ```

2. **`src/editor/compiler/compileBusAware.ts`**
   - Replace local `applyAdapterChain()` and `applyLensStack()` with imports from `transforms/apply.ts`
   - Add explicit scope parameter to all call sites (3 locations per STATUS):
     ```typescript
     // Wire connections (line 625)
     applyTransformStack(artifact, normalizeStack(connection), 'wire', ctx, resolveParam, errors)

     // Bus listeners (line 662)
     applyTransformStack(artifact, normalizeStack(listener), 'listener', ctx, resolveParam, errors)

     // Bus publishers (line 1072)
     applyTransformStack(artifact, normalizeStack(publisher), 'publisher', ctx, resolveParam, errors)
     ```
   - Delete local transform functions (~160 lines removed)

3. **`src/editor/lenses/lensResolution.ts`**
   - Replace ad-hoc lens param resolution with transform engine calls
   - Use `applyTransformStack()` for lens param bindings with scope `'lensParam'`
   - Ensure depth limit (3 levels per STATUS line 118) is enforced by validator

#### Acceptance Criteria
- [ ] `transforms/apply.ts` contains canonical implementation (not wrappers)
- [ ] All adapter and lens application goes through transform engine
- [ ] Scope parameter is explicit at all call sites (no hidden wire special cases)
- [ ] Lens param resolution uses same transform engine (recursive support intact)
- [ ] Depth limit for lens param bindings enforced by validator
- [ ] All bus compilation tests pass
- [ ] Field bus compilation tests pass (adapter chains critical here)
- [ ] Manual test: Wire → Publisher → Listener transform chain works end-to-end
- [ ] Manual test: Lens param binding with adapters resolves correctly
- [ ] `just check` passes

#### Technical Notes
- This is a **refactor of working code**—test incrementally
- Move one scope at a time (wire → publisher → listener) to minimize risk
- Keep error reporting format consistent with existing compiler errors
- Param resolver function signature may need adjustment for scope parameter

---

### Sprint 3 Summary
**Total Effort**: 4-5 days
**Deliverables**: 1
**Risk**: Medium (refactors core compilation path)

**Critical Path**:
- Day 1: Implement actual logic in `transforms/apply.ts`
- Day 2: Migrate wire transform application
- Day 3: Migrate publisher/listener transform application
- Day 4: Migrate lens param resolution
- Day 5: Cleanup and verification

**Verification**:
- `just check` passes
- All existing tests pass (especially bus compilation tests)
- Manual test: Create complex patch with all scope types, verify compilation
- Compare: Same patch compiles identically before/after Sprint 3

---

## Sprint 4: Registry-Driven Lens UI
**Duration**: 3-4 days
**Phases**: 5
**Goal**: Eliminate hardcoded lens catalogs in UI

### Deliverable 5: Migrate Lens UI to Registry (Phase 5)
**Effort**: 3 days
**Status**: Not Started
**Dependencies**: Sprint 2 (lens scope unified), Sprint 3 (transform engine exists)
**Spec Reference**: §6.2, §10 Phase 5 • **Status Reference**: STATUS-20251230.md "Phase 5: Registry-Driven Lens UI"

#### Description
**User Decision**: Copy lens UI components from `.worktrees/` if they exist, or create new ones. Don't skip this phase.

Current problem per plan (§6.2): `LensSelector.tsx` and `LensChainEditor.tsx` have hardcoded lens type lists and param editors, duplicating registry definitions. When registry changes, UI can become out of sync.

**Goal**: UI pulls lens metadata from `LensRegistry` at runtime.

#### Files to Locate/Create
1. **Locate in worktrees or main branch**:
   - `src/editor/components/LensSelector.tsx`
   - `src/editor/modulation-table/LensChainEditor.tsx`
   - If not found, search for lens editing UI in running app (`just dev` inspection)

2. **If found, modify**:
   - Get lens list from `LensRegistry.getAllLenses()` filtered by scope
   - Render param editors from `LensDef.params` schema using `UIControlHint`
   - Remove hardcoded lens type switches

3. **If missing, create new**:
   - `src/editor/components/LensSelector.tsx` - Dropdown for adding lenses
   - `src/editor/components/LensParamEditor.tsx` - Registry-driven param controls
   - `src/editor/components/LensChainEditor.tsx` - Reorderable lens stack UI
   - Integration: Wire inspector, bus inspector, modulation table

#### Helper to Create
**`src/editor/components/lens-ui/renderLensParams.tsx`** (~80 lines):
```typescript
export function renderLensParams(
  params: LensParam[],
  currentValues: Record<string, LensParamBinding>,
  onChange: (paramId: string, value: LensParamBinding) => void
): JSX.Element
```
- Uses `UIControlHint` from `LensDef.params` to select control type
- Supports: slider, toggle, dropdown, color picker, vec2 input
- Handles lens param bindings (default, literal, wire, bus)

#### Acceptance Criteria
- [ ] Lens UI components located or created
- [ ] `LensSelector` renders lens options from `LensRegistry.getAllLenses()`
- [ ] Lens list filtered by scope (wire selector shows wire-compatible lenses only)
- [ ] Lens list filtered by domain (float input shows float lenses only)
- [ ] Param editors render from `LensDef.params` schema (no hardcoded switches)
- [ ] All lens param types supported: default, literal, wire, bus bindings
- [ ] Reordering, enabling/disabling, removing lenses works
- [ ] Manual test in `just dev`: Add/edit/remove lenses via UI on wire
- [ ] Manual test: Add/edit/remove lenses via UI on publisher
- [ ] Manual test: Add/edit/remove lenses via UI on listener
- [ ] Changes persist correctly in patch
- [ ] `just check` passes

#### Technical Notes
- This phase has **unknown risk** due to missing UI files in main branch
- If UI was removed in refactor, may need to rebuild from scratch (3 day estimate assumes existing UI to modify)
- Consider using MobX reactions for live param preview if time permits
- Lens param bindings with their own transform stacks should show recursive editor (depth limit enforced)

---

### Sprint 4 Summary
**Total Effort**: 3-4 days
**Deliverables**: 1
**Risk**: Unknown (depends on locating existing UI)

**Critical Path**:
- Day 1: Locate or scaffold lens UI components
- Day 2: Implement registry-driven lens list and selection
- Day 3: Implement registry-driven param editors
- Day 4: Integration testing and polish

**Verification**:
- `just dev`: Full lens editing workflow (add/edit/remove/reorder)
- Lens options match registry definitions exactly
- Adding new lens to registry makes it immediately available in UI (no UI code change needed)

---

## Sprint 5: Full IR Transform Support
**Duration**: 5-7 days
**Phases**: 6
**Goal**: IR compiler supports transforms (not just rejection)

### Deliverable 6: IR Compiler Transform Lowering (Phase 6 - Option A)
**Effort**: 6 days
**Status**: Not Started
**Dependencies**: Sprint 3 (transform engine centralized)
**Spec Reference**: §8 Option A, §10 Phase 6 • **Status Reference**: STATUS-20251230.md "Phase 6: IR Compiler Consistency - Option A"

#### Description
**User Decision**: Implement **FULL** transform support in IR mode (not just rejection).

Currently per STATUS (§3): IR compiler rejects adapters and ignores lenses silently. This creates "works in closure mode but not IR mode" confusion and violates the principle that compiler mode shouldn't change patch semantics.

**Goal**: Thread transform stacks through IR lowering passes and generate IR nodes/runtime steps that execute adapters and lenses.

**Strategy**: Start with full support for cheap/pure transforms, explicit errors for expensive/stateful ones.

#### Supported Transforms (Initial)
**Adapters** (all 18 eventually):
- ✅ `ConstToSignal` (cheap, pure)
- ✅ `Broadcast*ToField` (required for field buses)
- ✅ `NormalizeToPhase`, `PhaseToNumber` (domain conversions)
- ✅ `NumberToDurationMs`, `DurationToNumberMs` (cheap)
- ⚠️ `ReduceFieldToSignal` (expensive - may reject with error initially)

**Lenses** (27 total, prioritize pure ones):
- ✅ **Pure/cheap**: scale, clamp, polarity, phaseOffset, phaseScale, rotate2d, translate2d, hueShift
- ⚠️ **Stateful** (reject initially): slew, hysteresis (require per-frame state)
- ✅ **Listener-only**: ease, mapRange (supported in listener scope only)

#### Files to Modify
1. **`src/editor/compiler/passes/pass6-block-lowering.ts`**
   - Thread adapter chains through IR node creation
   - For each block output, if connection has adapters, generate adapter IR nodes
   - May require new IR node types: `{ type: 'Adapter', adapterId, params, input }`

2. **`src/editor/compiler/passes/pass7-bus-lowering.ts`**
   - Apply publisher lens stacks before bus combine
   - Generate IR nodes for lens transformations on publisher artifacts
   - May require new IR node types: `{ type: 'Lens', lensId, params, input }`

3. **`src/editor/compiler/passes/pass8-link-resolution.ts`**
   - Apply wire transform stacks during link resolution
   - Apply listener transform stacks after bus reads
   - Generate composite IR expressions for transform chains

4. **`src/editor/adapters/AdapterRegistry.ts`**
   - Add `compileToIR?: (input: IRNode, params, ctx) => IRNode` to `AdapterDef`
   - Implement for all cheap adapters
   - Expensive adapters return error or fallback to runtime evaluation

5. **`src/editor/lenses/LensRegistry.ts`**
   - Add `compileToIR?: (input: IRNode, params, ctx) => IRNode` to `LensDef`
   - Implement for pure lenses (scale, clamp, etc.)
   - Stateful lenses return error or fallback to runtime evaluation

6. **`src/editor/transforms/validate.ts`**
   - Implement IR mode validator:
     ```typescript
     export function validateForIRMode(
       stack: TransformStack,
       errors: CompileError[]
     ): void {
       for (const step of stack) {
         if (step.kind === 'adapter') {
           const def = getAdapter(step.step.adapterId);
           if (!def?.compileToIR) {
             errors.push({
               message: `Adapter '${def?.label}' not supported in IR mode yet`,
               suggestion: 'Use closure mode or remove adapter'
             });
           }
         }
         if (step.kind === 'lens') {
           const def = getLens(step.lens.id);
           if (!def?.compileToIR) {
             errors.push({
               message: `Lens '${def?.label}' not supported in IR mode yet`,
               suggestion: 'Use closure mode or remove lens'
             });
           }
         }
       }
     }
     ```
   - Call early in IR compilation to fail fast

7. **`src/editor/compiler/ir/types.ts`** (if needed)
   - Add new IR node types for transforms:
     ```typescript
     export type IRNode =
       | { type: 'Adapter'; adapterId: string; params: Record<string, unknown>; input: IRNode }
       | { type: 'Lens'; lensId: string; params: Record<string, unknown>; input: IRNode }
       | ... existing types
     ```

8. **`src/editor/runtime/ir-executor.ts`** (if runtime evaluation needed)
   - Extend IR runtime to execute adapter/lens nodes
   - Call `AdapterDef.apply()` or `LensDef.apply()` at runtime for unsupported IR transforms

#### Acceptance Criteria
- [ ] All cheap adapters have `compileToIR` implementations
- [ ] All pure lenses have `compileToIR` implementations
- [ ] IR passes thread transform stacks through lowering (Pass 6, 7, 8 modified)
- [ ] IR validator rejects unsupported transforms with clear errors
- [ ] Supported transforms compile to IR nodes correctly
- [ ] IR runtime can execute adapter/lens nodes (if runtime fallback used)
- [ ] Wire transforms work in IR mode (test: `ConstToSignal` adapter on wire)
- [ ] Publisher transforms work in IR mode (test: `scale` lens on publisher)
- [ ] Listener transforms work in IR mode (test: `clamp` lens on listener)
- [ ] Unsupported transforms error clearly (test: `slew` lens errors with message)
- [ ] All existing IR tests pass
- [ ] Manual test: Same patch in closure vs IR mode produces same runtime behavior
- [ ] `just check` passes

#### Technical Notes
- This is **HIGH RISK** work touching IR core
- Implement incrementally: one adapter, verify, then next
- Start with Pass 8 (wire transforms) as simplest case
- IR node types may need AST extensions for lens params (nested bindings)
- Runtime fallback is acceptable for complex transforms (don't block on full IR compilation)
- Consider caching compiled transform chains for performance

---

### Sprint 5 Summary
**Total Effort**: 5-7 days
**Deliverables**: 1
**Risk**: High (complex IR changes, new AST node types)

**Critical Path**:
- Day 1: Design IR node types for transforms, update type definitions
- Day 2: Implement `compileToIR` for 5-6 cheap adapters
- Day 3: Implement `compileToIR` for 10-12 pure lenses
- Day 4: Modify Pass 6 (block lowering) for adapter support
- Day 5: Modify Pass 7 (bus lowering) for publisher lens support
- Day 6: Modify Pass 8 (link resolution) for wire/listener transforms
- Day 7: Validation, testing, edge cases

**Verification**:
- `just check` passes
- All IR tests pass
- Manual test: Create patch with transforms, verify closure vs IR mode equivalence
- Manual test: Stateful lens errors clearly in IR mode
- Compare: Supported transforms produce identical runtime behavior in both modes

---

## Optional Sprint 6: Semantic Registry
**Duration**: 3-4 days
**Phases**: 9 (from plan)
**Goal**: Phase-specific lens validation without leaking into generic types

### Deliverable 7: Numeric Semantics Registry (Optional Phase 9)
**Effort**: 3 days
**Status**: Not Started
**Dependencies**: Sprint 2 (lens scope unified)
**Spec Reference**: §9, Constraint 1.2 • **Status Reference**: STATUS-20251230.md "Phase 9: Numeric Semantics Registry"

#### Description
**Problem**: Phase-specific lenses (phaseOffset, pingPong, phaseWindow) need to know if an artifact is "phase-flavored", but we cannot add `semantics` field to `TypeDesc` (violates constraint 1.2).

**Solution**: Create a separate registry that maps `SlotType` strings and reserved bus names to semantic "flavors".

**When to build**: After Sprint 2 (lens scope unification), optionally before Sprint 5 (IR support) if phase lens validation is critical.

#### Files to Create
**`src/editor/semantics/ValueSemantics.ts`** (~120 lines):
```typescript
export type NumericKind = 'phase' | 'unit' | 'float' | 'vec2' | 'color';

const SEMANTICS: Record<string, NumericKind> = {
  'Signal<phase>': 'phase',
  'Signal<Unit>': 'unit',
  'Signal<float>': 'float',
  'Field<phase>': 'phase',
  // ... etc
};

const BUS_SEMANTICS: Record<string, NumericKind> = {
  'phaseA': 'phase',
  'phaseB': 'phase',
  'progress': 'unit',
  // ... etc
};

export function getSemantics(slotType: string): NumericKind | undefined;
export function getBusSemantics(busId: string): NumericKind | undefined;
export function isSemanticCompatible(
  artifact: Artifact,
  requiredKind: NumericKind
): boolean;
```

#### Files to Modify
1. **`src/editor/lenses/LensRegistry.ts`**
   - Add `requiresSemantics?: NumericKind` to `LensDef`
   - Update phase-specific lenses:
     ```typescript
     // phaseOffset
     {
       id: 'phaseOffset',
       domain: 'float',
       requiresSemantics: 'phase',
       allowedScopes: ['wire', 'publisher', 'listener'],
       ...
     }
     ```

2. **`src/editor/transforms/validate.ts`**
   - Add semantic validation:
     ```typescript
     export function validateLensSemantics(
       lensId: string,
       artifact: Artifact,
       errors: CompileError[]
     ): void {
       const def = getLens(lensId);
       if (def?.requiresSemantics) {
         if (!isSemanticCompatible(artifact, def.requiresSemantics)) {
           errors.push({
             message: `Lens '${def.label}' requires ${def.requiresSemantics} semantics`,
             actual: getSemantics(artifact.kind)
           });
         }
       }
     }
     ```

#### Acceptance Criteria
- [ ] `ValueSemantics.ts` created with semantic mappings
- [ ] All `Signal<phase>` and phase bus types mapped to `'phase'` semantic
- [ ] All phase-specific lenses declare `requiresSemantics: 'phase'`
- [ ] Semantic validator rejects phase lens on non-phase signal
- [ ] Semantic validator allows phase lens on `Signal<phase>` and `phaseA` bus
- [ ] No `semantics` field added to `TypeDesc`, `Slot`, or `Bus` (constraint 1.2 preserved)
- [ ] All existing tests pass
- [ ] Manual test: Apply `phaseOffset` to `Signal<float>` (rejected)
- [ ] Manual test: Apply `phaseOffset` to `Signal<phase>` (allowed)
- [ ] `just check` passes

#### Technical Notes
- This is **additive only** (doesn't break existing code)
- Semantic mappings are centralized (easy to extend for new types)
- Can be used for future UI hints (range metadata, default values)
- Optional but valuable for preventing runtime errors

---

### Sprint 6 Summary
**Total Effort**: 3-4 days
**Deliverables**: 1 (optional)
**Risk**: Low (additive, doesn't touch core compilation)

**When to Execute**:
- If phase lens bugs are common: Do after Sprint 2
- If IR support is priority: Defer until after Sprint 5
- If time limited: Skip entirely (phase lenses still work, just less validation)

**Verification**:
- Phase lenses only apply to phase-semantic artifacts
- Clear errors prevent "expected phase artifact" runtime bugs
- No regression in existing behavior

---

## Dependency Graph

```
Sprint 1 (Foundation)
  └─> Deliverable 1: Transform Facade Modules
       └─> Deliverable 2: Unified Adapter Execution

Sprint 2 (Lens Scope) [depends on Sprint 1]
  └─> Deliverable 3: Expand LensScope
       [uses transform facade from Sprint 1]

Sprint 3 (Centralization) [depends on Sprint 1, Sprint 2]
  └─> Deliverable 4: Centralized Transform Application
       [uses facade + scope validation]

Sprint 4 (UI) [depends on Sprint 2, Sprint 3]
  └─> Deliverable 5: Registry-Driven Lens UI
       [uses lens scope + transform engine]

Sprint 5 (IR Support) [depends on Sprint 3]
  └─> Deliverable 6: IR Transform Lowering
       [uses centralized transform engine]

Sprint 6 (Optional Semantics) [depends on Sprint 2]
  └─> Deliverable 7: Semantic Registry
       [extends lens scope validation]
```

**Critical Path**: Sprint 1 → Sprint 2 → Sprint 3 → Sprint 4
**Parallel Opportunity**: Sprint 5 can start after Sprint 3 (while Sprint 4 in progress if resources available)
**Optional**: Sprint 6 can run anytime after Sprint 2

---

## Risk Assessment

### High Risk Items
1. **Sprint 1, Deliverable 2**: Replacing adapter switch statement
   - **Impact**: Core compilation path, affects all adapters
   - **Mitigation**: Test each adapter as you move it; keep switch as fallback initially
   - **Rollback**: Easy (revert registry changes, restore switch)

2. **Sprint 3, Deliverable 4**: Centralizing transform application
   - **Impact**: All transform call sites change, three compilation scopes affected
   - **Mitigation**: Migrate one scope at a time (wire → publisher → listener)
   - **Rollback**: Medium (multiple files modified)

3. **Sprint 5, Deliverable 6**: IR transform support
   - **Impact**: IR AST changes, three compiler passes modified
   - **Mitigation**: Runtime fallback for complex transforms; incremental adapter/lens support
   - **Rollback**: Difficult (AST changes may be breaking)

### Medium Risk Items
1. **Sprint 2, Deliverable 3**: Expanding lens scope
   - **Impact**: 27 lens definitions modified
   - **Mitigation**: Grep for `LensScope` usage, audit all switches
   - **Rollback**: Easy (scope enum change is localized)

2. **Sprint 4, Deliverable 5**: UI refactor
   - **Impact**: Unknown (UI files missing from main branch)
   - **Mitigation**: Locate in worktrees or rebuild; MCP-based manual testing
   - **Rollback**: Medium (UI changes isolated from compiler)

### Low Risk Items
1. **Sprint 1, Deliverable 1**: Transform facade modules
   - **Impact**: None (new files, no existing code modified)
   - **Rollback**: Trivial (delete new files)

2. **Sprint 6, Deliverable 7**: Semantic registry
   - **Impact**: Additive only (new validation, no behavior change)
   - **Rollback**: Trivial (remove semantic checks)

---

## Testing Strategy

### Automated Testing (Required)
**Existing Test Suite**: Must pass after each deliverable (900+ tests)
- `just test` - Run full suite
- Focus areas: `bus-compilation.test.ts`, `field-bus-compilation.test.ts`, `lensResolution.test.ts`

**New Tests Required** (by sprint):

**Sprint 1**:
- [ ] Transform stack normalization (round-trip tests)
- [ ] Catalog filtering (lens list by scope/domain)
- [ ] Adapter registry execution (all 18 adapters)

**Sprint 2**:
- [ ] Lens scope validation (legal/illegal combinations)
- [ ] Wire lens application (all wire-compatible lenses)

**Sprint 3**:
- [ ] Transform application equivalence (old vs new implementation)
- [ ] Lens param binding resolution with transforms
- [ ] Depth limit enforcement for recursive params

**Sprint 4**:
- [ ] UI component rendering (snapshot tests if applicable)

**Sprint 5**:
- [ ] IR transform compilation (closure vs IR equivalence)
- [ ] IR validator (supported vs unsupported transforms)
- [ ] IR runtime execution (adapter/lens node evaluation)

**Sprint 6** (optional):
- [ ] Semantic registry lookups
- [ ] Phase lens validation (phase vs non-phase artifacts)

### Manual Verification (Critical - Required after each sprint)
**Via `just dev` + Chrome DevTools MCP**:

**Sprint 1 Verification**:
1. Create wire with `ConstToSignal` adapter
2. Verify compilation succeeds
3. Verify adapter execution produces correct artifact

**Sprint 2 Verification**:
1. Create wire with `scale` lens (should allow)
2. Create wire with `ease` lens (should reject with error)
3. Verify error messages are clear and actionable

**Sprint 3 Verification**:
1. Create patch with wire → publisher → listener transform chain
2. Verify end-to-end transform application
3. Create lens param binding with adapter chain
4. Verify recursive resolution works and depth limit enforced

**Sprint 4 Verification**:
1. Open lens selector for wire
2. Verify lens list matches registry definitions
3. Add lens, edit params, verify persistence
4. Verify param editors match `LensDef.params` schema
5. Repeat for publisher and listener

**Sprint 5 Verification**:
1. Create patch with transforms in closure mode (verify works)
2. Switch to IR mode (verify same behavior or explicit error)
3. Test cheap adapter in IR mode (verify compiles)
4. Test stateful lens in IR mode (verify clear error)
5. Compare runtime output: closure vs IR should be identical for supported transforms

**Sprint 6 Verification** (optional):
1. Apply `phaseOffset` lens to `Signal<phase>` (should allow)
2. Apply `phaseOffset` lens to `Signal<float>` (should reject)
3. Verify error message explains semantic mismatch

### Regression Checks (After each sprint)
**Critical User Flows**:
- [ ] Load existing patches with transforms → must work identically
- [ ] Disabled transforms (enabled=false) → correctly skipped
- [ ] Adapter suggestions in modulation table → consistent across scopes
- [ ] Bus compilation with field adapters → field materialization works
- [ ] Complex lens chains (3+ lenses) → applied in order correctly

### Data Flow Tracing (Sprint 3 and Sprint 5)
**Wire Connection Transform Flow**:
1. Block output artifact
2. Adapter chain: Type conversion (e.g., `Scalar<float>` → `Signal<float>`)
3. Lens stack: Value transformation (e.g., scale × 2, clamp 0-1)
4. Block input receives transformed artifact
5. **Verify**: Log intermediate values, ensure correct order

**Bus Publisher Transform Flow**:
1. Block output artifact
2. Adapter chain: Type conversion
3. Lens stack: Pre-combine transformation
4. Bus combine: Merge with other publishers
5. Bus artifact available to listeners
6. **Verify**: Bus value reflects all publisher transforms

**Lens Param Binding Flow** (recursive):
1. Lens needs param value
2. Resolve binding (wire/bus/default)
3. Apply binding's own adapter chain
4. Apply binding's own lens stack (depth limited to 3)
5. Param artifact for lens execution
6. **Verify**: No cycles, depth limit enforced

---

## Blockers and Open Questions

### Current Blockers
**None** - All prerequisites met per STATUS:
- ✅ Build stability (`just check` passes)
- ✅ Transform storage unified in types
- ✅ Lens registry has execution logic
- ✅ Adapter registry has metadata

### Resolved by User Decisions
1. ✅ **Wire lens scope**: Allow ALL publisher+listener lenses (most flexible)
2. ✅ **IR compiler strategy**: FULL transform support (not rejection)
3. ✅ **Lens UI components**: Copy from worktrees or create new

### Open Questions (Not blocking, informational)
1. **Sprint 4 UI Location**: Confirm `.worktrees/` has lens UI components or identify alternate location
   - **Action**: Run `just dev`, inspect UI to find lens editing locations
   - **Fallback**: Create new components if missing

2. **Sprint 5 IR Complexity**: Should we support stateful lenses (slew, hysteresis) in IR mode?
   - **Recommendation**: Defer to future work; explicit error is acceptable
   - **Rationale**: Requires per-frame state in IR runtime (complex)

3. **Sprint 6 Priority**: When to build semantic registry?
   - **Recommendation**: After Sprint 5 if time permits
   - **Rationale**: Optional enhancement, not blocking other work

---

## Recommended Execution Order

### Phase 1: Foundation (Sprints 1-2) — 9-11 days
**Goal**: Transform facade exists, adapters and lenses unified

1. **Sprint 1**: Create facade, unify adapter execution (5-6 days)
2. **Sprint 2**: Unify lens scope (4-5 days)

**Checkpoint**: `just check` passes, all tests pass, manual smoke test successful

---

### Phase 2: Application (Sprints 3-4) — 7-9 days
**Goal**: Centralized transform engine, registry-driven UI

3. **Sprint 3**: Centralize transform application (4-5 days)
4. **Sprint 4**: Registry-driven lens UI (3-4 days)

**Checkpoint**: UI uses registry, transform engine used everywhere

---

### Phase 3: IR Parity (Sprint 5) — 5-7 days
**Goal**: IR compiler supports transforms

5. **Sprint 5**: IR transform lowering (5-7 days)

**Checkpoint**: Closure vs IR mode behavior consistent

---

### Phase 4: Polish (Sprint 6 - Optional) — 3-4 days
**Goal**: Semantic validation for phase lenses

6. **Sprint 6**: Semantic registry (3-4 days, if time permits)

**Checkpoint**: Phase lens validation prevents runtime errors

---

## Total Effort Summary

**Minimum (Required Sprints 1-5)**: 18-24 days
**Complete (All Sprints 1-6)**: 21-28 days

**Breakdown**:
- Sprint 1 (Foundation): 5-6 days
- Sprint 2 (Lens Scope): 4-5 days
- Sprint 3 (Centralization): 4-5 days
- Sprint 4 (UI): 3-4 days
- Sprint 5 (IR Support): 5-7 days
- Sprint 6 (Optional Semantics): 3-4 days

**Risk Buffer**: +20% recommended (add 4-5 days for high-risk items)

---

## Success Criteria (Final Definition of Done)

### Required (All Must Pass)
- [ ] One canonical transform abstraction exists (`src/editor/transforms/*`)
- [ ] No adapter execution logic in compiler switch statements
- [ ] Lens scope enforced consistently (wires not special-cased)
- [ ] Lens lists and param schemas are registry-driven in UI
- [ ] IR compiler behavior is explicit and consistent (transforms supported, not silently ignored)
- [ ] `just check` passes without errors
- [ ] All existing tests pass (900+ tests)
- [ ] Manual verification in `just dev` (all flows documented above)

### Nice-to-Have (Future Work)
- [ ] Transform chain editor UI shared across Connection/Bus inspectors
- [ ] Numeric semantics registry for phase lens validation
- [ ] Performance optimizations for transform stack evaluation
- [ ] Plugin system for custom adapters/lenses

---

## Rollback Plan

**If Sprint 1 fails**:
- Delete `src/editor/transforms/` directory
- Revert adapter registry changes
- No impact on existing code

**If Sprint 2 fails**:
- Revert `LensScope` enum change
- Restore original lens scope validation
- Remove added `allowedScopes` arrays

**If Sprint 3 fails**:
- Revert `transforms/apply.ts` to wrappers
- Restore local transform functions in `compileBusAware.ts`
- Keep facade for future retry

**If Sprint 4 fails**:
- Revert UI changes
- Existing hardcoded UI still functional
- Registry-driven UI deferred to future work

**If Sprint 5 fails**:
- Revert IR pass changes
- Restore IR transform rejection/ignoring
- Keep transform facade for future retry

**If Sprint 6 fails**:
- Remove semantic registry
- Existing lens validation still functional
- Phase lens validation deferred to future work

**Critical Safety**: Each sprint is designed to be independently revertable without breaking existing functionality.

---

## Next Steps

**Immediate Actions** (ready to start):
1. Begin Sprint 1, Deliverable 1: Create `src/editor/transforms/` directory structure
2. Implement transform facade types (`types.ts`, `normalize.ts`)
3. Write unit tests for normalization functions

**Before Starting Sprint 4**:
1. Locate lens UI components in `.worktrees/` or main branch
2. If missing, plan UI component architecture

**Before Starting Sprint 5**:
1. Review IR AST types and plan extensions
2. Identify which adapters/lenses can compile to IR vs need runtime fallback

**Recommended Starting Point**: Sprint 1, Deliverable 1 (low risk, high value, no blockers)
