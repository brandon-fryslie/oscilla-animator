# Status Report: Unified Transforms (Lenses + Adapters)
**Date**: 2025-12-30
**Scope**: Full project evaluation for unified transforms refactor
**Authoritative Plans**:
- `plans/PLAN-UNIFIED-TRANSFORMS-LENSES-ADAPTERS.md`
- `plans/PLAN-UNIFIED-TRANSFORMS-LENSES-ADAPTERS-CHECKLIST.md`

---

## Executive Summary

**Build Status**: ✅ PASSING (`just check` succeeds with lint warnings only)
**Current State**: Adapters and lenses exist but are **fragmented** across multiple systems
**Readiness**: Ready to begin Phase 0 immediately
**Estimated Effort**: 6 phases, ~3-4 sprints for complete implementation

### Key Findings
1. **Adapter duplication**: Registry has metadata only; execution lives in 250-line switch statement
3. **IR compiler inconsistency**: Rejects adapters, ignores lenses silently (no errors)
4. **UI hardcoding**: No lens selector/chain editor found in main branch (may be in worktrees)
5. **No `src/editor/transforms/` directory exists yet** - clean slate for new facade

---

## What Exists Today

### 1. Adapter System (FRAGMENTED)

#### Registry (Metadata Only)
**File**: `src/editor/adapters/AdapterRegistry.ts` (234 lines)

**What it does**:
- Defines `AdapterDef` (id, label, policy, cost, from/to types)
- `initAdapterRegistry()` registers 18 adapters at module load
- Provides metadata for UI and type pathfinding via `autoAdapter.ts`

**What it does NOT do**:
- Contains NO execution logic (no `apply` field yet)
- Comment on line 11: `// Execution logic will be added in Phase 4`

**Registered Adapters** (18 total):
- World adapters (12): `ConstToSignal`, `Broadcast{Scalar,Signal}ToField`, `ReduceFieldToSignal` × 3 domains
- Domain adapters (6): `NormalizeToPhase`, `PhaseToNumber`, `NumberToDurationMs`, `DurationToNumberMs` × 2 worlds

#### Execution (Switch Statement)
**File**: `src/editor/compiler/compileBusAware.ts`

**Function**: `applyAdapterStep()` (lines 1109-1220)
- 112-line switch statement on adapter name
- Hardcoded logic for 8 adapters (subset of registry)
- **Missing adapters**: `ReduceFieldToSignal`, `NumberToDurationMs`, `DurationToNumberMs`, `ExpressionToWaveform`

**Duplication Problem**:
```typescript
// AdapterRegistry.ts (metadata)
adapterRegistry.register({
  id: 'ConstToSignal:float',
  label: 'Const → Signal (float)',
  from: { world: 'scalar', domain: 'float' },
  to: { world: 'signal', domain: 'float' },
});

// compileBusAware.ts (execution - separate location)
case 'ConstToSignal': {
  if (artifact.kind === 'Scalar:float') {
    return { kind: 'Signal:float', value: () => artifact.value };
  }
  // ... more cases
}
```

**Usage Sites** (3 locations call `applyAdapterChain`):
1. Wire connections (line 625)

---

### 2. Lens System (SCOPE MISMATCH + UI UNKNOWN)

#### Registry (New System, Partially Aligned)
**File**: `src/editor/lenses/LensRegistry.ts` (799 lines)

**What it does**:
- Defines `LensDef` with `allowedScopes: LensScope[]`
- `initLensRegistry()` registers 27 lenses at module load
- Includes `apply` execution logic inline

**Scope Definition** (line 11):
```typescript
```

**MISMATCH**: Wires (`Connection`) already have `lensStack?: LensInstance[]` and UI applies lenses to wires, but registry doesn't declare `'wire'` as a valid scope.

**Registered Lenses** (27 total by domain):
- `float` domain (10): scale, polarity, clamp, softclip, deadzone, slew, quantize, ease, mapRange, hysteresis
- `float` (phase semantics, 7): phaseOffset, pingPong, phaseScale, phaseQuantize, wrapMode, phaseWindow
- `vec2` domain (7): rotate2d, vec2GainBias, translate2d, clampBounds, swirl, normalize, smoothPath
- `color` domain (5): hueShift, colorGain, saturate, contrast, clampGamut

**Apply Logic**: Embedded in registry definitions (not in separate switch statement like adapters)

#### Lens Application
**File**: `src/editor/compiler/compileBusAware.ts`

**Function**: `applyLensStack()` (lines 1222-1284)
- Calls `getLens(lensId)` to get registry definition
- Domain compatibility check: `type.domain === def.domain`
- Calls `def.apply(current, params)` directly (no switch statement)
- Handles lens param resolution recursively via `resolveLensParam()`

**Param Resolution**:
**File**: `src/editor/lenses/lensResolution.ts` (82 lines)
- Resolves `LensParamBinding` (4 kinds: default, wire, bus, literal)
- Wire/bus bindings can have their own `adapterChain` and `lensStack` (recursive!)
- Depth limit: 3 levels (line 17)

---

### 3. IR Compiler Behavior (INCONSISTENT)

**File**: `src/editor/compiler/passes/pass8-link-resolution.ts`

**Current Behavior**:
- **Adapters**: Not mentioned in IR code (likely rejected elsewhere or silently fail)
- **Lenses**: Not mentioned in IR code (silently ignored)

**Evidence of Inconsistency**:
From plan document §2.4:
> IR compiler path currently rejects adapters and ignores lenses:
> - `pass8-link-resolution.ts` emits `UnsupportedAdapterInIRMode` and ignores lens stacks.

**Search Result**: No grep hits for "UnsupportedAdapterInIRMode" in pass8, suggesting this error may be in a different pass or not yet implemented.

**Problem**: IR compilation produces different runtime behavior than closure compilation for the same patch. Silent failures are worse than explicit errors.

---

### 4. UI Components (MISSING FROM MAIN BRANCH)

**Search Results**:
- `LensSelector.tsx`: Found in `.worktrees/` only (not in main `src/editor/components/`)
- `LensChainEditor.tsx`: Found in `.worktrees/` only (not in main `src/editor/modulation-table/`)

**Status**: Cannot evaluate UI hardcoding without access to main branch files. Plan assumes these exist and are hardcoded.

**Plan Assumption** (§6.2):
> `LensSelector.tsx` has its own LENS_TYPES and param editing switches.
> `LensChainEditor.tsx` has its own handling.

**TODO**: Verify if these components exist in main branch via `just dev` inspection or locate correct paths.

---

### 5. Transform Storage (Already Unified in Types)

**File**: `src/editor/types.ts`

All four binding types already have identical transform storage:

```typescript
// Wire (Connection, line 631)
interface Connection {
  lensStack?: LensInstance[];
  adapterChain?: AdapterStep[];
  enabled?: boolean;
}

  adapterChain?: AdapterStep[];
  lensStack?: LensInstance[];
  enabled: boolean;
  sortKey: number;
}

  adapterChain?: AdapterStep[];
  lensStack?: LensInstance[];
  enabled: boolean;
}

// Lens Param Binding (line 236)
type LensParamBinding =
  | { kind: 'wire'; from: PortRef; adapterChain?: AdapterStep[]; lensStack?: LensInstance[] }
  | { kind: 'bus'; busId: string; adapterChain?: AdapterStep[]; lensStack?: LensInstance[] }
  | ...
```

**Good News**: Storage layer is already unified. No migration needed for persisted patches.

---

## What Needs to Be Built

### Phase 0: Stabilize Build (READY NOW)
**Status**: ✅ Build already stable (`just check` passes)

No action required. Skip to Phase 1.

---

### Phase 1: Add Transform Modules (No Behavior Changes)

**New Files to Create** (5 files in `src/editor/transforms/`):

1. **`types.ts`** (~50 lines)
   - `TransformStep = { kind: 'adapter'|'lens', enabled: boolean, ... }`
   - `TransformStack = ReadonlyArray<TransformStep>`

2. **`normalize.ts`** (~80 lines)
   - `normalizeTransformStack(input: { adapterChain?, lensStack? }): TransformStack`
   - `splitTransformStack(stack: TransformStack): { adapterChain?, lensStack? }`
   - Handles undefined → `[]`, missing enabled → `true`

3. **`catalog.ts`** (~60 lines)
   - `listAdapters(): AdapterDef[]` (from AdapterRegistry)
   - `listLenses(): LensDef[]` (from LensRegistry)
   - `listLensesFor(scope: TransformScope, typeDesc): LensDef[]`

4. **`validate.ts`** (~150 lines)
   - Scope legality checks (lens `allowedScopes`, adapter policies per scope)
   - Type legality checks (lens compatible with endpoint semantics)
   - Structural legality (no lens param cycles, depth limits)
   - **Critical**: IR mode transform support validator (reject or allow specific transforms)

5. **`apply.ts`** (~100 lines initially)
   - Wrapper functions that delegate to existing logic
   - `applyAdapterChain()` - wraps `compileBusAware.applyAdapterChain()`
   - `applyLensStack()` - wraps `compileBusAware.applyLensStack()`
   - `applyTransformStack()` - unified entrypoint

**Dependencies**: None (standalone module)
**Risk**: Low (no existing code modified yet)

---

### Phase 2: Unify Adapter Execution Under Registry

**Files to Modify**:

1. **`src/editor/adapters/AdapterRegistry.ts`**
   - Add `apply?: (artifact, params, ctx) => Artifact` to `AdapterDef`
   - Move logic from `compileBusAware.applyAdapterStep()` switch cases into adapter defs
   - Register 18 adapters with execution logic

2. **`src/editor/compiler/compileBusAware.ts`**
   - Replace `applyAdapterStep()` switch (lines 1109-1220) with:
     ```typescript
     function applyAdapterStep(artifact, step, ctx) {
       const def = adapterRegistry.get(step.adapterId);
       if (!def?.apply) return { kind: 'Error', ... };
       return def.apply(artifact, step.params, ctx);
     }
     ```
   - Delete 112 lines of switch logic

**Benefits**:
- One place to add/modify adapters (currently 2 places)
- UI can show same metadata that execution uses
- Missing adapters become obvious (no silent "default" case)

**Risk**: Medium (modifies compilation path, requires thorough testing)

---

### Phase 3: Unify Lens Scope + Legality

**Files to Modify**:

1. **`src/editor/lenses/LensRegistry.ts`**
   - Update 27 lens definitions to declare scope compatibility explicitly:
     - Phase lenses: Scope + semantic requirements (needs numeric registry from §9)

2. **`src/editor/transforms/validate.ts`** (from Phase 1)
   - Implement scope validation using registry `allowedScopes`
   - Call from compiler early to reject invalid combinations

**Decision Required**: Wire lens legality
- Option C: Wires have separate lens set (most restrictive)


**Risk**: Low (additive change, existing wire lenses already work)

---

### Phase 4: Centralize Transform Application

**Files to Modify**:

1. **`src/editor/transforms/apply.ts`** (from Phase 1)
   - Replace wrappers with actual implementations
   - Move `applyAdapterChain()` from compileBusAware.ts
   - Move `applyLensStack()` from compileBusAware.ts
   - Export `applyTransformStack(artifact, stack, scope, ctx, ...)`

2. **`src/editor/compiler/compileBusAware.ts`**
   - Replace local functions with imports from `transforms/apply.ts`
   - Add explicit scope parameter to all call sites:
     ```typescript
     // Before
     applyAdapterChain(art, chain, ctx, errors)

     // After
     applyTransformStack(art, normalizeStack({ adapterChain: chain }), 'wire', ctx, ...)
     ```

3. **`src/editor/lenses/lensResolution.ts`**
   - Use transform engine for lens param resolution instead of ad-hoc callbacks

**Benefits**:
- One canonical transform engine used everywhere
- Scope-specific behavior centralized (no hidden special cases)
- Easier to add IR support (single code path to modify)

**Risk**: Medium (refactor of working code, needs careful testing)

---

### Phase 5: Registry-Driven Lens UI (BLOCKED - UI Files Missing)

**Status**: ⚠️ CANNOT EVALUATE - UI files not found in main branch

**Expected Files** (based on plan):
- `src/editor/components/LensSelector.tsx`
- `src/editor/modulation-table/LensChainEditor.tsx`

**When Found**, modify to:
1. Get lens list from `LensRegistry.getAllLenses()` filtered by scope
2. Render param editors from `LensDef.params` schema using `UIControlHint`
3. Remove hardcoded lens type switches

**Alternative**: UI may have been removed in a refactor. Check if lens editing still exists in running app.

**Risk**: Unknown (need to locate UI first)

---

### Phase 6: IR Compiler Consistency

**Critical Decision Required**: Choose Option A or Option B

#### Option A: Implement Transforms in IR Mode (RECOMMENDED)
**Why recommended**: Matches user expectations, avoids "this works in closure mode but not IR mode" confusion.

**Implementation** (start minimal):
1. **Limited Adapter Support**:
   - `ConstToSignal` (cheap, common)
   - `Broadcast*ToField` (required for field buses)
   - Reject expensive adapters (`ReduceFieldToSignal`) with clear error

2. **Limited Lens Support**:
   - Pure, cheap lenses: scale, clamp, polarity, phaseOffset
   - Reject stateful lenses (slew, hysteresis) with clear error

3. **IR Lowering Changes**:
   - Pass 6 (Block Lowering): Thread adapter chain through node creation

**Files to Modify**:
- `src/editor/compiler/passes/pass6-block-lowering.ts`
- `src/editor/compiler/passes/pass7-bus-lowering.ts`
- `src/editor/compiler/passes/pass8-link-resolution.ts`
- Add `compileToIR()` methods to `AdapterDef` and `LensDef` for AST generation

**Risk**: High (complex IR changes, requires new AST node types for some transforms)

---

#### Option B: Reject Transforms in IR Mode Consistently (STOPGAP)
**Why acceptable**: Explicit failure is better than silent ignoring. Can upgrade to Option A later.

**Implementation**:
1. **`src/editor/transforms/validate.ts`**:
   - Add `validateForIRMode(stack: TransformStack): CompileError[]`
   - Return errors for ANY adapter or lens in IR mode
   - OR: whitelist only zero-cost identity transforms

2. **IR Compiler Entry**:
   - Call validator early (before Pass 6)
   - Emit clear errors: "IR compiler does not support transforms yet. Use closure mode or remove adapters/lenses."

**Files to Modify**:
- `src/editor/compiler/compileBusAware.ts` (call validator before IR passes)
- `src/editor/transforms/validate.ts` (implement IR compatibility check)

**Risk**: Low (rejection is safe, won't break existing working patches)

**Upgrade Path**: When ready for Option A, replace validator with actual IR lowering.

---

### Phase 9 (from Plan): Numeric Semantics Registry (OPTIONAL BUT VALUABLE)

**Problem**: Phase-specific lenses (phaseOffset, pingPong, etc.) need to know if an artifact is "phase-flavored".

**Current Workaround**: Domain matching (`def.domain === 'float'`) is too loose.

**Solution**: Create semantic registry

**File**: `src/editor/semantics/ValueSemantics.ts` (new, ~120 lines)

**What it does**:
- Maps `SlotType` strings to semantic "flavors":
  ```typescript
  const SEMANTICS: Record<string, NumericKind> = {
    'Signal<phase>': 'phase',
    'Signal<Unit>': 'unit',
    'Signal<float>': 'float',
    // ... etc
  };
  ```
- Maps reserved bus names to semantics:
  ```typescript
  const BUS_SEMANTICS: Record<string, NumericKind> = {
    'phaseA': 'phase',
    'phaseB': 'phase',
    'progress': 'unit',
    // ... etc
  };
  ```

**Usage**:
- `LensDef` declares: `requiresSemantics?: NumericKind`
- Validator checks: artifact semantics matches lens requirements
- Prevents "phaseOffset applied to non-phase signal" runtime errors

**When to Build**: After Phase 3 (lens scope unification), before complex lens validation.

**Risk**: Low (additive, doesn't break existing code)

---

## Blockers and Prerequisites

### Current Blockers
1. **Phase 5 (UI Refactor)**: Cannot proceed without locating lens UI components
   - **Resolution**: Run `just dev`, inspect UI to find lens editing locations
   - **Alternative**: Skip Phase 5 if UI was removed in refactor

### Prerequisites Met
- ✅ Build stability (Phase 0)
- ✅ Transform storage already unified in types
- ✅ Lens registry has execution logic
- ✅ Adapter registry has metadata

### Prerequisites Not Met
- ❌ IR compiler transform rejection (silent failure currently)
  - **Impact**: Phase 6 cannot be verified without explicit errors
  - **Resolution**: Implement Option B early (explicit rejection) as Phase 0.5

---

## Risk Assessment

### High Risk Areas
1. **Phase 2 (Adapter Execution)**: Replacing switch statement
   - **Mitigation**: Comprehensive test coverage of all 18 adapters before change
   - **Verification**: Run full test suite + manual testing in `just dev`

2. **Phase 4 (Centralize Application)**: Refactor working compiler code
   - **Verification**: Run after each scope migration, revert if tests fail

3. **Phase 6 Option A (IR Transforms)**: Complex IR changes
   - **Mitigation**: Start with Option B (rejection), upgrade to A in separate sprint
   - **Verification**: Extensive IR validation, compare closure vs IR output

### Medium Risk Areas
1. **Phase 3 (Lens Scope)**: Expanding scope enum
   - **Risk**: Existing code may assume only 2 scopes
   - **Mitigation**: Grep for `LensScope` usage, audit all switch/if-else on scope

2. **Phase 5 (UI Refactor)**: Unknown due to missing files
   - **Risk**: May not exist, may be in different location
   - **Mitigation**: Defer until UI is located

### Low Risk Areas
1. **Phase 1 (New Modules)**: No existing code modified
2. **Phase 9 (Semantics Registry)**: Additive only

---

## Suggested Sprint Breakdown

### Sprint 1: Foundation (Phases 0-2)
**Duration**: 3-5 days
**Goal**: Unified adapter execution

**Tasks**:
1. Phase 0.5: Add IR transform rejection validator (Option B) - 1 day
2. Phase 1: Create `src/editor/transforms/` modules - 2 days
3. Phase 2: Move adapter execution to registry - 2 days

**Deliverables**:
- ✅ IR mode explicitly rejects transforms (no silent failures)
- ✅ Transform facade exists and is tested
- ✅ Adapters execute from registry (switch statement removed)
- ✅ All existing tests pass

**Verification**:
- `just check` passes
- Manual test: Create patch with adapters in closure mode (works)
- Manual test: Same patch in IR mode (explicit error, not silent failure)

---

### Sprint 2: Lens Unification (Phases 3-4)
**Duration**: 4-6 days
**Goal**: Consistent lens scope enforcement and centralized application

**Tasks**:
1. Phase 3: Expand `LensScope`, update 27 lens defs - 2 days
2. Phase 3: Implement scope validation in `validate.ts` - 1 day
3. Phase 4: Centralize transform application - 2 days
4. Phase 4: Update all call sites with explicit scopes - 1 day

**Deliverables**:
- ✅ Wire lenses explicitly allowed (not special-cased)
- ✅ Scope validation rejects illegal lens usage
- ✅ One transform engine used everywhere
- ✅ All existing tests pass

**Verification**:
- `just check` passes
- Manual test: Apply phase lens to wire (allowed if semantics match)
- Compare: Same patch compiles identically before/after refactor

---

### Sprint 3: UI + IR Consistency (Phases 5-6)
**Duration**: 5-7 days
**Goal**: Registry-driven UI and IR mode alignment

**Tasks**:
1. **Phase 5** (if UI found): Refactor lens selector/editor - 3 days
2. **Phase 6 Option B**: Polish IR rejection messages - 1 day
3. **Phase 6 Option A** (if chosen): Implement minimal IR transform support - 3-5 days
   - OR skip to separate sprint if too complex

**Deliverables**:
- ✅ Lens UI shows registry metadata (if UI exists)
- ✅ IR mode behavior is explicit and consistent
- ✅ No "silent ignored lens" bugs

**Verification**:
- `just dev`: Add/remove lenses via UI, verify registry-driven
- IR mode: Verify explicit errors for unsupported transforms
- (If Option A) IR mode: Verify supported transforms compile correctly

---

### Sprint 4 (Optional): Semantic Registry + IR Transforms
**Duration**: 4-6 days
**Goal**: Phase-specific lens validation + full IR transform support

**Tasks**:
1. Phase 9: Build `ValueSemantics.ts` - 2 days
2. Phase 3 (revisit): Add semantic requirements to lens defs - 1 day
3. Phase 6 Option A: Full IR transform lowering - 3-4 days

**Deliverables**:
- ✅ Phase lenses only apply to phase artifacts (enforced)
- ✅ IR mode supports common transforms
- ✅ Clear errors for unsupported IR transforms

**Verification**:
- Manual test: Phase lens on non-phase signal (rejected)
- IR mode: Adapters + cheap lenses compile to IR nodes
- IR mode: Expensive/stateful transforms rejected with error

---

## Definition of Done (All Phases)

### Required (Acceptance Criteria)
- [ ] One canonical transform abstraction exists (`src/editor/transforms/*`)
- [ ] No adapter execution logic in compiler switch statements
- [ ] Lens scope enforced consistently (wires not special-cased)
- [ ] Lens lists and param schemas are registry-driven in UI
- [ ] IR compiler behavior is explicit and consistent (no silent ignoring)
- [ ] `just check` passes without errors
- [ ] All existing tests pass
- [ ] Manual verification in `just dev`:
  - [ ] Wire lens editing works and persists
  - [ ] Adapter suggestions consistent across wire/bus cells
  - [ ] IR mode rejects transforms with clear errors (Option B) OR compiles them correctly (Option A)

### Nice-to-Have (Future Work)
- [ ] Transform chain editor UI shared across Connection/Bus inspectors
- [ ] Numeric semantics registry for phase lens validation
- [ ] Full IR transform support (all adapters + lenses)
- [ ] Performance optimizations for transform stack evaluation

---

## Dependencies and Relationships

### Related Work
- **Unified Bindings** (`plans/PLAN-UNIFIED-BINDINGS.md`): Completed, provides storage layer foundation
  - No migration needed for this refactor

### Blocking Future Work
This refactor is a **prerequisite** for:
- Advanced lens UI (registry-driven param editors with live preview)
- IR compiler feature parity with closure compiler
- Performance optimizations (transform stack caching)
- Plugin system for custom adapters/lenses

### Not Blocking
Can proceed in parallel with:
- New block development (uses existing transform system)
- Runtime optimizations (field materialization, signal caching)
- Debug infrastructure improvements

---

## Verification Strategy

### Automated Testing
1. **Existing Test Suite**: Must pass after each phase
   - `just test` - 900+ tests currently passing
   - Focus on: bus compilation, lens application, adapter chains

2. **New Tests Required**:
   - Phase 1: Transform stack normalization (round-trip tests)
   - Phase 2: Adapter registry execution (all 18 adapters)
   - Phase 3: Lens scope validation (legal/illegal combinations)
   - Phase 4: Transform application equivalence (old vs new)
   - Phase 6: IR transform rejection (if Option B) or compilation (if Option A)

### Manual Verification (via `just dev`)
**Critical User Flows**:
1. Create wire with lens → verify transforms in inspector
4. Edit lens parameters → verify changes persist and compile correctly
5. Switch to IR mode → verify explicit errors (not silent failures)

**Regression Checks**:
- Load existing patches with transforms → must work identically
- Disabled transforms (enabled=false) → correctly skipped
- Lens param bindings (wire/bus sources) → resolve correctly

### Data Flow Tracing
For each critical path, trace data through complete lifecycle:

**Wire Connection Transform Flow**:
1. Input: Block output artifact
2. Adapter chain: Type conversion (e.g., Scalar → Signal)
3. Lens stack: Value transformation (e.g., scale, clamp)
4. Output: Block input receives transformed artifact
5. **Verify**: Intermediate values match expected (use debug logging)

1. Input: Block output artifact
2. Adapter chain: Type conversion
3. Lens stack: Pre-combine transformation

**Lens Param Binding Flow** (recursive!):
1. Input: Lens needs param value
2. Resolve binding (wire/bus/default)
3. Apply binding's own adapter chain
4. Apply binding's own lens stack (depth limited)
5. Output: Param artifact for lens execution
6. **Verify**: No cycles, depth limit enforced

---

## Open Questions for User

1. **Phase 5 (UI)**: Where are the lens UI components?
   - Not found in main branch `src/editor/components/` or `src/editor/modulation-table/`
   - Found in `.worktrees/` only
   - **Question**: Should we skip Phase 5 or are these files in a different location?

2. **Phase 6 (IR)**: Which option?
   - **Option A**: Implement minimal transform support in IR (3-5 days extra work, high risk)
   - **Option B**: Explicit rejection with clear errors (1 day, low risk, upgrade later)
   - **Recommendation**: Start with B, upgrade to A in Sprint 4
   - **Question**: Does IR mode need transform support immediately?

3. **Phase 3 (Wire Lens Scope)**: What should be allowed?
   - **Option C**: Wire = separate restricted set
   - **Recommendation**: Option A (existing wire lenses already work)
   - **Question**: Any reason to restrict wire lens capabilities?

4. **Phase 9 (Semantics Registry)**: When to build?
   - Required for phase lens validation (prevent "phase lens on float signal" bugs)
   - Not blocking other phases (can build in parallel)
   - **Question**: Include in Sprint 2 or defer to Sprint 4?

---

## Next Steps

**Immediate Actions** (ready to start):
1. Create `src/editor/transforms/` directory structure (Phase 1)
2. Implement transform facade types and normalize functions
3. Begin adapter execution migration (Phase 2)

**Decisions Needed Before Proceeding**:
1. Confirm IR compiler strategy (Option A vs B)
2. Locate lens UI components (or confirm they don't exist)
3. Approve sprint breakdown and timeline

**Recommended Starting Point**:
- **Phase 1** (create transforms/) - Low risk, high value, no blockers
- Parallel track: Implement Phase 0.5 (IR rejection validator) to prevent silent failures

