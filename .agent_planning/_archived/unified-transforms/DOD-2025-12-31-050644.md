# Definition of Done: IR Transform Implementation
**Generated**: 2025-12-31-050644
**Plan**: PLAN-2025-12-31-050644.md
**Scope**: 22 transforms across 3 sprints (6-8 days)

---

## Sprint 1: Quick Wins (8 transforms)

### Deliverable 1: ConstToSignal Domain Variants
- [ ] ConstToSignal:vec2 has `compileToIR` implementation
- [ ] ConstToSignal:color has `compileToIR` implementation
- [ ] ConstToSignal:boolean has `compileToIR` implementation
- [ ] All three compile scalar const to signal const correctly
- [ ] Unit tests verify IR node generation for each domain
- [ ] Integration test: Wire with vec2 ConstToSignal adapter compiles in IR mode
- [ ] `just check` passes

### Deliverable 2: Phase Identity Adapters
- [ ] PhaseToNumber:signal returns input unchanged
- [ ] PhaseToNumber:scalar returns input unchanged
- [ ] No new IR nodes generated (identity = passthrough)
- [ ] Unit tests verify identity behavior
- [ ] Integration test: Wire with PhaseToNumber adapter compiles in IR mode
- [ ] `just check` passes

### Deliverable 3: Simple Math Lenses
- [ ] polarity lens has `compileToIR` implementation
- [ ] vec2GainBias lens has `compileToIR` implementation
- [ ] translate2d lens has `compileToIR` implementation
- [ ] polarity uses OpCode.Neg or OpCode.Abs correctly
- [ ] vec2GainBias applies gain and bias with vec2 domain
- [ ] translate2d applies offset with vec2 domain
- [ ] Unit tests verify OpCode selection and IR node generation
- [ ] Integration test: Wire with polarity lens compiles in IR mode
- [ ] Integration test: Wire with vec2GainBias lens compiles in IR mode
- [ ] `just check` passes

### Sprint 1 Scope
**This sprint delivers**: Multi-domain support (vec2, color, boolean) + basic math operations
**Coverage target**: 11/41 (27%)
**Deferred**: Phase transforms, advanced math, color transforms

---

## Sprint 2: Phase Transforms (6 transforms)

### Deliverable 4: Phase Domain Adapters
- [ ] NormalizeToPhase:signal has `compileToIR` implementation
- [ ] NormalizeToPhase:scalar has `compileToIR` implementation
- [ ] Signal variant uses OpCode.Mod with 1.0
- [ ] Scalar variant performs compile-time modulo
- [ ] Unit tests verify phase normalization (2.3 → 0.3, -0.5 → 0.5)
- [ ] Integration test: Wire with NormalizeToPhase adapter compiles in IR mode
- [ ] `just check` passes

### Deliverable 5: Phase Manipulation Lenses
- [ ] phaseOffset lens has `compileToIR` implementation
- [ ] phaseScale lens has `compileToIR` implementation
- [ ] quantize lens has `compileToIR` implementation
- [ ] pingPong lens has `compileToIR` implementation
- [ ] phaseOffset wraps to [0, 1) range correctly
- [ ] phaseScale maintains phase domain after multiplication
- [ ] quantize produces step-quantized output
- [ ] pingPong produces triangle wave (0→1→0 over [0, 1) input)
- [ ] Unit tests verify each lens with known input/output pairs
- [ ] Integration test: Phase lenses work in IR mode
- [ ] `just check` passes

### Sprint 2 Scope
**This sprint delivers**: Phase manipulation critical for animation timing
**Coverage target**: 17/41 (41%)
**Deferred**: Advanced math, color transforms

---

## Sprint 3: Common Math Transforms (8 transforms)

### Deliverable 6: Duration Adapters
- [ ] NumberToDurationMs has `compileToIR` implementation
- [ ] DurationToNumberMs has `compileToIR` implementation
- [ ] NumberToDurationMs multiplies by 1000 correctly
- [ ] DurationToNumberMs divides by 1000 correctly
- [ ] Unit tests verify conversion (1.5s → 1500ms, 3000ms → 3s)
- [ ] Integration test: Duration adapters work in IR mode
- [ ] `just check` passes

### Deliverable 7: Advanced Math Lenses
- [ ] deadzone lens has `compileToIR` implementation
- [ ] mapRange lens has `compileToIR` implementation
- [ ] softclip lens has `compileToIR` implementation
- [ ] wrapMode lens has `compileToIR` implementation
- [ ] deadzone zeroes values below threshold
- [ ] mapRange remaps [inMin, inMax] → [outMin, outMax] correctly
- [ ] mapRange clamp mode works (optional)
- [ ] softclip smoothly saturates values
- [ ] wrapMode wrap/clamp/mirror modes work correctly
- [ ] Unit tests verify each lens with known input/output pairs
- [ ] Integration test: Math lenses work in IR mode
- [ ] `just check` passes

### Deliverable 8: Color Lenses
- [ ] colorGain lens has `compileToIR` implementation
- [ ] contrast lens has `compileToIR` implementation
- [ ] colorGain multiplies RGB components correctly
- [ ] contrast scales around 0.5 midpoint (gray)
- [ ] Unit tests verify color transformations
- [ ] Integration test: Color lenses work in IR mode
- [ ] `just check` passes

### Sprint 3 Scope
**This sprint delivers**: High-value math operations (mapRange) + basic color support
**Coverage target**: 25/41 (61%)
**Deferred**: Tier 3 moderate complexity (10 transforms), Tier 4 complex (9 transforms)

---

## Overall Definition of Done (All Sprints Complete)

### Architecture (Required)
- [ ] 22 new transforms have `compileToIR` implementations
- [ ] All implementations follow established pattern (validate → extract → build → register → return)
- [ ] No infrastructure changes needed (uses existing IR primitives)
- [ ] All transforms compile scalar const params to IR nodes
- [ ] All transforms handle signal inputs correctly

### Coverage (Required)
- [ ] Coverage increases from 3/41 (7%) to 25/41 (61%)
- [ ] All ConstToSignal domain variants implemented (float, vec2, color, boolean)
- [ ] All phase manipulation transforms implemented (offset, scale, normalize, quantize, pingPong)
- [ ] High-value math transforms implemented (mapRange, quantize, deadzone, softclip, wrapMode)
- [ ] Basic color transforms implemented (colorGain, contrast)

### Testing (Required)
- [ ] All new transforms have unit tests
- [ ] All new transforms have integration tests
- [ ] All new transforms have equivalence tests (closure vs IR mode)
- [ ] All existing tests pass (no regressions)
- [ ] `just check` passes
- [ ] TypeScript compilation passes with no errors
- [ ] Linter passes with no new warnings

### Manual Verification Flows (Required)

**Multi-domain support**:
- [ ] Create wire with ConstToSignal:vec2 adapter in IR mode → compiles successfully
- [ ] Create wire with ConstToSignal:color adapter in IR mode → compiles successfully
- [ ] Create wire with ConstToSignal:boolean adapter in IR mode → compiles successfully
- [ ] Verify output matches closure mode for each domain

**Phase transforms**:
- [ ] Create animation patch with phaseOffset lens in IR mode → phase shifts correctly
- [ ] Create animation patch with phaseScale lens in IR mode → speed changes correctly
- [ ] Create animation patch with pingPong lens in IR mode → produces triangle wave
- [ ] Create wire with NormalizeToPhase adapter in IR mode → wraps to [0, 1) range
- [ ] Verify all phase transforms match closure mode output

**Math transforms**:
- [ ] Create wire with mapRange lens in IR mode → remaps range correctly
- [ ] Create wire with quantize lens in IR mode → produces step-quantized output
- [ ] Create wire with deadzone lens in IR mode → zeroes values below threshold
- [ ] Create wire with softclip lens in IR mode → smoothly saturates
- [ ] Create wire with wrapMode lens in IR mode → wrap/clamp/mirror modes work
- [ ] Verify all math transforms match closure mode output

**Color transforms**:
- [ ] Create wire with colorGain lens in IR mode → multiplies RGB correctly
- [ ] Create wire with contrast lens in IR mode → adjusts contrast around midpoint
- [ ] Verify color transforms match closure mode output

**Error handling**:
- [ ] Unsupported transforms (slew, hysteresis, smoothPath) still produce clear errors
- [ ] Error messages remain actionable and helpful
- [ ] No silent failures or degraded behavior

### Regression Prevention (Required)
- [ ] Load existing patches with supported transforms → work identically before/after
- [ ] Load existing patches with unsupported transforms → error messages unchanged
- [ ] Disabled transforms (enabled=false) → correctly skipped
- [ ] Empty transform stacks → no runtime errors
- [ ] Patches without transforms → unaffected by changes

### Documentation (Required)
- [ ] Update STATUS file with new coverage numbers (3/41 → 25/41)
- [ ] Document any OpCode approximations used (e.g., tanh approximation for softclip)
- [ ] List remaining unsupported transforms with complexity tiers
- [ ] Update AUDIT file if needed to reflect completion

---

## Per-Transform Acceptance Criteria Checklist

Use this checklist when implementing each transform:

### ConstToSignal:vec2
- [ ] `compileToIR` implementation added to AdapterRegistry
- [ ] Uses `sigConst()` with domain 'vec2'
- [ ] Validates input is scalarConst
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: scalar const → signal const
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### ConstToSignal:color
- [ ] `compileToIR` implementation added to AdapterRegistry
- [ ] Uses `sigConst()` with domain 'color'
- [ ] Validates input is scalarConst
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: scalar const → signal const
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### ConstToSignal:boolean
- [ ] `compileToIR` implementation added to AdapterRegistry
- [ ] Uses `sigConst()` with domain 'boolean'
- [ ] Validates input is scalarConst
- [ ] Optionally coerces value to 0/1
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: scalar const → signal const
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### PhaseToNumber:signal
- [ ] `compileToIR` implementation added to AdapterRegistry
- [ ] Returns input unchanged (identity transform)
- [ ] Validates input is sig
- [ ] No IR nodes generated
- [ ] Unit test: signal input → signal output unchanged
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### PhaseToNumber:scalar
- [ ] `compileToIR` implementation added to AdapterRegistry
- [ ] Returns input unchanged (identity transform)
- [ ] Validates input is scalarConst
- [ ] No IR nodes generated
- [ ] Unit test: scalar input → scalar output unchanged
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### polarity
- [ ] `compileToIR` implementation added to LensRegistry
- [ ] Uses OpCode.Neg or OpCode.Abs based on mode param
- [ ] Validates input is sig
- [ ] Validates mode param is scalarConst
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: bipolar mode (negate) works
- [ ] Unit test: unipolar mode (abs) works
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### vec2GainBias
- [ ] `compileToIR` implementation added to LensRegistry
- [ ] Applies gain (multiply) and bias (add) with vec2 domain
- [ ] Validates input is sig
- [ ] Validates gain and bias params are scalarConst
- [ ] Optimizes: skips gain if 1, skips bias if 0
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: gain and bias applied correctly
- [ ] Unit test: optimization works (identity values skipped)
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### translate2d
- [ ] `compileToIR` implementation added to LensRegistry
- [ ] Applies offset (add) with vec2 domain
- [ ] Validates input is sig
- [ ] Validates offset param is scalarConst
- [ ] Optimizes: skips if offset is 0
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: offset applied correctly
- [ ] Unit test: optimization works (zero offset skipped)
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### NormalizeToPhase:signal
- [ ] `compileToIR` implementation added to AdapterRegistry
- [ ] Uses OpCode.Mod with 1.0
- [ ] Validates input is sig
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: wraps to [0, 1) range (2.3 → 0.3)
- [ ] Unit test: handles negatives correctly (-0.5 → 0.5)
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### NormalizeToPhase:scalar
- [ ] `compileToIR` implementation added to AdapterRegistry
- [ ] Performs compile-time modulo 1.0
- [ ] Validates input is scalarConst
- [ ] Creates new const with normalized value
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: wraps to [0, 1) range at compile-time
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### phaseOffset
- [ ] `compileToIR` implementation added to LensRegistry
- [ ] Uses (input + offset) % 1.0 pattern
- [ ] Validates input is sig
- [ ] Validates offset param is scalarConst
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: adds offset and wraps correctly
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### phaseScale
- [ ] `compileToIR` implementation added to LensRegistry
- [ ] Uses (input * scale) % 1.0 pattern
- [ ] Validates input is sig
- [ ] Validates scale param is scalarConst
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: multiplies and wraps correctly
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### quantize
- [ ] `compileToIR` implementation added to LensRegistry
- [ ] Uses floor(input * steps) / steps pattern
- [ ] Validates input is sig
- [ ] Validates steps param is scalarConst
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: produces step-quantized output
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### pingPong
- [ ] `compileToIR` implementation added to LensRegistry
- [ ] Uses 1 - abs(2 * (x % 1.0) - 1) pattern
- [ ] Validates input is sig
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: produces triangle wave (0→1→0)
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### NumberToDurationMs
- [ ] `compileToIR` implementation added to AdapterRegistry
- [ ] Multiplies by 1000 (seconds → milliseconds)
- [ ] Validates input is sig
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: converts correctly (1.5s → 1500ms)
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### DurationToNumberMs
- [ ] `compileToIR` implementation added to AdapterRegistry
- [ ] Divides by 1000 (milliseconds → seconds)
- [ ] Validates input is sig
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: converts correctly (3000ms → 3s)
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### deadzone
- [ ] `compileToIR` implementation added to LensRegistry
- [ ] Uses abs(x) < threshold → 0 pattern (step function)
- [ ] Validates input is sig
- [ ] Validates threshold param is scalarConst
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: zeroes values below threshold
- [ ] Unit test: passes values above threshold
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### mapRange
- [ ] `compileToIR` implementation added to LensRegistry
- [ ] Uses ((x - inMin) / (inMax - inMin)) * (outMax - outMin) + outMin pattern
- [ ] Validates input is sig
- [ ] Validates all params (inMin, inMax, outMin, outMax, clamp) are scalarConst
- [ ] Implements optional clamp mode
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: remaps range correctly
- [ ] Unit test: clamp mode works
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### softclip
- [ ] `compileToIR` implementation added to LensRegistry
- [ ] Uses tanh(x / threshold) * threshold pattern (or approximation)
- [ ] Validates input is sig
- [ ] Validates threshold param is scalarConst
- [ ] Uses OpCode.Tanh if available, else approximation x / (1 + abs(x))
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: smoothly saturates values
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### wrapMode
- [ ] `compileToIR` implementation added to LensRegistry
- [ ] Supports wrap (mod), clamp (min/max), mirror (pingPong) modes
- [ ] Validates input is sig
- [ ] Validates mode param is scalarConst
- [ ] Implements compile-time branch based on mode value
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: wrap mode works (x % 1.0)
- [ ] Unit test: clamp mode works (clamp 0-1)
- [ ] Unit test: mirror mode works (triangle wave)
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### colorGain
- [ ] `compileToIR` implementation added to LensRegistry
- [ ] Multiplies RGB components by gain (component-wise)
- [ ] Validates input is sig
- [ ] Validates gain param is scalarConst
- [ ] Uses color domain
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: multiplies RGB correctly
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

### contrast
- [ ] `compileToIR` implementation added to LensRegistry
- [ ] Uses (x - 0.5) * contrast + 0.5 pattern
- [ ] Validates input is sig
- [ ] Validates contrast param is scalarConst
- [ ] Uses color domain
- [ ] Allocates slot and registers signal
- [ ] Returns packed ValueRef `{ k: 'sig', id, slot }`
- [ ] Unit test: adjusts contrast around 0.5 midpoint
- [ ] Unit test: invalid input → null return
- [ ] Integration test: wire compilation in IR mode

---

## Final Verification Command Sequence

Run these commands in order before marking complete:

```bash
# 1. Type check
just typecheck

# 2. Lint
just lint-fix

# 3. Test suite
just test

# 4. Full check
just check

# 5. Dev server (manual testing)
just dev
# → Perform all manual verification flows documented above

# 6. Build production
just build
```

**All must pass with no errors.**

---

## Metrics for Success

**Coverage**:
- Starting: 3/41 (7%)
- Target: 25/41 (61%)
- Increase: +22 transforms (+54 percentage points)

**Implementation**:
- Adapters: 1 → 9 (8 new implementations)
- Lenses: 2 → 16 (14 new implementations)

**Code Quality**:
- All implementations follow established pattern
- No infrastructure changes needed
- Zero technical debt added

**Consistency**:
- All transforms produce identical output in closure vs IR mode
- All transforms handle invalid inputs gracefully (return null)
- All transforms have complete test coverage
