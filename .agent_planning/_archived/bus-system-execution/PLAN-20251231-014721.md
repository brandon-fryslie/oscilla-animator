# Sprint Plan: Bus System Execution
**Generated**: 2025-12-31-014721
**Source**: STATUS-20251231.md
**Topic**: bus-system-execution

---

## Executive Summary

**Current State**: 20% complete - Critical infrastructure gaps prevent bus execution in IR mode

**Critical Issues**:
- Gap 1: busRoots NOT threaded through BuilderProgramIR (data loss between passes)
- Gap 2: IRBuilder has no busRoots storage API

**What Works**:
- Pass7 creates busRoots with combine nodes
- Pass8 threads busRoots through LinkedGraphIR
- Runtime executors implemented (executeBusEval, executeEventBusEval)
- Tests pass (2646/2667) but don't exercise IR bus execution

**What's Broken**:
- busRoots lost after Pass8 - NOT included in BuilderProgramIR
- buildSchedule cannot emit StepBusEval without busRoots
- Non-numeric buses (vec2/vec3/color) would crash at runtime
- Field buses have IR support but no schedule emission

**Sprint Goal**: Fix critical infrastructure gaps to enable basic bus execution in IR mode

---

## Sprint Scope (2-3 Deliverables)

### P0 - Bus Roots Threading (CRITICAL)
Fix the data flow gap that prevents bus execution. Add busRoots to IRBuilder and BuilderProgramIR, emit StepBusEval in schedule.

### P1 - Non-numeric Bus Safety
Emit compile-time errors for unsupported non-numeric bus configurations. Better to fail loudly than silently produce wrong results.

### P2 - End-to-end Bus Execution Tests
Add integration tests that verify bus evaluation works in IR mode.

### Deferred to Future Sprints
- Non-numeric bus combine implementation (vec2/vec3/color) - needs spec clarification
- Field buses execution step - complex, depends on P0
- Event bus schedule emission - depends on P0

---

## Backlog by Priority

---

## P0 (Critical) - Bus Roots Threading

### Status: Not Started
### Effort: Medium (4-6 hours)
### Dependencies: None
### Spec Reference: design-docs/implementation/compiler/07-Buses.md (BusTable, BusIR)
### Status Reference: STATUS-20251231.md § Critical Gaps 1 & 2

### Description
The busRoots data structure created in Pass7 is lost between Pass8 and buildSchedule. Pass7 creates `busRoots: Map<BusIndex, ValueRefPacked>`, Pass8 threads it through LinkedGraphIR, but IRBuilderImpl.build() does NOT include busRoots in BuilderProgramIR output. This means buildSchedule has no bus information and cannot emit StepBusEval steps. Without this fix, buses DO NOT evaluate in IR mode.

**Root Cause Analysis** (from STATUS):
1. Pass7 creates busRoots Map
2. Pass8 threads busRoots through LinkedGraphIR
3. **BUG**: IRBuilderImpl.build() does NOT include busRoots in BuilderProgramIR (lines 764-799)
4. buildCompiledProgram() receives BuilderProgramIR WITHOUT bus information
5. Schedule builder has NO bus roots to emit StepBusEval

### Acceptance Criteria (REQUIRED)
- [ ] BuilderProgramIR interface has `busRoots: readonly [BusIndex, ValueRefPacked][]` field
- [ ] IRBuilderImpl has `registerBusRoot(busIndex: BusIndex, ref: ValueRefPacked)` method
- [ ] Pass7 calls `builder.registerBusRoot()` for each bus combine node created
- [ ] IRBuilderImpl.build() includes `busRoots: Array.from(this.busRoots.entries())` in output
- [ ] buildSchedule emits StepBusEval for each busRoot BEFORE signal evaluation steps

### Technical Notes
**Files to Modify**:
1. `src/editor/compiler/ir/builderTypes.ts` - Add busRoots to BuilderProgramIR interface
2. `src/editor/compiler/ir/IRBuilderImpl.ts` - Add busRoots field and registerBusRoot() method
3. `src/editor/compiler/passes/pass7-bus-lowering.ts` - Call builder.registerBusRoot() around line 134
4. `src/editor/compiler/ir/buildSchedule.ts` - Emit StepBusEval for each busRoot

**Implementation Pattern**:
```typescript
// In IRBuilderImpl
class IRBuilderImpl {
  private busRoots: Map<BusIndex, ValueRefPacked> = new Map();

  registerBusRoot(busIndex: BusIndex, ref: ValueRefPacked): void {
    this.busRoots.set(busIndex, ref);
  }

  build(): BuilderProgramIR {
    return {
      // ... existing fields
      busRoots: Array.from(this.busRoots.entries()),
    };
  }
}
```

**Schedule Emission**:
- Emit StepBusEval BEFORE signal evaluation steps (buses must evaluate first)
- Each busRoot gets ONE StepBusEval step
- StepBusEval type already defined in schedule.ts:268-288
- executeBusEval runtime already implemented (executeBusEval.ts:42-179)

---

## P1 (High) - Non-numeric Bus Safety

### Status: Not Started
### Effort: Small (2-3 hours)
### Dependencies: None (can work in parallel with P0)
### Spec Reference: design-docs/implementation/compiler/07-Buses.md § 7.1 CombineSpec
### Status Reference: STATUS-20251231.md § Implementation Red Flags

### Description
Currently, executeBusEval only handles numeric combine operations (sum, average, min, max, last, product). If a bus has type vec2/vec3/color, the runtime would crash with uncaught TypeError. There is no compile-time validation to prevent creating non-numeric buses. This is a safety gap - better to emit a clear compile error than produce silent failures or runtime crashes.

**Current State**:
- executeBusEval.ts:147-179 only handles `number` values
- No TypeDesc domain check before calling combineValues
- No compile-time validation in busContracts or semantic layer

**Decision** (from STATUS Question 2): Use Option C - emit compile error for non-numeric buses for now, then implement proper semantics once spec is complete.

### Acceptance Criteria (REQUIRED)
- [ ] Add compile-time validation in busContracts or semantic layer that checks bus TypeDesc.domain
- [ ] Emit clear error message: "Non-numeric buses (vec2/vec3/color) not yet supported in IR mode. Bus '{busId}' has type '{domain}'"
- [ ] Error references the relevant bus and type in the message
- [ ] Test that creates vec2 bus and verifies compile error is emitted
- [ ] Test that creates color bus and verifies compile error is emitted

### Technical Notes
**Files to Modify**:
1. `src/editor/semantic/busContracts.ts` - Add validation in bus contract checking
   OR
2. `src/editor/compiler/passes/pass7-bus-lowering.ts` - Add type check before creating combine node

**Validation Logic**:
```typescript
function validateBusType(bus: BusIR, ctx: CompileContext): void {
  const { domain } = bus.type;
  if (domain !== "number") {
    ctx.addError({
      code: "UNSUPPORTED_BUS_TYPE",
      message: `Non-numeric buses (vec2/vec3/color) not yet supported in IR mode. Bus '${bus.id}' has type '${domain}'`,
      location: bus.meta?.location,
    });
  }
}
```

**Where to Add**:
- Best location: `busContracts.ts` in contract checking phase (compile-time)
- Alternative: Pass7 before creating combine node (also compile-time)
- DO NOT add runtime check in executeBusEval (too late, less clear errors)

---

## P2 (Medium) - End-to-end Bus Execution Tests

### Status: Not Started
### Effort: Medium (3-4 hours)
### Dependencies: P0 (Bus Roots Threading) must be complete
### Spec Reference: design-docs/implementation/compiler/07-Buses.md § 7.1 BusTable
### Status Reference: STATUS-20251231.md § Test Suite Assessment - Coverage Gaps

### Description
Current tests exercise legacy closure-based bus compilation, NOT IR bus execution. Tests pass but would NOT catch the busRoots threading bug (Gap 1) because IR is not enabled in test environment. Need integration tests that:
2. Compile to IR (not closure)
3. Verify StepBusEval appears in schedule

**Test Blind Spot** (from STATUS):
- Tests use legacy compilation (IR not enabled)
- Would NOT catch busRoots threading bug
- No verification that StepBusEval is emitted

### Acceptance Criteria (REQUIRED)
- [ ] Test compiles patch to IR mode (not closure)
- [ ] Test verifies schedule.steps includes StepBusEval for the bus
- [ ] Test runs schedule and verifies bus value in ValueStore matches published value

### Technical Notes
**Files to Create/Modify**:
1. Create `src/editor/compiler/__tests__/ir-bus-execution.test.ts`

**Test Structure**:
```typescript
describe("IR Bus Execution", () => {
  it("should emit StepBusEval and evaluate bus in IR mode", () => {
    const patch = createTestPatch({
      blocks: [
        { type: "Constant", outputs: { value: 42 } },
        { type: "BusPublish", busId: "testBus", sortKey: 0 },
        { type: "BusListen", busId: "testBus" },
      ],
    });

    // 2. Compile to IR
    const compiled = compilePatchToIR(patch);

    // 3. Verify StepBusEval in schedule
    const busEvalSteps = compiled.schedule.steps.filter(
      (s) => s.kind === "busEval"
    );
    expect(busEvalSteps).toHaveLength(1);

    // 4. Run schedule and verify bus value
    const runtime = new ScheduleExecutor(compiled);
    runtime.step(0);
    const busValue = runtime.valueStore.read(busSlot);
    expect(busValue).toBe(42);

    runtime.step(0.1);
    expect(runtime.valueStore.read(busSlot)).toBe(99);
  });
});
```

**Coverage Target**:
- Numeric bus with "last" combine mode (simplest case)
- Verify schedule emission (compile-time correctness)
- Verify runtime evaluation (execution correctness)

---

## Dependency Graph

```
P0: Bus Roots Threading (no dependencies)
  └─> P2: End-to-end Bus Execution Tests (depends on P0)

P1: Non-numeric Bus Safety (no dependencies, can run in parallel with P0)
```

**Critical Path**: P0 → P2 (7-10 hours total)
**Parallel Track**: P1 (2-3 hours, can overlap with P0)

---

## Recommended Sprint Execution Order

### Day 1 (Morning): P0 - Bus Roots Threading
1. Add busRoots to BuilderProgramIR interface (15 min)
2. Add registerBusRoot() to IRBuilderImpl (30 min)
3. Call registerBusRoot() in Pass7 (15 min)
4. Include busRoots in build() output (15 min)
5. Emit StepBusEval in buildSchedule (1 hour)
6. Manual smoke test with dev server (30 min)

### Day 1 (Afternoon): P1 - Non-numeric Bus Safety
1. Add validation in busContracts (45 min)
2. Write error message and location tracking (30 min)
3. Add tests for vec2/color bus errors (1 hour)

### Day 2: P2 - End-to-end Bus Execution Tests
1. Create test file and basic test structure (30 min)
2. Implement schedule emission verification (1 hour)
3. Implement runtime evaluation verification (1 hour)
4. Implement reactive update verification (1 hour)
5. Run full test suite and fix any issues (30 min)

**Total Effort**: 9-13 hours (1.5-2 days)

---

## Risk Assessment

### High Risk Items

**Risk 1: StepBusEval Emission Ordering**
- **Severity**: High
- **Likelihood**: Medium
- **Impact**: Bus values stale if emitted after signal eval
- **Mitigation**: Emit StepBusEval BEFORE signal steps, verify with test

**Risk 2: busRoots Format Mismatch**
- **Severity**: Medium
- **Likelihood**: Low
- **Impact**: Runtime crash if Map vs Array format wrong
- **Mitigation**: Use `Array.from(map.entries())` pattern consistently

### Medium Risk Items

**Risk 3: Missing Error Context**
- **Severity**: Medium
- **Likelihood**: Medium
- **Impact**: Unclear compile errors for non-numeric buses
- **Mitigation**: Include bus ID and type domain in error message

**Risk 4: Test Environment IR Mode**
- **Severity**: Low
- **Likelihood**: Low
- **Impact**: Tests pass but don't actually test IR path
- **Mitigation**: Explicitly enable IR mode in test, verify schedule format

---

## Out of Scope (Future Sprints)

### Deferred Work

**Non-numeric Bus Combine Implementation**
- **Effort**: 6-8 hours
- **Why Deferred**: Spec incomplete for color "layer" semantics
- **Prerequisites**: Spec clarification for vec2/vec3/color combine modes
- **Future Sprint**: Sprint 20 (after spec update)

**Field Buses Execution Step**
- **Effort**: 6-8 hours
- **Why Deferred**: Complex, requires field materialization ordering
- **Prerequisites**: P0 complete, field execution model clarified
- **Future Sprint**: Sprint 21

**Event Bus Schedule Emission**
- **Effort**: 2-3 hours
- **Why Deferred**: Depends on P0 infrastructure
- **Prerequisites**: P0 complete
- **Future Sprint**: Sprint 20 (can be bundled with non-numeric combine)

---

## Validation Checklist

Before marking sprint complete:
- [ ] All P0 acceptance criteria met
- [ ] All P1 acceptance criteria met
- [ ] All P2 acceptance criteria met
- [ ] `just check` passes (all tests, typecheck, lint)
- [ ] Manual test: Create patch with bus in dev server, verify bus value updates
- [ ] Schedule inspection: Verify StepBusEval appears before StepSignalEval
- [ ] Runtime test: Verify executeBusEval is actually called during execution
- [ ] Error test: Verify vec2/color bus emits clear compile error

---

## Files Modified Summary

### P0 (Bus Roots Threading)
- `src/editor/compiler/ir/builderTypes.ts` - Add busRoots field
- `src/editor/compiler/ir/IRBuilderImpl.ts` - Add registerBusRoot() and storage
- `src/editor/compiler/passes/pass7-bus-lowering.ts` - Call registerBusRoot()
- `src/editor/compiler/ir/buildSchedule.ts` - Emit StepBusEval

### P1 (Non-numeric Bus Safety)
- `src/editor/semantic/busContracts.ts` - Add type validation
- `src/editor/semantic/__tests__/busContracts.test.ts` - Add validation tests

### P2 (End-to-end Tests)
- `src/editor/compiler/__tests__/ir-bus-execution.test.ts` - New integration test file

**Total Files**: 7 (4 modified, 1 new test file, 2 existing test files)

---

## Success Criteria

Sprint is successful if:
1. Buses evaluate correctly in IR mode (P0)
2. Non-numeric buses emit clear compile errors (P1)
3. Integration tests verify bus execution works (P2)
4. All existing tests still pass
5. No regressions in legacy closure mode

Sprint is FAILED if:
- Buses still don't evaluate in IR mode after P0
- Non-numeric buses crash runtime instead of emitting compile errors
- Tests pass but manual testing reveals bugs
