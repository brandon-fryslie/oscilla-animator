# Sprint Plan: Time + Event Semantics Completion

**Generated:** 2025-12-31-013758
**Source:** STATUS-2025-12-31-013400.md
**Branch:** ir-backlog-02-time-event
**Topic:** Time + Event Semantics (Workstream 2)

---

## Executive Summary

**Current State:** 60% complete - TimeRoot extraction and wrap detection logic exist, but EventStore and scrub mode are missing.

**Total Gap:** 3 deliverables remain to complete this workstream:
1. Fix test compilation errors (BLOCKER)
2. Implement EventStore for discrete event semantics
3. Add scrub mode to suppress phantom wrap events

**Recommended Focus:** Fix tests first (5 min), then implement EventStore (2-3 hours), then add scrub mode (1-2 hours). Total estimated effort: 4-7 hours.

**Critical Success Factors:**
- Tests must pass before claiming any deliverable complete
- EventStore must provide discrete trigger semantics (not numeric storage)
- Scrub mode must suppress wrap events during non-monotonic time changes

---

## Sprint Deliverables

### Sprint Scope
This sprint delivers:
1. Working test suite (compilation errors fixed)
2. EventStore with discrete trigger semantics
3. Scrub mode in ScheduleExecutor

Deferred to future sprints:
- InfiniteTimeRoot naming clarification (needs user decision)
- End-to-end wrap consumption tests (can be added incrementally)
- Unified compiler alignment (architectural decision needed)

---

## P0: Fix Test Compilation Errors (CRITICAL - BLOCKER)

**Status:** Not Started
**Effort:** Small (5-10 minutes)
**Dependencies:** None
**Spec Reference:** N/A • **Status Reference:** STATUS-2025-12-31-013400.md:40-52

### Description

6 test files in `state-offset-resolution.test.ts` have TypeScript compilation errors. All mock `BuilderProgramIR` objects are missing the required `debugProbes` property.

**Evidence from STATUS:**
- Lines 84, 143, 206, 249, 307, 371 all fail with same error
- Error: `Type '{ ... }' is missing the following properties from type 'BuilderProgramIR': debugProbes`
- Impact: Cannot run `just test`, blocking validation of all time behavior

This **MUST** be completed first - no other work can be validated without passing tests.

### Acceptance Criteria
- [ ] All 6 TypeScript errors in `state-offset-resolution.test.ts` are resolved
- [ ] `just test` runs without compilation errors
- [ ] All existing tests pass (no new test failures introduced)
- [ ] Test mock objects include `debugProbes: []` property
- [ ] Verified with `just check` (full typecheck + lint + test)

### Technical Notes

**Fix Strategy:**
Add `debugProbes: []` to all mock `BuilderProgramIR` objects at the specified line numbers.

**Files to Modify:**
- `src/editor/compiler/ir/__tests__/state-offset-resolution.test.ts` (6 locations)

**Verification:**
```bash
just typecheck  # Must pass
just test       # Must run and pass
just check      # Full verification
```

**Risk:** None - mechanical fix with clear TypeScript error messages.

---

## P1: Implement EventStore for Discrete Event Semantics (HIGH)

**Status:** Not Started
**Effort:** Medium (2-3 hours)
**Dependencies:** P0 (test compilation must be fixed first)
**Spec Reference:** SPEC-05-time-architecture.md:278-312 • **Status Reference:** STATUS-2025-12-31-013400.md:107-166

### Description

Currently, `wrapEvent` is stored in `ValueStore` as a numeric value (0.0 or 1.0), making it indistinguishable from continuous signals. This violates the design principle that events are discrete triggers, not continuous values.

**Evidence from STATUS:**
- No `EventStore` class exists (search returned 0 results)
- wrapEvent written to ValueStore at `executeTimeDerive.ts:65-69`
- Plan specifies: `{ triggered: boolean, payload?: {...} }` semantics
- Missing per-frame reset mechanism
- No edge detection at storage level

**Why This Matters:**
- Edge detection happens at wrong level (consumers must detect 0→1 transition)
- Cannot distinguish "event fired this frame" from "value is currently 1.0"
- No support for event payloads (phase, count, deltaMs)
- Events persist across frames instead of being one-shot triggers

### Acceptance Criteria
- [ ] `EventStore` class created with `trigger()`, `check()`, and `reset()` methods
- [ ] EventStore added to `RuntimeState` (alongside `values`, `state`)
- [ ] `executeTimeDerive.ts` writes wrapEvent to EventStore instead of ValueStore
- [ ] EventStore.reset() called at start of each frame in ScheduleExecutor
- [ ] wrapEvent payload includes: `{ phase: number, count: number, deltaMs: number }`
- [ ] Unit tests verify: trigger→check returns true, check after reset returns false
- [ ] Integration test: wrap event fires once per cycle, not continuously

### Technical Notes

**Implementation Location:**
Create new file: `src/editor/runtime/executor/EventStore.ts`

**Interface Design (from SPEC-05:278-312):**
```typescript
interface EventSlotValue {
  triggered: boolean;
  payload?: {
    phase: number;    // Phase at wrap (0.0-1.0)
    count: number;    // Total wrap count since start
    deltaMs: number;  // Frame delta when wrap occurred
  };
}

class EventStore {
  private events = new Map<number, EventSlotValue>();

  trigger(slot: number, payload?: EventSlotValue["payload"]): void {
    this.events.set(slot, { triggered: true, payload });
  }

  check(slot: number): boolean {
    return this.events.get(slot)?.triggered ?? false;
  }

  getPayload(slot: number): EventSlotValue["payload"] | undefined {
    return this.events.get(slot)?.payload;
  }

  reset(): void {
    this.events.clear();
  }
}
```

**Integration Points:**

1. **RuntimeState.ts** (line ~63-64):
   - Add `events: EventStore` field
   - Initialize in `createRuntimeState()` (line ~613)
   - Preserve during hot-swap (line ~655)

2. **executeTimeDerive.ts** (line 65-69):
   ```typescript
   // BEFORE (numeric storage):
   runtime.values.write(step.out.wrapEvent, time.wrapEvent);

   // AFTER (event storage):
   if (time.wrapEvent) {
     runtime.events.trigger(step.out.wrapEvent, {
       phase: time.phase01,
       count: timeState.wrapCount,
       deltaMs: timeState.lastDeltaMs
     });
   }
   ```

3. **ScheduleExecutor.ts** (line ~97-101):
   - Call `runtime.events.reset()` at start of `executeFrame()`
   - Before processing any schedule steps

**Testing Strategy:**

1. **Unit test (EventStore.test.ts):**
   - Trigger event, check returns true
   - Check unset event returns false
   - Reset clears all events
   - Payload is preserved

2. **Integration test (timeResolution.test.ts):**
   - Create cyclic TimeModel (periodMs: 1000)
   - Frame 1: t=900ms → no wrap
   - Frame 2: t=1100ms → wrap fires once
   - Frame 3: t=1200ms → no wrap (reset worked)

**Risks:**
- Backward compatibility: Existing code may expect numeric wrapEvent
  - **Mitigation:** Search for wrapEvent consumers, update to use EventStore.check()
- State synchronization: EventStore must be cleared at right time
  - **Mitigation:** Call reset() at frame start, before any step execution

---

## P2: Add Scrub Mode to Suppress Phantom Wrap Events (MEDIUM)

**Status:** Not Started
**Effort:** Medium (1-2 hours)
**Dependencies:** P0 (tests), P1 (EventStore implementation)
**Spec Reference:** SPEC-05-time-architecture.md:330-380 • **Status Reference:** STATUS-2025-12-31-013400.md:170-246

### Description

When scrubbing (non-monotonic time changes, e.g., dragging timeline backward), wrap detection incorrectly fires wrapEvent. This causes phantom events during scrubbing, breaking the user experience.

**Evidence from STATUS:**
- Wrap detection logic handles scrubbing correctly (line 121-127)
- No scrub mode parameter in `ScheduleExecutor.executeFrame()` (line 203-210)
- No wrap suppression mechanism (line 217-222)
- Plan specifies scrub detection: large jumps (>1s) or backward time (line 227-232)

**Current Behavior:**
- User scrubs timeline backward across wrap boundary → wrapEvent fires
- Fast-forward (large time jump) → wrapEvent fires
- Any non-monotonic time change → wrap detection jitter

**Desired Behavior:**
- Normal playback: wrapEvent fires once per cycle
- Scrubbing: wrapEvent suppressed, no phantom triggers

### Acceptance Criteria
- [ ] `ScheduleExecutor.executeFrame()` accepts optional `mode: 'playback' | 'scrub'` parameter
- [ ] `resolveTime()` receives mode parameter and returns `isScrub` flag in result
- [ ] Scrub detection: `mode === 'scrub'` OR `|deltaMs| > 1000` OR `deltaMs < 0`
- [ ] When scrub detected: wrapEvent suppressed (not written to EventStore)
- [ ] Unit test: scrubbing backward across wrap boundary → no wrapEvent
- [ ] Unit test: large forward jump (>1s) → no wrapEvent
- [ ] Integration test: normal playback across wrap → wrapEvent fires exactly once

### Technical Notes

**Implementation Location:**
- `src/editor/runtime/executor/ScheduleExecutor.ts` (executeFrame signature)
- `src/editor/runtime/executor/timeResolution.ts` (resolveTime logic)
- `src/editor/runtime/executor/steps/executeTimeDerive.ts` (conditional event trigger)

**Signature Changes:**

1. **ScheduleExecutor.executeFrame()** (line 97-101):
   ```typescript
   // BEFORE:
   public executeFrame(
     program: CompiledProgramIR,
     runtime: RuntimeState,
     tMs: number,
   ): RenderFrameIR

   // AFTER:
   public executeFrame(
     program: CompiledProgramIR,
     runtime: RuntimeState,
     tMs: number,
     mode?: 'playback' | 'scrub',  // Default: 'playback'
   ): RenderFrameIR
   ```

2. **resolveTime()** (timeResolution.ts:92-181):
   ```typescript
   // Add to TimeResolutionInput:
   interface TimeResolutionInput {
     tAbsMs: number;
     mode?: 'playback' | 'scrub';
   }

   // Add to EffectiveTime output:
   interface EffectiveTime {
     // ... existing fields
     isScrub: boolean;  // True if scrub detected
   }
   ```

**Scrub Detection Logic (from SPEC-05:352-356):**
```typescript
function resolveTime(
  input: TimeResolutionInput,
  timeModel: TimeModelIR,
  state: TimeResolutionState
): EffectiveTime {
  const deltaMs = input.tAbsMs - state.prevFrameTimeMs;

  // Scrub detection
  const isScrub = input.mode === "scrub" ||
                  Math.abs(deltaMs) > 1000 ||  // >1s jump
                  deltaMs < 0;                  // Backwards

  // Normal time computation...
  const baseTime = computeTime(input.tAbsMs, timeModel, state);

  if (isScrub) {
    // Suppress wrap event
    return { ...baseTime, wrapEvent: false, isScrub: true };
  }

  // Normal playback - detect wrap
  return { ...baseTime, isScrub: false };
}
```

**Integration with EventStore:**

In `executeTimeDerive.ts`:
```typescript
// Only trigger wrap event if not scrubbing
if (time.wrapEvent && !time.isScrub) {
  runtime.events.trigger(step.out.wrapEvent, {
    phase: time.phase01,
    count: timeState.wrapCount,
    deltaMs: timeState.lastDeltaMs
  });
}
```

**Testing Strategy:**

1. **Scrub backward test:**
   ```typescript
   it('suppresses wrap when scrubbing backward', () => {
     const state = createTimeState();
     const model: TimeModelIR = { kind: 'cyclic', periodMs: 1000, mode: 'loop' };

     resolveTime({ tAbsMs: 1100, mode: 'playback' }, model, state);  // After wrap
     const result = resolveTime({ tAbsMs: 900, mode: 'scrub' }, model, state);  // Scrub back

     expect(result.isScrub).toBe(true);
     expect(result.wrapEvent).toBe(false);  // No phantom wrap
   });
   ```

2. **Large jump test:**
   ```typescript
   it('suppresses wrap on large forward jump', () => {
     const state = createTimeState();
     const model: TimeModelIR = { kind: 'cyclic', periodMs: 1000, mode: 'loop' };

     resolveTime({ tAbsMs: 0 }, model, state);
     const result = resolveTime({ tAbsMs: 5000 }, model, state);  // 5s jump

     expect(result.isScrub).toBe(true);
     expect(result.wrapEvent).toBe(false);
   });
   ```

3. **Normal playback test:**
   ```typescript
   it('fires wrap during normal playback', () => {
     const state = createTimeState();
     const model: TimeModelIR = { kind: 'cyclic', periodMs: 1000, mode: 'loop' };

     resolveTime({ tAbsMs: 900, mode: 'playback' }, model, state);
     const result = resolveTime({ tAbsMs: 1100, mode: 'playback' }, model, state);

     expect(result.isScrub).toBe(false);
     expect(result.wrapEvent).toBe(true);  // Wrap fires normally
   });
   ```

**Risks:**
- Heuristic scrub detection (>1s jump) may misfire on legitimate playback
  - **Mitigation:** Make threshold configurable, default to 1000ms based on spec
- Backward compatibility: existing callers don't pass mode parameter
  - **Mitigation:** Make mode optional, default to 'playback' (preserve existing behavior)
- Unified compiler has different scrub semantics (TimeCtx.mode)
  - **Mitigation:** Flag for user decision, document divergence for now

**Question for User:**
Should IR executor adopt unified compiler's `TimeCtx.mode` pattern, or maintain separate implementation? (See STATUS:238-246)

---

## Dependency Graph

```
P0 (Fix Tests)
    ↓
    ├─→ P1 (EventStore) ──→ P2 (Scrub Mode)
    └─→ P2 (can start independently, but needs P1 to integrate)
```

**Critical Path:** P0 → P1 → P2
**Parallel Opportunity:** After P0, P1 and P2 can be developed simultaneously (P2 just needs P1 interface)

---

## Risk Assessment

### High-Risk Items

1. **EventStore Integration (P1)**
   - Risk: Existing code may depend on numeric wrapEvent storage
   - Impact: Breaking change to wrapEvent consumers
   - Mitigation: Search codebase for wrapEvent consumers, update all references
   - Likelihood: Medium

2. **Scrub Detection Heuristic (P2)**
   - Risk: 1000ms threshold may be too aggressive or too lenient
   - Impact: False positives/negatives in scrub detection
   - Mitigation: Make threshold configurable, add tests for edge cases
   - Likelihood: Low

### Uncertain Items

1. **InfiniteTimeRoot Semantics**
   - Question: Should InfiniteTimeRoot emit infinite or cyclic time?
   - Impact: User-facing confusion, block naming mismatch
   - Blocker: No - can defer to separate workstream
   - Action: Document ambiguity, ask user during implementation

2. **IR vs Unified Compiler Alignment**
   - Question: Should IR executor use unified compiler's TimeCtx pattern?
   - Impact: Inconsistent scrub semantics between compilers
   - Blocker: No - can implement independently now
   - Action: Document divergence, plan alignment in future sprint

---

## Recommended Sprint Execution

### Session 1: Foundation (30 minutes)
1. Fix test compilation (P0) - 10 minutes
2. Verify tests pass - 5 minutes
3. Review EventStore spec and design - 15 minutes

### Session 2: EventStore Implementation (2-3 hours)
1. Create EventStore class - 30 minutes
2. Integrate into RuntimeState - 30 minutes
3. Update executeTimeDerive - 30 minutes
4. Write unit tests - 45 minutes
5. Write integration test - 45 minutes

### Session 3: Scrub Mode (1-2 hours)
1. Add mode parameter to executeFrame - 15 minutes
2. Update resolveTime with scrub detection - 30 minutes
3. Integrate with EventStore (suppress on scrub) - 15 minutes
4. Write scrub tests - 45 minutes

### Session 4: Validation (30 minutes)
1. Run full test suite (`just check`) - 5 minutes
2. Manual testing with Chrome DevTools MCP:
   - Play cyclic animation, verify wrap fires once per cycle
   - Scrub backward, verify no phantom wraps
   - Large time jump, verify no phantom wraps

---

## Definition of Done

See separate file: `DOD-2025-12-31-013758.md`

Sprint complete when:
- All 3 deliverables have passing acceptance criteria
- `just check` passes (typecheck + lint + test)
- Manual validation confirms no phantom wrap events during scrubbing
- Code reviewed for consistency with SPEC-05

---

## Files to Modify

### New Files
- `src/editor/runtime/executor/EventStore.ts` (P1)
- `src/editor/runtime/executor/__tests__/EventStore.test.ts` (P1)

### Modified Files
- `src/editor/compiler/ir/__tests__/state-offset-resolution.test.ts` (P0)
- `src/editor/runtime/executor/RuntimeState.ts` (P1, P2)
- `src/editor/runtime/executor/steps/executeTimeDerive.ts` (P1, P2)
- `src/editor/runtime/executor/ScheduleExecutor.ts` (P1, P2)
- `src/editor/runtime/executor/timeResolution.ts` (P2)
- `src/editor/runtime/executor/__tests__/timeResolution.test.ts` (P1, P2)

---

## Post-Sprint Follow-Up

**Not in this sprint, but should be tracked:**

1. **InfiniteTimeRoot Naming:** Clarify with user whether block should emit infinite or cyclic time (see STATUS:82-104)

2. **End-to-End Wrap Consumption Test:** Create test showing a block consuming wrapEvent and verifying edge detection (see STATUS:331-335)

3. **Unified Compiler Alignment:** Decide whether IR executor should adopt TimeCtx.mode pattern (see STATUS:236-246)

4. **Wrap Event Multi-Frame Test Hardening:** Current wrap test is weak (STATUS:273-276), add robust multi-frame sequence tests

---

## Provenance

- **Source STATUS:** STATUS-2025-12-31-013400.md
- **Generation Timestamp:** 2025-12-31-013758
- **Planner:** status-planner
- **Spec References:** SPEC-05-time-architecture.md, 02-time-event-semantics.md
