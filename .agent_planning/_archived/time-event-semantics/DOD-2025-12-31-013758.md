# Definition of Done: Time + Event Semantics Sprint

**Generated:** 2025-12-31-013758
**Plan:** PLAN-2025-12-31-013758.md
**Source STATUS:** STATUS-2025-12-31-013400.md

---

## Sprint Scope

This sprint delivers:
1. Working test suite (compilation errors fixed)
2. EventStore with discrete trigger semantics
3. Scrub mode to suppress phantom wrap events

Deferred:
- InfiniteTimeRoot naming clarification (needs user decision)
- End-to-end wrap consumption tests (incremental addition)
- Unified compiler alignment (architectural decision)

---

## Acceptance Criteria

### Deliverable 1: Fix Test Compilation (P0 - BLOCKER)

**Must Complete First** - No other work can be validated without passing tests.

- [ ] All 6 TypeScript errors in `state-offset-resolution.test.ts` are resolved
- [ ] `just test` runs without compilation errors
- [ ] All existing tests pass (no new test failures introduced)
- [ ] Test mock objects include `debugProbes: []` property
- [ ] Verified with `just check` (full typecheck + lint + test)

**Verification Command:**
```bash
just check  # Must pass all typecheck + lint + test
```

---

### Deliverable 2: EventStore Implementation (P1 - CORE)

**Discrete event semantics replacing numeric storage.**

#### EventStore Class
- [ ] `EventStore` class created with `trigger()`, `check()`, and `reset()` methods
- [ ] EventStore added to `RuntimeState` (alongside `values`, `state`)
- [ ] EventStore.reset() called at start of each frame in ScheduleExecutor

#### Wrap Event Integration
- [ ] `executeTimeDerive.ts` writes wrapEvent to EventStore instead of ValueStore
- [ ] wrapEvent payload includes: `{ phase: number, count: number, deltaMs: number }`
- [ ] Payload values are correct (phase from time resolution, count from timeState)

#### Unit Tests
- [ ] Test: `EventStore.trigger()` then `check()` returns true
- [ ] Test: `EventStore.check()` on unset event returns false
- [ ] Test: `EventStore.reset()` clears all events
- [ ] Test: Payload is preserved after trigger, accessible via `getPayload()`

#### Integration Tests
- [ ] Test: Cyclic model (periodMs: 1000), frame sequence 900→1100→1200ms
  - [ ] Frame 1 (900ms): no wrap event
  - [ ] Frame 2 (1100ms): wrap event fires (check returns true)
  - [ ] Frame 3 (1200ms): no wrap event (reset worked)
- [ ] Test: Wrap event fires exactly once per cycle (not continuously)
- [ ] Test: Multiple cycles increment wrap count in payload

**Verification Command:**
```bash
just test  # All EventStore tests must pass
```

**Files Modified:**
- Created: `src/editor/runtime/executor/EventStore.ts`
- Created: `src/editor/runtime/executor/__tests__/EventStore.test.ts`
- Modified: `src/editor/runtime/executor/RuntimeState.ts`
- Modified: `src/editor/runtime/executor/steps/executeTimeDerive.ts`
- Modified: `src/editor/runtime/executor/ScheduleExecutor.ts`
- Modified: `src/editor/runtime/executor/__tests__/timeResolution.test.ts`

---

### Deliverable 3: Scrub Mode (P2 - POLISH)

**Suppress phantom wrap events during non-monotonic time changes.**

#### API Changes
- [ ] `ScheduleExecutor.executeFrame()` accepts optional `mode: 'playback' | 'scrub'` parameter
- [ ] `resolveTime()` receives mode parameter and returns `isScrub` flag in result
- [ ] Mode parameter defaults to 'playback' (backward compatible)

#### Scrub Detection Logic
- [ ] Scrub detected when: `mode === 'scrub'` OR `|deltaMs| > 1000` OR `deltaMs < 0`
- [ ] When scrub detected: `isScrub: true` in EffectiveTime result
- [ ] When scrub detected: wrapEvent suppressed (not written to EventStore)

#### Unit Tests
- [ ] Test: Scrubbing backward across wrap boundary → no wrapEvent, isScrub=true
  - [ ] Frame 1: t=1100ms (after wrap)
  - [ ] Frame 2: t=900ms, mode='scrub' → no wrapEvent fired
- [ ] Test: Large forward jump (>1000ms) → no wrapEvent, isScrub=true
  - [ ] Frame 1: t=0ms
  - [ ] Frame 2: t=5000ms → isScrub=true, no wrapEvent
- [ ] Test: Backward time (negative delta) → no wrapEvent, isScrub=true
  - [ ] Frame 1: t=1000ms
  - [ ] Frame 2: t=500ms → isScrub=true, no wrapEvent

#### Integration Tests
- [ ] Test: Normal playback across wrap → wrapEvent fires exactly once, isScrub=false
  - [ ] Frame 1: t=900ms, mode='playback'
  - [ ] Frame 2: t=1100ms, mode='playback' → wrapEvent=true, isScrub=false
- [ ] Test: Scrub mode explicitly set → suppresses wrap even on boundary crossing
- [ ] Test: Multiple scrub operations don't accumulate phantom events

**Verification Command:**
```bash
just test  # All scrub mode tests must pass
```

**Files Modified:**
- Modified: `src/editor/runtime/executor/ScheduleExecutor.ts`
- Modified: `src/editor/runtime/executor/timeResolution.ts`
- Modified: `src/editor/runtime/executor/steps/executeTimeDerive.ts`
- Modified: `src/editor/runtime/executor/__tests__/timeResolution.test.ts`

---

## Sprint Complete Checklist

### Code Quality
- [ ] All TypeScript errors resolved (`just typecheck` passes)
- [ ] All linting errors resolved (`just lint` passes)
- [ ] All tests pass (`just test` passes)
- [ ] Full check passes (`just check` passes)

### Functional Verification
- [ ] EventStore stores events discretely (not as numeric values)
- [ ] Wrap event fires once per cycle during normal playback
- [ ] Wrap event suppressed during scrubbing (backward time, large jumps)
- [ ] Event payloads include correct phase, count, deltaMs values

### Manual Validation (Chrome DevTools MCP)
- [ ] Play cyclic animation (periodMs: 1000) → wrap fires once at t=1000ms, 2000ms, etc.
- [ ] Scrub timeline backward across wrap → no phantom wrap events
- [ ] Fast-forward with large time jump → no phantom wrap events
- [ ] Verify EventStore.check() returns false after frame reset

### Documentation
- [ ] Code comments explain EventStore semantics (discrete triggers vs continuous values)
- [ ] Scrub detection threshold (1000ms) documented in resolveTime()
- [ ] Known divergence from unified compiler documented (if applicable)

---

## Success Metrics

**Sprint is successful if:**
1. ✅ Tests compile and pass (`just check` clean)
2. ✅ Wrap event fires exactly once per cycle (verified in tests)
3. ✅ Scrubbing does not produce phantom wrap events (verified in tests + manual)
4. ✅ EventStore provides discrete trigger semantics (not numeric storage)

**Sprint is NOT successful if:**
- ❌ Tests still have compilation errors
- ❌ Wrap events fire continuously instead of once per cycle
- ❌ Scrubbing produces phantom wrap events
- ❌ EventStore stores events as numeric values in ValueStore

---

## Ready for Next Sprint When

- [ ] All acceptance criteria above are met
- [ ] `just check` passes cleanly
- [ ] Manual testing confirms correct behavior
- [ ] No known regressions in existing time behavior
- [ ] Code is consistent with SPEC-05-time-architecture.md

**Next Sprint Can Begin:**
Signal runtime stateful operations, Field runtime primitives, or Bus system execution (Workstreams 4, 3, or 5).

---

## Known Limitations / Deferred Work

**Not in this sprint, track separately:**

1. InfiniteTimeRoot naming/semantics clarification (user decision needed)
2. End-to-end wrap consumption test (block consuming wrapEvent)
3. Unified compiler alignment (TimeCtx.mode adoption decision)
4. Hardened multi-frame wrap detection tests (current tests are weak)
5. Scrub threshold configurability (1000ms is hardcoded)

---

## Provenance

- **Source STATUS:** STATUS-2025-12-31-013400.md
- **Full Plan:** PLAN-2025-12-31-013758.md
- **Generated:** 2025-12-31-013758
- **Planner:** status-planner
