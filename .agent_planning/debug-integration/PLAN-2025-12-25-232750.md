# Sprint Plan: Phase 7 Debug Infrastructure Integration

**Generated**: 2025-12-25-232750
**Source**: STATUS-2025-12-25-232500.md
**Topic**: debug-integration
**Scope**: Minimal viable integration to make debug infrastructure functional

---

## Executive Summary

**Current State**: 8 core debug infrastructure files are complete with 121 passing tests. All modules (DebugIndex, SpanRing, ValueRing, TypeKeyEncoding, TraceController, instrumentClosure) are implemented and tested in isolation.

**Critical Gap**: Zero integration with compiler or runtime. The debug system is a complete island - not exported, not instantiated, not wired into compilation passes, and not wrapping any closures.

**Sprint Goal**: Create the minimal integration path to enable debug tracing end-to-end:
1. Export debug modules from index.ts
2. Wire DebugIndex creation and population into compiler passes 1, 6, 7, 8
3. Add debugIndex + rings to CompileResult
4. Extend RuntimeCtx with frameId/tMs for span attribution

**Deferred to Future Sprints**:
- Closure wrapping in compileBusAware (too invasive for minimal integration)
- Debug UI consumption
- Performance optimization and testing
- EdgeRing for causal links
- Trace export/persistence

**Sprint Delivers**: A compiled patch will have a populated DebugIndex attached, RuntimeCtx will support span attribution, and all debug infrastructure is properly exported and ready for future instrumentation.

---

## Dependency Graph

```
Pass 1 (Normalize)
  ├─> Creates DebugIndex
  └─> Populates CompileResult.debugIndex

Pass 6 (Block Lowering)
  └─> Calls debugIndex.internBlock(blockId)

Pass 7 (Bus Lowering)
  └─> Calls debugIndex.internBus(busId)

Pass 8 (Link Resolution)
  └─> Calls debugIndex.internPort(portKey)

Player.renderOnce()
  └─> Populates RuntimeCtx.frameId & tMs
```

---

## Work Items

### P0-1: Export Debug Modules from index.ts

**Status**: Not Started
**Effort**: Small (5 min)
**Dependencies**: None
**Spec Reference**: N/A • **Status Reference**: STATUS-2025-12-25-232500.md § M1

#### Description
Update `/Users/bmf/code/oscilla-animator_codex/src/editor/debug/index.ts` to export all new debug infrastructure modules. Currently only exports old types and RingBuffer.

This is a pure additive change - no breaking changes, no behavioral changes. Makes debug infrastructure accessible to compiler and runtime.

#### Acceptance Criteria
- [ ] index.ts exports DebugIndex, SpanRing, ValueRing, TypeKeyEncoding, TraceController, SpanTypes, ValueRecord, instrumentClosure
- [ ] TypeScript compilation passes (`just typecheck`)
- [ ] No import errors in any file that imports from `editor/debug`

#### Technical Notes
Simply add 8 export lines:
```typescript
export * from './DebugIndex';
export * from './SpanRing';
export * from './ValueRing';
export * from './TypeKeyEncoding';
export * from './TraceController';
export * from './SpanTypes';
export * from './ValueRecord';
export * from './instrumentClosure';
```

---

### P0-2: Add debugIndex Field to CompileResult

**Status**: Not Started
**Effort**: Small (10 min)
**Dependencies**: P0-1
**Spec Reference**: design-docs/3-Synthesized/7-DebugInfra.md § CompileResult • **Status Reference**: STATUS-2025-12-25-232500.md § M2

#### Description
Extend `CompileResult` interface in `/Users/bmf/code/oscilla-animator_codex/src/editor/compiler/types.ts` to include optional debugIndex and typeKeyTable fields. These will be populated during compilation and used by debug UI/tooling.

#### Acceptance Criteria
- [ ] CompileResult interface includes `debugIndex?: DebugIndex` field
- [ ] CompileResult interface includes `typeKeyTable?: TypeKeyTable` field
- [ ] Import statements for DebugIndex and TypeKeyTable added to types.ts
- [ ] TypeScript compilation passes (`just typecheck`)
- [ ] Existing compiler tests still pass (fields are optional)

#### Technical Notes
Add after the existing ir/irWarnings fields:
```typescript
/** Debug index for string interning (when debug tracing enabled) */
debugIndex?: DebugIndex;
/** TypeKey to ID mapping for debug traces */
typeKeyTable?: TypeKeyTable;
```

Import from `../debug`:
```typescript
import type { DebugIndex, TypeKeyTable } from '../debug';
```

---

### P0-3: Create DebugIndex in Pass 1 (Normalize)

**Status**: Not Started
**Effort**: Medium (30 min)
**Dependencies**: P0-1, P0-2
**Spec Reference**: design-docs/3-Synthesized/7-DebugInfra.md § Compilation Integration • **Status Reference**: STATUS-2025-12-25-232500.md § M3

#### Description
Modify Pass 1 (Normalize) to create a new DebugIndex instance at the start of compilation. The DebugIndex constructor requires compileId and patchRevision for tracking debug data across hot reloads.

Pass 1 is the entry point to the compiler pipeline, so it's the natural place to initialize shared compilation artifacts like DebugIndex.

#### Acceptance Criteria
- [ ] Pass 1 creates new DebugIndex with generated compileId (UUID)
- [ ] Pass 1 passes debugIndex to Pass 2 via Pass1Output
- [ ] CompileResult.debugIndex is populated with the DebugIndex instance
- [ ] DebugIndex.compileId is unique per compilation
- [ ] TypeScript compilation passes (`just typecheck`)
- [ ] Integration test: compile a patch, verify debugIndex exists and has compileId

#### Technical Notes
- Import DebugIndex from `../debug`
- Generate compileId using `crypto.randomUUID()`
- Pass patchRevision from input (default to 0 if not provided)
- Thread debugIndex through Pass1Output → Pass2Input → ... → CompileResult
- All passes must accept and forward debugIndex even if they don't use it

```typescript
// In Pass 1
import { DebugIndex } from '../debug';

const debugIndex = new DebugIndex({
  compileId: crypto.randomUUID(),
  patchRevision: patch.revision ?? 0,
});

return {
  ...normalizedData,
  debugIndex,
};
```

---

### P0-4: Populate DebugIndex in Pass 6 (Block Lowering)

**Status**: Not Started
**Effort**: Medium (1 hour)
**Dependencies**: P0-3
**Spec Reference**: design-docs/3-Synthesized/7-DebugInfra.md § Interning Strategy • **Status Reference**: STATUS-2025-12-25-232500.md § M3

#### Description
Modify Pass 6 (Block Lowering) to intern all block IDs into the DebugIndex as blocks are lowered to IR. This creates the block ID → BlockId mapping used for debug span attribution.

Pass 6 iterates over all blocks in topological order, making it the natural place to populate the block interning table.

#### Acceptance Criteria
- [ ] Pass 6 calls `debugIndex.internBlock(blockId)` for every block lowered
- [ ] Interning happens before block compilation (so blockId is available for error reporting)
- [ ] DebugIndex.blocks map contains all block IDs from the patch
- [ ] TypeScript compilation passes (`just typecheck`)
- [ ] Integration test: compile patch with 3 blocks, verify debugIndex.blocks.size === 3

#### Technical Notes
- Access debugIndex from Pass6Input
- Call internBlock() in the block iteration loop before calling blockCompiler.compile()
- The returned BlockId (numeric) can be ignored for now - it's for future instrumentation

```typescript
// In Pass 6 block lowering loop
for (const blockInstance of topoOrder) {
  const blockId = debugIndex.internBlock(blockInstance.id);
  // ... existing compilation logic
}
```

---

### P0-5: Populate DebugIndex in Pass 7 (Bus Lowering)

**Status**: Not Started
**Effort**: Medium (1 hour)
**Dependencies**: P0-3
**Spec Reference**: design-docs/3-Synthesized/7-DebugInfra.md § Interning Strategy • **Status Reference**: STATUS-2025-12-25-232500.md § M3

#### Description
Modify Pass 7 (Bus Lowering) to intern all bus IDs into the DebugIndex as buses are processed. This creates the bus ID → BusId mapping used for debug span attribution.

Pass 7 processes all buses and creates bus combine closures, making it the natural place to populate the bus interning table.

#### Acceptance Criteria
- [ ] Pass 7 calls `debugIndex.internBus(busId)` for every bus processed
- [ ] Interning happens before bus combine closure creation
- [ ] DebugIndex.buses map contains all bus IDs from the patch
- [ ] TypeScript compilation passes (`just typecheck`)
- [ ] Integration test: compile patch with 2 buses, verify debugIndex.buses.size === 2

#### Technical Notes
- Access debugIndex from Pass7Input
- Call internBus() in the bus processing loop before creating combine closures
- The returned BusId (numeric) can be ignored for now - it's for future instrumentation

```typescript
// In Pass 7 bus processing loop
for (const bus of buses) {
  const busId = debugIndex.internBus(bus.id);
  // ... existing bus lowering logic
}
```

---

### P0-6: Populate DebugIndex in Pass 8 (Link Resolution)

**Status**: Not Started
**Effort**: Medium (1 hour)
**Dependencies**: P0-3
**Spec Reference**: design-docs/3-Synthesized/7-DebugInfra.md § Interning Strategy • **Status Reference**: STATUS-2025-12-25-232500.md § M3

#### Description
Modify Pass 8 (Link Resolution) to intern all port keys into the DebugIndex as port references are resolved. This creates the port key → PortId mapping used for debug span attribution.

Pass 8 resolves all port references (block outputs, bus values) and validates the IR graph, making it the natural place to populate the port interning table.

#### Acceptance Criteria
- [ ] Pass 8 calls `debugIndex.internPort(portKey)` for every port reference resolved
- [ ] Interning happens during link resolution (when port keys are constructed)
- [ ] DebugIndex.ports map contains all port keys from the patch
- [ ] TypeScript compilation passes (`just typecheck`)
- [ ] Integration test: compile patch with 5 ports, verify debugIndex.ports.size === 5

#### Technical Notes
- Access debugIndex from Pass8Input
- Call internPort() when constructing port keys (format: `blockId.portName`)
- The returned PortId (numeric) can be ignored for now - it's for future instrumentation
- Port keys are constructed in Pass 8 when resolving block outputs and bus values

```typescript
// In Pass 8 port resolution
const portKey = `${blockId}.${portName}`;
const portId = debugIndex.internPort(portKey);
// ... existing link resolution logic
```

---

### P1-1: Extend RuntimeCtx with frameId and tMs

**Status**: Not Started
**Effort**: Small (30 min)
**Dependencies**: P0-2
**Spec Reference**: design-docs/3-Synthesized/7-DebugInfra.md § Runtime Attribution • **Status Reference**: STATUS-2025-12-25-232500.md § M5

#### Description
Extend the `RuntimeCtx` interface in `/Users/bmf/code/oscilla-animator_codex/src/editor/compiler/types.ts` to include optional `frameId` and `tMs` fields. These are required for proper span attribution in debug traces.

The Player will populate these fields during renderOnce(), allowing instrumented closures to record which frame and time each span occurred.

#### Acceptance Criteria
- [ ] RuntimeCtx interface includes `frameId?: number` field
- [ ] RuntimeCtx interface includes `tMs?: number` field (separate from signal parameter)
- [ ] TypeScript compilation passes (`just typecheck`)
- [ ] Existing runtime code compiles without errors (fields are optional)
- [ ] instrumentClosure wrappers correctly default frameId to 0 when missing

#### Technical Notes
Add to RuntimeCtx interface:
```typescript
export interface RuntimeCtx {
  viewport: { w: number; h: number; dpr: number };
  reducedMotion?: boolean;
  frameId?: number;  // Frame counter for debug span attribution
  tMs?: number;      // Animation time for span recording (mirrors signal param)
}
```

The `tMs` field mirrors the `tMs` parameter to `program.signal()` - this redundancy allows debug wrappers to access time without threading it through all closure signatures.

---

### P1-2: Populate RuntimeCtx Fields in Player

**Status**: Not Started
**Effort**: Small (30 min)
**Dependencies**: P1-1
**Spec Reference**: design-docs/3-Synthesized/7-DebugInfra.md § Runtime Attribution • **Status Reference**: STATUS-2025-12-25-232500.md § M5

#### Description
Modify `Player.renderOnce()` in `/Users/bmf/code/oscilla-animator_codex/src/editor/runtime/Player.ts` to populate `runtimeCtx.frameId` and `runtimeCtx.tMs` before calling `program.signal()`.

This makes frame and time information available to instrumented closures for proper span attribution.

#### Acceptance Criteria
- [ ] Player maintains a frameId counter (starts at 0, increments per render)
- [ ] Player.renderOnce() sets runtimeCtx.frameId before calling program.signal()
- [ ] Player.renderOnce() sets runtimeCtx.tMs to current animation time
- [ ] frameId increments monotonically (even during scrubbing/hot reload)
- [ ] TypeScript compilation passes (`just typecheck`)
- [ ] Integration test: render 3 frames, verify frameId increments 0 → 1 → 2

#### Technical Notes
Add frameId counter to Player class:
```typescript
private frameId = 0;
```

In renderOnce():
```typescript
private renderOnce(): void {
  if (this.program === null || this.program === undefined) return;

  // Populate debug attribution fields
  this.runtimeCtx.frameId = this.frameId++;
  this.runtimeCtx.tMs = this.tMs;

  const tree = this.program.signal(this.tMs, this.runtimeCtx);
  // ... rest of method
}
```

Reset frameId on program swap to maintain monotonic invariant:
```typescript
private instantiateProgram(): void {
  // ... existing code
  this.frameId = 0; // Reset for new program
  this.renderOnce();
}
```

---

### P1-3: Create TypeKeyTable in Pass 2 (Types)

**Status**: Not Started
**Effort**: Medium (1 hour)
**Dependencies**: P0-2
**Spec Reference**: design-docs/3-Synthesized/7-DebugInfra.md § TypeKey Encoding • **Status Reference**: STATUS-2025-12-25-232500.md § M2

#### Description
Modify Pass 2 (Types) to create a TypeKeyTable instance and populate it with all TypeKeys encountered during type resolution. This creates the TypeKey → TypeKeyId mapping used for compact value encoding in debug traces.

Pass 2 is responsible for type checking and produces the typed IR, so it's the natural place to build the TypeKey table.

#### Acceptance Criteria
- [ ] Pass 2 creates new TypeKeyTable instance
- [ ] Pass 2 calls typeKeyTable.intern(typeKey) for all TypeKeys encountered
- [ ] CompileResult.typeKeyTable is populated with the TypeKeyTable instance
- [ ] TypeKeyTable contains all unique TypeKeys from the patch
- [ ] TypeScript compilation passes (`just typecheck`)
- [ ] Integration test: compile patch, verify typeKeyTable.size > 0

#### Technical Notes
- Import TypeKeyTable from `../debug`
- Create TypeKeyTable at start of Pass 2
- Call intern() whenever a TypeKey is constructed or validated
- Thread typeKeyTable through Pass2Output → Pass3Input → ... → CompileResult

```typescript
// In Pass 2
import { TypeKeyTable } from '../debug';

const typeKeyTable = new TypeKeyTable();

// When processing port types
const typeKey = TypeKeyEncoding.encode(portType);
typeKeyTable.intern(typeKey);

return {
  ...typeData,
  typeKeyTable,
};
```

---

## Recommended Sprint Execution Order

### Phase 1: Foundation (30 min)
Execute P0-1, P0-2, P0-3 in sequence. This establishes the basic plumbing and creates the DebugIndex artifact.

**Verification**: After Phase 1, a compiled patch should have CompileResult.debugIndex defined with a unique compileId.

### Phase 2: Population (3 hours)
Execute P0-4, P0-5, P0-6 in parallel (no dependencies between them). This populates the DebugIndex with all interned IDs.

**Verification**: After Phase 2, CompileResult.debugIndex should contain non-empty blocks, buses, and ports maps.

### Phase 3: Runtime Attribution (1 hour)
Execute P1-1, P1-2 in sequence. This extends RuntimeCtx and wires it into the Player.

**Verification**: After Phase 3, RuntimeCtx.frameId should increment on each render.

### Phase 4: Type Encoding (1 hour)
Execute P1-3 independently. This creates the TypeKeyTable for compact value encoding.

**Verification**: After Phase 4, CompileResult.typeKeyTable should contain all unique TypeKeys from the patch.

**Total Estimated Time**: ~6 hours

---

## Integration Test Requirements

After completing all work items, create an end-to-end integration test:

```typescript
test('debug infrastructure integration', () => {
  // Compile a patch with 2 blocks, 1 bus, 3 connections
  const patch = createTestPatch();
  const result = compile(patch);

  // Verify DebugIndex is populated
  expect(result.debugIndex).toBeDefined();
  expect(result.debugIndex.compileId).toMatch(/^[0-9a-f-]{36}$/); // UUID
  expect(result.debugIndex.blocks.size).toBe(2);
  expect(result.debugIndex.buses.size).toBe(1);
  expect(result.debugIndex.ports.size).toBeGreaterThan(0);

  // Verify TypeKeyTable is populated
  expect(result.typeKeyTable).toBeDefined();
  expect(result.typeKeyTable.size).toBeGreaterThan(0);

  // Verify RuntimeCtx supports debug attribution
  const player = createPlayer(/* ... */);
  player.setFactory(/* compiled program */);
  player.renderOnce();
  // frameId should be 0 on first render
  expect(player.getRuntimeCtx().frameId).toBe(0);
});
```

---

## Risk Assessment

| Risk | Severity | Mitigation |
|------|----------|------------|
| Pass pipeline threading complexity | MEDIUM | All passes already thread context objects; follow existing pattern |
| Performance impact of interning | LOW | Interning happens once per compile, not per frame |
| Missing port keys in Pass 8 | LOW | Pass 8 already constructs port keys for validation |
| RuntimeCtx mutation side effects | LOW | Fields are optional and only read by debug wrappers |
| TypeKeyTable size growth | LOW | Typical patches have <100 unique type keys |

---

## Definition of Done

This sprint is complete when:

1. **All P0 items are completed and verified**
2. **TypeScript compilation passes** (`just typecheck`)
3. **All existing tests pass** (`just test`)
4. **Integration test passes** (DebugIndex + TypeKeyTable populated)
5. **No regressions** in existing compiler/runtime behavior
6. **Manual verification**: Compile "Breathing Constellation" golden patch, inspect CompileResult.debugIndex in debugger

**Success Criteria**: A compiled patch has a populated DebugIndex with interned blocks/buses/ports, TypeKeyTable with type encodings, and RuntimeCtx supports frameId/tMs attribution. The system is ready for future closure instrumentation.

---

## Out of Scope (Deferred)

These items are NOT part of this sprint:

- **Closure wrapping in compileBusAware** - Too invasive, requires deep changes to 45K LOC file
- **SpanRing/ValueRing instantiation** - No closure instrumentation yet, so no spans to record
- **Debug UI consumption** - Phase 8 work
- **EdgeRing for causal links** - Mentioned in design doc but not implemented
- **Performance testing** - Defer until instrumentation is active
- **Trace export/persistence** - Future feature
- **TraceController mode switching UI** - Phase 8 work

These will be addressed in future sprints once the basic integration is proven and closure instrumentation is implemented.
