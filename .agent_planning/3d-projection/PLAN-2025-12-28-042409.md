# RenderInstances3D Block Implementation Plan

**Generated:** 2025-12-28-042409
**Source:** STATUS-2025-12-28-042409.md
**Scope:** RenderInstances3D block definition and lowering

---

## Executive Summary

Implement the RenderInstances3D block that bridges 3D domain data to the existing 2D canvas renderer via the projection infrastructure. This block:
1. Accepts Domain + Field<vec3> positions + Field<color> + optional Camera
2. Emits StepInstances3DProjectTo2D during compilation
3. Integrates with existing Camera block and default camera injection

**Prerequisites:** All 3D runtime infrastructure is complete (Camera, projection, stores). Camera block was just finished.

**Deliverables:**
1. RenderInstances3D block type definition
2. Block lowering function
3. Render sink handler integration
4. Test coverage

---

## Sprint Scope

### In Scope
- RenderInstances3D block definition with inputs: domain, positions3d, color, radius, opacity, camera
- Block lowering logic that validates inputs and registers render sink
- Integration with Camera block outputs
- Integration with default camera injection (pass8)
- Test coverage for block lowering

### Out of Scope (Deferred)
- Advanced projection options (zSort, cullMode as user inputs - use defaults)
- Mesh support (use default/hardcoded mesh for now)
- Rotation/scale fields (start with positions only)
- Preview widget in Inspector
- Performance optimizations beyond what's already in executeInstances3DProject

---

## Background Context

### Existing Infrastructure

**Camera Block** (src/editor/compiler/blocks/scene/Camera.ts)
- Input: position, target, up (Signal<vec3>)
- Input: projection params (fovYDeg, near, far)
- Output: camera (Special<camera> = camera index)
- Lowering: Converts lookAt → quaternion, registers CameraIR

**Projection Runtime** (src/editor/runtime/executor/steps/executeInstances3DProject.ts)
- Input: Domain count, CameraEval, Field<vec3> positions, color channels, radius
- Output: Instance2DBufferRef (x, y, r, g, b, a, s, z, alive)
- Logic: 3D→clip→NDC→screen, frustum culling, depth sorting

**RenderInstances2D Pattern** (src/editor/compiler/blocks/domain/RenderInstances2D.ts)
```typescript
const lowerRenderInstances2D: BlockLowerFn = ({ ctx, inputs }) => {
  // Validate inputs
  // Register render sink
  ctx.b.renderSink('instances2d', { domain, positions, radius, color, opacity });
  return { outputs: [], declares: { renderSink: { sinkId: 0 } } };
};
```

### Data Flow

```
[User Patch]
  ├─ Domain (DomainN, GridDomain)
  ├─ Camera block → CameraRef (index)
  ├─ Field<vec3> positions (Spatial3D operators)
  └─ Field<color> colors
       ↓
[RenderInstances3D Block] ← THIS SPRINT
       ↓
[Block Lowering] → renderSink('instances3d', inputs)
       ↓
[Render Sink Handler] → StepInstances3DProjectTo2D
       ↓
[Schedule Executor] → executeInstances3DProject()
       ↓
[Instance2DBufferRef] → Canvas renderer
```

---

## P0: RenderInstances3D Block Definition

**File:** `src/editor/compiler/blocks/domain/RenderInstances3D.ts` (NEW)

### Acceptance Criteria

- [ ] Block type registered with `registerBlockType()`
- [ ] Capability: `'render'`
- [ ] Input port: `domain` (Special<domain>)
- [ ] Input port: `positions3d` (Field<vec3>)
- [ ] Input port: `color` (Field<color>)
- [ ] Input port: `radius` (Field<number>, accepts Signal<number>)
- [ ] Input port: `opacity` (Signal<number>)
- [ ] Input port: `camera` (Special<camera>, optional)
- [ ] No output ports (render sink pattern)
- [ ] Lowering function `lowerRenderInstances3D` implemented
- [ ] File exports block type for registration

### Implementation Notes

**Input Port Definitions:**

```typescript
inputs: [
  {
    portId: 'domain',
    label: 'Domain',
    dir: 'in',
    type: { world: 'special', domain: 'domain' },
  },
  {
    portId: 'positions3d',
    label: 'Positions (3D)',
    dir: 'in',
    type: { world: 'field', domain: 'vec3' },
  },
  {
    portId: 'color',
    label: 'Color',
    dir: 'in',
    type: { world: 'field', domain: 'color' },
  },
  {
    portId: 'radius',
    label: 'Radius',
    dir: 'in',
    type: { world: 'field', domain: 'number' },
    // Note: Can also accept Signal<number> (broadcast)
  },
  {
    portId: 'opacity',
    label: 'Opacity',
    dir: 'in',
    type: { world: 'signal', domain: 'number' },
  },
  {
    portId: 'camera',
    label: 'Camera',
    dir: 'in',
    type: { world: 'special', domain: 'camera' },
    optional: true,  // Pass8 injects default if missing
  },
],
outputs: []  // Render sinks have no outputs
```

**Validation Logic:**

```typescript
const lowerRenderInstances3D: BlockLowerFn = ({ ctx, inputs }) => {
  const [domain, positions3d, color, radius, opacity, camera] = inputs;

  // Validate domain
  if (domain.k !== 'special' || domain.tag !== 'domain') {
    throw new Error('RenderInstances3D requires a Domain input');
  }

  // Validate positions3d
  if (positions3d.k !== 'field') {
    throw new Error(`RenderInstances3D requires Field<vec3> positions3d, got ${positions3d.k}`);
  }
  // TODO: Add domain type check (should be 'vec3')

  // Validate color
  if (color.k !== 'field') {
    throw new Error(`RenderInstances3D requires Field<color> color, got ${color.k}`);
  }

  // Validate radius (Field or Signal)
  if (radius.k !== 'field' && radius.k !== 'sig') {
    throw new Error(`RenderInstances3D requires Field<number> or Signal<number> radius, got ${radius.k}`);
  }

  // Validate opacity
  if (opacity.k !== 'sig') {
    throw new Error(`RenderInstances3D requires Signal<number> opacity, got ${opacity.k}`);
  }

  // Validate camera (optional)
  if (camera && (camera.k !== 'special' || camera.tag !== 'camera')) {
    throw new Error(`RenderInstances3D camera input must be Special<camera>, got ${camera.k}`);
  }

  // Register render sink
  const sinkInputs = {
    domain: domain.id,
    positions3d: positions3d.slot,
    color: color.slot,
    radius: radius.slot,
    opacity: opacity.slot,
    camera: camera?.id,  // undefined if not provided (pass8 injects default)
  };

  ctx.b.renderSink('instances3d', sinkInputs);

  return {
    outputs: [],
    declares: {
      renderSink: { sinkId: 0 },
    },
  };
};
```

**Technical Notes:**

- Follow RenderInstances2D pattern exactly
- Use `domain.id` (special types: id IS the slot)
- Use `.slot` for field/signal inputs
- Camera is optional - pass8 will inject default if undefined
- No need to handle color channel splitting here (render sink handler does it)

---

## P0: Render Sink Handler Integration

**File:** TBD (investigate where 'instances2d' handler lives)

### Investigation Required

**Before implementing, locate:**
1. Where `ctx.b.renderSink('instances2d', ...)` is handled
2. How it emits StepRenderAssemble or similar
3. How color Field<color> is split into RGBA channels

**Search strategy:**
```bash
# Find renderSink method definition
grep -r "renderSink(" src/editor/compiler/ir/

# Find instances2d handler
grep -r "'instances2d'" src/editor/compiler/
grep -r "instances2d" src/editor/runtime/
```

### Acceptance Criteria

- [ ] Located existing renderSink handler pattern
- [ ] Added 'instances3d' case to render sink dispatcher
- [ ] Handler allocates output slot for Instance2DBufferRef
- [ ] Handler extracts camera from inputs (or uses undefined for default)
- [ ] Handler splits Field<color> into 4 separate field materialization slots (R, G, B, A)
- [ ] Handler constructs StepInstances3DProjectTo2D with all required fields
- [ ] Handler registers step in schedule (render phase)
- [ ] Projection options set to defaults (zSort: true, cullMode: 'frustum', clipMode: 'discard', sizeSpace: 'px')

### Implementation Notes

**Expected structure:**

```typescript
// In IRBuilderImpl or similar
renderSink(kind: string, inputs: Record<string, ValueSlot>) {
  if (kind === 'instances2d') {
    // Existing 2D logic
  } else if (kind === 'instances3d') {
    // NEW: 3D projection logic
    const outSlot = this.allocSlot();

    // Extract inputs
    const domainSlot = inputs.domain;
    const positionSlot = inputs.positions3d;
    const colorSlot = inputs.color;
    const radiusSlot = inputs.radius;
    const opacitySlot = inputs.opacity;
    const cameraSlot = inputs.camera;  // May be undefined

    // Split color field into RGBA channels
    // (similar to how instances2d might do it)
    const colorRSlot = this.allocSlot();
    const colorGSlot = this.allocSlot();
    const colorBSlot = this.allocSlot();
    const colorASlot = this.allocSlot();

    // Register color channel materializations
    // TODO: Determine if this happens here or in render pass

    // Create projection step
    const step: StepInstances3DProjectTo2D = {
      kind: 'Instances3DProjectTo2D',
      id: `instances3d-project-${this.nextStepId++}`,
      domainSlot,
      cameraEvalSlot: cameraSlot,  // Pass8 resolves undefined → default
      positionSlot,
      colorRSlot,
      colorGSlot,
      colorBSlot,
      colorASlot,
      radiusSlot,
      zSort: true,
      cullMode: 'frustum',
      clipMode: 'discard',
      sizeSpace: 'px',
      outSlot,
    };

    this.addStep(step, 'render');  // Add to render phase
  }
}
```

**Critical question:** How to split color field?

**Option A:** Emit separate field expression evaluations for each channel
```typescript
colorRSlot ← FieldExpr { op: 'extractChannel', sourceField: colorSlot, channel: 'r' }
```

**Option B:** Runtime splitting in materialization step
```typescript
// Materialize full color field once, then split in projection step
```

**Recommendation:** Check how Instance2DBufferRef is populated in existing code.

---

## P1: Test Coverage

**File:** `src/editor/compiler/blocks/domain/__tests__/RenderInstances3D.test.ts` (NEW)

### Acceptance Criteria

- [ ] Test: Block lowers with all required inputs
- [ ] Test: Block lowers with optional camera omitted (default injection)
- [ ] Test: Error thrown if domain is not Special<domain>
- [ ] Test: Error thrown if positions3d is not Field<vec3>
- [ ] Test: Error thrown if color is not Field<color>
- [ ] Test: Error thrown if radius is neither Field nor Signal
- [ ] Test: Error thrown if opacity is not Signal<number>
- [ ] Test: Error thrown if camera is provided but not Special<camera>
- [ ] Test: Render sink registered with correct inputs
- [ ] Test: Integration with Camera block output (CameraRef connects correctly)

### Test Structure

```typescript
import { describe, it, expect } from 'vitest';
import { lowerRenderInstances3D } from '../RenderInstances3D';
import { createMockLowerCtx } from './test-helpers';

describe('RenderInstances3D block lowering', () => {
  it('lowers successfully with all inputs', () => {
    const ctx = createMockLowerCtx();
    const inputs: ValueRefPacked[] = [
      { k: 'special', tag: 'domain', id: 1 },
      { k: 'field', id: 10, slot: 100 },  // positions3d
      { k: 'field', id: 11, slot: 101 },  // color
      { k: 'field', id: 12, slot: 102 },  // radius
      { k: 'sig', id: 20, slot: 200 },    // opacity
      { k: 'special', tag: 'camera', id: 2 },  // camera
    ];

    const result = lowerRenderInstances3D({ ctx, inputs });

    expect(result.outputs).toEqual([]);
    expect(result.declares.renderSink).toBeDefined();
    expect(ctx.b.renderSink).toHaveBeenCalledWith('instances3d', {
      domain: 1,
      positions3d: 100,
      color: 101,
      radius: 102,
      opacity: 200,
      camera: 2,
    });
  });

  it('lowers successfully with camera omitted (default injection)', () => {
    const ctx = createMockLowerCtx();
    const inputs: ValueRefPacked[] = [
      { k: 'special', tag: 'domain', id: 1 },
      { k: 'field', id: 10, slot: 100 },
      { k: 'field', id: 11, slot: 101 },
      { k: 'field', id: 12, slot: 102 },
      { k: 'sig', id: 20, slot: 200 },
      undefined,  // camera omitted
    ];

    const result = lowerRenderInstances3D({ ctx, inputs });

    expect(ctx.b.renderSink).toHaveBeenCalledWith('instances3d', {
      domain: 1,
      positions3d: 100,
      color: 101,
      radius: 102,
      opacity: 200,
      camera: undefined,  // Pass8 will inject default
    });
  });

  it('throws if domain is not Special<domain>', () => {
    const ctx = createMockLowerCtx();
    const inputs: ValueRefPacked[] = [
      { k: 'field', id: 1, slot: 10 },  // WRONG: should be special
      { k: 'field', id: 10, slot: 100 },
      { k: 'field', id: 11, slot: 101 },
      { k: 'field', id: 12, slot: 102 },
      { k: 'sig', id: 20, slot: 200 },
    ];

    expect(() => lowerRenderInstances3D({ ctx, inputs }))
      .toThrow('RenderInstances3D requires a Domain input');
  });

  it('throws if positions3d is not Field<vec3>', () => {
    const ctx = createMockLowerCtx();
    const inputs: ValueRefPacked[] = [
      { k: 'special', tag: 'domain', id: 1 },
      { k: 'sig', id: 10, slot: 100 },  // WRONG: should be field
      { k: 'field', id: 11, slot: 101 },
      { k: 'field', id: 12, slot: 102 },
      { k: 'sig', id: 20, slot: 200 },
    ];

    expect(() => lowerRenderInstances3D({ ctx, inputs }))
      .toThrow('RenderInstances3D requires Field<vec3> positions3d');
  });

  // Add more error cases...
});
```

---

## P2: End-to-End Validation

**Scope:** Verify full pipeline from Camera + Domain → Canvas

### Acceptance Criteria

- [ ] Create test patch with Camera block
- [ ] Create test patch with DomainN block
- [ ] Create test patch with Spatial3D positions (or constant Field<vec3>)
- [ ] Create test patch with Field<color>
- [ ] Connect all to RenderInstances3D
- [ ] Compile patch to IR
- [ ] Verify CameraIR in program.cameras
- [ ] Verify StepInstances3DProjectTo2D in schedule
- [ ] Execute schedule with mock viewport
- [ ] Verify Instance2DBufferRef output
- [ ] Verify projected x/y coordinates are in screen space
- [ ] Verify RGBA channels populated correctly

### Test File

**Location:** `src/editor/compiler/blocks/domain/__tests__/RenderInstances3D.e2e.test.ts` (NEW)

**Structure:**
```typescript
describe('RenderInstances3D end-to-end', () => {
  it('compiles and executes 3D → 2D projection pipeline', () => {
    // 1. Create patch with Camera + Domain + RenderInstances3D
    // 2. Compile to IR
    // 3. Verify IR structure
    // 4. Execute schedule
    // 5. Verify output buffers
  });
});
```

---

## Implementation Order

### Phase 1: Investigation (30 min)
1. Locate renderSink handler implementation
2. Understand color field splitting mechanism
3. Verify StepInstances3DProjectTo2D is already in StepIR union (it is)

### Phase 2: Block Definition (1-2 hours)
1. Create `src/editor/compiler/blocks/domain/RenderInstances3D.ts`
2. Define port declarations
3. Implement `lowerRenderInstances3D` function
4. Register block type
5. Export from module

### Phase 3: Sink Handler (2-3 hours)
1. Add 'instances3d' case to renderSink dispatcher
2. Implement color channel splitting
3. Construct StepInstances3DProjectTo2D
4. Register step in render phase
5. Handle default camera (undefined → pass8 injection)

### Phase 4: Testing (1-2 hours)
1. Unit tests for block lowering
2. Error handling tests
3. Integration test with Camera block
4. End-to-end validation test

### Phase 5: Validation (30 min)
1. Run full test suite
2. Verify TypeScript compilation
3. Manual test in UI (if time permits)

---

## Risk Assessment

### Low Risk
- Block definition (well-established pattern)
- Port declarations (straightforward from spec)
- Validation logic (copy from RenderInstances2D)

### Medium Risk
- Render sink handler location (need to investigate)
- Color channel splitting (mechanism unclear)
- Integration with pass8 default camera injection

### High Risk
- None identified

### Mitigation Strategies

**For Medium Risks:**
1. **Sink handler location:** Start with grep search, follow code to dispatcher
2. **Color splitting:** Check Instance2DBufferRef usage in existing code, may need to ask for guidance
3. **Pass8 integration:** Test with camera=undefined, verify default injection works

---

## Open Questions

1. **Where is renderSink handler?** → INVESTIGATE in Phase 1
2. **How to split Field<color> into RGBA?** → INVESTIGATE in Phase 1
3. **Should projection options be exposed as inputs?** → DEFER (use defaults)
4. **Should mesh be an input?** → DEFER (out of scope for MVP)
5. **Should rotation/scale be supported?** → DEFER (positions only for now)

---

## Success Criteria

### Definition of Done
- RenderInstances3D block type defined and registered
- Block lowering validates inputs and registers render sink
- Render sink handler emits StepInstances3DProjectTo2D
- Test coverage for block lowering and error cases
- End-to-end test verifies 3D → 2D projection pipeline
- All tests passing
- TypeScript compiles without errors
- No new linter warnings

### Verification Steps
1. Run `just check` (typecheck + lint + test)
2. Verify block appears in block registry
3. Verify block can be instantiated in patch
4. Verify compilation to IR succeeds
5. Verify execution produces Instance2DBufferRef
6. Verify output connects to Canvas renderer

---

## References

### Design Docs
- design-docs/13-Renderer/07-3d-Canonical.md (§7.2 - Instances3D_ProjectTo2D contract)
- design-docs/13-Renderer/06-3d-IR-Deltas.md (§3 - Projection pass)
- design-docs/12-Compiler-Final/16-Block-Lowering.md

### Implementation
- src/editor/compiler/blocks/domain/RenderInstances2D.ts (2D pattern)
- src/editor/compiler/blocks/scene/Camera.ts (Camera block reference)
- src/editor/runtime/executor/steps/executeInstances3DProject.ts (Runtime executor)
- src/editor/compiler/ir/types3d.ts (Type definitions)

### Tests
- src/editor/runtime/executor/steps/__tests__/executeInstances3DProject.test.ts (Step tests)
