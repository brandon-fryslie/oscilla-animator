# Sprint Plan: Type Contracts + IR Plumbing
**Generated:** 2025-12-31-045033
**Source:** STATUS-20251231.md
**Topic:** type-contracts-ir-plumbing

---

## Executive Summary

**Current State:**
- Adapter/Lens IR compilation: ✅ COMPLETE (implemented in pass8, commit e4143af)
- TypeDesc unification: ❌ NOT STARTED (two incompatible definitions exist)
- DefaultSource materialization: ⚠️ PARTIAL (works but inconsistent, no shared helper)
- Pass 8 validation: ⚠️ PARTIAL (basic errors work, missing output/bus validation)
- Test suite: ⚠️ BLOCKED (typecheck fails on missing `debugProbes` field)

**Gap Analysis:**
The core blocker is **TypeDesc fragmentation**. The editor and compiler have evolved separate, incompatible type contracts. This prevents proper type checking across compiler boundaries, creates confusion about bundle types and bus eligibility, and makes it unclear which world union (`config` vs `special`) is authoritative.

**Strategy (per user clarification):**
- **TypeDesc Unification:** Option B - Create unified TypeDesc in `src/core/types.ts`
- **Bundle Types:** Include `lanes[]` (semantic shape) in unified TypeDesc; keep packing strategy IR/runtime-only
- **World Union:** Unify to `'config'` only (explicit "not runtime-evaluated" world); IR-internal specials are non-TypeDesc metadata

**Sprint Scope:**
This sprint delivers **3 core deliverables** that can be completed as a cohesive unit:

1. **Unified TypeDesc Contract** - Single authoritative type contract in `src/core/types.ts`
2. **DefaultSource Shared Helper** - Extract and align defaultSource materialization logic
3. **Pass 8 Validation Hardening** - Add output/bus validations, fix test blockers

**Recommended Execution Order:**
1. Fix test blocker first (Priority 0) - 15 minutes
2. Implement TypeDesc unification (Deliverable 1) - foundational
3. Align defaultSource with unified types (Deliverable 2) - depends on 1
4. Complete Pass 8 validation (Deliverable 3) - depends on 1 & 2

**Deferred Work:**
- Performance optimization (not in scope)
- Advanced lens parameter bindings (TODO already documented)
- End-to-end runtime verification (separate testing workstream)

---

## P0 (Critical): Fix Test Blocker

**Status:** NOT STARTED
**Effort:** Small (15 minutes)
**Dependencies:** None
**Spec Reference:** N/A (tooling fix) • **Status Reference:** STATUS-20251231.md lines 30-40

### Description
Typecheck fails because test mocks in `state-offset-resolution.test.ts` are missing the `debugProbes` field from `BuilderProgramIR`. This blocks the entire check pipeline (typecheck → lint → test).

**Root Cause:**
Recent work added `debugProbes` to `BuilderProgramIR` interface, but test mocks were not updated.

**Impact:**
Cannot run tests or verify any other deliverables until this is resolved.

### Acceptance Criteria
- [ ] Add `debugProbes` field to all 6 test mocks in `src/editor/compiler/ir/__tests__/state-offset-resolution.test.ts`
- [ ] `just typecheck` passes without errors
- [ ] Test file imports and runs without type errors
- [ ] Mock structure matches current `BuilderProgramIR` interface exactly

### Technical Notes
- Field type is likely `Map<string, DebugProbeEntry>` or similar (check `BuilderProgramIR` definition)
- Can use empty Map/object for test mocks unless tests specifically verify probe behavior
- Run `just typecheck` after changes to verify fix

---

## P0 (Critical): Unified TypeDesc Contract

**Status:** NOT STARTED
**Effort:** Large (1-2 days)
**Dependencies:** P0 test blocker fixed
**Spec Reference:** CLAUDE.md Type Hierarchy section • **Status Reference:** STATUS-20251231.md lines 51-98

### Description
Create a single, authoritative `TypeDesc` interface in `src/core/types.ts` that serves both editor and compiler. Currently, two incompatible definitions exist:

- **Editor TypeDesc** (`src/editor/types.ts`): Has `category`, `busEligible`, uses `'config'` world
- **IR TypeDesc** (`src/editor/compiler/ir/types.ts`): Has `bundleKind`/`bundleArity`, uses `'special'` world

This fragmentation creates type incompatibilities, prevents proper type checking, and makes bundle/bus semantics ambiguous.

**Unification Strategy (per user):**
- Location: `src/core/types.ts` (shared between editor and compiler)
- Bundle types: Include `lanes: number[]` (semantic shape) in unified TypeDesc
- World union: Use `'config'` only (not `'special'`)
- Bus metadata: Include `busEligible` in unified TypeDesc
- Category: Include `category` in unified TypeDesc

### Acceptance Criteria
- [ ] Create unified `TypeDesc` interface in `src/core/types.ts` with fields:
  - `world: TypeWorld` (union includes `'signal' | 'event' | 'field' | 'scalar' | 'config'`)
  - `domain: Domain` (migrate from editor/Domain type)
  - `category: TypeCategory` (migrate from editor)
  - `busEligible: boolean` (migrate from editor)
  - `lanes?: number[]` (NEW - semantic shape, replaces bundleKind/bundleArity)
  - `semantics?: string` (preserved from both)
  - `unit?: string` (preserved from both)
- [ ] Update editor (`src/editor/types.ts`) to re-export unified TypeDesc:
  - Remove local TypeDesc definition
  - Export `type TypeDesc = CoreTypeDesc` from core/types
  - Update all editor code to use re-exported type
- [ ] Update compiler IR (`src/editor/compiler/ir/types.ts`) to use unified TypeDesc:
  - Remove local TypeDesc definition
  - Import from `src/core/types.ts`
  - Update all IR code to use unified type
- [ ] Migrate `'special'` world references to appropriate alternatives:
  - If crossing editor/compiler boundary → `'config'`
  - If IR-internal metadata → remove from TypeDesc, use opaque IDs or enums
- [ ] Create migration helper `bundleKindToLanes(kind: BundleKind): number[]`:
  - Maps `'scalar'` → `[1]`, `'vec2'` → `[2]`, `'vec3'` → `[3]`, `'rgba'` → `[4]`, etc.
  - Use during migration, remove once all code uses `lanes`
- [ ] All typecheck errors resolved (no incompatible TypeDesc errors)
- [ ] Unit tests pass for type utilities (if any exist)

### Technical Notes

**lanes vs bundleKind/bundleArity:**
- `lanes` describes semantic shape (e.g., `[3]` = single 3-component vector, `[3, 3]` = two 3-component vectors)
- Compiler/scheduler uses `lanes` for slot allocation and buffer materialization
- Editor uses `lanes` for port rendering, defaultSource validation, auto-adapter suggestions
- Packing strategy (AoS/SoA, buffer formats) remains IR/runtime-only (NOT in TypeDesc)

**Migration Path:**
1. Create unified TypeDesc in `src/core/types.ts` (new file)
2. Update editor imports (easy - mostly compatible)
3. Update compiler IR imports (harder - need to migrate bundleKind → lanes)
4. Search for all `world === 'special'` and replace with appropriate alternative
5. Run `just typecheck` iteratively to catch all breaking changes
6. Clean up old TypeDesc definitions once migration complete

**Special → Config Migration:**
- Domain handles: `'config'` (not evaluated at runtime)
- Opaque IDs (schedule refs, buffer handles): Remove from TypeDesc entirely, use separate types
- Anything crossing editor/compiler boundary: Must be `'config'` if not signal/field/scalar/event

**Rollback Plan:**
If migration introduces runtime bugs, keep unified TypeDesc but add feature flag to toggle between old/new behavior until stabilized.

---

## P1 (High): DefaultSource Shared Helper

**Status:** NOT STARTED
**Effort:** Medium (3-5 days)
**Dependencies:** P0 TypeDesc unification complete
**Spec Reference:** CLAUDE.md Philosophy (looping/signal flow) • **Status Reference:** STATUS-20251231.md lines 128-235

### Description
Extract defaultSource materialization logic into a single shared helper used by both pass6 (block lowering) and pass8 (link resolution). Currently, two separate implementations exist with subtle differences:

- **Pass6**: Coerces non-numeric signal values to numbers (lossy)
- **Pass8**: Uses const pool for non-numeric signal values (preserves data)
- **Pass6**: Handles `special/domain` types
- **Pass8**: Returns `null` for `special/domain`

This inconsistency creates unpredictable behavior depending on which compiler pass resolves the default.

**Alignment Strategy:**
- Use const pool approach for non-numeric signals (Pass8 behavior is correct)
- Document that `'config'` world defaults use const pool (since they're non-runtime)
- Remove `special/domain` handling entirely (should use `'config'` after TypeDesc unification)

### Acceptance Criteria
- [ ] Create `src/editor/compiler/ir/defaultSourceUtils.ts` with exported helper:
  ```typescript
  export function materializeDefaultSource(
    builder: IRBuilder,
    type: TypeDesc,
    value: unknown
  ): ValueRefPacked | null
  ```
- [ ] Helper handles all worlds consistently:
  - `signal` (numeric): `sigConst` + `allocValueSlot` + `registerSigSlot` → `{ k: "sig", id, slot }`
  - `signal` (non-numeric): `allocConstId` → `{ k: "scalarConst", constId }`
  - `field`: `fieldConst` + `allocValueSlot` + `registerFieldSlot` → `{ k: "field", id, slot }`
  - `scalar`: `allocConstId` → `{ k: "scalarConst", constId }`
  - `config`: `allocConstId` → `{ k: "scalarConst", constId }`
  - `event`: Return `null` (events have no default values)
- [ ] Update Pass6 (`src/editor/compiler/passes/pass6-block-lowering.ts` lines 308-342):
  - Replace inline defaultSource logic with call to `materializeDefaultSource()`
  - Remove `special/domain` special case (no longer needed after TypeDesc unification)
  - Verify signal non-numeric handling now uses const pool (not coercion)
- [ ] Update Pass8 (`src/editor/compiler/passes/pass8-link-resolution.ts` lines 155-185):
  - Replace `createDefaultRef()` local helper with call to `materializeDefaultSource()`
  - Add `config` world handling (same as scalar)
- [ ] Add unit tests for `materializeDefaultSource()`:
  - Signal numeric: Returns sig + slot
  - Signal non-numeric (e.g., string): Returns scalarConst
  - Field: Returns field + slot
  - Scalar: Returns scalarConst
  - Config: Returns scalarConst
  - Event: Returns null
  - Verify `lanes` field is respected (if TypeDesc has lanes, allocate correct slot count)
- [ ] Integration test: Verify defaults resolve identically in pass6 and pass8 paths
- [ ] No regressions in existing defaultSource behavior (run full test suite)

### Technical Notes

**Signal Non-Numeric Handling:**
- Old behavior (Pass6): `const numValue = typeof value === 'number' ? value : ...coerce...`
- New behavior (shared): Use const pool for non-numeric (same as scalar)
- Rationale: Non-numeric signals are likely assets/handles that should be const

**Config World:**
- After TypeDesc unification, `config` replaces `special`
- Config values are non-runtime (not evaluated per-frame)
- Should behave same as scalar (const pool)

**Lanes/Bundle Handling:**
- If TypeDesc has `lanes: [3]`, should allocate 3 consecutive slots
- Helper should call `builder.allocValueSlot(type)` which respects lanes
- Test with bundle types (vec2, vec3, rgba) to verify slot allocation

**Error Handling:**
- Return `null` for unsupported worlds (graceful degradation)
- Emit diagnostic if value type incompatible with TypeDesc domain (e.g., string for numeric domain)

---

## P1 (High): Harden Pass 8 Link Resolution

**Status:** NOT STARTED
**Effort:** Medium (3-5 days)
**Dependencies:** P0 TypeDesc unification, P1 defaultSource helper
**Spec Reference:** CLAUDE.md Critical Rules (fail fast) • **Status Reference:** STATUS-20251231.md lines 237-282

### Description
Add missing validations to pass8 link resolution to catch misconfigured patches at compile-time. Currently, basic error detection exists (dangling wires, missing inputs), but critical validation gaps remain:

- **Output slots:** No validation that block outputs are properly registered
- **Bus publishers:** No validation that bus roots have at least one publisher
- **Null ValueRefs:** Unclear when null is expected (non-IR types) vs problematic (missing data)

These gaps allow invalid IR to reach the runtime, causing silent failures or confusing runtime errors instead of clear compile-time diagnostics.

**Validation Strategy:**
- Iterate all block output ports, verify slots are registered in IR
- Iterate all bus roots, verify at least one block publishes to each
- Document null ValueRef expectations (when it's valid vs error)

### Acceptance Criteria
- [ ] **Output Slot Validation:**
  - After all blocks lowered, iterate `blockOutputRoots` in IR
  - For each output, verify slot is registered (check `sigSlots`, `fieldSlots`, or `scalarConsts`)
  - Emit `MissingOutputRegistration` diagnostic if output has no slot
  - Include `{ blockId, portId, type }` in error metadata
- [ ] **Bus Publisher Validation:**
  - After bus lowering (pass7), iterate `busRoots` in IR
  - For each bus, verify at least one block output publishes to it
  - Check block outputs' `busTargets` field for matching bus ID
  - Emit `BusWithoutPublisher` diagnostic if bus has zero publishers
  - Include `{ busId, busType }` in error metadata
- [ ] **Null ValueRef Documentation:**
  - Add code comment in pass8 wire resolution (near line 625) explaining:
    - When null is expected: Non-IR types (Domain, Event without data)
    - When null is error: IR types (signal/field/scalar) with missing data
  - Add runtime assertion: If null for IR type, emit diagnostic instead of silent skip
- [ ] Add unit tests for new validations:
  - Block with output port but no slot registration → `MissingOutputRegistration` error
  - Bus with zero publishers → `BusWithoutPublisher` error
  - Wire to signal port resolves to null → diagnostic emitted
  - Event port resolves to null → NO error (expected behavior)
- [ ] Integration test: Build patch with intentional validation errors, verify all diagnostics emitted
- [ ] Verify error messages are actionable (include block/port/bus names, not just IDs)

### Technical Notes

**Output Slot Registration Check:**
- `blockOutputRoots: Map<string, Map<string, ValueRefPacked>>`
- For each `ValueRefPacked`, check its `k` field:
  - `"sig"` → verify `id` exists in `sigSlots`
  - `"field"` → verify `id` exists in `fieldSlots`
  - `"scalarConst"` → verify `constId` exists in `scalarConsts`
  - `"special"` → skip (not runtime-evaluated)
- If missing, emit error with block/port info

**Bus Publisher Check:**
- `busRoots: Map<string, BusRoot>`
- For each bus ID, search all `blockOutputRoots` for `ValueRefPacked` with matching bus target
- Alternative: Track publisher count during pass7, store in BusRoot metadata
- If count === 0, emit error

**Null ValueRef Handling:**
- Current code (line 625-628): "expected for non-IR types - NOT an error"
- Problem: No way to distinguish intended null (Event) from problematic null (missing signal data)
- Solution: Check TypeDesc world:
  - If `world === 'event'` → null is expected
  - If `world === 'signal' | 'field' | 'scalar'` → null is error
  - If `world === 'config'` → null might be error (depends on context)

**Error Message Quality:**
- Include human-readable names (block.name, port.label) not just IDs
- Suggest fix: "Block 'Oscillator' output 'phase' has no slot registration. Did you forget to call registerSigSlot()?"
- Link to relevant compiler pass in message for developer debugging

**Testing Strategy:**
- Create minimal test patches that trigger each validation error
- Verify error codes match expected values
- Verify error metadata contains expected fields
- Check that valid patches still compile without false positives

---

## Dependency Graph

```
P0: Fix Test Blocker (15 min)
  └─> UNBLOCKS all other work

P0: Unified TypeDesc (1-2 days)
  └─> REQUIRED BY defaultSource helper (uses unified TypeDesc)
  └─> REQUIRED BY pass8 validation (checks TypeDesc.world for null handling)

P1: DefaultSource Shared Helper (3-5 days)
  └─> DEPENDS ON unified TypeDesc
  └─> USED BY pass6 and pass8

P1: Harden Pass 8 Validation (3-5 days)
  └─> DEPENDS ON unified TypeDesc (null handling checks TypeDesc.world)
  └─> DEPENDS ON defaultSource helper (validation tests use defaults)
```

---

## Recommended Sprint Planning

### Sprint Goal
Establish a unified type contract across editor and compiler, eliminate defaultSource inconsistencies, and harden IR validation to catch errors at compile-time.

### Iteration 1: Foundation (Days 1-2)
1. Fix test blocker (15 min)
2. Start TypeDesc unification:
   - Create `src/core/types.ts` with unified interface
   - Update editor imports (easier migration first)
   - Run typecheck, fix editor-side breaks

### Iteration 2: Compiler Migration (Days 3-4)
3. Complete TypeDesc unification:
   - Update compiler IR imports
   - Migrate `bundleKind/bundleArity` → `lanes`
   - Replace `'special'` → `'config'` or remove from TypeDesc
   - Run full typecheck, fix all breaks

### Iteration 3: Consistency (Days 5-7)
4. Implement defaultSource helper:
   - Extract shared logic to `defaultSourceUtils.ts`
   - Update pass6 and pass8 to use helper
   - Add unit tests for all worlds
5. Start pass8 validation:
   - Add output slot validation
   - Add unit tests

### Iteration 4: Hardening (Days 8-10)
6. Complete pass8 validation:
   - Add bus publisher validation
   - Document null ValueRef expectations
   - Add integration tests
7. Full regression check:
   - Run `just check` (typecheck + lint + test)
   - Manual verification with dev server
   - Verify error messages are actionable

---

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| **TypeDesc migration breaks existing code** | HIGH - Could break editor UI, compiler passes, runtime | Incremental migration (editor first, then compiler). Keep both definitions temporarily during migration. Feature flag for rollback. |
| **Bundle type migration (bundleKind → lanes) is complex** | MEDIUM - Many code references, subtle semantic changes | Create migration helper `bundleKindToLanes()`. Search codebase for all bundleKind/bundleArity refs. Add tests for each bundle type. |
| **DefaultSource helper misses edge case** | MEDIUM - Could cause runtime errors or silent failures | Extract existing logic exactly (no behavior changes initially). Add unit tests for all edge cases. Integration test comparing old vs new behavior. |
| **Pass8 validation too strict (false positives)** | LOW - Could reject valid patches | Start with warnings, upgrade to errors after testing. Add escape hatch for known-safe patterns. Document validation rules. |
| **'special' → 'config' migration breaks runtime** | HIGH - If misidentified, could cause runtime type errors | Audit all `world === 'special'` usages before migrating. Add runtime assertions for config values. Test with actual patches. |
| **Null ValueRef validation breaks Event handling** | MEDIUM - Events legitimately have null values | Check TypeDesc.world before emitting errors. Add tests for Event nulls. Document expected null cases. |

---

## Success Metrics

### Technical Metrics
- **Type Safety:** Zero TypeDesc incompatibility errors across editor/compiler boundary
- **Consistency:** DefaultSource behavior identical in pass6 and pass8 paths
- **Validation Coverage:** All IR validation rules documented and tested
- **Test Pass Rate:** 100% of existing tests pass after migration

### Quality Metrics
- **Compile-Time Errors:** Invalid patches caught at compile with actionable messages
- **Runtime Stability:** No new runtime errors introduced by type contract changes
- **Code Clarity:** Single authoritative TypeDesc, clear world semantics, documented null handling

### Developer Experience
- **Onboarding:** New contributors can understand type system from one location
- **Debugging:** Type errors point to root cause (not "incompatible types")
- **Confidence:** Compiler validates IR correctness before runtime

---

## Deferred Work (Out of Scope)

The following items are NOT in this sprint:

1. **Advanced Lens Parameter Bindings** - TODO documented in pass8, wire/bus param bindings for lenses (future enhancement)
2. **Performance Optimization** - Bundle packing strategies (AoS/SoA), SIMD, GPU buffer formats (runtime workstream)
3. **End-to-End Runtime Verification** - Chrome DevTools MCP testing, visual regression tests (separate testing workstream)
4. **Domain Migration to Config** - Large refactor, needs separate planning (currently `special/domain`, should be `config`)
5. **Type Inference** - Auto-detect types from values, smart defaultSource suggestions (future UX enhancement)

---

## Workflow Notes

### Before Starting
1. Read STATUS-20251231.md (lines 51-282) for detailed current state
2. Verify test blocker is only issue blocking typecheck
3. Check for conflicting work in other branches

### During Implementation
1. Run `just typecheck` after every significant change
2. Keep both TypeDesc definitions during migration (remove only when 100% migrated)
3. Use feature flag if runtime behavior changes are risky
4. Document all `'special'` → `'config'` migrations in commit messages

### Testing Strategy
1. Unit tests for isolated helpers (materializeDefaultSource, bundleKindToLanes)
2. Integration tests for compiler passes (pass6/pass8 with defaults, pass8 validation)
3. Regression tests for existing behavior (no behavioral changes intended)
4. Manual testing with dev server after all changes

### Definition of Done (Sprint Level)
- [ ] All P0 and P1 deliverables complete with acceptance criteria met
- [ ] `just check` passes (typecheck + lint + test)
- [ ] No new runtime errors introduced
- [ ] All validation errors include actionable messages
- [ ] Code review completed
- [ ] Commits follow convention (feat/fix/refactor)

---

**End of Plan**
