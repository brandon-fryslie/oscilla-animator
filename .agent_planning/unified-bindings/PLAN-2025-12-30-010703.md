# Implementation Plan: Unified Bindings UI Architecture Refactor
Generated: 2025-12-30-010703
Source: STATUS-20251230.md
Spec: plans/PLAN-UNIFIED-BINDINGS.md

## Executive Summary

**Current State**: 0% complete, no blockers, TypeScript clean, 1063 tests passing

**Goal**: Unify "block→block wires" and "block↔bus bindings" under one shared abstraction to eliminate duplication across 5+ UI components and centralize all wire/publisher/listener branching logic.

**Total Work**: 4 sprints (estimated 6-8 hours total)
- Sprint 1: Binding Facade Foundation (1-2 hours)
- Sprint 2: High-Value UI Migration (2-3 hours)
- Sprint 3: Complete UI Migration (1-2 hours)
- Sprint 4: Validation Layer (Optional, 1 hour)

**Key Wins**:
- Remove 5+ copies of "find compatible buses" logic
- Remove 3+ copies of tri-array scanning in UI
- Single source of truth for binding resolution
- 90% code reuse for lens/adapter editing

**Critical Scope Exclusion**: This plan **IGNORES lenses and adapters entirely** per user instruction. We skip:
- setBindingLensStack, setBindingAdapterChain
- Lens stack UI updates
- Adapter chain UI updates

---

## Dependency Graph

```
Sprint 1 (Foundation)
    ↓
Sprint 2 (High-Value UI)  ← Must complete before Sprint 3
    ↓
Sprint 3 (Complete UI)    ← Can run in parallel with Sprint 4
    ↓
Sprint 4 (Validation)     ← Optional
```

---

## Sprint 1: Binding Facade Foundation

**Status**: Not Started
**Effort**: Small (1-2 hours)
**Dependencies**: None
**Spec Reference**: PLAN-UNIFIED-BINDINGS.md §4, §5, §6 • STATUS-20251230.md §Phase 1

### Description
Create the core binding facade abstraction that becomes the **only** place in the codebase that branches on wire/publisher/listener. This provides a unified API for both read (queries) and write (mutations) operations.

Evidence from STATUS:
- Three edge types already have near-identical metadata (STATUS §1)
- SemanticGraph already unifies edges as `GraphEdge` (STATUS §5)
- Store APIs exist, just need thin wrappers (STATUS §2)

### Acceptance Criteria
- [ ] File `src/editor/bindings/types.ts` exists with all required types:
  - [ ] `BindingKind = 'wire' | 'publisher' | 'listener'`
  - [ ] `BindingRef` with discriminated union on `kind`
  - [ ] `EndpointRef` for port vs bus endpoints
  - [ ] `NormalizedBinding` with NO optional fields (wire/publisher/listener variants)
  - [ ] `ResolvedEndpoint` (port vs bus, with block/slot/bus/type resolved)
  - [ ] `ResolvedBinding` (binding + from + to endpoints)
- [ ] File `src/editor/bindings/read.ts` exists with read-side facade:
  - [ ] `resolveBinding(root, ref): ResolvedBinding` - single resolution for all kinds
  - [ ] `getIncomingBindingForInputPort(root, blockId, slotId): NormalizedBinding | null` - returns wire OR listener
  - [ ] `getOutgoingBindingsForOutputPort(root, blockId, slotId): NormalizedBinding[]` - returns wires + publishers
  - [ ] `getPublishersForBus(root, busId): NormalizedBinding[]`
  - [ ] `getListenersForBus(root, busId): NormalizedBinding[]`
  - [ ] `isPortPublishingToBus(root, portRef, busId): boolean`
  - [ ] `isPortSubscribedToBus(root, portRef, busId): boolean`
- [ ] File `src/editor/bindings/write.ts` exists with write-side facade:
  - [ ] `disconnectBinding(root, ref)` - unified disconnect (calls patchStore.disconnect or busStore.removePublisher/removeListener based on kind)
  - [ ] `setBindingEnabled(root, ref, enabled)` - unified enable/disable (calls patchStore.updateConnection or busStore.updatePublisher/updateListener)
- [ ] File `src/editor/bindings/index.ts` exists and re-exports all public APIs
- [ ] `BusStore.updateListener()` signature expanded to accept `adapterChain` in updates:
  - [ ] Current signature: `updates: Partial<Pick<Listener, 'enabled' | 'lensStack'>>`
  - [ ] Updated signature: `updates: Partial<Pick<Listener, 'enabled' | 'lensStack' | 'adapterChain'>>`
  - [ ] Location: `src/editor/stores/BusStore.ts:405`
- [ ] TypeScript compiles clean (no new errors)
- [ ] Existing tests still pass (1063 tests)
- [ ] Sanity check: Can import facade in scratch file and call functions without runtime crash

### Technical Notes
**Normalization Rules**:
- Wire `enabled?: boolean` → normalize missing to `true`
- All `lensStack?: LensInstance[]` → normalize missing to `[]`
- All `adapterChain?: AdapterStep[]` → normalize missing to `[]`

**resolveBinding() Implementation**:
```typescript
// Pseudo-code outline
switch (ref.kind) {
  case 'wire':
    // Find in root.patchStore.connections
    // Resolve from/to ports → block + slot + type
  case 'publisher':
    // Find in root.busStore.publishers
    // Resolve from port, to bus
  case 'listener':
    // Find in root.busStore.listeners
    // Resolve from bus, to port
}
```

**Type Resolution**:
- Port type: `SLOT_TYPE_TO_TYPE_DESC[slot.type]`
- Bus type: `bus.type`

**Why First**:
- Foundation for all subsequent UI work
- Isolates all branching logic in one module
- Can be built and tested independently before UI changes

---

## Sprint 2: High-Value UI Migration

**Status**: Not Started
**Effort**: Medium (2-3 hours)
**Dependencies**: Sprint 1 (Binding Facade Foundation)
**Spec Reference**: PLAN-UNIFIED-BINDINGS.md §7.2, §7.3, §7.4 • STATUS-20251230.md §Phase 2 Steps 1-3

### Description
Migrate the three highest-impact UI components to use the binding facade, removing all manual tri-scanning of connections/publishers/listeners. These three components are the core of the connection UI and account for the most significant duplication.

Evidence from STATUS:
- ConnectionInspector has 90% identical lens editing logic repeated 3+ times (STATUS §3, lines 172-188, 272-288, 371-387)
- PatchBay `getConnectionInfo()` scans 3 arrays per port render - O(N²) performance issue (STATUS §3, lines 475-510)
- Inspector port panel queries both patchStore AND busStore separately (STATUS §3)

### Work Items

#### 2.1: Migrate ConnectionInspector.tsx
**Acceptance Criteria**:
- [ ] Replace manual resolution logic (lines 703-867) with single `resolveBinding(root, ref)` call
- [ ] Keep existing view components (WireConnectionView, PublisherConnectionView, ListenerConnectionView) unchanged initially
- [ ] Data flow: BindingRef → resolveBinding() → ResolvedBinding → view component
- [ ] TypeScript compiles clean
- [ ] Manual verification: Open ConnectionInspector for wire, verify correct data displayed
- [ ] Manual verification: Open ConnectionInspector for publisher, verify correct data displayed
- [ ] Manual verification: Open ConnectionInspector for listener, verify correct data displayed

**Technical Notes**:
- This is the lowest-risk migration because ConnectionInspector already handles all three kinds
- Just changing data source from manual resolution to facade
- Later work can unify the view components, but not required for this sprint

#### 2.2: Migrate Inspector.tsx Port Panel
**Acceptance Criteria**:
- [ ] Replace `getConnectionsForPort()` helper with facade queries
- [ ] For input ports: call `getIncomingBindingForInputPort(root, blockId, slotId)`
- [ ] For output ports: call `getOutgoingBindingsForOutputPort(root, blockId, slotId)`
- [ ] Remove direct scans of `busStore.publishers` and `busStore.listeners`
- [ ] Port panel renders bindings without knowing if they are wires or bus edges
- [ ] Clicking a binding row selects connection via `uiStore.selectConnection(kind, id)` (already supported)
- [ ] TypeScript compiles clean
- [ ] Manual verification: Select block with wired input, verify Inspector shows wire
- [ ] Manual verification: Select block with bus listener, verify Inspector shows listener
- [ ] Manual verification: Select block with output publishing to bus, verify Inspector shows publisher
- [ ] Manual verification: Clicking binding row in Inspector selects correct connection in ConnectionInspector

**Technical Notes**:
- Input writer invariant guarantees at most one incoming binding
- Output can have multiple bindings (wires + publishers)
- Performance win: No more O(N) scans per selected port

#### 2.3: Migrate PatchBay.tsx Port Decorations
**Acceptance Criteria**:
- [ ] Replace `getConnectionInfo()` function (lines 475-510) with facade calls
- [ ] For input ports: call `getIncomingBindingForInputPort(root, blockId, slotId)`
- [ ] For output ports: call `getOutgoingBindingsForOutputPort(root, blockId, slotId).length` for count
- [ ] Remove tri-scan logic checking connections/publishers/listeners separately
- [ ] Port decorations show correct "connected vs disconnected" glyph
- [ ] Port tooltips show what the port is connected to
- [ ] TypeScript compiles clean
- [ ] Manual verification: Wire two blocks, verify port decorations show "connected" state
- [ ] Manual verification: Publish output to bus, verify output decoration shows bus connection
- [ ] Manual verification: Subscribe input to bus, verify input decoration shows bus connection
- [ ] Manual verification: Port tooltip shows correct destination (block name or bus name)

**Technical Notes**:
- Biggest performance win: `getConnectionInfo()` was called on every port render
- Facade queries can be memoized, tri-scans cannot
- No UI behavior change, just data source optimization

### Sprint-Level Acceptance
- [ ] All three components migrated to facade
- [ ] No manual tri-scans of connections/publishers/listeners remain in these components
- [ ] TypeScript compiles clean
- [ ] All 1063 existing tests still pass
- [ ] Manual verification via Chrome DevTools MCP:
  - [ ] Connect wire between blocks → Inspector and PatchBay show correct state
  - [ ] Publish output to bus → Inspector and PatchBay show correct state
  - [ ] Subscribe input to bus → Inspector and PatchBay show correct state
  - [ ] Input writer invariant preserved (wire replaces listener, listener replaces wire)

### Why These Three Components?
1. **ConnectionInspector**: Already handles all three kinds, easiest migration
2. **Inspector**: High user visibility, directly shows what's connected
3. **PatchBay**: Performance-critical (renders every frame), biggest O(N²) reduction

---

## Sprint 3: Complete UI Migration

**Status**: Not Started
**Effort**: Small (1-2 hours)
**Dependencies**: Sprint 2 (High-Value UI Migration)
**Spec Reference**: PLAN-UNIFIED-BINDINGS.md §7.5, §7.6 • STATUS-20251230.md §Phase 2 Steps 4-5

### Description
Complete the UI migration by refactoring the remaining components that duplicate bus connection logic: BusInspector, BusPicker, and PublishMenu. This removes the last 200+ lines of duplication.

Evidence from STATUS:
- BusInspector has separate PublisherItem/ListenerItem components with duplicated enable/jump/lens logic (STATUS §3)
- BusPicker and PublishMenu have EXACT SAME `getCompatibleBuses()` function duplicated (STATUS §3)
- 5+ copies of "find compatible buses" logic across codebase

### Work Items

#### 3.1: Migrate BusInspector.tsx
**Acceptance Criteria**:
- [ ] Replace direct mapping of `Publisher[]` with `getPublishersForBus(root, busId)`
- [ ] Replace direct mapping of `Listener[]` with `getListenersForBus(root, busId)`
- [ ] Create single unified `BindingItem` component (or reuse existing if possible)
- [ ] Remove `PublisherItem` component (lines 120-162)
- [ ] Remove `ListenerItem` component (lines 168-210)
- [ ] Enable/disable logic unified in single place
- [ ] Jump-to-block logic unified in single place
- [ ] TypeScript compiles clean
- [ ] Manual verification: Select bus, verify publishers list shows correct items
- [ ] Manual verification: Select bus, verify listeners list shows correct items
- [ ] Manual verification: Toggle enable on publisher, verify state changes
- [ ] Manual verification: Toggle enable on listener, verify state changes
- [ ] Manual verification: Click "jump to block" on publisher, verify selection jumps
- [ ] Manual verification: Click "jump to block" on listener, verify selection jumps

**Technical Notes**:
- Publishers and listeners now share 100% of UI logic except label direction
- Can use single component with `direction: 'input' | 'output'` prop
- Later work can add lens editing, but not required for this sprint

#### 3.2: Migrate BusPicker.tsx
**Acceptance Criteria**:
- [ ] Remove local `getCompatibleBuses()` function (lines 34-36)
- [ ] Remove local `isPortSubscribedToBus()` function (lines 38-48)
- [ ] Replace with facade helper `isPortSubscribedToBus(root, portRef, busId)`
- [ ] Use existing `isDirectlyCompatible()` from types.ts for compatibility (can extract to facade later)
- [ ] TypeScript compiles clean
- [ ] Manual verification: Right-click input port → BusPicker shows compatible buses
- [ ] Manual verification: Already-subscribed bus shows "subscribed" indicator
- [ ] Manual verification: Selecting bus subscribes port to bus

**Technical Notes**:
- Compatibility logic can stay using `isDirectlyCompatible()` for now
- Future work: Move compatibility to facade with adapter suggestions

#### 3.3: Migrate PublishMenu.tsx
**Acceptance Criteria**:
- [ ] Remove local `getCompatibleBuses()` function (lines 32-38, exact duplicate of BusPicker)
- [ ] Remove local `getPortPublishers()` function (lines 40-48)
- [ ] Remove local `isPortPublishingToBus()` function (lines 50-57)
- [ ] Replace with facade helper `isPortPublishingToBus(root, portRef, busId)`
- [ ] Use `getOutgoingBindingsForOutputPort()` filtered by `kind === 'publisher'` for port publishers
- [ ] TypeScript compiles clean
- [ ] Manual verification: Right-click output port → PublishMenu shows compatible buses
- [ ] Manual verification: Already-publishing bus shows "published" indicator
- [ ] Manual verification: Selecting bus publishes port to bus

**Technical Notes**:
- This removes the most egregious duplication (exact copy of BusPicker logic)
- After this, ZERO tri-scans remain in UI layer

### Sprint-Level Acceptance
- [ ] All UI components migrated to facade
- [ ] No direct access to `patchStore.connections`, `busStore.publishers`, or `busStore.listeners` from UI components
- [ ] Duplication count reduced from 5+ to 0 for "find compatible buses"
- [ ] Duplication count reduced from 3+ to 0 for "is port connected to bus"
- [ ] TypeScript compiles clean
- [ ] All 1063 existing tests still pass
- [ ] Manual verification via Chrome DevTools MCP:
  - [ ] BusInspector shows correct publishers/listeners
  - [ ] BusPicker shows correct compatible buses and subscription state
  - [ ] PublishMenu shows correct compatible buses and publish state
  - [ ] All enable/disable toggles work
  - [ ] All jump-to-block actions work

---

## Sprint 4: Validation Layer (Optional)

**Status**: Not Started
**Effort**: Small (1 hour)
**Dependencies**: Sprint 2 (High-Value UI Migration) - can run in parallel with Sprint 3
**Spec Reference**: PLAN-UNIFIED-BINDINGS.md §8 • STATUS-20251230.md §Phase 3

### Description
Add preflight validation methods for bus edges to centralize compatibility policy. Currently, validation is scattered across UI components with inconsistent rules.

Evidence from STATUS:
- `Validator.canAddConnection()` exists for wires but no equivalent for publishers/listeners (STATUS §4)
- Compatibility checking scattered across 3+ utilities (STATUS §4)
- No single source of truth for "can these endpoints connect?"

### Acceptance Criteria
- [ ] Add `Validator.canAddPublisher(patchDoc, fromPortRef, busId): ValidationResult` to `src/editor/semantic/validator.ts`
  - [ ] Check: fromPort exists
  - [ ] Check: bus exists
  - [ ] Check: types compatible (direct or adaptable)
  - [ ] Return warning if not compatible but adaptable
- [ ] Add `Validator.canAddListener(patchDoc, busId, toPortRef): ValidationResult` to `src/editor/semantic/validator.ts`
  - [ ] Check: bus exists
  - [ ] Check: toPort exists
  - [ ] Check: types compatible (direct or adaptable)
  - [ ] Check: single-writer invariant (input has no other listener/wire)
  - [ ] Return warning if will replace existing connection
- [ ] Use existing utilities for compatibility checks:
  - [ ] `areSlotTypesCompatible()` from semantic/index.ts
  - [ ] `findAdapterPath()` from adapters/autoAdapter.ts
- [ ] Validation follows warn-only preflight pattern (like `PatchStore.connect()`)
- [ ] TypeScript compiles clean
- [ ] Add unit tests for validation methods:
  - [ ] Test canAddPublisher with compatible types → success
  - [ ] Test canAddPublisher with incompatible types → failure
  - [ ] Test canAddListener with compatible types → success
  - [ ] Test canAddListener with existing listener → warning (will replace)
  - [ ] Test canAddListener with existing wire → warning (will replace)

### Technical Notes
**Integration with Facade** (optional for this sprint):
- `bindings/write.ts` can call these validators before mutations
- Emit warnings to console or DiagnosticHub
- Don't block operations (compiler is ultimate authority)

**ValidationResult Shape** (use existing pattern):
```typescript
type ValidationResult = {
  valid: boolean;
  warnings?: string[];
  errors?: string[];
}
```

**Why Optional**:
- Not required for facade to function
- Can be added later without affecting UI
- Nice-to-have for better error messages

---

## Risk Assessment

### Low Risk
- **Data model alignment**: Types already 90% unified (STATUS §1)
- **Store APIs**: All exist, just need wrappers (STATUS §2)
- **Type system**: Clean, no breaking changes
- **Tests**: Passing, UI refactor won't break them

### Medium Risk
- **UI component refactors**: Large surface area, requires manual testing
- **Performance**: Facade adds indirection, but removes O(N²) scans (net win expected)

### High Risk
None identified.

### Mitigations
- **Incremental migration**: Add facade without changing UI (Sprint 1), then migrate component by component (Sprint 2-3)
- **Manual verification**: Use Chrome DevTools MCP to verify each sprint
- **Rollback plan**: Facade is additive, can revert UI changes independently

---

## Implementation Order Summary

1. **Sprint 1**: Create facade (types, read, write) - no UI changes
2. **Sprint 2**: Migrate high-value UI (ConnectionInspector, Inspector, PatchBay)
3. **Sprint 3**: Migrate remaining UI (BusInspector, BusPicker, PublishMenu)
4. **Sprint 4**: Add validation (optional, can run in parallel with Sprint 3)

Each sprint has manual verification checkpoints via `just dev` + Chrome DevTools MCP.

---

## Success Metrics

### Quantitative
- **Lines of code removed**: 200+ (duplication in BusPicker/PublishMenu alone)
- **Tri-scan removal**: 8+ instances across UI components
- **Components unified**: 3 pairs (PublisherItem/ListenerItem, etc)
- **Single source of truth**: 1 module (bindings/) vs 5+ files

### Qualitative
- **Maintainability**: Future binding features (e.g., conditional edges) only touch facade
- **Performance**: O(N²) scans replaced with O(1) or O(N) queries
- **Testability**: Facade can be unit tested independently of UI
- **Consistency**: All UI components show same data (no mismatch bugs)

---

## Definition of Done (Overall)

### Required (Must Complete)
- [ ] Binding Facade exists in `src/editor/bindings/`
- [ ] All branching on wire/publisher/listener moved to facade
- [ ] ConnectionInspector, Inspector, PatchBay migrated (Sprint 2)
- [ ] BusInspector, BusPicker, PublishMenu migrated (Sprint 3)
- [ ] No direct tri-scans of connections/publishers/listeners in UI
- [ ] Input writer invariant preserved everywhere
- [ ] TypeScript compiles clean
- [ ] All 1063 tests pass
- [ ] Manual verification complete (all checkpoints passed)

### Nice-to-Have (Optional)
- [ ] Validator.canAddPublisher/Listener implemented (Sprint 4)
- [ ] Validation integrated in facade write operations

### Explicitly Out of Scope
- ❌ Lens stack UI updates (per user instruction)
- ❌ Adapter chain UI updates (per user instruction)
- ❌ setBindingLensStack, setBindingAdapterChain (per user instruction)
- ❌ Numeric UI semantics registry (separate work, see PLAN-UNIFIED-BINDINGS.md §9)
- ❌ Any renaming of existing types (Connection, Publisher, Listener)

---

## Next Steps After Completion

1. **Lens/Adapter Refactor**: Once lens system is finalized, add setBindingLensStack/AdapterChain
2. **Numeric Semantics Registry**: Implement as separate work (see PLAN-UNIFIED-BINDINGS.md §9)
3. **Performance Profiling**: Measure facade overhead vs tri-scan savings
4. **Connection UI Polish**: Unify view components (WireConnectionView, PublisherConnectionView, ListenerConnectionView) into single component
