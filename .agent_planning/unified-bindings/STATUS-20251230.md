# Status Report - Unified Bindings Refactor
Timestamp: 2025-12-30-010000
Scope: project/unified-bindings
Confidence: FRESH

## Executive Summary
Overall: 0% complete | Blocking issues: 0 | TypeScript: CLEAN | Tests: PASSING (1063 tests)

**Ready to begin implementation.** No blockers detected. Plan is sound and aligned with existing architecture.

---

## What Exists Today

### 1. Data Model (Already Unified Structure)

The three edge types have **nearly identical metadata**, differing only in endpoint types:

**Connection (Wire)** - `src/editor/types.ts:631-649`
```typescript
interface Connection {
  id: string;
  from: PortRef;        // output port
  to: PortRef;          // input port
  lensStack?: LensInstance[];
  adapterChain?: AdapterStep[];
  enabled?: boolean;    // OPTIONAL (defaults true)
}
```

**Publisher** - `src/editor/types.ts:262-286`
```typescript
interface Publisher {
  id: string;
  busId: string;
  from: PortRef;        // output port
  adapterChain?: AdapterStep[];
  lensStack?: LensInstance[];
  enabled: boolean;     // REQUIRED
  weight?: number;
  sortKey: number;
}
```

**Listener** - `src/editor/types.ts:291-309`
```typescript
interface Listener {
  id: string;
  busId: string;
  to: PortRef;          // input port
  adapterChain?: AdapterStep[];
  enabled: boolean;     // REQUIRED
  lensStack?: LensInstance[];
}
```

**Key observation:** Already 90% structurally unified. Only differences:
- Endpoint types (port vs bus)
- `enabled` field (optional vs required)
- Publisher-only: `sortKey`, `weight`

### 2. Store APIs (Mutation Layer)

**PatchStore** - `src/editor/stores/PatchStore.ts`
- `connect(from, to, adapterChain?, lensStack?)` - creates wire
- `disconnect(connectionId)` - removes wire
- `updateConnection(id, updates: Partial<Connection>)` - updates wire
- `disconnectInputPort(blockId, slotId)` - enforces single-writer invariant

**BusStore** - `src/editor/stores/BusStore.ts`
- `addPublisher(busId, blockId, slotId, adapterChain?, lensStack?, options?)` - creates publisher
- `removePublisher(publisherId, options?)` - removes publisher
- `updatePublisher(id, updates: Partial<Publisher>)` - updates publisher
- `addListener(busId, blockId, slotId, adapterChain?, lensStack?, options?)` - creates listener
  - **Already enforces single-writer**: calls `root.patchStore.disconnectInputPort()` internally
- `removeListener(listenerId, options?)` - removes listener
- `updateListener(id, updates: Partial<Pick<Listener, 'enabled' | 'lensStack'>>)` - updates listener
  - **LIMITATION**: Does NOT support `adapterChain` updates (plan identifies this gap)

**Input Writer Invariant** - Already Enforced:
- `PatchStore.connect()` → calls `disconnectInputPort()` before adding wire
- `BusStore.addListener()` → calls `root.patchStore.disconnectInputPort()` before adding listener
- This ensures an input port has **at most one writer** (wire OR listener, never both)

### 3. UI Components (Duplication Points)

**ConnectionInspector.tsx** - `src/editor/ConnectionInspector.tsx`
- Lines 703-867: Manual resolution logic for wire/publisher/listener
- Separate view components: `WireConnectionView`, `PublisherConnectionView`, `ListenerConnectionView`
- Each implements lens editing independently (lines 172-188, 272-288, 371-387)
- **Code smell**: 90% identical lens editing logic repeated 3+ times

**Inspector.tsx** - `src/editor/Inspector.tsx`
- Port panel shows connections for selected port
- Must query both `patchStore.connections` AND `busStore.publishers/listeners`
- Uses helper `getConnectionsForPort()` (portUtils.ts) which performs tri-scan

**PatchBay.tsx** - `src/editor/PatchBay.tsx:475-510`
```typescript
const getConnectionInfo = (slotId: string, direction: 'input' | 'output'): ConnectionInfo => {
  // Check for block-to-block connections
  const hasBlockConnection = direction === 'input'
    ? connections.some((c) => c.to.blockId === block.id && c.to.slotId === slotId)
    : connections.some((c) => c.from.blockId === block.id && c.from.slotId === slotId);

  // Check for bus connections (publishers/listeners)
  let hasBusConnection = false;
  let busName: string | undefined;
  if (direction === 'input') {
    const listener = listeners.find(l => l.to.blockId === block.id && l.to.slotId === slotId);
    // ...
  } else {
    const publisher = publishers.find(p => p.from.blockId === block.id && p.from.slotId === slotId);
    // ...
  }
  // Returns combined info
}
```
**Problem**: Every port render calls this, scanning 3 arrays. High N overhead.

**BusInspector.tsx** - `src/editor/BusInspector.tsx:120-162, 168-210`
- Separate `PublisherItem` and `ListenerItem` components
- Each has its own enable/disable logic (lines 135-137, 187-189)
- Each has jump-to-block logic (lines 130-133, 183-185)
- Lens editing duplicated (lines 191-210)

**BusPicker.tsx** - `src/editor/BusPicker.tsx:34-48`
```typescript
function getCompatibleBuses(store: RootStore, portType: TypeDesc): Bus[] {
  return store.busStore.buses.filter((bus: Bus) => isDirectlyCompatible(bus.type, portType));
}

function isPortSubscribedToBus(store: RootStore, portRef: PortRef, busId: string): boolean {
  return store.busStore.listeners.some(
    (l: Listener) =>
      l.busId === busId &&
      l.to.blockId === portRef.blockId &&
      l.to.slotId === portRef.slotId
  );
}
```

**PublishMenu.tsx** - `src/editor/PublishMenu.tsx:32-57`
```typescript
// EXACT SAME logic duplicated
function getCompatibleBuses(store: RootStore, portType: TypeDesc): Bus[] {
  return store.busStore.buses.filter((bus: Bus) => isDirectlyCompatible(bus.type, portType));
}

function getPortPublishers(store: RootStore, portRef: PortRef): Publisher[] {
  return store.busStore.publishers.filter(
    (p: Publisher) =>
      p.from.blockId === portRef.blockId &&
      p.from.slotId === portRef.slotId
  );
}

function isPortPublishingToBus(store: RootStore, portRef: PortRef, busId: string): boolean {
  return store.busStore.publishers.some(
    (p: Publisher) =>
      p.busId === busId &&
      p.from.blockId === portRef.blockId &&
      p.from.slotId === portRef.slotId
  );
}
```

**Duplication count**: 5+ copies of "find compatible buses", 3+ copies of "is port connected to bus"

### 4. Validation Layer

**Validator** - `src/editor/semantic/validator.ts`
- `validateAll(patch)` - validates entire patch
- No `canAddPublisher()` or `canAddListener()` methods exist
- Connection validation exists but only for wires
- **Gap identified**: Bus edge validation is ad-hoc in UI components

**Compatibility Checking** - Scattered:
- `isDirectlyCompatible()` in types.ts (used by BusPicker/PublishMenu)
- `areTypesCompatible()` in portUtils.ts (used by Inspector)
- `findAdapterPath()` in adapters/autoAdapter.ts (used by ConnectionInspector for cells)
- **No single source of truth** for "can these endpoints connect?"

### 5. Semantic Graph (Already Unified!)

**SemanticGraph** - `src/editor/semantic/graph.ts`
```typescript
type GraphEdge = WireEdge | PublisherEdge | ListenerEdge;
```
This type already exists and unifies all three edge kinds!

**Strong architectural signal**: The semantic layer already treats edges uniformly. UI should follow.

---

## What Needs to Be Built

### Phase 1: Binding Facade (Core Abstraction)

**New directory**: `src/editor/bindings/`

**Files to create**:

1. **`types.ts`** - Unified binding types
   - `BindingRef = { kind: 'wire' | 'publisher' | 'listener'; id: string }`
   - `EndpointRef = { kind: 'port'; port: PortRef } | { kind: 'bus'; busId: string }`
   - `NormalizedBinding` - wire/publisher/listener with NO OPTIONALS
   - `ResolvedBinding` - binding + resolved endpoints (block/slot/bus/type)

2. **`read.ts`** - Read-side facade
   - `resolveBinding(root, ref): ResolvedBinding` - single resolution for all kinds
   - `getIncomingBindingForInputPort(root, blockId, slotId): NormalizedBinding | null`
   - `getOutgoingBindingsForOutputPort(root, blockId, slotId): NormalizedBinding[]`
   - `getPublishersForBus(root, busId): NormalizedBinding[]`
   - `getListenersForBus(root, busId): NormalizedBinding[]`
   - `isPortPublishingToBus(root, portRef, busId): boolean`
   - `isPortSubscribedToBus(root, portRef, busId): boolean`

3. **`write.ts`** - Write-side facade
   - `disconnectBinding(root, ref)` - unified disconnect
   - `setBindingEnabled(root, ref, enabled)` - unified enable/disable
   - ~~`setBindingLensStack(root, ref, lensStack)`~~ **SKIP** (per scope exclusion)
   - ~~`setBindingAdapterChain(root, ref, adapterChain)`~~ **SKIP** (per scope exclusion)

4. **`index.ts`** - Re-exports

**Store API Fix Required**:
- Expand `BusStore.updateListener()` signature to accept `adapterChain` in updates
  - Current: `updates: Partial<Pick<Listener, 'enabled' | 'lensStack'>>`
  - Needed: `updates: Partial<Pick<Listener, 'enabled' | 'lensStack' | 'adapterChain'>>`
  - Location: `src/editor/stores/BusStore.ts:405`

### Phase 2: UI Migration (Remove Duplication)

**Step 1: ConnectionInspector** (Highest ROI)
- Replace lines 703-867 resolution logic with `resolveBinding()`
- Keep existing view components (WireConnectionView, etc) unchanged initially
- Just change data source from manual resolution to facade
- **Win**: Single resolution path, easier to maintain

**Step 2: Inspector Port Panel**
- Replace `getConnectionsForPort()` + useMemo scans with facade queries
- Use `getIncomingBindingForInputPort()` / `getOutgoingBindingsForOutputPort()`
- **Win**: No more tri-array scanning per selected port

**Step 3: PatchBay Port Decorations**
- Replace `getConnectionInfo()` helper (lines 475-510) with facade calls
- For inputs: `getIncomingBindingForInputPort()`
- For outputs: `getOutgoingBindingsForOutputPort().length`
- **Win**: Performance - cached queries instead of linear scans

**Step 4: BusInspector** (Optional for Phase 1)
- Replace `PublisherItem` / `ListenerItem` with single `BindingItem` component
- Use `getPublishersForBus()` / `getListenersForBus()`
- **Win**: 1 component instead of 2, shared enable/jump logic

**Step 5: BusPicker / PublishMenu** (Optional for Phase 1)
- Extract shared logic to facade helpers
- Replace inline `isPort{Publishing|Subscribed}ToBus()` with facade calls
- **Win**: Remove 200+ lines of duplication

### Phase 3: Validation Unification (Optional)

**Add to Validator**:
- `canAddPublisher(patch, fromPortRef, busId): ValidationResult`
- `canAddListener(patch, busId, toPortRef): ValidationResult`
- Check: endpoints exist, types compatible (direct or adaptable), single-writer invariant

**Use existing utilities**:
- `areSlotTypesCompatible()` from semantic/index.ts
- `findAdapterPath()` from adapters/autoAdapter.ts

**Integration**:
- Call from `bindings/write.ts` wrappers (warn-only, don't block)
- Compiler is ultimate authority, UI just provides helpful feedback

---

## Blockers and Prerequisites

### TypeScript Status
✅ **CLEAN** - All tests passing (1063 tests), no type errors, only ESLint warnings (functional/immutable-data in DiagnosticHub - not blocking)

### Git Status
**Modified files (23)**:
- Most changes in compiler/blocks domain (TimeRoot refactor)
- No conflicts with binding refactor scope
- New plan files exist but won't interfere

### Dependencies
✅ All required utilities exist:
- Type compatibility: `isDirectlyCompatible()`, `areSlotTypesCompatible()`
- Adapter resolution: `findAdapterPath()`
- Store APIs: All mutation methods present
- Semantic graph: `SemanticGraph` already unifies edges

### Prerequisites
None. Ready to implement immediately.

---

## Risk Assessment

### Low Risk Areas
1. **Data model alignment** - Types already 90% unified, no renaming needed
2. **Store APIs** - All exist, just need thin wrappers
3. **Type system** - Clean, no breaking changes
4. **Existing tests** - Passing, UI refactor won't break them

### Medium Risk Areas
1. **UI component refactors** - Large surface area, manual testing required
2. **Performance** - Facade adds indirection, but removes N² scans (net win expected)
3. **ConnectionInspector complexity** - Handles 4 kinds (wire/pub/lis/cell), needs careful migration

### High Risk Areas
None identified.

### Mitigations
- **Incremental migration**: Add facade without changing UI, then migrate component by component
- **Manual verification**: Use Chrome DevTools MCP to verify each step
- **Rollback plan**: Facade is additive, can revert UI changes independently

---

## Implementation Strategy

### Sprint 1: Foundation (1-2 hours)
1. Create `src/editor/bindings/` directory
2. Implement `types.ts` (BindingRef, NormalizedBinding, ResolvedBinding)
3. Implement `read.ts` facade (all query functions)
4. Implement `write.ts` facade (disconnect, setEnabled)
5. Fix `BusStore.updateListener()` signature to accept `adapterChain`
6. **Sanity check**: Import facade in scratch file, call functions, verify no crashes

### Sprint 2: High-Value UI Migration (2-3 hours)
1. Migrate ConnectionInspector to use `resolveBinding()`
2. Migrate Inspector port panel to use facade queries
3. Migrate PatchBay `getConnectionInfo()` to use facade
4. **Manual verification**: Test all three in `just dev`
   - Connect wire, verify inspector shows correct data
   - Publish to bus, verify PatchBay shows bus connection
   - Subscribe to bus, verify input shows listener

### Sprint 3: Polish (Optional, 1-2 hours)
1. Migrate BusInspector to unified BindingItem component
2. Extract BusPicker/PublishMenu shared logic to facade
3. Add `Validator.canAddPublisher/Listener()` methods
4. Wire up validation in facade write operations

### Sprint 4: Manual Verification (1 hour)
Use Chrome DevTools MCP to verify:
- [ ] Wire connect/disconnect works
- [ ] Publish to bus works
- [ ] Subscribe to bus works
- [ ] Input writer invariant holds (wire replaces listener, vice versa)
- [ ] Inspector shows same bindings as PatchBay decorations
- [ ] ConnectionInspector opens for wire/publisher/listener
- [ ] Enable/disable toggle works for all binding kinds
- [ ] Jump-to-block works from BusInspector

---

## Suggested First Steps

1. **Create facade directory**: `mkdir src/editor/bindings`
2. **Implement types.ts**: Start with `BindingRef` and `NormalizedBinding`
3. **Implement read.ts**: Start with `resolveBinding()` - handles the core branching logic
4. **Test in isolation**: Import in ConnectionInspector, replace resolution logic, verify builds
5. **Iterate**: Once `resolveBinding()` works, add query helpers one by one

---

## Acceptance Criteria

### Must Have (Sprint 1-2)
- [ ] Binding Facade exists in `src/editor/bindings/`
- [ ] All tri-scan logic moved to facade (ConnectionInspector, Inspector, PatchBay)
- [ ] Manual verification passes for all basic operations
- [ ] No regressions in existing functionality
- [ ] TypeScript builds clean

### Nice to Have (Sprint 3)
- [ ] BusInspector uses unified BindingItem
- [ ] BusPicker/PublishMenu duplication removed
- [ ] Validator has `canAddPublisher/Listener()` methods

### Explicitly Out of Scope
- ❌ Lens stack UI migration (deferred to post-lens-refactor)
- ❌ Adapter chain UI migration (deferred to post-lens-refactor)
- ❌ Numeric UI semantics registry (separate work)
- ❌ Any renaming of existing types (Connection, Publisher, Listener)

---

## Notes

**Plan quality**: Excellent. Thoroughly researched, incrementally executable, aligned with architecture.

**Key insight from plan**: Semantic layer already unified edges (`GraphEdge`), UI just needs to catch up.

**Biggest win**: Removing 5+ copies of "find compatible buses" and 3+ copies of tri-array scans.

**Confidence**: HIGH. No blockers, clean tests, all dependencies present, plan is conservative and reversible.

---

## Workflow Recommendation
✅ **CONTINUE** - Ready for implementation. Start with Sprint 1 (foundation).
