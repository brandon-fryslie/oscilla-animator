# Definition of Done: Graph Normalization Layer

**Generated**: 2026-01-03-121430
**Plan**: PLAN-2026-01-03-121430.md
**Sprint Goal**: RawGraph/NormalizedGraph separation with eager normalization

---

## Sprint Scope

This sprint delivers:
1. Type system for RawGraph/NormalizedGraph separation
2. GraphNormalizer module (pure editor-layer normalization)
3. PatchStore integration (compiler receives NormalizedGraph)

**Deferred** (out of scope):
- Wire-state blocks (removed per user)
- Bus junction normalization (buses are user-created)
- Incremental normalization (optimization)
- Cryptographic hash IDs (simple strings sufficient)

---

## Acceptance Criteria

### Deliverable 1: Type System Foundation

- [ ] Create `src/editor/graph/types.ts` with RawGraph, NormalizedGraph, Anchor interfaces
- [ ] RawGraph contains: blocks (user only), edges (user only), attachments (default sources only)
- [ ] NormalizedGraph contains: blocks (user + structural), edges (user + structural), mapping (no attachments)
- [ ] Anchor type supports defaultSource kind with blockId, port, direction fields
- [ ] Add `role?: EdgeRole` field to Edge type in `src/editor/types.ts` where EdgeRole = "user" | "structural"
- [ ] StructuralMapping interface defines anchorToIds and idToAnchor bidirectional maps
- [ ] All types compile without errors (`just typecheck`)

### Deliverable 2: GraphNormalizer Module

- [ ] Create `src/editor/graph/GraphNormalizer.ts` with pure function `normalize(raw: RawGraph): NormalizedGraph`
- [ ] Migrate default source materialization logic from `src/editor/compiler/passes/pass0-materialize.ts` to GraphNormalizer
- [ ] GraphNormalizer creates provider blocks (DSConstSignalFloat, DomainN, etc.) for unconnected inputs
- [ ] GraphNormalizer generates deterministic IDs using `generateProviderId(blockId, slotId)` pattern
- [ ] GraphNormalizer produces StructuralMapping with anchor ↔ ID bidirectional lookup
- [ ] All generated blocks have `role: "structural"` metadata
- [ ] All generated edges have `role: "structural"` metadata
- [ ] GraphNormalizer is pure (no mutations, no side effects)
- [ ] Unit test: `normalize(raw)` returns identical output for identical inputs (determinism)
- [ ] Unit test: Moving a block doesn't change its provider IDs (anchor stability)
- [ ] Unit test: StructuralMapping correctly maps anchors to IDs and vice versa

### Deliverable 3: PatchStore Integration

- [ ] PatchStore internally maintains RawGraph representation (filter structural artifacts from Patch)
- [ ] Add `PatchStore.getNormalizedGraph()` method that returns cached NormalizedGraph
- [ ] Cache invalidates when RawGraph changes (any block/edge mutation)
- [ ] Compiler integration point calls `getNormalizedGraph()` instead of reading Patch directly
- [ ] Remove `src/editor/compiler/passes/pass0-materialize.ts` from compiler pipeline
- [ ] Update compiler pass chain: pass1-normalize receives NormalizedGraph (already has providers)
- [ ] Undo/redo operates on RawGraph only (structural artifacts regenerate automatically)
- [ ] All existing tests pass after integration (`just test`)
- [ ] Integration test: Unwired input gets provider block in compiled graph
- [ ] Integration test: Undo/redo preserves default source behavior
- [ ] Manual test (Chrome DevTools): Create block with unwired input, verify provider appears

---

## Validation Checklist

### Type System
- [ ] TypeScript compilation succeeds (`just typecheck`)
- [ ] No type errors in new graph module
- [ ] Edge.role field correctly typed as optional union

### GraphNormalizer
- [ ] Determinism test passes (same input → same output)
- [ ] ID stability test passes (anchor-based IDs don't thrash)
- [ ] Mapping test passes (bidirectional anchor ↔ ID lookup works)
- [ ] Provider selection logic works (DSConstSignalFloat, DomainN, etc.)

### Integration
- [ ] All existing unit tests pass (`just test`)
- [ ] Compiler receives NormalizedGraph (verified in debugger)
- [ ] pass0-materialize.ts deleted or commented out
- [ ] Undo/redo doesn't leak structural artifacts
- [ ] Existing patches load correctly (backward compatibility)

### Manual Testing (Required)
- [ ] Create Oscillator, leave `freq` unwired → provider block appears
- [ ] Inspect compiled graph in DevTools → structural blocks have correct role
- [ ] Undo adding a block → provider disappears
- [ ] Redo → provider reappears with same ID
- [ ] Load old patch file → normalizes correctly without errors

---

## Performance Requirements

- [ ] Normalization completes in <50ms for typical patch (10-20 blocks)
- [ ] Normalization completes in <200ms for large patch (100 blocks)
- [ ] No observable lag when editing (eager normalization acceptable)

---

## Documentation Requirements

- [ ] Add inline comments explaining RawGraph vs NormalizedGraph distinction
- [ ] Document eager normalization strategy in GraphNormalizer.ts
- [ ] Update relevant architecture docs with new flow diagram
- [ ] Add JSDoc comments to public API (normalize, getNormalizedGraph)

---

## Blockers and Known Issues

**None** - All ambiguities resolved by user:
- Eager normalization (not lazy)
- No wire-state blocks (removed from scope)
- Simple string IDs (no hashing)
- Buses are user-created (not structural)

---

## Success Criteria

Sprint succeeds if:
1. All acceptance criteria checkboxes above are checked
2. `just check` passes (typecheck + lint + test)
3. Manual testing confirms default sources work correctly
4. Compiler receives NormalizedGraph (no longer does normalization itself)

Sprint fails if:
- Default sources stop working (regression)
- Existing patches don't load (breaking change)
- Normalization is non-deterministic (flaky tests)
- Structural artifacts leak into undo history (architecture violation)
