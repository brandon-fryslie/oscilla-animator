# Graph Normalization Layer - Sprint Plan

**Generated**: 2026-01-03-121815
**Source Evaluation**: EVALUATION-2026-01-03.md
**Git Commit**: 1c4bd23
**Sprint Scope**: RawGraph/NormalizedGraph separation - Simplified scope per user clarifications

---

## Provenance

**Source STATUS**: `.agent_planning/graph-normalization/EVALUATION-2026-01-03.md`
**Generation Timestamp**: 2026-01-03-121815

**User Clarifications Applied**:
1. Normalization timing: EAGER normalization (RawGraph in transactions, NormalizedGraph is derived view)
2. Wire-state: DELETED from scope (not needed)
3. ID algorithm: Simple string concatenation `${blockId}_default_${slotId}` (no hashing)
4. BusBlocks: Always user-created (normalization doesn't touch them)
5. Undo/redo: Operates on RawGraph only

---

## Executive Summary

**Current State**: Single `Patch` representation with default source materialization in `pass0-materialize.ts` (compiler layer). No RawGraph/NormalizedGraph separation.

**Target State**: Clean separation where:
- **RawGraph** = User intent (transactions, undo/redo)
- **NormalizedGraph** = Compiler input (explicit blocks + edges)
- **GraphNormalizer** = Pure function in editor layer

**Scope Simplification**: With wire-state removed and buses excluded:
1. Type system: RawGraph, NormalizedGraph, Anchor types
2. GraphNormalizer: Move `pass0-materialize` logic from compiler to editor
3. Role metadata: Add `role?: EdgeRole` to Edge type

**Total Work**: 2-3 deliverables, estimated 3-4 days effort

---

## Sprint Deliverables

### Deliverable 1: Type System Foundation

**Effort**: Small (1 day)
**Dependencies**: None
**Priority**: P0 (Critical - blocks all other work)

#### What to Build

Create type definitions for RawGraph/NormalizedGraph separation:

**New file**: `src/editor/graph/types.ts`

```typescript
import type { Block, Edge, PortRef } from '../types';

/**
 * RawGraph: User intent (what transactions operate on)
 * Contains only user-created blocks and edges.
 * Attachments represent UI concepts (badges, default source indicators).
 */
export interface RawGraph {
  blocks: Block[];  // User blocks only (no structural providers)
  edges: Edge[];    // User edges only (no structural edges)
  attachments: DefaultSourceAttachment[];  // UI metadata
}

/**
 * NormalizedGraph: Compiler input (fully explicit)
 * Contains user blocks + structural artifacts (providers, etc.)
 * No attachments - everything is explicit blocks + edges.
 */
export interface NormalizedGraph {
  blocks: Block[];  // User + structural blocks
  edges: Edge[];    // User + structural edges
  mapping: StructuralMapping;  // For UI selection
}

/**
 * Anchor: Identifies a structural artifact deterministically
 * Anchors are derived from graph structure, not creation order.
 */
export type Anchor = {
  kind: "defaultSource";
  blockId: string;      // The user block this provider serves
  port: PortRef;        // The input port
  direction: "in" | "out";
};

/**
 * Bidirectional mapping between anchors and IDs.
 * Allows UI to select structural artifacts by their anchor.
 */
export interface StructuralMapping {
  anchorToIds: Map<string, { nodeId?: string; edgeIds: string[] }>;
  idToAnchor: Map<string, Anchor>;
}

/**
 * Default source attachment (UI metadata in RawGraph)
 */
export interface DefaultSourceAttachment {
  blockId: string;
  slotId: string;
  providerType: string;  // e.g., 'DSConstSignalFloat'
  value: unknown;
}
```

**Modified file**: `src/editor/types.ts`

Add role field to existing Edge interface:

```typescript
export interface Edge {
  // ... existing fields (id, from, to, enabled, etc.)

  /**
   * Role: Distinguishes user-created edges from structural edges.
   * - "user": Created by user action (wiring in UI)
   * - "structural": Created by normalization (e.g., default source providers)
   */
  role?: "user" | "structural";
}
```

#### Acceptance Criteria

- [ ] `src/editor/graph/types.ts` exists with RawGraph, NormalizedGraph, Anchor, StructuralMapping types
- [ ] RawGraph contains blocks (user only), edges (user only), attachments (default sources)
- [ ] NormalizedGraph contains blocks (user + structural), edges (user + structural), mapping
- [ ] Anchor type has `kind: "defaultSource"` with blockId, port, direction
- [ ] Edge type in `src/editor/types.ts` has `role?: "user" | "structural"` field
- [ ] All types compile without errors (`just typecheck`)

#### Technical Notes

**Design decisions**:
- Anchor uses PortRef (existing type) for port identity
- No wire-state anchor (removed from scope)
- No bus junction anchor (buses are user-created)
- Simple serialization: `serializeAnchor(anchor)` returns JSON string for Map keys

**Migration strategy**:
- Current `Patch` type unchanged (backward compatibility)
- RawGraph/NormalizedGraph are new parallel concepts
- Existing code continues to work during migration

---

### Deliverable 2: GraphNormalizer Module

**Effort**: Medium (2-3 days)
**Dependencies**: Deliverable 1 (Type System)
**Priority**: P0 (Critical - core normalization logic)

#### What to Build

Create GraphNormalizer module that performs pure RawGraph → NormalizedGraph transformation.

**New file**: `src/editor/graph/GraphNormalizer.ts`

Key responsibilities:
1. Scan RawGraph for unconnected inputs with default sources
2. Create provider blocks (DSConstSignalFloat, DomainN, etc.)
3. Generate deterministic IDs using anchor-based algorithm
4. Create edges from providers to inputs
5. Build StructuralMapping (anchor ↔ ID bidirectional lookup)
6. Tag all structural artifacts with `role: "structural"`

**Algorithm** (migrate from `pass0-materialize.ts`):

```typescript
export function normalize(raw: RawGraph): NormalizedGraph {
  const structuralBlocks: Block[] = [];
  const structuralEdges: Edge[] = [];
  const mapping: StructuralMapping = {
    anchorToIds: new Map(),
    idToAnchor: new Map(),
  };

  // For each user block
  for (const block of raw.blocks) {
    const blockDef = getBlockDefinition(block.type);
    if (!blockDef) continue;

    // For each input with defaultSource
    for (const inputDef of blockDef.inputs) {
      if (!inputDef.defaultSource) continue;

      if (isInputDriven(raw, block.id, inputDef.id)) continue;

      // Create provider block
      const providerId = generateProviderId(block.id, inputDef.id);
      const providerType = selectProviderType(
        inputDef.defaultSource.world,
        extractDomain(inputDef.type)
      );

      const provider: Block = {
        id: providerId,
        type: providerType,
        params: buildProviderParams(providerType, inputDef.defaultSource.value),
        position: { x: 0, y: 0 },  // Hidden
        role: "structural",  // NEW: mark as structural
      };

      // Create edge from provider to input
      const edge: Edge = {
        id: `${providerId}_edge`,
        from: { kind: 'port', blockId: providerId, slotId: 'out' },
        to: { kind: 'port', blockId: block.id, slotId: inputDef.id },
        enabled: true,
        role: "structural",  // NEW: mark as structural
      };

      structuralBlocks.push(provider);
      structuralEdges.push(edge);

      // Build mapping
      const anchor: Anchor = {
        kind: "defaultSource",
        blockId: block.id,
        port: { kind: 'port', blockId: block.id, slotId: inputDef.id },
        direction: "in",
      };
      const anchorKey = serializeAnchor(anchor);
      mapping.anchorToIds.set(anchorKey, { nodeId: providerId, edgeIds: [edge.id] });
      mapping.idToAnchor.set(providerId, anchor);
      mapping.idToAnchor.set(edge.id, anchor);
    }
  }

  return {
    blocks: [...raw.blocks, ...structuralBlocks],
    edges: [...raw.edges, ...structuralEdges],
    mapping,
  };
}
```

**Helper functions** (copy from `pass0-materialize.ts`):
- `selectProviderType(world, domain)`: Map world + domain to provider block type
- `generateProviderId(blockId, slotId)`: Simple string concatenation `${blockId}_default_${slotId}`
- `buildProviderParams(type, value)`: Handle DomainN vs DSConst* param shapes

#### Acceptance Criteria

- [ ] `src/editor/graph/GraphNormalizer.ts` exists with `normalize(raw: RawGraph): NormalizedGraph`
- [ ] Default source materialization logic migrated from `pass0-materialize.ts`
- [ ] GraphNormalizer creates provider blocks (DSConstSignalFloat, DomainN, etc.)
- [ ] IDs generated using `generateProviderId(blockId, slotId)` (deterministic)
- [ ] StructuralMapping populated with anchor ↔ ID mappings
- [ ] All structural blocks have `role: "structural"` metadata
- [ ] All structural edges have `role: "structural"` metadata
- [ ] GraphNormalizer is pure (no mutations, no side effects)
- [ ] Unit test: Determinism - `normalize(raw)` returns identical output for identical inputs
- [ ] Unit test: ID stability - Moving a block doesn't change provider IDs
- [ ] Unit test: Mapping correctness - Anchor lookups work bidirectionally

#### Technical Notes

**ID algorithm** (simplified per user):
- Use simple string concatenation: `${blockId}_default_${slotId}`
- No cryptographic hashing (current approach is fine)
- Deterministic from structure (anchor-based), not creation order

**Provider selection**:
- DomainN for `config:domain` inputs (structural domain provider)
- DSConstSignalFloat, DSConstScalarFloat, etc. for other types
- Copy logic from `pass0-materialize.ts` (already correct)

**Purity requirements**:
- No mutations of input RawGraph
- No global state access
- Same input → same output (testable)

**Migration path**:
- Copy tests from `pass0-materialize.test.ts`
- Run side-by-side comparison (old vs new)
- Verify identical outputs before removing old code

---

### Deliverable 3: PatchStore Integration

**Effort**: Medium (1-2 days)
**Dependencies**: Deliverable 1 (Types), Deliverable 2 (GraphNormalizer)
**Priority**: P1 (High - required for complete integration)

#### What to Build

Integrate GraphNormalizer into PatchStore so that:
1. PatchStore maintains RawGraph internally
2. Normalization runs eagerly (cached, invalidated on edits)
3. Compiler receives NormalizedGraph (not RawGraph)
4. Undo/redo operates on RawGraph only

**Modified file**: `src/editor/stores/PatchStore.ts`

```typescript
import { normalize } from '../graph/GraphNormalizer';
import type { RawGraph, NormalizedGraph } from '../graph/types';

class PatchStore {
  // Internal state
  private rawGraph: RawGraph;
  private normalizedCache: NormalizedGraph | null = null;

  // Public API
  getNormalizedGraph(): NormalizedGraph {
    if (!this.normalizedCache) {
      this.normalizedCache = normalize(this.rawGraph);
    }
    return this.normalizedCache;
  }

  // Invalidate on mutations
  addBlock(...args) {
    // ... mutate rawGraph
    this.normalizedCache = null;  // Invalidate cache
  }

  connect(...args) {
    // ... mutate rawGraph
    this.normalizedCache = null;  // Invalidate cache
  }

  // ... other mutations invalidate cache
}
```

**Modified file**: `src/editor/compiler/index.ts`

```typescript
function compile(store: PatchStore) {
  const normalizedGraph = store.getNormalizedGraph();

  // Pass to pass1-normalize (skip pass0-materialize)
  const ir = pass1Normalize(normalizedGraph);
  // ... rest of compilation
}
```

**Deleted file**: `src/editor/compiler/passes/pass0-materialize.ts` (logic moved to GraphNormalizer)

#### Acceptance Criteria

- [ ] PatchStore maintains RawGraph internally (filter structural artifacts from current Patch)
- [ ] `PatchStore.getNormalizedGraph()` method returns cached NormalizedGraph
- [ ] Cache invalidates on any block/edge mutation (addBlock, connect, deleteBlock, etc.)
- [ ] Compiler integration point calls `getNormalizedGraph()` instead of reading Patch directly
- [ ] `pass0-materialize.ts` removed from compiler pipeline (or commented out)
- [ ] Compiler pass chain updated: pass1-normalize receives NormalizedGraph (already has providers)
- [ ] Undo/redo operates on RawGraph only (structural artifacts regenerate automatically)
- [ ] All existing tests pass (`just test`)
- [ ] Integration test: Unwired input gets provider block in compiled graph
- [ ] Integration test: Undo/redo preserves default source behavior
- [ ] Manual test: Create Oscillator, leave `freq` unwired, verify provider appears in DevTools

#### Technical Notes

**Eager normalization flow**:
```
User action → mutate RawGraph → invalidate cache
  → compile triggered → getNormalizedGraph() → normalize(rawGraph) → cache result
  → compiler receives NormalizedGraph
```

**Undo/redo integration**:
- History stack stores RawGraph snapshots only
- On undo: restore RawGraph snapshot, invalidate cache
- On redo: restore RawGraph snapshot, invalidate cache
- Structural artifacts regenerate automatically (not in history)

**Backward compatibility**:
- Existing Patch serialization unchanged
- On load: deserialize Patch → filter into RawGraph → normalize
- On save: serialize NormalizedGraph (includes structural artifacts for debugging)

**Performance**:
- Normalization runs once per edit (acceptable for eager approach)
- Cache prevents redundant normalization during same frame
- Profile with large patches (100+ blocks) to verify <200ms

---

## Deferred Work (Out of Sprint)

### Wire-State Blocks
**Reason**: Removed from scope per user clarification.

Wire-state infrastructure (slew/delay on edges) is not needed for this sprint. If needed in future:
- Add anchor type: `{ kind: "wireState"; edgeId: string }`
- Add normalization pass to insert state blocks on edges
- Update StructuralMapping to track wire-state artifacts

**Spec reference**: EVALUATION §274-283

---

### Bus Junction Normalization
**Reason**: BusBlocks are always user-created, not structural artifacts.

Current behavior: Users explicitly create BusBlock via PatchStore. Normalization treats buses as ordinary blocks (no special handling).

If automatic bus creation needed in future:
- Add bus creation policy to StructuralManager
- Generate anchor-based junction IDs
- Update normalization to create bus tap blocks

**Spec reference**: EVALUATION §350-356

---

### Incremental Normalization
**Reason**: Not needed for correctness; full normalization is fast enough.

Current approach: Full normalization on every change (eager, from scratch).

If performance becomes issue:
- Pass `previousNormalized` to normalize()
- Reuse structural IDs when anchors unchanged
- Detect changed subgraph, renormalize only affected parts

**Spec reference**: EVALUATION §287-298

---

### Cryptographic Hash IDs
**Reason**: Simple string concatenation is sufficient.

Current approach: `${blockId}_default_${slotId}` (deterministic, readable).

If ID stability across renames needed:
- Implement hash-based ID generation (SHA-256 or UUID v5)
- Update anchor serialization
- Maintain backward compatibility

**Spec reference**: EVALUATION §301-311

---

## Dependency Graph

```
Deliverable 1: Type System
  └─> Deliverable 2: GraphNormalizer (depends on types)
       └─> Deliverable 3: PatchStore Integration (depends on normalizer)
```

**Critical path**: Sequential (must complete in order)

**Parallelization**: None possible (tight coupling between deliverables)

---

## Risk Assessment

### High Risk: Breaking Default Sources During Migration

**Risk**: Existing default source behavior breaks when migrating from pass0-materialize to GraphNormalizer.

**Mitigation**:
- Copy tests from pass0-materialize.test.ts
- Run side-by-side comparison (old vs new implementation)
- Verify identical outputs before deleting old code
- Test with existing patch files

**Validation**:
- All existing patches compile identically before/after
- Manual testing with unwired inputs
- Chrome DevTools inspection of compiled graph

---

### Medium Risk: Undo/Redo Leaking Structural Artifacts

**Risk**: History stack might contain structural artifacts from old implementation.

**Mitigation**:
- Clear history on migration (one-time cost)
- Filter structural artifacts during undo (if old snapshots exist)
- Add validation: assert no structural artifacts in RawGraph

**Validation**:
- Manual testing of undo/redo with default sources
- Unit test: verify RawGraph has no structural blocks after undo

---

### Medium Risk: Backward Compatibility

**Risk**: Old patches serialized with structural artifacts might not load correctly.

**Mitigation**:
- Add migration logic to strip structural artifacts on load
- Filter blocks/edges by role field (if present)
- Regenerate via normalization

**Validation**:
- Load old patch files from disk
- Verify normalization regenerates providers correctly
- Compare rendered output before/after migration

---

### Low Risk: Performance of Eager Normalization

**Risk**: Normalizing on every edit might be slow for large graphs.

**Mitigation**:
- Profile normalization with large patches (100 blocks)
- Target: <50ms for typical patch, <200ms for large patch
- If too slow: defer to incremental normalization (out of sprint)

**Validation**:
- Performance test with 100-block patch
- Measure normalization time in profiler

---

## Validation Strategy

### Unit Tests (Required)

**Type system**:
- [ ] RawGraph → NormalizedGraph conversion
- [ ] Anchor serialization/deserialization
- [ ] StructuralMapping bidirectional lookup

**GraphNormalizer determinism**:
```typescript
test('normalize is deterministic', () => {
  const raw = createTestRawGraph();
  const norm1 = normalize(raw);
  const norm2 = normalize(raw);
  expect(norm1).toEqual(norm2);
});
```

**ID stability**:
```typescript
test('structural IDs stable under block moves', () => {
  const raw1 = createGraph([{ id: 'b1', x: 0, y: 0 }]);
  const norm1 = normalize(raw1);
  const providerId1 = getProviderId(norm1, 'b1', 'in');

  const raw2 = moveBlock(raw1, 'b1', { x: 100, y: 100 });
  const norm2 = normalize(raw2);
  const providerId2 = getProviderId(norm2, 'b1', 'in');

  expect(providerId1).toBe(providerId2);
});
```

### Integration Tests (Required)

**End-to-end compilation**:
```typescript
test('compiler receives NormalizedGraph with providers', () => {
  const store = createStoreWithUnwiredInput();
  const compiled = compile(store);

  expect(compiled.blocks).toContainEqual(
    expect.objectContaining({ role: 'structural' })
  );
});
```

**Undo/redo**:
```typescript
test('undo/redo operates on RawGraph only', () => {
  const store = new PatchStore();
  store.addBlock('Oscillator', { x: 0, y: 0 });
  const normBefore = store.getNormalizedGraph();

  store.undo();
  store.redo();

  const normAfter = store.getNormalizedGraph();
  expect(normBefore).toEqual(normAfter);
});
```

### Manual Tests (Required - Chrome DevTools MCP)

1. **Default source materialization**:
   - Create Oscillator block
   - Leave `freq` input unwired
   - Open DevTools, inspect compiled graph
   - Verify: DSConstSignalFloat provider exists
   - Verify: Edge connects provider to `freq`

2. **Role metadata**:
   - Compile patch with default sources
   - Inspect NormalizedGraph blocks/edges
   - Verify: Structural artifacts have `role: "structural"`

3. **Undo/redo**:
   - Create block, undo, redo
   - Verify: Provider appears/disappears correctly
   - Verify: Provider ID stable across redo

---

## Success Criteria

Sprint is **complete** when:

1. All acceptance criteria checked (see deliverables above)
2. `just check` passes (typecheck + lint + test)
3. Manual tests pass (DevTools verification)
4. Compiler receives NormalizedGraph (pass0-materialize removed)
5. Undo/redo works correctly (operates on RawGraph only)

Sprint has **FAILED** if:

- Default sources stop working (regression)
- Existing patches don't load correctly (breaking change)
- Normalization is non-deterministic (flaky tests)
- Structural artifacts appear in undo history (leaky abstraction)
- Performance degrades (>200ms normalization for large patches)

---

## Files Referenced

### Spec (Read-Only)
- `.agent_planning/graph-normalization/EVALUATION-2026-01-03.md` (current state analysis)
- `design-docs/final-System-Invariants/` (core invariants)

### Existing (Migrate/Modify)
- `src/editor/compiler/passes/pass0-materialize.ts` (logic to migrate)
- `src/editor/types.ts` (add role field to Edge)
- `src/editor/stores/PatchStore.ts` (integrate normalization)
- `src/editor/compiler/index.ts` (use NormalizedGraph)

### New (Created This Sprint)
- `src/editor/graph/types.ts` (RawGraph, NormalizedGraph, Anchor)
- `src/editor/graph/GraphNormalizer.ts` (normalize function)
- `src/editor/graph/index.ts` (exports)

---

## Timeline Estimate

**Day 1**: Deliverable 1 (Type System)
- Create types.ts
- Add role field to Edge
- Verify typecheck passes

**Day 2-3**: Deliverable 2 (GraphNormalizer)
- Migrate pass0-materialize logic
- Write unit tests (determinism, ID stability)
- Verify tests pass

**Day 4**: Deliverable 3 (Integration)
- Integrate into PatchStore
- Update compiler integration
- Remove pass0-materialize
- Manual testing (DevTools)

**Total**: 3-4 days (assuming no major blockers)

---

## Next Steps for Implementer

1. Read EVALUATION-2026-01-03.md (understand current state)
2. Start with Deliverable 1 (Type System) - foundation for everything
3. Run `just typecheck` after each change
4. Write tests alongside implementation (not after)
5. Use Chrome DevTools MCP to verify compiler receives NormalizedGraph
6. Do not skip manual testing (critical for correctness validation)
