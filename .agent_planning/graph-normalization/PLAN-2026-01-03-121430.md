# Graph Normalization Layer - Implementation Plan

**Generated**: 2026-01-03-121430
**Source Evaluation**: EVALUATION-2026-01-03.md
**Git Commit**: 1c4bd23
**Sprint Scope**: RawGraph/NormalizedGraph separation with eager normalization

---

## Executive Summary

**Current State**: Single Patch representation with ad-hoc normalization scattered across compiler passes. Default source materialization exists in `pass0-materialize.ts` (compiler layer) but doesn't follow spec architecture.

**Target State**: Clean RawGraph → NormalizedGraph separation where:
- RawGraph = user intent (undoable, no structural artifacts)
- NormalizedGraph = compiler input (fully explicit blocks + edges)
- GraphNormalizer = pure function in editor layer (not compiler)

**Total Gap**: 3 deliverables over 1 sprint
- P0: Type system foundation (RawGraph, NormalizedGraph, Anchor types)
- P0: GraphNormalizer module (migrate pass0-materialize logic)
- P1: Role metadata on edges (distinguish user vs structural)

**Simplified Scope** (per user clarifications):
- Eager normalization (transactions write RawGraph, normalization is derived view)
- No wire-state blocks (removed from scope)
- Simple string concatenation IDs (no cryptographic hashing)
- BusBlocks are user-created (normalization doesn't touch them)
- Undo/redo operates on RawGraph only

---

## Backlog by Priority

### P0-1: Type System Foundation

**Status**: Not Started
**Effort**: Small (1 day)
**Dependencies**: None
**Spec Reference**: 16-Graph-Normalization.md §142-171 • **Status Reference**: EVALUATION-2026-01-03.md §127-152

#### Description

Define the core type system for RawGraph/NormalizedGraph separation. This establishes the contract between editor (RawGraph) and compiler (NormalizedGraph).

**Key decisions resolved by user**:
- RawGraph contains attachments (UI concepts like default source badges)
- NormalizedGraph contains only explicit blocks + edges (no attachments)
- Anchor types use simple structure (no wire-state variant needed)
- Edge type gets role metadata to distinguish structural from user edges

#### Acceptance Criteria

- [ ] Create `src/editor/graph/types.ts` with RawGraph, NormalizedGraph, Anchor interfaces
- [ ] RawGraph contains: blocks (user only), edges (user only), attachments (default sources only - no wire-state)
- [ ] NormalizedGraph contains: blocks (user + structural), edges (user + structural), no attachments
- [ ] Anchor type supports `{ kind: "defaultSource"; blockId: string; port: PortRef; direction: "in" | "out" }`
- [ ] Add `role?: EdgeRole` field to Edge type in `src/editor/types.ts` where EdgeRole = "user" | "structural"
- [ ] All types compile without errors (`just typecheck`)

#### Technical Notes

**Type structure**:
```typescript
// src/editor/graph/types.ts
export interface RawGraph {
  blocks: Block[];  // User blocks only (no structural providers)
  edges: Edge[];    // User edges only (no structural edges)
  attachments: DefaultSourceAttachment[];  // UI concepts
}

export interface NormalizedGraph {
  blocks: Block[];  // User + structural (provider blocks)
  edges: Edge[];    // User + structural (edges to providers)
  mapping: StructuralMapping;  // For UI selection
}

export type Anchor = {
  kind: "defaultSource";
  blockId: string;
  port: PortRef;
  direction: "in" | "out";
};

export interface StructuralMapping {
  anchorToIds: Map<string, { nodeId?: string; edgeIds: string[] }>;
  idToAnchor: Map<string, Anchor>;
}
```

**Edge role metadata**:
```typescript
// src/editor/types.ts (extend existing Edge interface)
export interface Edge {
  // ... existing fields
  role?: "user" | "structural";  // NEW: distinguish edge origins
}
```

**Migration strategy**:
- Patch interface keeps current shape (backward compatibility)
- RawGraph/NormalizedGraph are new concepts (no breaking changes)
- Current Patch can be converted to RawGraph (filter out structural blocks/edges)

---

### P0-2: GraphNormalizer Module

**Status**: Not Started
**Effort**: Medium (3 days)
**Dependencies**: P0-1 (Type System)
**Spec Reference**: 16-Graph-Normalization.md §48-82, §172-178 • **Status Reference**: EVALUATION-2026-01-03.md §44-89

#### Description

Create `GraphNormalizer` module in editor layer that performs pure RawGraph → NormalizedGraph transformation. Migrate existing default source materialization logic from `pass0-materialize.ts` (compiler) into this new module.

**Normalization timing** (resolved by user):
- Eager normalization: PatchStore maintains RawGraph, derives NormalizedGraph on-demand
- NormalizedGraph is a cached view (recompute when RawGraph changes)
- Compiler receives NormalizedGraph, never performs normalization itself

**ID algorithm** (resolved by user):
- Simple string concatenation: `${blockId}_default_${slotId}`
- No cryptographic hashing (current approach is fine)
- Anchor-based = deterministic from structure, not creation order

#### Acceptance Criteria

- [ ] Create `src/editor/graph/GraphNormalizer.ts` with pure function `normalize(raw: RawGraph): NormalizedGraph`
- [ ] Migrate default source materialization logic from `src/editor/compiler/passes/pass0-materialize.ts` to GraphNormalizer
- [ ] GraphNormalizer creates provider blocks (DSConstSignalFloat, DomainN, etc.) for unconnected inputs
- [ ] GraphNormalizer generates deterministic IDs using `generateProviderId(blockId, slotId)` (existing algorithm)
- [ ] GraphNormalizer produces StructuralMapping (anchor ↔ IDs) for UI selection
- [ ] All generated blocks have `role: "structural"` metadata
- [ ] All generated edges have `role: "structural"` metadata
- [ ] GraphNormalizer is pure (no mutations, same input → same output)
- [ ] Unit tests verify determinism: `normalize(raw1) === normalize(raw2)` for identical inputs
- [ ] Unit tests verify ID stability: moving a block doesn't change its provider IDs

#### Technical Notes

**Module location**:
- Create `src/editor/graph/` directory
- GraphNormalizer.ts goes here (editor layer, not compiler)

**Normalization pass order** (simplified from spec):
1. Default sources (only pass needed for this sprint)
2. ~~Bus junctions~~ (out of scope - buses are user-created)
3. ~~Wire-state~~ (out of scope - removed per user)
4. Final validation (type-check, no cycles without state blocks)

**Reuse existing logic**:
- `selectProviderType(world, domain)` → copy from pass0-materialize.ts
- `isInputDriven(patch, blockId, slotId)` → adapt for RawGraph
- `generateProviderId(blockId, slotId)` → reuse exactly as-is

**Mapping generation**:
```typescript
// For each structural artifact created:
const anchor: Anchor = {
  kind: "defaultSource",
  blockId,
  port: { slotId, direction: "in" },
  direction: "in"
};

const anchorKey = serializeAnchor(anchor);
mapping.anchorToIds.set(anchorKey, { nodeId: providerId, edgeIds: [edgeId] });
mapping.idToAnchor.set(providerId, anchor);
mapping.idToAnchor.set(edgeId, anchor);
```

**Validation step**:
- Every structural block references a valid anchor target (blockId exists)
- Every structural edge connects to existing ports
- No cycles unless mediated by state blocks (defer to existing cycle detection)

---

### P1-3: Integration with PatchStore

**Status**: Not Started
**Effort**: Medium (2 days)
**Dependencies**: P0-1 (Types), P0-2 (GraphNormalizer)
**Spec Reference**: 16-Graph-Normalization.md §86-99 • **Status Reference**: EVALUATION-2026-01-03.md §95-110

#### Description

Integrate GraphNormalizer into PatchStore so that:
- PatchStore maintains RawGraph as source of truth
- Normalized view is derived on-demand (cached)
- Compiler receives NormalizedGraph, not RawGraph
- Undo/redo operates on RawGraph only

**Store flow** (eager normalization):
```
User action → mutate RawGraph → invalidate cache → recompute NormalizedGraph → compile
```

#### Acceptance Criteria

- [ ] PatchStore internally maintains RawGraph representation (filter out structural artifacts from current Patch)
- [ ] Add `PatchStore.getNormalizedGraph()` method that returns cached NormalizedGraph
- [ ] Cache invalidates when RawGraph changes (any block/edge mutation)
- [ ] Compiler integration point (`editorToPatch()`) calls `getNormalizedGraph()` instead of reading Patch directly
- [ ] Remove `pass0-materialize.ts` from compiler pipeline (logic now in GraphNormalizer)
- [ ] Update compiler pass chain: pass1-normalize now receives NormalizedGraph (already has providers)
- [ ] Undo/redo operates on RawGraph only (structural artifacts regenerate automatically)
- [ ] All existing tests pass after integration (`just test`)
- [ ] Manual test: Create block, leave input unwired, verify provider appears in compiled graph

#### Technical Notes

**PatchStore changes**:
```typescript
class PatchStore {
  // Internal state
  private rawGraph: RawGraph;
  private normalizedCache: NormalizedGraph | null = null;

  // Public API
  getNormalizedGraph(): NormalizedGraph {
    if (!this.normalizedCache) {
      this.normalizedCache = normalize(this.rawGraph);
    }
    return this.normalizedCache;
  }

  // Invalidation on mutations
  addBlock(...) {
    // ... mutate rawGraph
    this.normalizedCache = null;  // Invalidate
  }
}
```

**Compiler integration**:
```typescript
// src/editor/compiler/index.ts
function compile(store: PatchStore) {
  const normalizedGraph = store.getNormalizedGraph();
  // Pass normalizedGraph to pass1-normalize (skip pass0-materialize)
}
```

**Backward compatibility**:
- Keep Patch serialization format unchanged (contains structural artifacts)
- On load: deserialize Patch, filter into RawGraph, normalize to rebuild
- On save: serialize NormalizedGraph (preserves structural artifacts for debugging)

**Migration path**:
- Existing patches load correctly (structural blocks filtered out, regenerated)
- No user-visible changes (default sources still work)
- Performance: normalization runs once per edit (acceptable for eager approach)

---

## Deferred Work (Out of Sprint Scope)

### Wire-State Blocks
**Reason**: Removed from scope per user clarification. Wire-state infrastructure (slew/delay) not needed for this sprint.

**Original spec reference**: 16-Graph-Normalization.md §176 (Pass 3: Wire-state)

**Future work**: If wire-state is needed, add:
- Anchor type: `{ kind: "wireState"; edgeId: string }`
- Normalization pass to insert state blocks on edges with transforms
- Update StructuralMapping to track wire-state artifacts

---

### Bus Junction Normalization
**Reason**: BusBlocks are always user-created (not structural artifacts). Normalization doesn't create or modify buses.

**Original spec reference**: 16-Graph-Normalization.md §175 (Pass 2: Bus junctions)

**Current behavior**: Users explicitly create BusBlock via PatchStore.addBus. Normalization treats buses as ordinary blocks (no special handling).

**Future work**: If automatic bus creation is needed:
- Add bus creation policy to StructuralManager
- Generate anchor-based junction IDs
- Update normalization pass to create bus tap blocks

---

### Incremental Normalization
**Reason**: Not needed for correctness. Normalization is deterministic and fast enough without reuse optimization.

**Original spec reference**: 16-Graph-Normalization.md §51 ("Can reuse previous normalized mapping")

**Current approach**: Full normalization on every change (eager, from scratch)

**Future optimization**: If performance becomes an issue:
- Pass `previousNormalized` to normalize()
- Reuse structural IDs when anchors unchanged
- Detect which parts of graph changed, only renormalize affected subgraph

---

### Cryptographic Hash IDs
**Reason**: Simple string concatenation is sufficient. No collision risk in practice.

**Original spec reference**: 16-Graph-Normalization.md §77 (`hash("structNode", anchor)`)

**Current approach**: `${blockId}_default_${slotId}` (deterministic, readable)

**Future work**: If ID stability across renames is needed:
- Implement hash-based ID generation (SHA-256 or UUID v5)
- Update anchor serialization to produce hash input
- Maintain backward compatibility (migrate old IDs)

---

## Dependency Graph

```
P0-1: Type System
  └─> P0-2: GraphNormalizer (depends on types)
       └─> P1-3: PatchStore Integration (depends on normalizer)
```

**Critical path**: P0-1 → P0-2 → P1-3 (sequential)

---

## Recommended Sprint Planning

**Sprint Goal**: Enable RawGraph/NormalizedGraph separation with eager normalization for default sources only.

### Sprint Deliverables (2-3 items max)

1. **Type System + GraphNormalizer** (P0-1 + P0-2 combined)
   - Implement types and normalizer together (tightly coupled)
   - Deliverable: GraphNormalizer produces NormalizedGraph from RawGraph
   - Tests: Determinism, ID stability

2. **PatchStore Integration** (P1-3)
   - Wire GraphNormalizer into store and compiler
   - Deliverable: Compiler receives NormalizedGraph, pass0-materialize removed
   - Tests: Existing tests pass, manual validation

3. **Documentation + Migration** (implicit)
   - Update ARCHITECTURE.md with new flow diagram
   - Document RawGraph vs NormalizedGraph distinction
   - Add comments explaining eager normalization strategy

### Out of Sprint
- Wire-state blocks (removed from scope)
- Bus junction normalization (buses are user-created)
- Incremental normalization (optimization, not required)
- Hash-based IDs (current approach sufficient)

---

## Risk Assessment

### High Risk Items

**P0-2: Migrating pass0-materialize logic**
- **Risk**: Breaking existing default source behavior during migration
- **Mitigation**: Copy tests from pass0-materialize.test.ts, run side-by-side comparison
- **Validation**: All existing patches compile identically before/after migration

**P1-3: Undo/redo on RawGraph only**
- **Risk**: History stack might contain structural artifacts from old implementation
- **Mitigation**: Clear history on migration, or filter structural artifacts during undo
- **Validation**: Manual testing of undo/redo with default sources

### Medium Risk Items

**Backward compatibility with existing patches**
- **Risk**: Patches serialized with structural artifacts might not load correctly
- **Mitigation**: Add migration logic to strip structural artifacts on load
- **Validation**: Load old patch files, verify normalized graph regenerates correctly

**Performance of eager normalization**
- **Risk**: Normalizing on every edit might be slow for large graphs
- **Mitigation**: Profile normalization performance, optimize if needed (or defer to lazy approach)
- **Validation**: Test with large patch (100+ blocks), measure normalization time

---

## Validation Strategy

### Unit Tests (New)

1. **Type system validation**
   - RawGraph → NormalizedGraph conversion
   - Anchor serialization/deserialization
   - StructuralMapping bidirectional lookup

2. **GraphNormalizer determinism**
   ```typescript
   test('normalize is deterministic', () => {
     const raw = createTestRawGraph();
     const norm1 = normalize(raw);
     const norm2 = normalize(raw);
     expect(norm1).toEqual(norm2);
   });
   ```

3. **ID stability**
   ```typescript
   test('structural IDs stable under block moves', () => {
     const raw1 = createGraph([{ id: 'b1', x: 0, y: 0 }]);
     const norm1 = normalize(raw1);
     const providerId1 = getProviderId(norm1, 'b1', 'in');

     const raw2 = moveBlock(raw1, 'b1', { x: 100, y: 100 });
     const norm2 = normalize(raw2);
     const providerId2 = getProviderId(norm2, 'b1', 'in');

     expect(providerId1).toBe(providerId2);
   });
   ```

### Integration Tests

4. **End-to-end compilation**
   ```typescript
   test('compiler receives NormalizedGraph with providers', () => {
     const store = createStoreWithUnwiredInput();
     const compiled = compile(store);

     // Verify provider block exists in compiled output
     expect(compiled.blocks).toContainEqual(
       expect.objectContaining({ role: 'structural' })
     );
   });
   ```

5. **Undo/redo preserves intent**
   ```typescript
   test('undo/redo operates on RawGraph only', () => {
     const store = new PatchStore();
     store.addBlock('Oscillator', { x: 0, y: 0 });
     const normBefore = store.getNormalizedGraph();

     store.undo();
     store.redo();

     const normAfter = store.getNormalizedGraph();
     expect(normBefore).toEqual(normAfter);
   });
   ```

### Manual Tests (Chrome DevTools)

6. **Default source materialization**
   - Create Oscillator block
   - Leave `freq` input unwired
   - Open DevTools, inspect compiled graph
   - Verify: DSConstSignalFloat provider exists, edge connects to `freq`

7. **Role metadata visibility**
   - Compile patch with default sources
   - Inspect NormalizedGraph blocks/edges
   - Verify: Structural artifacts have `role: "structural"`

---

## Files Referenced

### Existing (Read-Only)
- `design-docs/final-System-Invariants/16-Graph-Normalization.md` (spec)
- `src/editor/compiler/passes/pass0-materialize.ts` (logic to migrate)
- `src/editor/types.ts` (Patch, Block, Edge types)
- `src/editor/stores/PatchStore.ts` (integration point)

### New (Created This Sprint)
- `src/editor/graph/types.ts` (RawGraph, NormalizedGraph, Anchor)
- `src/editor/graph/GraphNormalizer.ts` (normalize function)
- `src/editor/graph/index.ts` (exports)

### Modified
- `src/editor/types.ts` (add `role?: EdgeRole` to Edge)
- `src/editor/stores/PatchStore.ts` (integrate normalization)
- `src/editor/compiler/index.ts` (use NormalizedGraph)
- `src/editor/compiler/passes/pass1-normalize.ts` (remove materialization logic)

---

## Success Criteria

Sprint is complete when:

1. Type system compiles without errors (`just typecheck`)
2. GraphNormalizer tests pass (determinism, ID stability)
3. All existing tests pass (`just test`)
4. Compiler receives NormalizedGraph (pass0-materialize removed)
5. Manual test: Unwired input gets provider block
6. Undo/redo works correctly (operates on RawGraph only)

Sprint has FAILED if:

- Default sources stop working (regression)
- Existing patches don't load correctly (breaking change)
- Normalization is non-deterministic (same input → different output)
- Structural artifacts appear in undo history (leaky abstraction)
