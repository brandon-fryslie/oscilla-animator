# Connection Unification Research
**Generated**: 2025-12-27-041500
**Question**: Can we unify bus→block, block→bus, and block→block connections?

---

## Current Architecture

### Three Connection Types

| Type | Source | Sink | Store | Purpose |
|------|--------|------|-------|---------|
| **Wire (Connection)** | Block output port | Block input port | PatchStore.connections | Direct data flow |

### Key Discovery: GraphEdge Already Unifies Them

In the semantic validation layer (`src/editor/compiler/passes/pass2-wiring.ts`), there's already a unified abstraction:

```typescript
type GraphEdge =
  | { kind: 'wire'; connection: Connection }
```

This is used for:
- Type checking all edges uniformly
- Cycle detection across all edge types
- Dependency ordering

---

## Why They're Separate (Semantic Differences)

### 1. **Cardinality**
- **Wire**: 1:1 (one output → one input)

### 2. **Combine Semantics**
- **Wire**: No combining needed
- **Bus**: Requires combine mode (sum, max, latest, etc.)
- This is a fundamental semantic difference that can't be abstracted away

### 3. **Naming & Discovery**
- **Wire**: Anonymous, identified by port references
- **Bus**: Named entity, discoverable by name ("phaseA", "masterClock")
- Users think about buses as "channels" they can browse

### 4. **Type Domains**
- **Bus**: Has explicit domain type (Signal:phase, Event, Field:number, etc.)
- **Wire**: Type inferred from connected ports
- Bus types can be changed independently of connections

---

## Options Analysis

### Option A: Status Quo (Keep Separate)
**Effort**: 0 days
**Risk**: None
**Impact**: Continue implementing features 3 times

### Option B: Full Unification at Store Layer
**Effort**: 15-20 days
**Risk**: HIGH - Breaks bus semantics, combine modes, naming
**Impact**: Forces buses into wire model, loses broadcast semantics

### Option C: Strengthen Semantic Layer (RECOMMENDED)
**Effort**: 2-3 days
**Risk**: Low - Additive, no breaking changes
**Impact**: Unified query interface, less UI duplication

### Option D: Eliminate Buses
**Effort**: 30+ days
**Risk**: EXTREME - Violates design docs, breaks user mental model
**Impact**: Complete architecture rewrite

---

## Recommendation: Option C - EdgeQueryService

Create a unified query interface that abstracts over all edge types for common operations:

```typescript
// src/editor/services/EdgeQueryService.ts
export class EdgeQueryService {
  constructor(private patchStore: PatchStore, private busStore: BusStore) {}

  getEdgesForBlock(blockId: string): GraphEdge[] { ... }

  // Get all edges for a port
  getEdgesForPort(blockId: string, portId: string, direction: 'in' | 'out'): GraphEdge[] { ... }

  // Disconnect a port from everything
  disconnectPort(blockId: string, portId: string, direction: 'in' | 'out'): void { ... }

  getValueSourceForInput(blockId: string, inputId: string): ValueSource { ... }

  // Sample value at any edge (unified for probe mode!)
  sampleEdgeValue(edge: GraphEdge): ValueSummary { ... }
}
```

### Benefits
1. **Unified Probe Mode**: One hover handler works for all edge types
2. **Less UI Duplication**: Inspector, BusBoard, PatchBay share queries
3. **Edge-Agnostic Operations**: "Delete all connections to this block" works uniformly
4. **Preserves Semantics**: Stores remain separate, type safety preserved

### What Stays Different
- Bus naming and discovery (BusBoard)
- Combine mode configuration
- Bus type editing

---

## Conclusion

**Answer**: Yes, unification is possible and ALREADY EXISTS at the semantic layer. The right approach is NOT to force unification at the store layer, but to strengthen the query interface for UI operations.

The three concepts should remain separate because:
1. Buses have broadcast (1:N) semantics, wires are point-to-point
2. Buses have combine modes, wires don't
3. Buses are named entities users browse, wires are anonymous

But for features like:
- Probe Mode hover (show value for any edge)
- Disconnection (remove any edge from a port)
- Edge visualization (highlight any edge)

An `EdgeQueryService` provides the unified abstraction without breaking the semantic model.
