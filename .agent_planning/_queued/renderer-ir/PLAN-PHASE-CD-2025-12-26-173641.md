# Sprint Plan: Phases C+D - Instances2D and Paths2D Runtime
**Generated:** 2025-12-26-173641
**Source STATUS:** STATUS-20251226160000.md
**Source Specs:** Doc 01 (RendererIR), Doc 09 (Materialization Steps)
**Prerequisites:** Phase A COMPLETE, Phase B COMPLETE
**Estimated Complexity:** LARGE (4 sprints total: 2 for Phase C, 2 for Phase D)

---

## Sprint Goal

Build end-to-end runtime pipelines for both Instances2D and Paths2D rendering primitives, enabling the renderer IR system to produce and consume typed buffers for both high-volume particle systems and expressive vector path rendering. These phases implement the materialization → assembly → render pipeline for both primitives together, sharing buffer infrastructure and integration points.

**Combined Success Criteria:**
- Instances2D: 1000 circles with colors render correctly via RenderFrameIR
- Paths2D: Simple path with curves renders correctly via RenderFrameIR
- MaterializeColor and MaterializePath run as scheduled steps
- Canvas renderer consumes Instances2DPassIR and Paths2DPassIR
- Buffer management uses ColorBufferDesc and PathCommandStreamDesc from Phase B
- ScheduleExecutor integrates new step types cleanly
- Visual smoke tests demonstrate both primitives working together

---

## In Scope

### Phase C: Instances2D Runtime (Sprints 1-2)

#### Deliverable C1: MaterializeColor Scheduled Step
Implement color quantization as an explicit, cacheable scheduled step that converts field&lt;color&gt; to u8x4 premultiplied linear RGBA buffers.

#### Deliverable C2: InstanceBufferSetIR Assembly
Implement buffer assembly logic that packs per-instance attributes (posXY, size, rot, colorRGBA) into typed arrays referenced by BufferRefIR.

#### Deliverable C3: Instances2D Rendering
Update Canvas renderer to consume Instances2DPassIR and draw instances using packed buffers.

#### Deliverable C4: Instance Sorting Infrastructure
Implement optional per-instance sorting (InstanceSortIR) for correct alpha blending.

### Phase D: Paths2D Runtime (Sprints 3-4)

#### Deliverable D1: MaterializePath Scheduled Step
Implement path encoding as an explicit, cacheable scheduled step that converts path expressions to command streams and point arrays.

#### Deliverable D2: PathGeometryBufferIR Assembly
Implement path geometry buffer packing with per-path indexing (pathCommandStart, pathPointStart arrays).

#### Deliverable D3: Paths2D Rendering
Update Canvas renderer to consume Paths2DPassIR and draw paths from packed geometry buffers.

#### Deliverable D4: Path Flattening Infrastructure (Optional)
Implement optional curve-to-polyline flattening using CANONICAL_FLATTEN_TOL_PX.

---

## Out of Scope

- **Caching infrastructure** - Phase E work (cache keys, policies, eviction)
- **Full Canvas renderer rewrite** - Phase F work (this phase extends existing renderer)
- **3D projection** - Phases G-H
- **Export pipeline** - Separate initiative
- **Performance optimization** - Focus on correctness first, optimize in Phase F
- **Advanced path operations** - Boolean ops, variable-width strokes deferred
- **Sprite and glyph materials** - Shape2D only for now (InstanceMaterialIR extensibility proven)

---

## Work Items

### Phase C: Instances2D Runtime

---

#### P0.C1: Implement MaterializeColor Step Executor

**Status:** Not Started
**Effort:** MEDIUM
**Dependencies:** Phase B complete (ColorBufferDesc, quantizeColorRGBA kernel)
**Spec Reference:** Doc 09 (MaterializeColor contract) • Doc 04 (ColorBufferDesc)
**Status Reference:** STATUS-20251226160000.md section "Doc 05: Upstream Impacts"

##### Description
Create the `executeMaterializeColor` step executor that converts field&lt;color&gt; or signal&lt;color&gt; values to u8x4 premultiplied linear RGBA buffers using the ColorQuantize kernel from Phase B.

##### Acceptance Criteria
- [ ] `executeMaterializeColor.ts` created in `src/editor/runtime/executor/steps/`
- [ ] Handles signal&lt;color&gt; (single value) and field&lt;color&gt; (instanceCount values)
- [ ] Calls `quantizeColorRGBA()` for signal, `quantizeColorRGBABatch()` for field
- [ ] Writes Uint8Array to bufferSlot in ValueStore
- [ ] Emits performance counters: cpuMs, bytesWritten, sourceEvalMs
- [ ] Unit test: signal&lt;color&gt; → u8x4 buffer produces correct bytes
- [ ] Unit test: field&lt;color&gt; with 100 instances → u8x4 buffer (400 bytes)

##### Technical Notes
- Use existing `quantizeColorRGBA()` from `src/editor/runtime/kernels/ColorQuantize.ts`
- Buffer allocation via ValueStore (not BufferPool yet - caching is Phase E)
- Performance counters prepare for Phase E cache attribution
- Step contract follows Doc 09 exactly

---

#### P0.C2: Define StepMaterializeColor IR Type

**Status:** Not Started
**Effort:** SMALL
**Dependencies:** Phase A (ScheduleIR types)
**Spec Reference:** Doc 09 (MaterializeColor contract)
**Status Reference:** STATUS-20251226160000.md section "Dependencies: What Phase 6 Work Must Complete First"

##### Description
Extend ScheduleIR with StepMaterializeColor type so compiler can emit color materialization steps.

##### Acceptance Criteria
- [ ] `StepMaterializeColor` interface defined in `src/editor/compiler/ir/schedule.ts`
- [ ] Fields: `kind: "materializeColor"`, `sourceSlot`, `bufferSlot`, `instanceCount?`, `bufferDesc: ColorBufferDesc`
- [ ] Added to `StepIR` union type
- [ ] ScheduleExecutor dispatch handles "materializeColor" case
- [ ] TypeScript compilation passes
- [ ] Unit test: StepMaterializeColor type guards work

##### Technical Notes
- Separate from generic `StepMaterialize` to make color quantization explicit
- `instanceCount` is optional (undefined for signal&lt;color&gt;, required for field&lt;color&gt;)
- `bufferDesc` always uses `CANONICAL_COLOR_BUFFER_DESC` from Phase B

---

#### P0.C3: Implement InstanceBufferSetIR Assembly

**Status:** Not Started
**Effort:** LARGE
**Dependencies:** P0.C1, P0.C2
**Spec Reference:** Doc 01 (InstanceBufferSetIR) • Doc 01 (BufferRefIR)
**Status Reference:** STATUS-20251226160000.md section "Doc 01: RenderFrameIR Specification"

##### Description
Build the buffer assembly logic that converts materialized field buffers into InstanceBufferSetIR structures with BufferRefIR references for posXY, size, rot, colorRGBA, etc.

##### Acceptance Criteria
- [ ] Function `assembleInstanceBuffers()` created in runtime executor
- [ ] Handles required buffer: posXY (Float32Array, length=count*2)
- [ ] Handles optional buffers: size, rot, colorRGBA, opacity (BufferRefIR or ScalarF32IR/ScalarU32IR)
- [ ] Allocates dense bufferIds from ValueStore
- [ ] Produces BufferRefIR with correct type ("f32", "u32", etc.) and length
- [ ] Unit test: 10 instances with posXY, size, colorRGBA → valid InstanceBufferSetIR
- [ ] Unit test: Scalar broadcast (all instances same size) → ScalarF32IR, no buffer allocation
- [ ] E2E test: Materialize colors → assemble instance buffers → read buffers from ValueStore

##### Technical Notes
- BufferRefIR.bufferId is dense index into ValueStore's buffer array
- Scalar broadcasts avoid allocating N copies of constant value
- Instance count must match across all buffers (validate in assembler)
- ShapeId encoding: 0=circle, 1=square, 2=star (document convention)

---

#### P0.C4: Extend Canvas Renderer for Instances2DPassIR

**Status:** Not Started
**Effort:** LARGE
**Dependencies:** P0.C3
**Spec Reference:** Doc 01 (Instances2DPassIR) • Doc 00 (Renderer responsibilities)
**Status Reference:** STATUS-20251226160000.md section "Current Render Pipeline (Legacy - To Be Replaced)"

##### Description
Update Canvas2DRenderer to consume Instances2DPassIR from RenderFrameIR and draw instances using packed buffers, not per-instance objects.

##### Acceptance Criteria
- [ ] `renderInstances2DPass()` function created in Canvas renderer
- [ ] Reads buffers from ValueStore via BufferRefIR
- [ ] Handles scalar broadcasts (ScalarF32IR/ScalarU32IR) as constant values
- [ ] Draws shape2d material: circles, squares, stars (shapeId selection)
- [ ] Applies per-instance posXY, size, rot, colorRGBA from buffers
- [ ] Respects RenderPassHeaderIR: z-order, clip, view transform, blend
- [ ] Unit test: Mock Instances2DPassIR with 5 circles → 5 Canvas arc() calls
- [ ] E2E test: Compile simple patch → RenderFrameIR → Canvas draws correctly
- [ ] Visual smoke test: 1000 circles with random colors render at 60fps

##### Technical Notes
- No per-instance save/restore (spec prohibits this for performance)
- Use setTransform() once per pass for view transform
- Unpack u8x4 colors to Canvas RGBA via dequantizeColorRGBA()
- Shape rendering uses unit-sized primitives scaled by size buffer
- Legacy RenderCmd path can coexist during migration (dual-emit pattern)

---

#### P1.C5: Implement Instance Sorting

**Status:** Not Started
**Effort:** MEDIUM
**Dependencies:** P0.C4
**Spec Reference:** Doc 01 (InstanceSortIR)
**Status Reference:** STATUS-20251226160000.md section "Doc 01: RenderFrameIR Specification"

##### Description
Implement optional per-instance sorting for correct alpha blending (back-to-front or front-to-back ordering).

##### Acceptance Criteria
- [ ] `sortInstances()` function created in runtime executor
- [ ] Handles InstanceSortIR.kind="byKey" with Float32 sort key buffer
- [ ] Sorts indices (not buffers) to preserve buffer stability
- [ ] Order: "asc" or "desc" as specified
- [ ] Stable sort (deterministic for equal keys)
- [ ] Canvas renderer draws in sorted order
- [ ] Unit test: 10 instances with random keys → sorted draw order
- [ ] E2E test: Overlapping semi-transparent circles sort correctly by z-key

##### Technical Notes
- Sort creates index array, renderer iterates in index order
- Sorting is O(n log n) but only when InstanceSortIR present (optional)
- Determinism critical: same keys → same order (stable sort required)
- Default (no InstanceSortIR) is pass-order (no sorting overhead)

---

#### P1.C6: End-to-End Instances2D Pipeline Test

**Status:** Not Started
**Effort:** MEDIUM
**Dependencies:** P0.C1, P0.C2, P0.C3, P0.C4
**Spec Reference:** Doc 01 (complete Instances2D pipeline)
**Status Reference:** STATUS-20251226160000.md section "Workflow Recommendation"

##### Description
Build comprehensive end-to-end test demonstrating the complete Instances2D pipeline from patch compilation through materialization to rendering.

##### Acceptance Criteria
- [ ] E2E test: Simple patch with Instances2D block compiles to RenderFrameIR
- [ ] Test verifies: ScheduleIR includes materializeColor, renderAssemble steps
- [ ] Test verifies: RenderFrameIR contains Instances2DPassIR with correct buffers
- [ ] Test verifies: Canvas renderer draws instances correctly
- [ ] Visual smoke test: 1000 circles with gradient colors, rotation, varying sizes
- [ ] Performance check: 1000 instances render in <16ms (60fps)
- [ ] Determinism check: Same patch → identical RenderFrameIR on repeat compile

##### Technical Notes
- Use minimal patch (Instances2D with constant or simple signal inputs)
- Mock Canvas for unit tests, real Canvas for visual smoke tests
- Performance baseline: legacy RenderCmd vs new Instances2DPassIR
- Capture RenderFrameIR snapshot for regression testing (Phase F)

---

### Phase D: Paths2D Runtime

---

#### P0.D1: Implement MaterializePath Step Executor

**Status:** Not Started
**Effort:** LARGE
**Dependencies:** Phase B complete (PathCommandStreamDesc, FlattenPolicy)
**Spec Reference:** Doc 09 (MaterializePath contract) • Doc 04 (PathCommandStreamDesc)
**Status Reference:** STATUS-20251226160000.md section "Doc 04: Decision-to-IR Mapping"

##### Description
Create the `executeMaterializePath` step executor that converts path expressions to PathCommandStream buffers (u16 opcodes) with optional curve flattening.

##### Acceptance Criteria
- [ ] `executeMaterializePath.ts` created in `src/editor/runtime/executor/steps/`
- [ ] Handles path expressions with curves (MoveTo, LineTo, QuadTo, CubicTo, Close)
- [ ] Encodes commands to Uint16Array with canonical opcodes (0=M, 1=L, 2=Q, 3=C, 4=Z)
- [ ] Packs control points to Float32Array (interleaved xy pairs)
- [ ] Writes commandsSlot (Uint16Array) and pointsSlot (Float32Array) to ValueStore
- [ ] FlattenPolicy.off: Preserves curves (default)
- [ ] FlattenPolicy.on: Flattens curves to polylines with CANONICAL_FLATTEN_TOL_PX
- [ ] Emits performance counters: cpuMs, bytesCommands, bytesPoints, flattenedSegments
- [ ] Unit test: Simple path (M, L, L, Z) → correct command/point buffers
- [ ] Unit test: Path with quad curve → Q command consumes 2 points
- [ ] Unit test: Path with cubic curve → C command consumes 3 points

##### Technical Notes
- Command encoding: M=0, L=1, Q=2, C=3, Z=4 (u16, little-endian)
- Point consumption: M:1pt, L:1pt, Q:2pts, C:3pts, Z:0pts
- Flattening uses adaptive subdivision (de Casteljau or midpoint)
- Tolerance is screen-space (pixel-based), so view-dependent
- Without flattening, paths are viewport-independent (better cache reuse)

---

#### P0.D2: Define StepMaterializePath IR Type

**Status:** Not Started
**Effort:** SMALL
**Dependencies:** Phase A (ScheduleIR types)
**Spec Reference:** Doc 09 (MaterializePath contract)
**Status Reference:** STATUS-20251226160000.md section "Doc 05: Upstream Impacts"

##### Description
Extend ScheduleIR with StepMaterializePath type so compiler can emit path materialization steps.

##### Acceptance Criteria
- [ ] `StepMaterializePath` interface defined in `src/editor/compiler/ir/schedule.ts`
- [ ] Fields: `kind: "materializePath"`, `sourceSlot`, `commandsSlot`, `pointsSlot`, `flattenPolicy`, `commandDesc`
- [ ] Added to `StepIR` union type
- [ ] ScheduleExecutor dispatch handles "materializePath" case
- [ ] TypeScript compilation passes
- [ ] Unit test: StepMaterializePath type guards work

##### Technical Notes
- `flattenPolicy` uses FlattenPolicy from Phase B (off or on-canonical)
- `commandDesc` always uses `CANONICAL_PATH_COMMAND_DESC` (u16, LE)
- Flattened paths require viewport/DPR in cache key (Phase E work)

---

#### P0.D3: Implement PathGeometryBufferIR Assembly

**Status:** Not Started
**Effort:** LARGE
**Dependencies:** P0.D1, P0.D2
**Spec Reference:** Doc 01 (PathGeometryBufferIR) • Doc 01 (PathEncodingIR)
**Status Reference:** STATUS-20251226160000.md section "Doc 01: RenderFrameIR Specification"

##### Description
Build the path geometry buffer assembly logic that packs multiple paths into a single geometry buffer with per-path indexing.

##### Acceptance Criteria
- [ ] Function `assemblePathGeometry()` created in runtime executor
- [ ] Handles multiple paths (pathCount > 1)
- [ ] Generates pathCommandStart, pathCommandLen arrays (Uint32Array, length=pathCount)
- [ ] Generates pathPointStart, pathPointLen arrays (Uint32Array, length=pathCount)
- [ ] Concatenates all path commands into single Uint16Array
- [ ] Concatenates all path points into single Float32Array
- [ ] Produces PathGeometryBufferIR with correct BufferRefIR references
- [ ] Unit test: 2 simple paths → correct indexing (path 0: cmd[0..2], path 1: cmd[3..5])
- [ ] Unit test: Path with no commands (empty) → zero-length slice
- [ ] E2E test: Materialize 3 paths → assemble geometry → read buffers from ValueStore

##### Technical Notes
- Per-path indexing enables efficient morphing (stable point counts)
- Command/point streams are flat (no nested arrays)
- Indexing uses start+length, not start+end (avoids off-by-one errors)
- Empty paths are valid (zero-length slices)

---

#### P0.D4: Extend Canvas Renderer for Paths2DPassIR

**Status:** Not Started
**Effort:** LARGE
**Dependencies:** P0.D3
**Spec Reference:** Doc 01 (Paths2DPassIR) • Doc 01 (PathStyleIR)
**Status Reference:** STATUS-20251226160000.md section "Current Render Pipeline (Legacy - To Be Replaced)"

##### Description
Update Canvas2DRenderer to consume Paths2DPassIR from RenderFrameIR and draw paths from packed command/point buffers.

##### Acceptance Criteria
- [ ] `renderPaths2DPass()` function created in Canvas renderer
- [ ] Reads command/point buffers from ValueStore via BufferRefIR
- [ ] Decodes u16 commands to Canvas path operations (moveTo, lineTo, quadraticCurveTo, bezierCurveTo, closePath)
- [ ] Applies PathStyleIR: fill (fillStyle, fillRule), stroke (strokeStyle, lineWidth, lineCap, lineJoin, dash)
- [ ] Handles per-path or global styling (scalar vs buffer)
- [ ] Respects RenderPassHeaderIR: z-order, clip, view transform, blend
- [ ] Unit test: Mock Paths2DPassIR with simple path → Canvas moveTo/lineTo calls
- [ ] E2E test: Compile path block → RenderFrameIR → Canvas draws correctly
- [ ] Visual smoke test: Simple path with quad and cubic curves renders accurately

##### Technical Notes
- Command decoding: 0→moveTo(1pt), 1→lineTo(1pt), 2→quadraticCurveTo(2pts), 3→bezierCurveTo(3pts), 4→closePath(0pts)
- Fill rule: "nonzero" (default) or "evenodd"
- Dash pattern: setLineDash(pattern), lineDashOffset=offset
- Scalar color broadcasts avoid per-path fillStyle changes (performance)
- Per-path indexing: iterate paths, extract command/point slices, build Canvas path

---

#### P1.D5: Implement Path Flattening Kernel (Optional)

**Status:** Not Started
**Effort:** MEDIUM
**Dependencies:** P0.D1
**Spec Reference:** Doc 04 (FlattenPolicy, CANONICAL_FLATTEN_TOL_PX)
**Status Reference:** STATUS-20251226160000.md section "Doc 03: Decisions"

##### Description
Implement optional curve-to-polyline flattening using CANONICAL_FLATTEN_TOL_PX (0.75px) for paths that need Canvas2D performance optimization.

##### Acceptance Criteria
- [ ] `flattenPathKernel()` function created in `src/editor/runtime/kernels/`
- [ ] Accepts path with curves (Q, C commands)
- [ ] Outputs flattened path (M, L, Z commands only)
- [ ] Tolerance: CANONICAL_FLATTEN_TOL_PX (0.75px in screen space)
- [ ] Uses adaptive subdivision (recursive midpoint or de Casteljau)
- [ ] Produces deterministic output (same curve → same polyline)
- [ ] Unit test: Quad curve → polyline with max deviation <0.75px
- [ ] Unit test: Cubic curve → polyline with max deviation <0.75px
- [ ] Unit test: Straight line (L) → unchanged (no subdivision)

##### Technical Notes
- Flattening is screen-space dependent (needs viewport transform context)
- Recursive subdivision until all segments within tolerance
- Tolerance check: distance from curve to chord < CANONICAL_FLATTEN_TOL_PX
- Fallback: If flattening fails (pathological curve), preserve curve (safe default)
- This is a kernel (pure function), not a step executor

---

#### P1.D6: End-to-End Paths2D Pipeline Test

**Status:** Not Started
**Effort:** MEDIUM
**Dependencies:** P0.D1, P0.D2, P0.D3, P0.D4
**Spec Reference:** Doc 01 (complete Paths2D pipeline)
**Status Reference:** STATUS-20251226160000.md section "Workflow Recommendation"

##### Description
Build comprehensive end-to-end test demonstrating the complete Paths2D pipeline from patch compilation through materialization to rendering.

##### Acceptance Criteria
- [ ] E2E test: Simple patch with path block compiles to RenderFrameIR
- [ ] Test verifies: ScheduleIR includes materializePath, renderAssemble steps
- [ ] Test verifies: RenderFrameIR contains Paths2DPassIR with correct geometry
- [ ] Test verifies: Canvas renderer draws paths correctly
- [ ] Visual smoke test: Path with M, L, Q, C commands renders accurately
- [ ] Visual smoke test: Multiple paths with different fill/stroke styles
- [ ] Determinism check: Same patch → identical PathGeometryBufferIR on repeat compile

##### Technical Notes
- Use path with all command types (M, L, Q, C, Z) to validate encoding
- Test both flattening on and off (if D5 implemented)
- Compare visual output to reference (Canvas Path2D from legacy code)
- Capture PathGeometryBufferIR snapshot for regression testing

---

### Integration Work Items (Shared Between C and D)

---

#### P0.I1: Extend ScheduleExecutor Dispatch

**Status:** Not Started
**Effort:** SMALL
**Dependencies:** P0.C2, P0.D2
**Spec Reference:** Design docs 12-Compiler-Final/17-Scheduler-Full.md
**Status Reference:** STATUS-20251226160000.md section "Dependencies: What Phase 6 Work Must Complete First"

##### Description
Update ScheduleExecutor to dispatch materializeColor and materializePath steps to their respective executors.

##### Acceptance Criteria
- [ ] ScheduleExecutor switch statement handles "materializeColor" case
- [ ] ScheduleExecutor switch statement handles "materializePath" case
- [ ] Both cases call correct executor functions
- [ ] Performance counters collected and reported
- [ ] Unit test: Schedule with materializeColor step executes correctly
- [ ] Unit test: Schedule with materializePath step executes correctly

##### Technical Notes
- Extend existing executor dispatch (similar to materialize, nodeEval)
- Performance counters prepare for Phase E cache attribution
- Error handling: invalid step types throw with clear message

---

#### P0.I2: Implement executeRenderAssemble for RenderFrameIR

**Status:** Not Started
**Effort:** LARGE
**Dependencies:** P0.C3, P0.D3
**Spec Reference:** Doc 01 (RenderFrameIR)
**Status Reference:** STATUS-20251226160000.md section "Dependencies: What Phase 6 Work Must Complete First"

##### Description
Complete the `executeRenderAssemble` step executor that assembles RenderFrameIR from materialized instance/path buffers and pass specifications.

##### Acceptance Criteria
- [ ] `executeRenderAssemble()` in `steps/executeRenderAssemble.ts` assembles RenderFrameIR
- [ ] Creates RenderPassHeaderIR for each pass (z, enabled, clip, view, blend)
- [ ] Assembles Instances2DPassIR from instance buffer sets
- [ ] Assembles Paths2DPassIR from path geometry buffers
- [ ] Writes RenderFrameIR to output slot in ValueStore
- [ ] Handles ClearSpecIR (color or none)
- [ ] Handles optional overlays (future work, stubbed)
- [ ] Unit test: Assemble RenderFrameIR with 1 Instances2D pass
- [ ] Unit test: Assemble RenderFrameIR with 1 Paths2D pass
- [ ] Unit test: Assemble RenderFrameIR with mixed passes (Instances2D + Paths2D)

##### Technical Notes
- This is the bridge from ValueStore buffers to RenderFrameIR structure
- Pass ordering by z-order (stable sort)
- RenderFrameIR version always 1
- FrameKey preparation for Phase E cache continuity (optional for now)

---

#### P1.I3: Dual-Emit Pattern for Migration Safety

**Status:** Not Started
**Effort:** MEDIUM
**Dependencies:** P0.I2
**Spec Reference:** Doc 00 (migration strategy)
**Status Reference:** STATUS-20251226160000.md section "Risks and Ambiguities"

##### Description
Implement dual-emit pattern where compiler can produce both legacy RenderCmd and new RenderFrameIR during migration, allowing gradual rollout and A/B testing.

##### Acceptance Criteria
- [ ] Feature flag: `USE_RENDER_FRAME_IR` (default false for safety)
- [ ] When true: emit RenderFrameIR path
- [ ] When false: emit legacy RenderCmd path
- [ ] Both paths can coexist in same build
- [ ] Runtime switches based on flag
- [ ] Unit test: Flag=true → RenderFrameIR path used
- [ ] Unit test: Flag=false → legacy path used
- [ ] Visual regression: Both paths produce identical output for simple patches

##### Technical Notes
- Dual-emit allows gradual migration without breaking existing patches
- Phase F will remove legacy path once RenderFrameIR proven stable
- Feature flag in compiler feature flags module
- Smoke tests should run both paths initially

---

## Dependencies

### Critical Dependencies (BLOCKING)
- **Phase A complete** - All RenderFrameIR types defined (COMPLETE per PHASE-A-VERIFICATION)
- **Phase B complete** - ColorBufferDesc, PathCommandStreamDesc, quantization kernels (IN PROGRESS)
- **ScheduleExecutor** - Step dispatch infrastructure (EXISTS, needs extension)
- **ValueStore** - Typed buffer storage (COMPLETE from Phase 6)
- **BufferPool** - Buffer reuse infrastructure (COMPLETE from Phase 6)

### Non-Blocking Dependencies (Can Proceed in Parallel)
- **Caching infrastructure** - Phase E work (materialization can work without caching)
- **Full Canvas renderer rewrite** - Phase F work (incremental extension for now)
- **Hot-swap continuity** - Phase E work (cache keys enable this)

### Shared Infrastructure (Built in These Phases)
- Buffer assembly utilities (shared by C and D)
- ScheduleExecutor extensions (shared by C and D)
- RenderFrameIR assembly (shared by C and D)
- ValueStore buffer management patterns (shared by C and D)

---

## Risks

### High-Risk Areas

| Risk | Impact | Mitigation |
|------|--------|------------|
| **Color quantization performance** | Could be slower than direct float RGBA | Benchmark early, optimize with SIMD if needed (Phase F) |
| **Path encoding correctness** | Wrong command encoding breaks rendering | Comprehensive unit tests, visual regression tests |
| **Buffer indexing errors** | Off-by-one in path indexing causes crashes | Test boundary conditions, validate all indices |
| **Canvas API quirks** | Browser differences in path rendering | Normalize conventions, test across browsers |
| **Dual-emit complexity** | Maintaining two code paths increases risk | Keep dual-emit period short, remove legacy in Phase F |

### Medium-Risk Areas

| Risk | Impact | Mitigation |
|------|--------|------------|
| **Performance regression** | New pipeline could be slower than legacy | Benchmark early, profile Canvas ops |
| **Memory usage** | More buffers = more memory | Use BufferPool reuse, defer optimization to Phase E |
| **Flattening tolerance** | Pixel-based tolerance interacts with zoom/DPR | Lock canonical tolerance, document viewport dependency |
| **Sort stability** | Unstable sort breaks determinism | Use stable sort algorithm, test with equal keys |

---

## Verification Strategy

### Per-Phase Checks

**Phase C (Instances2D):**
```bash
just test:instances2d        # Unit tests for instance pipeline
just smoke:instances2d       # Visual smoke test: 1000 circles
just bench:instances2d       # Performance: instances2d vs legacy
```

**Phase D (Paths2D):**
```bash
just test:paths2d            # Unit tests for path pipeline
just smoke:paths2d           # Visual smoke test: path with curves
just test:path-flatten       # Path flattening correctness
```

**Integration:**
```bash
just test:render-ir          # Combined Instances2D + Paths2D tests
just smoke:render-ir         # Visual: mixed passes render correctly
```

### Persistent Checks (Always Run)
```bash
just check                   # Typecheck + lint + test (must pass)
just test:field              # Field materialization (dependency)
just test:signal             # Signal evaluation (dependency)
```

### Visual Smoke Tests

**Instances2D Visual Test:**
- 1000 circles with random positions, sizes, colors, rotation
- Verify: all circles visible, colors correct, blending smooth
- Performance: 60fps minimum

**Paths2D Visual Test:**
- Path with M, L, Q, C, Z commands
- Verify: curves smooth, no artifacts, stroking/filling correct
- Test with and without flattening (if D5 implemented)

**Mixed Pass Visual Test:**
- Patch with both Instances2D and Paths2D passes
- Verify: z-ordering correct, blending between pass types
- Verify: view transforms apply to both pass types

---

## Success Metrics

**Functional:**
- [ ] Instances2D: 1000 circles render correctly via RenderFrameIR
- [ ] Paths2D: Path with curves renders correctly via RenderFrameIR
- [ ] MaterializeColor step executes and produces u8x4 buffers
- [ ] MaterializePath step executes and produces command/point buffers
- [ ] Canvas renderer consumes both pass types
- [ ] ScheduleExecutor integrates new step types cleanly

**Performance:**
- [ ] Instances2D: ≥90% of legacy RenderCmd performance (defer optimization to Phase F)
- [ ] Paths2D: Comparable to legacy Path2DCommand performance
- [ ] Color quantization: <1ms for 1000 instances
- [ ] Path encoding: <5ms for 1000-point path

**Quality:**
- [ ] All unit tests pass
- [ ] Visual smoke tests pass
- [ ] Zero TypeScript errors
- [ ] Deterministic output (same patch → same buffers)

---

## Next Steps After Completion

**Immediate (Phase E):**
1. Implement caching infrastructure (CacheKeySpec, policies, budgets)
2. Add cache keys to MaterializeColor and MaterializePath
3. Validate hot-swap continuity (cache persists across recompile)

**After Phase E (Phase F):**
1. Complete Canvas renderer rewrite (consume only RenderFrameIR)
2. Remove legacy RenderCmd/Canvas2DRenderer code
3. Performance optimization pass
4. Visual regression test suite

**Deferred (Phases G-H):**
1. 3D camera and mesh infrastructure
2. 3D→2D projection pipeline

---

## Files to Create/Modify

### Phase C Files

**New Files:**
- `src/editor/runtime/executor/steps/executeMaterializeColor.ts`
- `src/editor/runtime/executor/assembleInstanceBuffers.ts`
- `src/editor/runtime/canvasRenderer/renderInstances2DPass.ts`
- `src/editor/runtime/kernels/SortInstances.ts`
- `src/editor/compiler/ir/__tests__/stepMaterializeColor.test.ts`
- `src/editor/runtime/__tests__/instances2d-pipeline.test.ts`

**Modified Files:**
- `src/editor/compiler/ir/schedule.ts` (add StepMaterializeColor)
- `src/editor/runtime/executor/ScheduleExecutor.ts` (dispatch materializeColor)
- `src/editor/runtime/canvasRenderer.ts` (add Instances2DPassIR branch)

### Phase D Files

**New Files:**
- `src/editor/runtime/executor/steps/executeMaterializePath.ts`
- `src/editor/runtime/executor/assemblePathGeometry.ts`
- `src/editor/runtime/canvasRenderer/renderPaths2DPass.ts`
- `src/editor/runtime/kernels/FlattenPath.ts` (optional)
- `src/editor/compiler/ir/__tests__/stepMaterializePath.test.ts`
- `src/editor/runtime/__tests__/paths2d-pipeline.test.ts`

**Modified Files:**
- `src/editor/compiler/ir/schedule.ts` (add StepMaterializePath)
- `src/editor/runtime/executor/ScheduleExecutor.ts` (dispatch materializePath)
- `src/editor/runtime/canvasRenderer.ts` (add Paths2DPassIR branch)

### Integration Files

**New Files:**
- `src/editor/runtime/__tests__/render-frame-ir-e2e.test.ts`

**Modified Files:**
- `src/editor/runtime/executor/steps/executeRenderAssemble.ts` (complete implementation)
- `src/editor/compiler/featureFlags.ts` (add USE_RENDER_FRAME_IR flag)

---

## Appendix: Design Doc Coverage

### Phase C Coverage
- **Doc 01 Section 3:** Complete Instances2D implementation
- **Doc 09 MaterializeColor:** Complete contract implementation
- **Doc 04 ColorBufferDesc:** Uses encoding from Phase B
- **Doc 05 Impact 2:** Materialization as scheduled step (Instances2D case)

### Phase D Coverage
- **Doc 01 Section 4:** Complete Paths2D implementation
- **Doc 09 MaterializePath:** Complete contract implementation
- **Doc 04 PathCommandStreamDesc:** Uses encoding from Phase B
- **Doc 04 FlattenPolicy:** Implements optional flattening
- **Doc 05 Impact 2:** Materialization as scheduled step (Paths2D case)

### Deferred Coverage (Phase E+)
- **Doc 08:** Complete caching specification (Phase E)
- **Doc 05 Impact 3:** Cache keys with encoding/policy (Phase E)
- **Doc 05 Impact 4:** Debugger instrumentation (Phase E)
- **Doc 07:** 3D additions (Phases G-H)
