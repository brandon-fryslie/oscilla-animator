# Definition of Done: Phase B - Color & Encoding Foundation
**Generated:** 2025-12-26-164500
**Plan:** PLAN-PHASE-B-2025-12-26-164500.md
**Sprint Goal:** Establish foundational encoding contracts for color and path data

---

## Acceptance Criteria

### Deliverable 1: Type System Split (TypeDesc vs BufferDesc)

#### P0.1: Define BufferDesc Type Hierarchy
- [ ] `BufferDesc` base interface defined in `src/editor/ir/types/BufferDesc.ts`
- [ ] Clear documentation of authoring vs storage type distinction
- [ ] `BufferDesc` includes: `kind`, `encoding`, `strideBytes`, `endianness` (where applicable)
- [ ] TypeScript compilation passes with zero errors
- [ ] Unit test: BufferDesc type guards work correctly

---

### Deliverable 2: Color Encoding Migration

#### P0.2: Define ColorBufferDesc Contract
- [ ] `ColorBufferDesc` interface defined with fixed contract:
  - `kind: "u8x4"`
  - `encoding: "linear_premul_rgba8"` (only valid value)
  - `channelOrder: "RGBA"` (fixed)
  - `strideBytes: 4` (fixed)
- [ ] `ColorEncoding` type defined as literal `"linear_premul_rgba8"`
- [ ] Documentation explains: premultiplied, linear (not sRGB), RGBA order, u8 per channel
- [ ] Type enforces immutability of encoding constants
- [ ] Unit test: ColorBufferDesc construction validates encoding

#### P0.4: Implement Color Quantization Kernel
- [ ] `quantizeColorRGBA()` function in `src/editor/runtime/kernels/ColorQuantize.ts`
- [ ] Signature: `(r: number, g: number, b: number, a: number) => Uint8Array` (4 bytes)
- [ ] Premultiply RGB by alpha before quantization: `[r*a, g*a, b*a, a]`
- [ ] Clamp inputs to [0, 1] before scaling to [0, 255]
- [ ] Use Math.round() for deterministic rounding (not floor/ceil)
- [ ] Unit tests:
  - [ ] Fully opaque white (1,1,1,1) → [255, 255, 255, 255]
  - [ ] Half-transparent red (1,0,0,0.5) → [128, 0, 0, 128]
  - [ ] Fully transparent → [0, 0, 0, 0]
  - [ ] Out-of-range values clamped correctly
  - [ ] Determinism: same input always produces same output (100 iterations)

---

### Deliverable 3: Path Encoding Specification

#### P0.3: Define PathCommandStreamDesc Contract
- [ ] `PathCommandStreamDesc` interface defined with fixed contract:
  - `opcodeWidth: 16` (u16, fixed)
  - `endianness: "LE"` (little-endian, fixed)
- [ ] Documentation explains: Uint16Array commands, LE byte order for serialization
- [ ] Path cache resources reference this descriptor (not inline magic numbers)
- [ ] Type enforces immutability of width and endianness
- [ ] Unit test: PathCommandStreamDesc validates fixed values

#### P1.1: Define FlattenPolicy Type
- [ ] `FlattenPolicy` discriminated union type defined:
  - `{ kind: "off" }` - keep curves (default)
  - `{ kind: "on"; tolerancePx: number }` - flatten with tolerance
- [ ] `CANONICAL_FLATTEN_TOL_PX` constant defined (value: 0.75px)
- [ ] Documentation explains:
  - Tolerance is in screen pixels (view-dependent)
  - Only canonical tolerance is permitted (no arbitrary values)
  - "off" preserves curves for quality/morphing
  - "on" generates polylines for performance
- [ ] Type guard functions: `isFlattenOff()`, `isFlattenOn()`
- [ ] Unit test: FlattenPolicy type guards work correctly

---

### Deliverable 4: Foundation for Materialization Step

#### P1.2: Update TypeDesc Documentation
- [ ] JSDoc comment at top of `TypeDesc.ts` explains authoring vs storage split
- [ ] Examples: `field<color>` (TypeDesc) vs `linear_premul_rgba8` (BufferDesc)
- [ ] Cross-reference to `BufferDesc.ts` in documentation
- [ ] No changes to TypeDesc runtime behavior (documentation only)
- [ ] Memory file `02-type-system.md` updated with authoring/storage distinction

#### P1.3: Document Materialization Step Requirements
- [ ] Document created: `design-docs/13-Renderer/09-Materialization-Steps.md`
- [ ] Specifies MaterializeColor and MaterializePath as schedule step types
- [ ] Lists required inputs: ValueSlot refs, BufferDesc targets, cache policy
- [ ] Lists outputs: BufferRefIR with typed array payload
- [ ] Explains why materialization is NOT a renderer responsibility
- [ ] Cache key requirements documented (encoding + policy fields)
- [ ] Performance counter requirements: cpuMs, bytesWritten, cacheHit

---

## Quality Gates

### Performance Benchmarks

#### P2.1: Color Quantization Performance
- [ ] Benchmark script in `scripts/bench-color-quantize.ts`
- [ ] Measures quantization throughput: colors/second
- [ ] Test cases:
  - [ ] 1k colors (typical single frame)
  - [ ] 10k colors (heavy particle system)
  - [ ] 100k colors (stress test)
- [ ] Baseline: quantization must be <1ms for 10k colors on reference hardware
- [ ] Results documented in benchmark output

---

### Documentation Quality

#### P2.2: Rust/WASM Compatibility Documentation
- [ ] Document created: `design-docs/13-Renderer/10-Rust-WASM-Compatibility.md`
- [ ] Specifies endianness (LE), numeric types (u8, u16, f32), rounding rules
- [ ] ColorQuantize algorithm documented with exact steps
- [ ] PathCommandStream encoding documented with opcode table stub
- [ ] Float precision requirements: use f32 (not f64) for determinism
- [ ] Saturation rules: clamp-to-range (not wraparound)

#### P2.3: Memory Files Updated
- [ ] Section added to `02-type-system.md`: "Authoring vs Storage Types"
- [ ] ColorBufferDesc contract documented
- [ ] PathCommandStreamDesc contract documented
- [ ] FlattenPolicy explained
- [ ] Examples: field&lt;color&gt; → linear_premul_rgba8
- [ ] Cross-references to design docs 03, 04, 05

---

## Persistent Checks

All must pass before sprint completion:

```bash
just check          # Typecheck + lint + test (zero errors/warnings)
just test:field     # Field materialization (no regressions)
just test:signal    # Signal evaluation (no regressions)
just test:encoding  # New: all encoding-related tests pass
```

---

## Sprint Scope

**This sprint delivers:**
1. BufferDesc type hierarchy (authoring vs storage split)
2. ColorBufferDesc + quantization kernel (u8x4 premul linear)
3. PathCommandStreamDesc + FlattenPolicy (u16, LE, canonical tolerance)
4. Materialization step specifications (preparatory docs for Phase C/D)

**Deferred to Phase C/D:**
- Runtime implementation of MaterializeColor/MaterializePath steps
- Actual color conversion in blocks (dual-emit pattern)
- Path flattening implementation
- Cache key implementation

**Deferred to Phase E:**
- CacheKeySpec with encoding/policy fields
- Cache hit/miss tracking

**Out of scope (later phases):**
- 3D color/geometry additions (Phase G-H)
- Export pipeline (separate initiative)
- WebGPU renderer (future work)

---

## Files Created/Modified

### Created:
- `src/editor/ir/types/BufferDesc.ts`
- `src/editor/runtime/kernels/ColorQuantize.ts`
- `src/editor/runtime/kernels/__tests__/ColorQuantize.test.ts`
- `scripts/bench-color-quantize.ts`
- `design-docs/13-Renderer/09-Materialization-Steps.md`
- `design-docs/13-Renderer/10-Rust-WASM-Compatibility.md`

### Modified:
- `src/editor/ir/types/TypeDesc.ts` (documentation only, no runtime changes)
- `claude_memory/02-type-system.md` (new section added)

---

## Success Metrics

**Technical:**
- Zero TypeScript errors in `just check`
- Color quantization determinism: 100 iterations produce identical output
- Color quantization performance: <1ms for 10k colors
- All unit tests pass

**Documentation:**
- Two new design docs created (09, 10)
- Memory files synced with design decisions
- Clear separation between authoring and storage types documented

**Architectural:**
- Clean boundary between TypeDesc (semantic) and BufferDesc (physical)
- Encoding decisions are authoritative and immutable
- Foundation laid for Phases C-D materialization work

---

**Ready for Phase C (Instances2D Runtime) when all criteria above are met.**
