# Sprint Plan: Phase E - IR Rendering Pipeline Final Wiring

**Generated:** 2025-12-26-183605
**Source:** STATUS-2025-12-26-183500.md
**Topic:** IR Rendering Pipeline Integration (Final Wiring)
**Sprint Scope:** Instances2D (circles) only - defer Paths2D to follow-up sprint

---

## Executive Summary

**Current State:** 60% infrastructure exists, 0% pipeline wired end-to-end

The Renderer IR system has all the necessary infrastructure from Phases A-D, but the critical "last mile" wiring is completely missing. Components exist in isolation:

- **Block lowering** registers render sinks but doesn't emit materialization steps
- **executeMaterializeColor/Path** work correctly but are never called
- **executeRenderAssemble** creates empty stub RenderFrameIR instead of real passes
- **PreviewPanel** calls legacy render() instead of renderFrame()
- **IRRuntimeAdapter** uses bridge mode with closure-based rendering

**Target State:** End-to-end IR rendering pipeline working for Instances2D

This sprint connects all components to achieve:
- Block lowering emits StepMaterializeColor for color fields
- Schedule includes materialization steps in dependency order
- executeRenderAssemble assembles real Instances2DPassIR from buffers
- PreviewPanel calls renderFrame() when RenderFrameIR available
- IRRuntimeAdapter outputs RenderFrameIR in pure IR mode

**Sprint Deliverables:**
1. Updated StepIR types (user-provided definitions)
2. Block lowering emits materialization steps
3. executeMaterializeColor handles new step format (separate R,G,B,A slots)
4. executeRenderAssemble assembles real Instances2DPassIR
5. PreviewPanel wired to renderFrame()
6. IRRuntimeAdapter outputs RenderFrameIR

**Focus:** Circles (Instances2D) only. Paths2D deferred to follow-up sprint.

---

## Gap Analysis Summary

| Component | Current State | Target State | Gap |
|-----------|--------------|--------------|-----|
| schedule.ts StepIR types | Old format (single bufferSlot) | New format (separate R,G,B,A slots) | Update type definitions |
| RenderInstances2D lowering | Calls renderSink() only | Emits StepMaterializeColor steps | Add step emission logic |
| executeMaterializeColor | Writes to single bufferSlot | Writes to 4 separate slots (R,G,B,A) | Update to new step format |
| executeRenderAssemble | Creates empty stub | Assembles Instances2DPassIR from buffers | Implement assembly logic |
| PreviewPanel | Calls render() | Calls renderFrame() when RenderFrameIR ready | Add IR path check |
| IRRuntimeAdapter | Bridge mode only | Pure IR mode with RenderFrameIR output | Extract RenderFrameIR from schedule |

---

## Work Items (Prioritized Backlog)

### P0-1: Update schedule.ts with User-Provided StepIR Types

**Status**: Not Started
**Effort**: Small (1-2 hours)
**Dependencies**: None
**Spec Reference**: User-provided StepIR definitions • **Status Reference**: STATUS §GAP 1, §GAP 2

#### Description

Replace the current StepMaterializeColor and StepMaterializePath type definitions in `/src/editor/compiler/ir/schedule.ts` with the user-provided types that use separate buffer slots for each color channel and new field names.

**Key Changes:**
- Replace `StepMaterializeColor.bufferSlot` with separate `outRSlot`, `outGSlot`, `outBSlot`, `outASlot`
- Add `domainSlot` and `colorExprSlot` fields
- Replace `StepMaterializePath` fields with `domainSlot`, `pathExprSlot`, `outCmdsSlot`, `outParamsSlot`
- Add new `StepRenderAssemble` with `instance2dListSlot`, `pathBatchListSlot`, `outFrameSlot`

#### Acceptance Criteria

- [ ] `schedule.ts` lines 363-441 replaced with user-provided StepIR type definitions
- [ ] `StepMaterializeColor` has fields: `domainSlot`, `colorExprSlot`, `outRSlot`, `outGSlot`, `outBSlot`, `outASlot`, optional `format`
- [ ] `StepMaterializePath` has fields: `domainSlot`, `pathExprSlot`, `outCmdsSlot`, `outParamsSlot`, optional `flattenTolerancePx`
- [ ] `StepRenderAssemble` has fields: `instance2dListSlot`, `pathBatchListSlot`, `outFrameSlot`
- [ ] TypeScript compilation succeeds (existing code using old types will fail - expected, will be fixed in P0-2 and P0-3)

#### Technical Notes

This is a breaking change - code using the old StepMaterializeColor format will fail to compile until updated in P0-2 and P0-3. That's intentional - we want type errors to guide the migration.

The user-provided `StepBase` includes `deps: StepId[]` and `cacheKey?: CacheKeySpec` which should be merged with the existing `StepBase` interface.

---

### P0-2: Update executeMaterializeColor for New Step Format

**Status**: Not Started
**Effort**: Small (2-3 hours)
**Dependencies**: P0-1
**Spec Reference**: User-provided StepIR • **Status Reference**: STATUS §Phase C/D, §executeMaterializeColor

#### Description

Update `/src/editor/runtime/executor/steps/executeMaterializeColor.ts` to work with the new StepMaterializeColor format that writes to 4 separate buffer slots (R,G,B,A) instead of a single interleaved buffer.

**Current behavior:**
- Reads color from `sourceSlot`
- Quantizes to Uint8Array (interleaved RGBA)
- Writes to single `bufferSlot`

**New behavior:**
- Reads domain handle from `domainSlot` (or count)
- Reads field expr handle from `colorExprSlot`
- Quantizes to 4 separate Float32Arrays (R, G, B, A channels)
- Writes to `outRSlot`, `outGSlot`, `outBSlot`, `outASlot`

#### Acceptance Criteria

- [ ] Function signature updated to accept new `StepMaterializeColor` format
- [ ] Reads domain/count from `domainSlot` (handle or number)
- [ ] Reads color field expr from `colorExprSlot`
- [ ] Creates 4 separate Float32Array buffers (one per channel)
- [ ] Writes R channel to `step.outRSlot`
- [ ] Writes G channel to `step.outGSlot`
- [ ] Writes B channel to `step.outBSlot`
- [ ] Writes A channel to `step.outASlot`
- [ ] Handles both signal<color> (single value broadcast) and field<color> (per-instance)
- [ ] Performance counters still emitted (debug logging)
- [ ] Unit test added: signal<color> produces 4 single-value buffers
- [ ] Unit test added: field<color>[10] produces 4 ten-element buffers
- [ ] TypeScript compilation succeeds with no errors

#### Technical Notes

The new format uses **Float32Array** instead of Uint8Array for better GPU compatibility. Color components are stored in linear space [0..1] range, not quantized u8.

The `format?: "rgba_f32"` field in the step confirms this encoding.

Color quantization kernels (quantizeColorRGBA) may need to be updated or replaced with float-based versions. Check if existing kernels support float output.

---

### P0-3: Update RenderInstances2D Block Lowering to Emit Materialization Steps

**Status**: Not Started
**Effort**: Medium (4-6 hours)
**Dependencies**: P0-1, P0-2
**Spec Reference**: RenderInstances2D.ts lines 48-97 • **Status Reference**: STATUS §GAP 1

#### Description

Update `/src/editor/compiler/blocks/domain/RenderInstances2D.ts` lowering function to emit `StepMaterializeColor` for the color field input, allocate buffer slots, and register them with the render sink.

**Current behavior:**
```typescript
ctx.b.renderSink('instances2d', sinkInputs);
return { outputs: [], declares: { renderSink: { sinkId: 0 } } };
```

**New behavior:**
1. Allocate 4 buffer slots for color channels (R, G, B, A)
2. Create `StepMaterializeColor` step with:
   - `domainSlot`: domain input's slot
   - `colorExprSlot`: color field input's slot
   - `outRSlot`, `outGSlot`, `outBSlot`, `outASlot`: allocated slots
3. Emit step via `ctx.b.addStep(step)` or equivalent
4. Pass buffer slot references to render sink metadata
5. Return step declarations in lowering result

#### Acceptance Criteria

- [ ] Block lowering allocates 4 ValueSlots for color channels (R, G, B, A)
- [ ] Creates `StepMaterializeColor` with all required fields from user-provided format
- [ ] Sets `domainSlot` to domain input's value slot
- [ ] Sets `colorExprSlot` to color field input's value slot
- [ ] Sets `outRSlot`, `outGSlot`, `outBSlot`, `outASlot` to allocated slots
- [ ] Step is added to schedule via IRBuilder API
- [ ] Render sink receives metadata with buffer slot references
- [ ] Lowering result declares materialize step(s)
- [ ] TypeScript compilation succeeds
- [ ] Unit test: lowering RenderInstances2D block produces StepMaterializeColor in schedule
- [ ] E2E test: Simple patch with RenderInstances2D compiles without errors

#### Technical Notes

The IRBuilder API for emitting steps may need updates. Check if `ctx.b.addStep()` exists or if a different method is required.

The render sink metadata needs to reference the buffer slots so executeRenderAssemble can find them. This may require updating the renderSink registration API.

Position and radius fields are NOT materialized in this sprint - they're handled differently (TBD in follow-up work). Focus only on color materialization.

---

### P0-4: Implement Real Instances2DPassIR Assembly in executeRenderAssemble

**Status**: Not Started
**Effort**: Medium (4-5 hours)
**Dependencies**: P0-2, P0-3
**Spec Reference**: executeRenderAssemble.ts lines 73-121 • **Status Reference**: STATUS §GAP 2

#### Description

Replace the stub implementation in `/src/editor/runtime/executor/steps/executeRenderAssemble.ts` that creates an empty RenderFrameIR with real assembly logic that builds `Instances2DPassIR` from materialized buffers.

**Current behavior:**
```typescript
const stubFrame: RenderFrameIR = {
  version: 1,
  clear: { mode: "none" },
  passes: [],  // EMPTY!
};
```

**New behavior:**
1. Read step metadata to locate buffer slots (from render sink registration)
2. Read R, G, B, A buffers from ValueStore using buffer slots
3. Read domain/instance count
4. Call `assembleInstanceBuffers()` to create `InstanceBufferSetIR`
5. Create `Instances2DPassIR` with header, material, count, buffers
6. Build `RenderFrameIR` with real passes array
7. Write to `step.outFrameSlot`

#### Acceptance Criteria

- [ ] Reads `instance2dListSlot` from step to get render sink metadata
- [ ] Extracts buffer slot references from metadata
- [ ] Reads R, G, B, A Float32Array buffers from ValueStore
- [ ] Reads instance count from domain or buffer length
- [ ] Creates `InstanceBufferSetIR` with color buffers as `BufferRefIR`
- [ ] Creates `InstanceMaterialIR` with default circle material
- [ ] Creates `Instances2DPassIR` with header, buffers, material, count
- [ ] Creates `RenderFrameIR` with clear spec and passes array containing the Instances2D pass
- [ ] Writes RenderFrameIR to `step.outFrameSlot`
- [ ] Handles empty/zero-instance case gracefully (empty passes array)
- [ ] Unit test: executeRenderAssemble with valid buffers produces Instances2DPassIR
- [ ] E2E test: Full pipeline from block lowering to RenderFrameIR assembly succeeds

#### Technical Notes

The step metadata structure for passing buffer slots is TBD - may require updating StepRenderAssemble type definition.

For this sprint, use hardcoded circle rendering material:
- Geometry: circle primitive
- No transforms
- Default blend mode (source-over)

Position and radius buffers are stubbed for now (use default positions/radii or skip). Focus on color channel assembly.

The `assembleInstanceBuffers()` helper may not exist yet - implement inline in executeRenderAssemble or create as separate utility.

---

### P0-5: Wire PreviewPanel to Call renderFrame() in IR Mode

**Status**: Not Started
**Effort**: Small (2-3 hours)
**Dependencies**: P0-4
**Spec Reference**: PreviewPanel.tsx lines 300-353 • **Status Reference**: STATUS §GAP 3

#### Description

Update `/src/editor/PreviewPanel.tsx` canvas render loop to call `Canvas2DRenderer.renderFrame()` when RenderFrameIR is available from the IR path, instead of always calling `render()` with legacy RenderTree.

**Current behavior:**
```typescript
if (renderTree) {
  canvasRenderer.render(renderTree as Parameters<typeof canvasRenderer.render>[0]);
}
```

**New behavior:**
```typescript
if (useIR && lastGoodIRProgramRef.current) {
  // Extract RenderFrameIR from IR runtime
  const frameIR = extractRenderFrameIR(lastGoodIRProgramRef.current, runtime);
  if (frameIR) {
    canvasRenderer.renderFrame(frameIR, runtime.values);
  }
} else if (renderTree) {
  canvasRenderer.render(renderTree);
}
```

#### Acceptance Criteria

- [ ] Canvas render loop checks `useIR` flag (from store.uiStore.settings.useNewCompiler)
- [ ] In IR mode: extracts RenderFrameIR from IR program/adapter
- [ ] Calls `canvasRenderer.renderFrame(frameIR, valueStore)` with extracted frame
- [ ] Passes ValueStore instance to renderFrame() for buffer reads
- [ ] Falls back to legacy `render()` path when not in IR mode
- [ ] Handles case where RenderFrameIR is not yet available (skip render or show blank)
- [ ] No visual regressions in legacy (non-IR) mode
- [ ] E2E test: IR mode renders circles to canvas successfully
- [ ] Manual test: Toggle IR flag on/off, both modes work

#### Technical Notes

The `extractRenderFrameIR()` helper needs to be implemented. It should:
1. Access the IRRuntimeAdapter instance
2. Read the RenderFrameIR from the schedule's output slot
3. Return the RenderFrameIR or null if not available

The ValueStore instance may need to be exposed by IRRuntimeAdapter. Check if `adapter.getValueStore()` exists or needs to be added.

PreviewPanel already has access to `lastGoodIRProgramRef.current` which is the Program<RenderTree> returned by `adapter.createProgram()`. We need a way to get the RenderFrameIR from the adapter.

Consider adding `IRRuntimeAdapter.getRenderFrameIR(): RenderFrameIR | null` method.

---

### P0-6: Update IRRuntimeAdapter to Output RenderFrameIR in Pure IR Mode

**Status**: Not Started
**Effort**: Medium (3-4 hours)
**Dependencies**: P0-4, P0-5
**Spec Reference**: IRRuntimeAdapter.ts lines 84-120 • **Status Reference**: STATUS §GAP 4

#### Description

Update `/src/editor/runtime/executor/IRRuntimeAdapter.ts` to extract and return RenderFrameIR from the schedule execution in pure IR mode, instead of using legacy bridge mode with closure-based rendering.

**Current behavior:**
```typescript
if (this.legacyRenderFn !== null) {
  return this.legacyRenderFn(tMs, runtimeCtx) as unknown as RenderTree;
}
return { cmds: [] } as unknown as RenderTree;
```

**New behavior:**
```typescript
// Pure IR mode: extract RenderFrameIR from executeRenderAssemble output
if (this.program.outputs && this.program.outputs.length > 0) {
  const renderAssembleSlot = this.program.outputs[0].slot;
  const frameIR = this.runtime.values.read(renderAssembleSlot) as RenderFrameIR;
  // Store for PreviewPanel to access
  this.lastFrameIR = frameIR;
}
```

#### Acceptance Criteria

- [ ] Adds `getRenderFrameIR(): RenderFrameIR | null` method to IRRuntimeAdapter
- [ ] After `executeFrame()`, reads RenderFrameIR from schedule output slot
- [ ] Stores RenderFrameIR in private field for access by PreviewPanel
- [ ] `getRenderFrameIR()` returns latest RenderFrameIR or null if not available
- [ ] Bridge mode still works (if legacyRenderFn provided)
- [ ] Pure IR mode works (if legacyRenderFn is null/undefined)
- [ ] Unit test: IRRuntimeAdapter with complete schedule produces RenderFrameIR
- [ ] E2E test: PreviewPanel successfully calls getRenderFrameIR() and renders

#### Technical Notes

The output slot for RenderFrameIR needs to be identified. Check `CompiledProgramIR.outputs` structure to find the correct slot.

The `createProgram()` method currently returns `Program<RenderTree>` for Player compatibility. This may need to remain unchanged - the RenderFrameIR is accessed via the new `getRenderFrameIR()` method, not through the Program interface.

Consider whether bridge mode should continue to be supported or removed in this sprint. For safety, keep bridge mode working but add pure IR mode as an alternative path.

---

### P1-1: Add E2E Integration Test for IR Rendering Pipeline

**Status**: Not Started
**Effort**: Medium (4-5 hours)
**Dependencies**: P0-1 through P0-6
**Spec Reference**: STATUS §Missing Persistent Checks • **Status Reference**: STATUS §Test Suite Assessment

#### Description

Create a comprehensive end-to-end test that verifies the complete IR rendering pipeline from patch compilation through canvas rendering.

**Test Flow:**
1. Create simple patch with RenderInstances2D block (100 colored circles)
2. Compile with IR compiler (useNewCompiler = true)
3. Verify CompiledProgramIR contains StepMaterializeColor
4. Verify schedule execution produces RenderFrameIR
5. Verify RenderFrameIR has Instances2DPassIR with buffers
6. Verify Canvas2DRenderer.renderFrame() draws successfully
7. Verify output matches expected visual (snapshot or pixel comparison)

#### Acceptance Criteria

- [ ] Test file created: `src/editor/compiler/__tests__/ir-rendering-pipeline.e2e.test.ts`
- [ ] Test creates patch with Domain + RenderInstances2D
- [ ] Compiles with IR compiler and verifies CompiledProgramIR structure
- [ ] Verifies schedule contains StepMaterializeColor step
- [ ] Executes schedule and reads RenderFrameIR from output slot
- [ ] Verifies RenderFrameIR.passes[0].kind === 'instances2d'
- [ ] Verifies Instances2DPassIR has valid buffers and instance count
- [ ] Renders to canvas and verifies no errors thrown
- [ ] Test passes reliably (no flakiness)
- [ ] Documented in test file with clear explanation of what's being tested

#### Technical Notes

This test may be slow (compilation + execution + rendering). Consider marking as e2e or integration test category that runs separately from unit tests.

Visual verification (snapshot/pixel comparison) is valuable but may be fragile. Start with structural verification (RenderFrameIR shape) and add visual checks if time permits.

Use headless canvas or JSDOM for test environment compatibility.

---

### P1-2: Update Documentation and Add Runtime Verification

**Status**: Not Started
**Effort**: Small (2-3 hours)
**Dependencies**: P0-1 through P0-6
**Spec Reference**: STATUS §Recommendations • **Status Reference**: STATUS §Files Summary

#### Description

Update documentation to reflect the completed IR rendering pipeline and add runtime verification/logging to help debug issues.

**Documentation updates:**
1. Update HANDOFF.md or equivalent to mark Phase E as complete
2. Add inline comments explaining the new data flow
3. Update any outdated design docs that reference the old architecture

**Runtime verification:**
1. Add debug logging at each pipeline stage (block lowering, materialization, assembly, rendering)
2. Add validation in executeRenderAssemble (check buffer sizes match instance count)
3. Add performance counters for materialization and assembly steps

#### Acceptance Criteria

- [ ] HANDOFF.md (or equivalent) updated with Phase E completion status
- [ ] Inline comments added to RenderInstances2D lowering explaining step emission
- [ ] Inline comments added to executeMaterializeColor explaining new format
- [ ] Inline comments added to executeRenderAssemble explaining assembly logic
- [ ] Debug logging added to each pipeline stage (controllable via flag)
- [ ] executeRenderAssemble validates buffer sizes match instance count
- [ ] Performance counters emitted for materialization time
- [ ] Performance counters emitted for assembly time
- [ ] Console logs clearly indicate IR vs legacy rendering mode

#### Technical Notes

Debug logging should be conditional (only when debug mode enabled) to avoid performance impact in production.

Consider using structured logging (JSON) for easier parsing by external tools.

Performance counters should integrate with existing stats infrastructure (RenderStats type).

---

### P2-1: Optimize Buffer Allocation and Reduce Memory Churn

**Status**: Not Started
**Effort**: Medium (3-4 hours)
**Dependencies**: P1-1, P1-2
**Spec Reference**: STATUS §Caching Policy • **Status Reference**: STATUS §executeMaterializeColor

#### Description

Optimize the materialization and assembly steps to reduce memory allocations and improve frame-to-frame performance.

**Optimizations:**
1. Reuse Float32Array buffers across frames (buffer pool)
2. Implement cache key checking in executeMaterializeColor (skip materialization if unchanged)
3. Preallocate buffers based on maximum instance count
4. Use ArrayBuffer views to avoid buffer copies

#### Acceptance Criteria

- [ ] Buffer pool implemented for Float32Array reuse
- [ ] executeMaterializeColor checks cache key before materializing
- [ ] Cache hit skips quantization and reuses previous buffer
- [ ] Buffers preallocated to max size (resize only when growing)
- [ ] No unnecessary buffer copies in assembly step
- [ ] Performance test: 1000 circles at 60fps with <2ms materialization time
- [ ] Memory profiling shows reduced allocation rate
- [ ] Cache hit rate logged for debugging

#### Technical Notes

This is a performance optimization and can be deferred if time is tight. The pipeline must work correctly first (P0 items).

Cache key implementation should follow the spec in schedule.ts (CacheKeySpec type).

Consider using SharedArrayBuffer for future Web Worker parallelization.

---

## Sprint Scope Summary

**In Scope (MUST complete):**
- P0-1 through P0-6: Core pipeline wiring for Instances2D
- Focus on color materialization only
- Focus on circles only (Instances2D primitive)

**Deferred to Follow-up Sprint:**
- Paths2D rendering (StepMaterializePath wiring)
- Position and radius materialization (currently stubbed)
- Advanced caching optimizations (P2-1)
- Performance benchmarking and profiling
- Visual regression testing suite

**Out of Scope:**
- Legacy compiler removal (keep both paths working)
- Other render primitives (text, images, effects)
- GPU acceleration
- WASM integration

---

## Dependency Graph

```
P0-1 (Update StepIR types)
  ↓
  ├─→ P0-2 (Update executeMaterializeColor)
  │     ↓
  │     P0-3 (Update block lowering)
  │       ↓
  │       P0-4 (Implement executeRenderAssemble)
  │         ↓
  │         P0-5 (Wire PreviewPanel)
  │         ↓
  │         P0-6 (Update IRRuntimeAdapter)
  │           ↓
  │           ├─→ P1-1 (E2E test)
  │           └─→ P1-2 (Documentation)
  │                 ↓
  │                 P2-1 (Optimizations)
```

**Critical Path:** P0-1 → P0-2 → P0-3 → P0-4 → P0-5 → P0-6

All P0 items must be completed in sequence. P1 and P2 items can proceed in parallel after P0-6.

---

## Recommended Implementation Order

1. **Day 1 Morning:** P0-1 (Update types) + P0-2 (executeMaterializeColor)
2. **Day 1 Afternoon:** P0-3 (Block lowering) + verify compilation
3. **Day 2 Morning:** P0-4 (executeRenderAssemble) + verify assembly works
4. **Day 2 Afternoon:** P0-5 (PreviewPanel) + P0-6 (IRRuntimeAdapter)
5. **Day 3:** P1-1 (E2E test) + P1-2 (Documentation) + manual testing
6. **(Optional) Day 4:** P2-1 (Optimizations) if time permits

**Total Estimated Effort:** 20-30 hours (3-4 days at moderate pace)

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|-----------|
| Buffer slot allocation API doesn't exist | Medium | High | Implement minimal IRBuilder.allocSlot() if needed |
| Render sink metadata structure unclear | Medium | High | Define metadata schema early, update as needed |
| Position/radius materialization required | Low | High | Stub with default values, defer to follow-up |
| Performance regression from Float32 buffers | Low | Medium | Profile early, optimize in P2-1 if needed |
| PreviewPanel can't access ValueStore | Medium | Medium | Add IRRuntimeAdapter.getValueStore() method |
| Test environment lacks canvas support | Low | Low | Use headless canvas or skip visual tests |

**Highest Risk Items:**
1. Render sink metadata structure (affects P0-3 and P0-4 integration)
2. Buffer slot allocation API (needed in P0-3)
3. Position/radius handling (may block rendering even with color working)

**Mitigation Strategy:**
- Spike on render sink metadata structure before starting P0-3
- Review IRBuilder API and implement allocSlot() if missing
- Stub position/radius with defaults (center of viewport, fixed radius)

---

## Success Criteria (Sprint Complete When...)

**Functional Requirements:**
- [ ] Simple patch with RenderInstances2D compiles without errors
- [ ] Schedule contains StepMaterializeColor with correct format
- [ ] executeMaterializeColor produces 4 Float32Array buffers
- [ ] executeRenderAssemble produces RenderFrameIR with Instances2DPassIR
- [ ] PreviewPanel renders circles to canvas using renderFrame()
- [ ] Circles are visible with correct colors
- [ ] No console errors during rendering

**Technical Requirements:**
- [ ] All P0 items completed and tested
- [ ] TypeScript compilation succeeds with no errors
- [ ] Existing tests pass (no regressions)
- [ ] E2E test added and passing
- [ ] Documentation updated

**Quality Requirements:**
- [ ] Code reviewed by at least one other developer
- [ ] Manual testing shows circles render correctly
- [ ] Performance acceptable (60fps for 100 circles)
- [ ] No memory leaks detected

**Deliverables:**
- [ ] PLAN-PHASE-E-2025-12-26-183605.md (this file)
- [ ] DOD-PHASE-E-2025-12-26-183605.md (acceptance criteria only)
- [ ] Working code changes across 6+ files
- [ ] E2E test suite
- [ ] Updated documentation

---

## Files Modified (Estimated)

### Core Implementation (P0)
- `/src/editor/compiler/ir/schedule.ts` (type updates)
- `/src/editor/runtime/executor/steps/executeMaterializeColor.ts` (new format)
- `/src/editor/compiler/blocks/domain/RenderInstances2D.ts` (step emission)
- `/src/editor/runtime/executor/steps/executeRenderAssemble.ts` (assembly logic)
- `/src/editor/PreviewPanel.tsx` (renderFrame() wiring)
- `/src/editor/runtime/executor/IRRuntimeAdapter.ts` (RenderFrameIR extraction)

### Supporting Changes
- `/src/editor/compiler/ir/IRBuilder.ts` (may need allocSlot() method)
- `/src/editor/runtime/kernels/ColorQuantize.ts` (may need float output)
- `/src/editor/runtime/renderPassExecutors.ts` (verify buffer handling)

### Tests (P1)
- `/src/editor/compiler/__tests__/ir-rendering-pipeline.e2e.test.ts` (new)
- `/src/editor/runtime/executor/steps/__tests__/executeMaterializeColor.test.ts` (update)
- `/src/editor/runtime/executor/steps/__tests__/executeRenderAssemble.test.ts` (update)

### Documentation (P1)
- `/HANDOFF.md` or equivalent (completion status)
- Inline comments in modified files

**Total Files:** ~10-12 files modified/created

---

## Blockers and Questions

**Questions for User:**
1. What is the API for allocating buffer slots in IRBuilder? Does `ctx.b.allocSlot()` exist?
2. What should the render sink metadata structure be for passing buffer slots to executeRenderAssemble?
3. How should position and radius be handled in this sprint? (Options: stub with defaults, materialize like color, defer entirely)
4. Should legacy bridge mode be removed or kept working during this sprint?

**Known Issues:**
- Position and radius materialization is not scoped for this sprint but may be required for circles to render
- Buffer slot allocation API may not exist yet in IRBuilder
- Render sink metadata structure is undefined

**Assumptions:**
- Position/radius can be stubbed with default values (center viewport, fixed radius 10px)
- IRBuilder will be extended if necessary APIs don't exist
- Render sink metadata can be defined as needed by P0-3/P0-4

---

## Notes

- This sprint focuses exclusively on **Instances2D (circles)** to minimize scope
- **Paths2D is explicitly deferred** to a follow-up sprint
- Position and radius materialization may be required - if so, add as P0-3.5 work item
- Legacy compiler/renderer must continue working (no breaking changes)
- Performance optimization (P2-1) is nice-to-have, not required for sprint success
