# Status Report: Renderer IR System
**Timestamp:** 2025-12-26-160000
**Scope:** project/renderer-ir (new subsystem evaluation)
**Confidence:** FRESH
**Git Commit:** 7e7be1f (compiler_rewrite branch)

---

## Executive Summary

**Overall Assessment:** NOT STARTED (0% complete)

The Renderer IR system is a LARGE new subsystem specified across 8 design documents in `design-docs/13-Renderer/`. It builds on the completed Phase 1-5 compiler IR work and the partially-complete Phase 6 runtime.

**Critical Finding:** This is the largest architectural addition since the compiler rewrite itself. It touches the type system, materialization pipeline, caching infrastructure, and introduces two entirely new render primitives (Instances2D buffers + Paths2D geometry).

**Estimated Scope:** 8-12 sprints minimum (not including 3D additions)

---

## What Exists (Infrastructure from Phases 1-6)

### Supportive Infrastructure (FRESH)

| Component | Location | Status | Supports Renderer IR? |
|-----------|----------|--------|----------------------|
| TypeDesc system | `src/editor/ir/types/TypeDesc.ts` | COMPLETE | Partial - needs new domains |
| ValueStore | `src/editor/compiler/ir/stores.ts` | COMPLETE | Yes - typed array storage |
| StateBuffer | `src/editor/compiler/ir/stores.ts` | COMPLETE | Yes - state persistence |
| FieldMaterializer | `src/editor/runtime/field/Materializer.ts` | COMPLETE | Yes - buffer production |
| BufferPool | `src/editor/runtime/field/BufferPool.ts` | COMPLETE | Yes - buffer reuse |
| ScheduleExecutor | `src/editor/runtime/executor/ScheduleExecutor.ts` | PARTIAL | Yes - step dispatch |
| Canvas2DRenderer | `src/editor/runtime/canvasRenderer.ts` | COMPLETE (legacy) | Rewrite needed |
| RenderCmd types | `src/editor/runtime/renderCmd.ts` | COMPLETE (legacy) | Replace with RenderFrameIR |

### Current Render Pipeline (Legacy - To Be Replaced)

The existing render system produces `RenderTree` (DrawNode-based) and `RenderCmd[]` structures:

1. **RenderCmd types** (`renderCmd.ts:159-163`):
   - `ClearCommand`, `GroupCommand`, `Instances2DCommand`, `Path2DCommand`
   - Uses Float32Array for transforms, Uint32Array for packed colors
   - This is CLOSE to the spec but not aligned with BufferRefIR model

2. **Canvas2DRenderer** (`canvasRenderer.ts`):
   - Consumes RenderTree/RenderCmd structures
   - Per-instance save/restore (inefficient - spec says avoid this)
   - No buffer management, no caching, no performance counters
   - Uses unit-sized glyphs (correct convention)

3. **RenderInstances2D Block** (`compiler/blocks/domain/RenderInstances2D.ts`):
   - Produces DrawNode-based render tree (legacy)
   - IR lowering registers render sink but doesn't produce proper IR

---

## What's Missing (Gap Analysis Against 8 Design Docs)

### Doc 00: Overview & Context

| Requirement | Status | Gap |
|-------------|--------|-----|
| RenderFrame per-frame output to ValueSlot | MISSING | No RenderFrameIR type exists |
| Renderer consumes typed buffers, not objects | PARTIAL | RenderCmd uses some typed arrays |
| No simulation/conversion in renderer | OK | Current renderer is passive |
| Passes: Instances2D, Paths2D, PostFX | PARTIAL | Path2DCommand exists but incomplete |
| Hybrid architecture (instances + paths as peers) | MISSING | No Paths2D geometry buffers |

### Doc 01: RenderFrameIR Specification

| IR Type | Status | Notes |
|---------|--------|-------|
| `RenderFrameIR` | MISSING | Root frame structure not defined |
| `RenderPassHeaderIR` | MISSING | z-order, blend, clip, view |
| `Instances2DPassIR` | MISSING | Closest is Instances2DCommand |
| `Paths2DPassIR` | MISSING | Path2DCommand is simple polyline only |
| `InstanceBufferSetIR` | MISSING | posXY, size, rot, colorRGBA buffers |
| `PathGeometryBufferIR` | MISSING | Command streams, point arrays |
| `BufferRefIR` | MISSING | bufferId, type, length |
| `InstanceMaterialIR` | MISSING | shape2d, sprite, glyph materials |
| `ScalarF32IR/U32IR/U16IR` | MISSING | Scalar broadcast specs |
| `ClearSpecIR`, `BlendSpecIR`, `ClipSpecIR` | MISSING | Pass-level specs |
| `Mat3x2IR` | MISSING | 2D affine view transform |

**Effort Estimate:** 2 sprints for complete IR type definitions

### Doc 03: Decisions (Color, Path Commands, Flattening, 3D)

| Decision | Specified | Implemented |
|----------|-----------|-------------|
| Color: u8x4 premultiplied linear RGBA | YES | NO - uses 0-1 float ColorRGBA |
| Path commands: u16 | YES | NO - not typed array based |
| Flattening: optional per PathCache | YES | NO - no flattening infrastructure |
| 3D: projection prepass model | YES | NO - no 3D at all |

**Effort Estimate:** 1 sprint for color/path encoding; 3D is separate large work

### Doc 04: Decision-to-IR Mapping

| IR Addition | Status | Notes |
|-------------|--------|-------|
| `ColorBufferDesc` (u8x4, linear_premul_rgba8) | MISSING | Color encoding contract |
| `PathCommandStreamDesc` (u16, LE) | MISSING | Command stream contract |
| `FlattenPolicy` | MISSING | off / on with tolerance |
| `CANONICAL_FLATTEN_TOL_PX` constant | MISSING | Single canonical tolerance |

**Effort Estimate:** 0.5 sprints - type definitions only

### Doc 05: Upstream Architectural Impacts

| Impact Area | Status | Work Required |
|-------------|--------|---------------|
| 1. Type system split (authoring vs storage) | MISSING | TypeDesc + BufferDesc separation |
| 2. Materialization as scheduled step | PARTIAL | executeMaterialize exists but incomplete |
| 3. Cache keys include encoding/policy | MISSING | No CacheKeySpec with color/path fields |
| 4. Debugger instrumentation | MISSING | No MaterializeColor/MaterializePath events |
| 5. Export pipeline semantics | MISSING | No OutputAdapter stage |
| 6. Runtime memory layout | PARTIAL | Arena/pool infrastructure exists |
| 7. Rust/WASM compatibility | MISSING | No kernel specs, no deterministic guarantees |

**Effort Estimate:** 2-3 sprints for core impacts

### Doc 06: 3D Again (Empty File)

File is empty (0 bytes). Superseded by Doc 07.

### Doc 07: 3D Canonical Additions

| IR Addition | Status | Notes |
|-------------|--------|-------|
| TypeDomain extensions (vec3, quat, mat4, mesh, camera) | MISSING | TypeDesc.ts needs extension |
| `CameraIR` (id, projection, pose, conventions) | MISSING | Complete camera contract |
| `CameraEval` (viewMat4, projMat4, viewportKey) | MISSING | Runtime cache product |
| `CameraTable` | MISSING | Program-level camera registry |
| `MeshIR` (extrusion recipes only) | MISSING | ExtrudeProfile2D, ExtrudeKind |
| `MeshTable` | MISSING | Program-level mesh registry |
| `MeshBufferRef` | MISSING | Materialized mesh buffers |
| `Instance2DBufferRef` (split RGBA channels) | MISSING | Canvas sink input contract |
| `StepPerfCounters` | MISSING | cpuMs, cacheHit, bytesWritten |
| New schedule dependencies | MISSING | CameraEval -> Projection -> Render |
| Phase partitioning | MISSING | cameraEval, meshMaterialize, projection |
| New opcodes (CameraEval, MeshMaterialize, Instances3D_ProjectTo2D) | MISSING | opcode registry extension |
| CameraStore, MeshStore, Instance2DStore | MISSING | Runtime handle stores |

**Effort Estimate:** 4-5 sprints for complete 3D projection pipeline

### Doc 08: Caching Specification

| Cache Requirement | Status | Notes |
|-------------------|--------|-------|
| Step-scoped caching invariant | PARTIAL | FrameCache exists |
| `CachePolicy` enum | MISSING | none/perFrame/perTime/persistent |
| `TimeQuantization` | MISSING | exact/frame/ms/phase |
| `CacheStorage` | MISSING | localStep/globalShared |
| `CacheClass` enum | MISSING | FieldMaterialize, MeshMaterialize, etc. |
| `CacheKeySpecIR` | MISSING | Complete cache key specification |
| `SlotFingerprint` | MISSING | Slot-level cache contribution |
| `RuntimeEpochs` | MISSING | viewport, assets, external, program |
| Cache budgets per class | MISSING | FieldMaterializeBytes, etc. |
| LRU eviction policies | MISSING | No eviction strategy |
| Pinning rules | MISSING | No export/current-frame pinning |
| `MissReasonCode` | MISSING | Diagnostics for cache misses |
| Cache key hash algorithm | MISSING | No canonical xxHash64/wyhash |
| Hot-swap cache persistence rules | MISSING | No stepId-based reuse |

**Effort Estimate:** 2-3 sprints for complete caching infrastructure

---

## Dependencies: What Phase 6 Work Must Complete First

### BLOCKING Dependencies

1. **executeNodeEval** (INCOMPLETE)
   - Currently exists but needs full implementation for all node types
   - Render sinks require nodeEval to produce RenderFrameIR

2. **executeRenderAssemble** (INCOMPLETE)
   - Exists as stub; needs to assemble RenderFrameIR from materialized buffers
   - This is the bridge from ValueStore to renderer

3. **ScheduleIR render step types** (INCOMPLETE)
   - `renderAssemble` step needs complete specification
   - Needs to reference buffer slots, pass ordering

### NON-BLOCKING Dependencies (Can Proceed in Parallel)

1. **Hot-swap semantics** (Phase 6) - Can implement renderer IR first
2. **Determinism enforcement** (Phase 6) - Should be done but not blocking
3. **Legacy runtime removal** (Phase 6) - Renderer IR can coexist

---

## Risks and Ambiguities

### High-Risk Areas

1. **Type System Split (Authoring vs Storage)**
   - Impact: Pervasive changes across TypeDesc, IR, and blocks
   - Risk: If done wrong, affects all field/signal types
   - Recommendation: Design carefully, implement in isolated sprint

2. **Color Encoding Migration**
   - Current: 0-1 float ColorRGBA
   - Target: u8x4 premultiplied linear RGBA
   - Risk: All blocks producing colors must change
   - Recommendation: Introduce ColorBufferDesc as new type, migrate gradually

3. **Path Geometry System**
   - Current: Simple polyline Float32Array
   - Target: Command stream + point stream with per-path indexing
   - Risk: Completely new data structure, no existing code
   - Recommendation: Build from scratch, test with simple paths first

4. **3D Projection Pipeline**
   - Risk: Largest single addition (4-5 sprints)
   - Dependency: Requires CameraStore, MeshStore, projection step
   - Recommendation: Defer until 2D renderer IR is complete

### Ambiguities Requiring Clarification

| Question | Impact | Default Assumption |
|----------|--------|-------------------|
| Should legacy RenderCmd/Canvas2DRenderer be preserved during migration? | Major | Yes - dual-emit pattern |
| Is flattening tolerance screen-space or world-space? | Cache keys | Screen-space (pixel-based) |
| What is the priority of 3D vs optimizing 2D? | Scope | 2D first, 3D deferred |
| Should export pipeline be part of initial scope? | Scope | No - separate phase |

---

## Scope Assessment and Sprint Estimate

### Phase Breakdown

| Phase | Sprints | Description |
|-------|---------|-------------|
| **Phase A: IR Types** | 2 | RenderFrameIR, BufferRefIR, all pass/buffer types |
| **Phase B: Color/Encoding** | 1 | ColorBufferDesc, quantization kernels, migration |
| **Phase C: Instances2D Runtime** | 2 | InstanceBufferSetIR, materialize->render pipeline |
| **Phase D: Paths2D Runtime** | 2 | PathGeometryBufferIR, command streams, flattening |
| **Phase E: Caching Infrastructure** | 2-3 | CacheKeySpec, policies, budgets, eviction |
| **Phase F: Canvas Renderer Rewrite** | 1 | New renderer consuming RenderFrameIR |
| **SUBTOTAL (2D)** | **10-11** | Complete 2D renderer IR |
| **Phase G: 3D Camera/Mesh** | 2 | CameraIR, MeshIR, stores, materialization |
| **Phase H: 3D Projection** | 2-3 | Instances3D_ProjectTo2D, schedule integration |
| **SUBTOTAL (with 3D)** | **14-16** | Complete renderer IR system |

### Recommended Approach

1. **Start with Phase A (IR Types)** - Pure type definitions, no runtime changes
2. **Then Phase C (Instances2D)** - Build end-to-end pipeline for the common case
3. **Defer 3D** - Phases G-H can wait until 2D is stable
4. **Defer Export** - OutputAdapter and export semantics are separate work

---

## Persistent Check Requirements

### Checks That Should Exist

| Check | Purpose | Status |
|-------|---------|--------|
| `just test:renderer-ir` | Unit tests for IR types | NOT EXISTS |
| `just test:instances2d` | Instances2D materialization -> render | NOT EXISTS |
| `just test:paths2d` | Paths2D geometry buffers | NOT EXISTS |
| `just test:cache-policy` | Cache key computation, hit/miss | NOT EXISTS |
| `just smoke:render-ir` | E2E: compile -> IR -> render | NOT EXISTS |

### Existing Checks (run before starting)

```bash
just check        # Typecheck + lint + test (must pass)
just test:field   # Field materialization (must pass - dependency)
just test:signal  # Signal evaluation (must pass - dependency)
```

---

## Workflow Recommendation

**Verdict:** CONTINUE - but with scoped approach

**Reasoning:**
- Design documents are comprehensive and well-specified
- Dependencies from Phase 6 are mostly ready
- No blocking ambiguities that require clarification

**Recommended Next Steps:**

1. Complete Phase 6 `executeNodeEval` and `executeRenderAssemble` stubs
2. Define RenderFrameIR and related types (Phase A)
3. Build Instances2D pipeline end-to-end (Phase C)
4. Validate with visual tests before proceeding to Paths2D

---

## Files Read for This Evaluation

### Design Documents
- `/design-docs/13-Renderer/00-Overview-n-Context.md`
- `/design-docs/13-Renderer/01-RendererIR.md`
- `/design-docs/13-Renderer/03-Decisions-Color-PathFlattening-Basic3d.md`
- `/design-docs/13-Renderer/04-Decision-to-IR.md`
- `/design-docs/13-Renderer/05-Decisions-Upstream-Impacts.md`
- `/design-docs/13-Renderer/06-3d-Again.md` (empty)
- `/design-docs/13-Renderer/07-3d-Canonical.md`
- `/design-docs/13-Renderer/08-Caching-Spec.md`

### Codebase Files
- `/src/editor/ir/types/TypeDesc.ts`
- `/src/editor/compiler/ir/stores.ts`
- `/src/editor/runtime/renderCmd.ts`
- `/src/editor/runtime/canvasRenderer.ts`
- `/src/editor/runtime/executor/ScheduleExecutor.ts`
- `/src/editor/runtime/field/Materializer.ts`
- `/src/editor/compiler/blocks/domain/RenderInstances2D.ts`

### Planning Documents
- `/.agent_planning/ROADMAP.md`
