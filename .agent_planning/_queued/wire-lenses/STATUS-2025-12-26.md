# Status Report: Wire Lens Support
Date: 2025-12-26
Scope: wire-lenses (add lens support to block-to-block wire connections)
Confidence: FRESH

## Executive Summary

**Goal**: Make lenses a first-class capability for ALL connection types with uniform capabilities.

| Connection Type | Lens Support | Adapter Support | UI Editing |
|-----------------|--------------|-----------------|------------|
| Wire (block -> block) | **MISSING** | NONE | NONE |
| Publisher (block -> bus) | Partial (in types, compiled) | YES | No UI yet |
| Listener (bus -> block) | **FULL** | YES | Partial (preview in ConnectionInspector) |

**Assessment**: Wire connections are second-class citizens. They lack both the `lensStack` field and the compiler/UI infrastructure to apply transformations. This creates an inconsistent user experience where the same operations (scale, clamp, ease) are available via bus routing but not via direct wiring.

---

## 1. What Exists Today

### 1.1 Connection Interface (src/editor/types.ts:551-560)

```typescript
export interface Connection {
  readonly id: string;
  readonly from: PortRef;  // Source block + slot
  readonly to: PortRef;    // Destination block + slot
  // NOTE: NO lensStack field
  // NOTE: NO adapterChain field
}
```

Wires are the simplest connection type - just endpoint references with no transformation capability.

### 1.2 Publisher and Listener Interfaces (types.ts:194-241)

Both support transformation:
```typescript
export interface Publisher {
  readonly adapterChain?: AdapterStep[];
  readonly lensStack?: LensInstance[];  // <-- EXISTS
  // ...
}

export interface Listener {
  readonly adapterChain?: AdapterStep[];
  readonly lensStack?: LensInstance[];  // <-- EXISTS
  // ...
}
```

### 1.3 LensInstance Structure (types.ts:174-179)

```typescript
export interface LensInstance {
  lensId: string;                           // References LensRegistry
  params: Record<string, LensParamBinding>; // Default sources, wires, or buses
  enabled: boolean;
  sortKey?: number;
}
```

Lens params can be bound to:
- `default`: A DefaultSource value (most common)
- `wire`: Another port's output
- `bus`: A bus value

### 1.4 Lens Infrastructure (src/editor/lenses/)

| File | Purpose | Status |
|------|---------|--------|
| LensRegistry.ts | 30+ lens definitions (scale, clamp, ease, etc.) | COMPLETE |
| lensInstances.ts | Create LensInstance from LensDefinition | COMPLETE |
| lensResolution.ts | Resolve LensParamBinding to Artifact | COMPLETE |
| index.ts | Exports + legacy applyLens() | COMPLETE |

**LensRegistry.ts:11-12** defines scope:
```typescript
export type LensScope = 'publisher' | 'listener';
```

**AMBIGUITY**: No 'wire' scope exists. Many lenses specify `allowedScopes: ['publisher', 'listener']`. Decision needed: Should wires use a new 'wire' scope, or should they be treated as equivalent to 'listener' (they're consuming a value)?

### 1.5 Compiler Pipeline (compileBusAware.ts)

**Wire resolution (lines 596-608):**
```typescript
const wireConn = incoming.get(keyOf(blockId, p.name))?.[0];
if (wireConn !== null && wireConn !== undefined) {
  const srcKey = keyOf(wireConn.from.blockId, wireConn.from.port);
  const src = compiledPortMap.get(srcKey);
  inputs[p.name] = src ?? errorArtifact;  // <-- NO lens application!
}
```

Wires pass artifacts through unchanged. No `applyLensStack()` call.

**Bus listener resolution (lines 615-637):**
```typescript
if (busListener !== null && busListener !== undefined) {
  const busArtifact = getBusValue(...);
  const adapted = applyAdapterChain(busArtifact, busListener.adapterChain, ...);
  const lensed = applyLensStack(adapted, busListener.lensStack, ...);  // <-- LENSES APPLIED
  inputs[p.name] = lensed;
}
```

Full lens support for bus listeners.

### 1.6 UI (ConnectionInspector.tsx)

**WireConnectionView (lines 121-183):**
- Shows endpoints
- Disconnect button
- NO lens section, NO adapter section

**ListenerConnectionView (lines 269-361):**
- Shows endpoints
- Enable/disable toggle
- Lens section with badge preview (placeholder for LensChainEditor)

---

## 2. What's Missing for Wire Lenses

### 2.1 Type System Changes

**Connection interface needs extension:**
```typescript
export interface Connection {
  readonly id: string;
  readonly from: PortRef;
  readonly to: PortRef;
  // ADD:
  readonly adapterChain?: AdapterStep[];
  readonly lensStack?: LensInstance[];
}
```

**Impact**: Breaking change to serialization format. Need migration strategy for saved patches.

### 2.2 Store Changes (PatchStore.ts)

**Connection creation** needs lens/adapter parameters:
```typescript
// Current:
connect(fromBlockId, fromSlotId, toBlockId, toSlotId, options?)

// Needed:
connect(fromBlockId, fromSlotId, toBlockId, toSlotId, {
  adapterChain?: AdapterStep[],
  lensStack?: LensInstance[],
  suppressGraphCommitted?: boolean
})
```

**Update methods needed:**
```typescript
updateConnection(connectionId: string, updates: Partial<{
  adapterChain: AdapterStep[],
  lensStack: LensInstance[]
}>): void

addLensToConnection(connectionId: string, lens: LensDefinition, index?: number): void
removeLensFromConnection(connectionId: string, index: number): void
```

### 2.3 Compiler Changes (compileBusAware.ts)

**Wire resolution** needs lens application (around line 608):
```typescript
if (wireConn !== null && wireConn !== undefined) {
  const srcKey = keyOf(wireConn.from.blockId, wireConn.from.port);
  let src = compiledPortMap.get(srcKey) ?? errorArtifact;

  // ADD: Apply adapter chain
  src = applyAdapterChain(src, wireConn.adapterChain, ctx, errors);

  // ADD: Apply lens stack
  src = applyLensStack(src, wireConn.lensStack, ctx, defaultSources, buses, publishers, compiledPortMap, errors);

  inputs[p.name] = src;
}
```

**Challenge**: The current code destructures `wireConn` from `CompilerConnection` type, which doesn't have lens/adapter fields. Need to pass full Connection objects through the compiler pipeline or build a lookup map.

### 2.4 UI Changes

**ConnectionInspector.tsx - WireConnectionView:**
- Add lens section (same pattern as ListenerConnectionView)
- Add enable/disable toggle per lens
- Add adapter section (if supporting adapters on wires)

**LensChainEditor (not yet implemented):**
- Embedded component for editing lens stacks
- Reusable across wire, publisher, listener views

### 2.5 Semantic Validator (optional but recommended)

Extend Validator.canAddConnection() to check lens type compatibility.

---

## 3. Dependencies and Risks

### 3.1 Dependencies

| Dependency | Status | Notes |
|------------|--------|-------|
| LensRegistry | DONE | All lenses defined |
| LensInstance/LensParamBinding | DONE | Type system complete |
| DefaultSourceStore | DONE | For lens param defaults |
| applyLensStack() | DONE | Compiler function exists |
| LensChainEditor UI | **NOT STARTED** | Needed for all connection types |

### 3.2 Risks

1. **Serialization Breaking Change**: Adding fields to Connection will break existing saved patches.
   - Mitigation: Make fields optional, add migration in loadPatch()

2. **Compiler Complexity**: Wire resolution is currently simple; adding lens/adapter layers increases complexity.
   - Mitigation: Reuse existing applyLensStack/applyAdapterChain functions

3. **UI Consistency**: Three different connection types need uniform lens editing.
   - Mitigation: Create shared LensChainEditor component

4. **Scope Confusion**: LensScope is 'publisher' | 'listener' - no 'wire'.
   - Decision needed: Treat wire as 'listener' equivalent? Add new scope?

---

## 4. Ambiguities Requiring Clarification

### 4.1 Lens Scope for Wires

**Question**: Should wires use a new 'wire' scope, or be treated as 'listener' equivalent?

**Context**: Most lenses specify `allowedScopes: ['publisher', 'listener']`. Wires are semantically similar to listeners (they consume a value and deliver it to an input).

**Options**:
- A) Add 'wire' scope, update all lens definitions
- B) Treat wires as 'listener' scope (no lens changes needed)
- C) Remove scope restrictions entirely (lenses work on any connection)

**Recommendation**: Option B (treat as 'listener') - least invasive, semantically correct.

### 4.2 Adapter Support for Wires

**Question**: Should wires support adapter chains like bus connections?

**Context**: Adapters handle type conversions (ConstToSignal, BroadcastSignalToField). Currently, the compiler does implicit type coercion for some wire connections.

**Options**:
- A) Add full adapter support (matches bus behavior)
- B) Add limited adapter support (only explicit user-added adapters)
- C) No adapter support (keep wires simple)

**Recommendation**: Option A for consistency, but lower priority than lenses.

### 4.3 Publisher Lens UI

**Question**: Publishers have lensStack in the type but no UI for editing. Should we add it?

**Context**: ConnectionInspector.tsx:255 has a TODO comment: "Lens section for publisher (if publishers support lenses)"

**Options**:
- A) Add lens UI for publishers (full parity)
- B) Keep publishers lens-less (they're publishing to a shared bus)

**Recommendation**: Option A - publishers may want to pre-transform values before combining.

---

## 5. Implementation Order

### Phase 1: Type System (Low Risk)
1. Extend Connection interface with optional lensStack/adapterChain
2. Add patch migration for backward compatibility
3. Update PatchStore with connection update methods

### Phase 2: Compiler (Medium Risk)
1. Update CompilerConnection type
2. Pass Connection objects through compilation
3. Add lens/adapter application to wire resolution

### Phase 3: UI (Medium Effort)
1. Create shared LensChainEditor component
2. Add lens section to WireConnectionView
3. Add lens section to PublisherConnectionView
4. Replace placeholder in ListenerConnectionView

### Phase 4: Validation (Low Priority)
1. Extend semantic validator for wire lens type checking
2. Add domain compatibility warnings

---

## 6. Test Strategy

### Missing Tests Needed

1. **Unit: Wire lens application**
   - Wire with scale lens multiplies artifact value
   - Wire with multiple lenses applies in order
   - Wire with disabled lens skips it

2. **Integration: Compiler pipeline**
   - Patch with lensed wire compiles correctly
   - Lens error on wire produces clear diagnostic

3. **E2E: UI interaction**
   - Add lens to wire via ConnectionInspector
   - Remove lens from wire
   - Reorder lenses in stack

### Existing Tests to Verify

Check `src/editor/__tests__/composite.expansion.test.ts:365` - it tests listener lens preservation during composite expansion. Similar pattern needed for wires.

---

## 7. Verdict

**Completion**: 0% (wires have no lens support at all)

**Recommendation**: CONTINUE - No blocking ambiguities. The scope question (4.1) can be resolved with Option B (treat wires as listener scope) without blocking implementation.

**Priority Ordering**:
1. Connection type extension + store methods
2. Compiler wire lens support
3. LensChainEditor component (benefits all connection types)
4. Wire/Publisher UI integration

**Estimated Complexity**: Medium
- Type changes: LOW
- Store changes: LOW
- Compiler changes: MEDIUM
- UI changes: MEDIUM (new component)
