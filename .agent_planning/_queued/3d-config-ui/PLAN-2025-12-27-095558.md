# Implementation Plan: 3D Configuration UI
**Generated:** 2025-12-27-095558
**Source:** STATUS-20251227-150000.md
**Topic:** 3d-config-ui

---

## Executive Summary

The 3D runtime infrastructure (CameraStore, MeshStore, step executors) is **complete and well-designed**. This sprint focuses on building the UI bridge to configure 3D scenes in patches, following proven patterns from 2D rendering.

**Current State:**
- 3D runtime infrastructure: ✅ COMPLETE
- Camera/Mesh block definitions: ❌ NOT STARTED
- Vec3/Quaternion UI controls: ❌ NOT STARTED
- Compiler lowering for 3D blocks: ❌ NOT STARTED

**Sprint Scope:**
This sprint delivers **3 focused deliverables**:
1. Vec3 Editor Control (extend DefaultSourceControl)
2. Camera Block Definition (position, lookAt, projection params)
3. Camera Compiler/Lowering (generate CameraIR → CameraTable)

**Deferred to Future Sprints:**
- RenderInstances3D block (depends on working camera)
- Mesh block definition (can use default meshes initially)
- Quaternion editor (using lookAt instead for now)
- Preview widgets (camera frustum, mesh wireframe)

**Total Work Items:** 3 (P0: 2, P1: 1)

---

## Gap Analysis Summary

Based on STATUS-20251227-150000.md, the key gaps are:

| Component | Current State | Target State | Priority |
|-----------|---------------|--------------|----------|
| Vec3 Editor | Not implemented | `uiHint.kind: 'vec3'` → three number inputs | P0 |
| Camera Block | Does not exist | Block with position, lookAt, projection inputs | P0 |
| Camera Lowering | No compiler integration | Generate CameraIR from block → CameraTable | P1 |
| RenderInstances3D | Does not exist | Block consuming camera + domain + fields | DEFERRED |
| Mesh Block | Does not exist | Block with profile/extrusion params | DEFERRED |

---

## Backlog by Priority

### P0 (Critical) - Foundation for 3D UI

---

## P0-1: Vec3 Editor Control

**Status**: Not Started
**Effort**: Small (1-2 hours)
**Dependencies**: None
**Spec Reference**: `design-docs/3-Synthesized/07-UI-Spec.md` (Inspector section) • `STATUS-20251227-150000.md` § 3 (Inspector Integration)

### Description

Extend the `DefaultSourceControl` component in `src/editor/Inspector.tsx` to handle `uiHint.kind === 'vec3'`. This control will display three labeled number inputs (X, Y, Z) for editing 3D vector values like camera position or lookAt target.

**Current Pattern:**
The `xy` control (lines 1132-1156) shows the pattern: parse `ds.value` as an object with named fields, render separate inputs, call `onChange` with updated object.

**Implementation:**
Add a new conditional branch before the text fallback (line 1158) that checks for `uiHint?.kind === 'vec3'`.

### Acceptance Criteria

- [ ] DefaultSourceControl renders three number inputs labeled "X", "Y", "Z" when `uiHint.kind === 'vec3'`
- [ ] Inputs correctly parse `ds.value` as `{ x: number, y: number, z: number }`
- [ ] Changing any input calls `onChange` with updated object preserving other two values
- [ ] Control respects `isDriven` prop (disables inputs when driven by wire/bus)
- [ ] Styling matches existing `param-xy` pattern (uses `.param-xyz` class or similar)

### Technical Notes

**File:** `src/editor/Inspector.tsx`
**Location:** Insert after line 1156 (after `xy` control), before line 1158 (text fallback)

**Code Pattern:**
```typescript
// Vec3 control (xyz)
if (uiHint?.kind === 'vec3') {
  const value = ds.value as { x?: number; y?: number; z?: number } | undefined;
  const x = value?.x ?? 0;
  const y = value?.y ?? 0;
  const z = value?.z ?? 0;
  return (
    <div className="param-xyz">
      <input
        type="number"
        className="param-input"
        placeholder="x"
        value={x}
        disabled={isDriven}
        onChange={(e) => onChange({ x: parseFloat(e.target.value) || 0, y, z })}
      />
      <input
        type="number"
        className="param-input"
        placeholder="y"
        value={y}
        disabled={isDriven}
        onChange={(e) => onChange({ x, y: parseFloat(e.target.value) || 0, z })}
      />
      <input
        type="number"
        className="param-input"
        placeholder="z"
        value={z}
        disabled={isDriven}
        onChange={(e) => onChange({ x, y, z: parseFloat(e.target.value) || 0 })}
      />
    </div>
  );
}
```

**CSS:** Add to `src/editor/Inspector.css` (follow `.param-xy` pattern):
```css
.param-xyz {
  display: flex;
  gap: 4px;
}
.param-xyz input {
  flex: 1;
}
```

**Verification:**
1. Create a Camera block (after P0-2) with position input
2. Select the block in the patch bay
3. Inspector should show three inputs for X, Y, Z
4. Changing values should update the position

---

## P0-2: Camera Block Definition

**Status**: Not Started
**Effort**: Small (2-3 hours)
**Dependencies**: P0-1 (Vec3 Editor)
**Spec Reference**: `design-docs/3-Synthesized/09-Blocks.md` (Block creation) • `STATUS-20251227-150000.md` § 2 (Block Definition Gaps)

### Description

Create a Camera block definition following the existing domain block pattern. The Camera block will configure a 3D camera with position, lookAt target, projection type, and lens parameters (FOV, near/far clipping planes).

**Reference Pattern:**
- `src/editor/blocks/domain.ts` - DomainN, GridDomain (input definitions with defaultSource)
- Block uses `createBlock()` factory
- Inputs have `tier: 'primary' | 'secondary'` for UI organization
- `defaultSource` provides initial value + `uiHint` for UI control type

**CameraIR Structure (from runtime layer):**
```typescript
interface CameraIR {
  id: string;
  position: SignalSlot<vec3>;
  lookAt: SignalSlot<vec3>;
  up?: SignalSlot<vec3>;  // Optional, defaults to [0,1,0]
  projection: {
    kind: 'perspective' | 'orthographic';
    fovY?: number;  // For perspective
    orthoHeight?: number;  // For orthographic
    aspect: number;
    near: number;
    far: number;
  };
}
```

### Acceptance Criteria

- [ ] Camera block defined in `src/editor/blocks/camera.ts` with type `'Camera'`
- [ ] Block has primary inputs: position (Signal<vec3>), lookAt (Signal<vec3>), projectionKind (Scalar:string)
- [ ] Block has secondary inputs: fovY (Signal<number>), near (Signal<number>), far (Signal<number>)
- [ ] All inputs have sensible defaultSource values (position: {0,0,100}, lookAt: {0,0,0}, fovY: 60, near: 0.1, far: 1000)
- [ ] Position/lookAt use `uiHint: { kind: 'vec3' }` to trigger Vec3 editor
- [ ] projectionKind uses `uiHint: { kind: 'select', options: [...] }` with perspective/orthographic options
- [ ] Block registered in block registry with `laneKind: 'Scene'` and appropriate color
- [ ] Block outputs a special `camera` type (similar to Domain output)

### Technical Notes

**File:** `src/editor/blocks/camera.ts` (new file)

**Implementation Pattern:**
```typescript
import { createBlock } from './factory';
import { input, output } from './utils';

export const Camera = createBlock({
  type: 'Camera',
  label: 'Camera',
  description: '3D camera with position, orientation, and projection parameters',
  inputs: [
    input('position', 'Position', 'Signal<vec3>', {
      tier: 'primary',
      defaultSource: {
        value: { x: 0, y: 0, z: 100 },
        world: 'signal',
        uiHint: { kind: 'vec3' },
      },
    }),
    input('lookAt', 'Look At', 'Signal<vec3>', {
      tier: 'primary',
      defaultSource: {
        value: { x: 0, y: 0, z: 0 },
        world: 'signal',
        uiHint: { kind: 'vec3' },
      },
    }),
    input('projectionKind', 'Projection', 'Scalar:string', {
      tier: 'primary',
      defaultSource: {
        value: 'perspective',
        world: 'scalar',
        uiHint: {
          kind: 'select',
          options: [
            { value: 'perspective', label: 'Perspective' },
            { value: 'orthographic', label: 'Orthographic' },
          ],
        },
      },
    }),
    input('fovY', 'Field of View (deg)', 'Signal<number>', {
      tier: 'secondary',
      defaultSource: {
        value: 60,
        world: 'signal',
        uiHint: { kind: 'slider', min: 10, max: 120, step: 5 },
      },
    }),
    input('near', 'Near Clip', 'Signal<number>', {
      tier: 'secondary',
      defaultSource: {
        value: 0.1,
        world: 'signal',
        uiHint: { kind: 'number', min: 0.01, max: 10, step: 0.1 },
      },
    }),
    input('far', 'Far Clip', 'Signal<number>', {
      tier: 'secondary',
        defaultSource: {
        value: 1000,
        world: 'signal',
        uiHint: { kind: 'number', min: 100, max: 10000, step: 100 },
      },
    }),
  ],
  outputs: [
    output('camera', 'Camera', 'Camera'),  // Special type like Domain
  ],
  color: '#3B82F6',  // Blue for 3D/camera
  laneKind: 'Scene',
  priority: 10,
});
```

**Registry Integration:**
Export from `src/editor/blocks/index.ts` or appropriate aggregator.

**Verification:**
1. Camera block appears in block library
2. Dragging to patch bay creates block instance
3. Selecting block shows Inspector with all inputs
4. Vec3 controls appear for position/lookAt
5. Dropdown appears for projection type
6. Sliders appear for FOV/near/far

---

### P1 (High) - Compiler Integration

---

## P1-1: Camera Compiler Lowering

**Status**: Not Started
**Effort**: Medium (3-4 hours)
**Dependencies**: P0-2 (Camera Block Definition)
**Spec Reference**: `design-docs/3-Synthesized/05-Compilation.md` (Block lowering) • `STATUS-20251227-150000.md` § 2 (Block Definition Gaps), § 4 (Store/State Integration)

### Description

Create compiler lowering for Camera block that generates CameraIR and populates the CameraTable in the IR program. This follows the pattern from RenderInstances2D lowering, extracting input values and calling IR builder methods.

**Reference Pattern:**
- `src/editor/compiler/blocks/domain/RenderInstances2D.ts` - Shows how to extract inputs, validate, and call IR builder methods
- Camera block generates a single CameraIR entry with ID derived from block ID
- Inputs are Signal<vec3> or Signal<number>, so they resolve to value slots
- CameraIR is added to program's CameraTable via `ctx.b.addCamera()` (to be added to IRBuilder)

**Data Flow:**
```
Camera Block → lowerCamera() → CameraIR → CameraTable (in Program)
                                              ↓
                                         CameraStore (runtime cache)
                                              ↓
                                         CameraEval step (matrix calculation)
```

### Acceptance Criteria

- [ ] File `src/editor/compiler/blocks/domain/Camera.ts` created with `lowerCamera` function
- [ ] Camera block registered in `src/editor/compiler/ir/lowerTypes.ts` with `capability: 'camera'`
- [ ] Lowering extracts position, lookAt, projection inputs as value slots
- [ ] Lowering generates CameraIR with id = `camera-${blockId}`
- [ ] CameraIR added to program via `ctx.b.addCamera(cameraIR)` or similar API
- [ ] Lowering validates that position/lookAt are Signal<vec3> (not Field)
- [ ] Lowering validates that projectionKind is Scalar:string with value 'perspective' or 'orthographic'
- [ ] Camera block outputs a reference (special type) that can be consumed by future 3D render blocks

### Technical Notes

**Files:**
- `src/editor/compiler/blocks/domain/Camera.ts` (new file)
- `src/editor/compiler/ir/IRBuilder.ts` (add `addCamera` method)
- `src/editor/compiler/ir/program.ts` (add `cameras: Map<string, CameraIR>` to Program type)

**Implementation Pattern:**

`src/editor/compiler/blocks/domain/Camera.ts`:
```typescript
import { registerBlockType, type BlockLowerFn } from '../../ir/lowerTypes';

const lowerCamera: BlockLowerFn = ({ ctx, blockId, inputs }) => {
  const [position, lookAt, projectionKind, fovY, near, far] = inputs;

  // Validate inputs
  if (position.k !== 'sig') {
    throw new Error(`Camera requires Signal<vec3> position, got ${position.k}`);
  }
  if (lookAt.k !== 'sig') {
    throw new Error(`Camera requires Signal<vec3> lookAt, got ${lookAt.k}`);
  }
  if (projectionKind.k !== 'scalar') {
    throw new Error(`Camera requires Scalar:string projectionKind, got ${projectionKind.k}`);
  }

  // Extract projection type from scalar value
  const projKind = projectionKind.value as 'perspective' | 'orthographic';
  if (projKind !== 'perspective' && projKind !== 'orthographic') {
    throw new Error(`Camera projectionKind must be 'perspective' or 'orthographic', got '${projKind}'`);
  }

  // Build CameraIR
  const cameraId = `camera-${blockId}`;
  const cameraIR = {
    id: cameraId,
    position: position.slot,  // SignalSlot<vec3>
    lookAt: lookAt.slot,      // SignalSlot<vec3>
    projection: {
      kind: projKind,
      fovY: fovY.slot,        // SignalSlot<number>
      aspect: 16/9,           // TODO: Get from canvas/viewport
      near: near.slot,        // SignalSlot<number>
      far: far.slot,          // SignalSlot<number>
    },
  };

  // Add to program's CameraTable
  ctx.b.addCamera(cameraIR);

  // Output a camera reference (special type)
  const cameraRef = ctx.b.special('camera', cameraId);

  return {
    outputs: [cameraRef],
    declares: {
      camera: cameraId,
    },
  };
};

registerBlockType({
  type: 'Camera',
  capability: 'camera',
  inputs: [
    { portId: 'position', label: 'Position', dir: 'in', type: { world: 'signal', domain: 'vec3' } },
    { portId: 'lookAt', label: 'Look At', dir: 'in', type: { world: 'signal', domain: 'vec3' } },
    { portId: 'projectionKind', label: 'Projection', dir: 'in', type: { world: 'scalar', domain: 'string' } },
    { portId: 'fovY', label: 'FOV', dir: 'in', type: { world: 'signal', domain: 'number' } },
    { portId: 'near', label: 'Near', dir: 'in', type: { world: 'signal', domain: 'number' } },
    { portId: 'far', label: 'Far', dir: 'in', type: { world: 'signal', domain: 'number' } },
  ],
  outputs: [
    { portId: 'camera', label: 'Camera', dir: 'out', type: { world: 'special', domain: 'camera' } },
  ],
  lower: lowerCamera,
});
```

`src/editor/compiler/ir/IRBuilder.ts` (add method):
```typescript
addCamera(camera: CameraIR): void {
  this.program.cameras.set(camera.id, camera);
}
```

`src/editor/compiler/ir/program.ts` (add to Program type):
```typescript
export interface Program {
  // ... existing fields
  cameras: Map<string, CameraIR>;
  meshes: Map<string, MeshIR>;
}
```

**Verification:**
1. Create a Camera block in a patch
2. Compile the patch (trigger via play/scrub)
3. Check program IR: `cameras` map should contain one entry
4. Camera ID should be `camera-${blockId}`
5. CameraIR should have position/lookAt/projection slots
6. No compilation errors

**Edge Cases:**
- Multiple cameras: Allow for now, IDs will be unique per block
- Aspect ratio: Hardcode 16:9 for now, future work to get from canvas
- Orthographic: fovY slot unused for ortho, but included in IR (consumer ignores)

---

## Dependency Graph

```
P0-1 (Vec3 Editor)
    ↓
P0-2 (Camera Block Definition)
    ↓
P1-1 (Camera Compiler/Lowering)
```

**Critical Path:** P0-1 → P0-2 → P1-1 (sequential)

All work items are sequential dependencies for enabling 3D camera configuration.

---

## Recommended Sprint Execution

### Day 1: UI Foundation
1. **P0-1: Vec3 Editor Control** (1-2 hours)
   - Add control to DefaultSourceControl
   - Add CSS styling
   - Manual test with mock data

### Day 2: Block Definition
2. **P0-2: Camera Block Definition** (2-3 hours)
   - Create Camera block file
   - Export from registry
   - Test in UI (drag, select, inspect)
   - Verify Vec3 controls appear

### Day 3: Compiler Integration
3. **P1-1: Camera Compiler/Lowering** (3-4 hours)
   - Extend IRBuilder with `addCamera` method
   - Create Camera lowering
   - Register block type
   - Test compilation (check IR output)

**Total Estimated Effort:** 6-9 hours (small-medium sprint)

---

## Risk Assessment

| Risk | Severity | Mitigation |
|------|----------|------------|
| Vec3 control styling breaks on small screens | Low | Follow existing `param-xy` pattern exactly |
| Camera IR type mismatch with runtime | Medium | Reference existing CameraIR in runtime/field/types.ts |
| Aspect ratio unknown at compile time | Low | Hardcode 16:9 for now, document TODO |
| Multiple cameras cause confusion | Low | Defer multi-camera support, document single-camera assumption |
| Type system doesn't support `Signal<vec3>` | High | Verify type compatibility early, may need adapter |

**High Risk Item:** Type system compatibility for `Signal<vec3>`. The current type system may not support vec3 as a signal domain. **Mitigation:** Check existing type definitions in `src/editor/types.ts` and `src/editor/compiler/types.ts` before starting P0-2. If vec3 is not supported as a signal domain, use three separate `Signal<number>` inputs (posX, posY, posZ) instead.

---

## Blockers and Questions

None identified. The 3D runtime infrastructure is complete and the patterns from 2D rendering are well-established.

---

## Follow-Up Work (Future Sprints)

After this sprint completes, the next logical steps are:

1. **RenderInstances3D Block** (depends on working camera)
   - Consumes Domain, Camera reference, Mesh reference, Field<vec3> positions
   - Outputs Instance2DBufferRef via Instances3DProjectTo2D step
   - Effort: Medium (4-6 hours)

2. **Mesh Block Definition** (lower priority)
   - Profile type selector (circle/ngon/polyline)
   - Extrusion controls (linear/rounded, depth, caps)
   - Generates MeshIR
   - Effort: Medium-Large (6-8 hours)

3. **UI Enhancements**
   - Quaternion editor (for advanced rotation control)
   - Camera frustum preview widget
   - Mesh wireframe preview
   - Effort: Large (8-12 hours)

---

## References

**Specification Documents:**
- `design-docs/3-Synthesized/07-UI-Spec.md` - Inspector and control patterns
- `design-docs/3-Synthesized/09-Blocks.md` - Block creation guidelines
- `design-docs/3-Synthesized/05-Compilation.md` - Compiler architecture

**Status Report:**
- `STATUS-20251227-150000.md` - Current state evaluation

**Code References:**
- `src/editor/Inspector.tsx` - DefaultSourceControl (lines 1042-1168)
- `src/editor/blocks/domain.ts` - Domain block patterns (DomainN, GridDomain)
- `src/editor/compiler/blocks/domain/RenderInstances2D.ts` - Lowering pattern
- `src/editor/runtime/field/types.ts` - CameraIR definition
