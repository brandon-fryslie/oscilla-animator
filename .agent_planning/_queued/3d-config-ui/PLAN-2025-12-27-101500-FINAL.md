# Sprint Plan: 3D Camera Configuration UI (FINAL)
**Generated:** 2025-12-27-101500
**Status:** Revised per architectural feedback

## Sprint Goal

Deliver camera configuration UI with correct resource-ref architecture, explicit selection semantics, and robust validation.

---

## Architecture Principles

### 1. Camera is a Resource with Routable Reference

Camera block:
- Contributes a `CameraIR` entry to `program.cameras` table
- Outputs a `Special:CameraRef` (resource reference, not signal/field)
- Reference can be wired to render sinks that accept camera inputs
- Reference is NOT a value in scheduling sense - just typed ID routing

### 2. Explicit Camera Selection (No Hidden "First" Rules)

- `program.defaultCameraId: CameraId` - always present, deterministic
- 0 cameras → compiler injects `DefaultCameraIR` (implicit, not in patch)
- 1 camera → that camera is the default
- N cameras → first created is default, but sinks can override
- Render sinks have `cameraId?: CameraId` - if omitted, uses defaultCameraId

**Key:** "Which camera am I using?" is never a surprise.

### 3. Epsilon-Based Validation

Float equality is dangerous. Use tolerance:
- `|position - target| < ε` (ε ≈ 1e-6 world units)
- `|cross(viewDir, up)| < ε` for parallel check

### 4. Explicit Angle Semantics

TypeDesc for angles includes `semantics: 'angleRad'` so downstream never invents "degrees".

---

## Scope

**In scope:**
1. Vec3 Default Source Editor
2. Camera Block with CameraRef output
3. CameraIR Schema (locked)
4. Camera Compiler/Lowering
5. Validation with epsilon tolerance
6. Explicit camera selection semantics

**Deferred:**
- RenderInstances3D block
- Mesh block
- Camera frustum preview
- Multi-camera picker UI

---

## Work Items

### P0-1: Vec3 Default Source Editor

*(Unchanged from previous revision)*

**File:** `src/editor/components/DefaultSourceControl.tsx` or Inspector.tsx

**Requirements:**
- Three labeled inputs (X, Y, Z) when `uiHint.kind === 'vec3'`
- Parses/updates single `{ x, y, z }` object
- Disabled when driven
- Paste JSON `{"x":1,"y":2,"z":3}` or comma-separated `1,2,3`

**Acceptance Criteria:**
- [ ] Three inputs render for vec3 uiHint
- [ ] Changing X preserves Y and Z
- [ ] Disabled when port is driven
- [ ] Paste support works

---

### P0-2: Camera Block with CameraRef Output

**File:** `src/editor/blocks/camera.ts` (new)

**Block Definition:**

```typescript
{
  type: 'Camera',
  category: 'Scene',

  inputs: {
    position: {
      type: { world: 'signal', domain: 'vec3' },
      defaultSource: { x: 0, y: 0, z: 100 },
      uiHint: { kind: 'vec3' }
    },
    target: {
      type: { world: 'signal', domain: 'vec3' },
      defaultSource: { x: 0, y: 0, z: 0 },
      uiHint: { kind: 'vec3' }
    },
    up: {
      type: { world: 'signal', domain: 'vec3' },
      defaultSource: { x: 0, y: 1, z: 0 },
      uiHint: { kind: 'vec3' }
    },
    projectionKind: {
      type: { world: 'scalar', domain: 'string' },
      defaultSource: 'perspective',
      uiHint: { kind: 'select', options: ['perspective', 'orthographic'] }
    },
    fovYDeg: {
      type: { world: 'signal', domain: 'number', semantics: 'angleDeg' },
      defaultSource: 60,
      uiHint: { kind: 'slider', min: 10, max: 120 }
    },
    orthoHeight: {
      type: { world: 'signal', domain: 'number' },
      defaultSource: 10,
      uiHint: { kind: 'number' }
    },
    near: {
      type: { world: 'signal', domain: 'number' },
      defaultSource: 0.1,
      uiHint: { kind: 'number', min: 0.001 }
    },
    far: {
      type: { world: 'signal', domain: 'number' },
      defaultSource: 1000,
      uiHint: { kind: 'number' }
    },
  },

  outputs: {
    camera: {
      type: { world: 'special', domain: 'cameraRef' },
      // This is a resource reference, not a signal/field
      // Can only be wired to sinks that accept cameraRef
    }
  },
}
```

**Key Points:**
- Output is `Special:CameraRef` - typed reference to camera ID
- NOT a signal/field - just routes which camera to use
- Render sinks accept this type on their `camera` input

**Acceptance Criteria:**
- [ ] Camera block has ONE output port (cameraRef)
- [ ] Output type is `{ world: 'special', domain: 'cameraRef' }`
- [ ] Output can wire to render sink camera input (future)
- [ ] Block still contributes to `program.cameras` table

---

### P0-3: CameraIR Schema (Locked)

**File:** `src/editor/compiler/ir/types3d.ts`

```typescript
export interface CameraIR {
  /** Unique ID: `camera-${blockId}` */
  id: CameraId;

  /** Coordinate conventions (LOCKED) */
  handedness: 'right';
  forwardAxis: '-Z';
  upAxis: '+Y';

  /** Projection */
  projection: {
    kind: 'perspective' | 'orthographic';
    near: number;           // > 0
    far: number;            // > near
    fovYRad: number;        // RADIANS (0, π) - semantics: angleRad
    orthoHeight: number;
  };

  /** LookAt pose (with up defaulted if not provided) */
  pose: {
    position: { x: number; y: number; z: number };
    target: { x: number; y: number; z: number };
    up: { x: number; y: number; z: number };
  };

  viewportPolicy: 'useRuntimeViewport';
  sourceBlockId: BlockId;
}

/** Default camera injected when patch has 0 camera blocks */
export const DEFAULT_CAMERA_IR: Omit<CameraIR, 'id' | 'sourceBlockId'> = {
  handedness: 'right',
  forwardAxis: '-Z',
  upAxis: '+Y',
  projection: {
    kind: 'perspective',
    near: 0.1,
    far: 1000,
    fovYRad: Math.PI / 3,  // 60 degrees
    orthoHeight: 10,
  },
  pose: {
    position: { x: 0, y: 0, z: 100 },
    target: { x: 0, y: 0, z: 0 },
    up: { x: 0, y: 1, z: 0 },
  },
  viewportPolicy: 'useRuntimeViewport',
};
```

**Angle Semantics (explicit):**
- **Input port** `fovYDeg`: `{ domain: 'number', semantics: 'angleDeg' }` - UI-friendly degrees
- **IR field** `fovYRad`: `{ domain: 'number', semantics: 'angleRad' }` - math-friendly radians
- **Lowering** converts: `fovYRad = fovYDeg * (Math.PI / 180)`

**Acceptance Criteria:**
- [ ] CameraIR has all fields with literal types
- [ ] DEFAULT_CAMERA_IR constant exported
- [ ] fovYRad documented as radians
- [ ] Conventions locked with literal types

---

### P1-1: Camera Compiler/Lowering

**File:** `src/editor/compiler/blocks/scene/Camera.ts`

```typescript
export function lowerCamera(block: BlockIR, ctx: LoweringContext): void {
  // Extract inputs with defaults
  const position = ctx.resolveVec3('position');
  const target = ctx.resolveVec3('target');
  const up = ctx.resolveVec3('up', { x: 0, y: 1, z: 0 });  // Default applied

  const kind = ctx.resolveScalarString('projectionKind');
  const fovYDeg = ctx.resolveNumber('fovYDeg');
  const orthoHeight = ctx.resolveNumber('orthoHeight');
  const near = ctx.resolveNumber('near');
  const far = ctx.resolveNumber('far');

  // Convert degrees to radians
  const fovYRad = fovYDeg * (Math.PI / 180);

  const cameraIR: CameraIR = {
    id: `camera-${block.id}`,
    handedness: 'right',
    forwardAxis: '-Z',
    upAxis: '+Y',
    projection: { kind, near, far, fovYRad, orthoHeight },
    pose: { position, target, up },
    viewportPolicy: 'useRuntimeViewport',
    sourceBlockId: block.id,
  };

  // Add to cameras table
  ctx.builder.addCamera(cameraIR);

  // Output camera ref (just the ID for routing)
  ctx.emitOutput('camera', { kind: 'cameraRef', cameraId: cameraIR.id });
}
```

**Acceptance Criteria:**
- [ ] Camera.ts created in compiler/blocks/scene/
- [ ] Registered with `capability: 'camera'`
- [ ] `ctx.builder.addCamera()` API exists
- [ ] fovYDeg → fovYRad conversion (× π/180)
- [ ] up defaults to (0,1,0) if not connected
- [ ] Output emits cameraRef with ID

---

### P1-2: Validation with Epsilon Tolerance

**File:** `src/editor/compiler/blocks/scene/Camera.ts`

**Epsilon constant:**
```typescript
const CAMERA_EPSILON = 1e-6;  // World units
```

**Validation Rules:**

| Condition | Check | Error Code |
|-----------|-------|------------|
| near invalid | `near <= 0` | `CAMERA_INVALID_NEAR` |
| far invalid | `far <= near` | `CAMERA_INVALID_FAR` |
| degenerate lookAt | `distance(position, target) < ε` | `CAMERA_DEGENERATE_LOOKAT` |
| degenerate up | `|cross(viewDir, up)| < ε` | `CAMERA_DEGENERATE_UP` |
| invalid FOV | `fovYDeg <= 1 \|\| fovYDeg >= 179` | `CAMERA_INVALID_FOV` |
| invalid projection | `kind not in ['perspective', 'orthographic']` | `CAMERA_INVALID_PROJECTION` |

**Helper functions:**
```typescript
function distance(a: Vec3, b: Vec3): number {
  const dx = a.x - b.x, dy = a.y - b.y, dz = a.z - b.z;
  return Math.sqrt(dx*dx + dy*dy + dz*dz);
}

function crossMagnitude(a: Vec3, b: Vec3): number {
  const cx = a.y*b.z - a.z*b.y;
  const cy = a.z*b.x - a.x*b.z;
  const cz = a.x*b.y - a.y*b.x;
  return Math.sqrt(cx*cx + cy*cy + cz*cz);
}
```

**Acceptance Criteria:**
- [ ] CAMERA_EPSILON = 1e-6 defined
- [ ] distance() used for position === target check
- [ ] cross magnitude used for up parallel check
- [ ] All 6 error codes emitted with `{ blockId, port }`
- [ ] Validation runs AFTER defaulting up

---

### P1-3: Explicit Camera Selection Semantics

**Files:**
- `src/editor/compiler/ir/program.ts` (update CompiledProgramIR)
- `src/editor/compiler/compileBusAware.ts` or similar (selection logic)

**Program Extension:**
```typescript
export interface CompiledProgramIR {
  // ... existing fields ...

  cameras: CameraIR[];

  /** Always present - ID of default camera */
  defaultCameraId: CameraId;
}
```

**Selection Rules:**

| Cameras | defaultCameraId | Behavior |
|---------|-----------------|----------|
| 0 | `'__default__'` | Inject DEFAULT_CAMERA_IR with id='__default__' |
| 1 | that camera's ID | Obvious default |
| N | first by block creation order | Deterministic; **emit warning** `WARN_MULTIPLE_CAMERAS_USING_DEFAULT` |

**Warning for N > 1 cameras:**
```typescript
// Emit during compilation when multiple cameras exist
if (cameras.length > 1) {
  ctx.emitWarning({
    code: 'WARN_MULTIPLE_CAMERAS_USING_DEFAULT',
    severity: 'warning',
    message: `Multiple cameras defined (${cameras.length}). Using '${defaultCameraId}' as default. ` +
             `Render sinks can specify cameraId to use a different camera.`,
    data: {
      defaultCameraId,
      cameraIds: cameras.map(c => c.id),
    },
  });
}
```

**Render Sink Contract (for future):**
```typescript
interface RenderSinkIR {
  // ... other fields ...
  cameraId?: CameraId;  // If omitted, uses program.defaultCameraId
}
```

**Injection Logic (0 cameras case):**
```typescript
if (cameras.length === 0) {
  const implicitCamera: CameraIR = {
    ...DEFAULT_CAMERA_IR,
    id: '__default__',
    sourceBlockId: '__implicit__',
  };
  cameras.push(implicitCamera);
  defaultCameraId = '__default__';
} else {
  defaultCameraId = cameras[0].id;  // First by creation order
}
```

**Acceptance Criteria:**
- [ ] `program.defaultCameraId` always present (never null)
- [ ] 0 cameras → `__default__` camera injected
- [ ] 1 camera → that camera is default
- [ ] N cameras → first by creation order is default
- [ ] DEFAULT_CAMERA_IR used for implicit camera
- [ ] Render sinks can specify `cameraId` to override (future-ready)

---

## Dependencies

P0-2 → P0-1 (needs vec3 editor)
P1-1 → P0-2, P0-3 (needs block and schema)
P1-2 → P1-1 (validation in lowering)
P1-3 → P1-1 (needs cameras table)

---

## Risks

| Risk | Mitigation |
|------|------------|
| Special:cameraRef type not in type system | Add to TypeDomain enum in types.ts |
| Output wiring to render sinks not tested | Defer wiring test to RenderInstances3D sprint |
| Epsilon too small/large | Start with 1e-6, tune if needed |

---

## Deferred

- RenderInstances3D block with cameraId input
- Mesh blocks
- Multi-camera UI picker
- Camera frustum preview
- Animation/keyframes
