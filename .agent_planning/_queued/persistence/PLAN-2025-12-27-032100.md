# Implementation Plan: Patch Persistence (Save/Load)

**Generated**: 2025-12-27-032100
**Source**: STATUS-2025-12-27-032100.md
**Topic**: persistence
**Scope**: Save and Load patches to/from disk (2 deliverables)

---

## Executive Summary

**Current State**: Core serialization/deserialization infrastructure is complete and working (`RootStore.toJSON()` and `RootStore.loadPatch()`). UI buttons exist but are disabled. No file download/upload implementation. No localStorage auto-save.

**Gap Analysis**: The foundation is solid (40% complete). Missing pieces are purely UI integration—wiring existing serialization to browser file APIs. Reference implementations exist in PathManagerModal.tsx for file upload/download patterns.

**Sprint Goal**: Enable users to save patches as JSON files to disk and load them back. Defer Export (animation export) and cloud storage to future sprints. Include optional localStorage auto-save if implementation remains simple.

**Total Effort**: Medium (3-5 days)
**Risk Level**: Low—well-understood browser APIs, working serialization, clear patterns

---

## Backlog by Priority

### P0 (Critical): Core Save/Load UI

#### P0.1: Implement Save to File

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: None
**Spec Reference**: STATUS § "What's Missing" (lines 106-154) • PathManagerModal.tsx reference (lines 295-308)

##### Description
Enable the Save button in SettingsToolbar to download the current patch as a JSON file to the user's local disk. Use the existing `RootStore.toJSON()` method and the browser Blob/URL API pattern from PathManagerModal.

##### Implementation Notes
- Remove `disabled` attribute from Save button
- Create `handleSavePatch()` handler
- Call `rootStore.toJSON()` to serialize patch
- Use `JSON.stringify(patch, null, 2)` for readable formatting
- Generate filename: `patch-YYYY-MM-DD-HHmmss.oscilla.json` (timestamp for uniqueness, `.oscilla.json` extension for clarity)
- Create Blob, object URL, trigger download via temporary anchor element
- Clean up object URL after download

**Pattern from PathManagerModal.tsx:295-308**:
```typescript
const handleExport = (id: string) => {
  const json = pathLibrary.exportAsJSON(id);
  const filename = `path-${entry?.name ?? 'export'}-${Date.now()}.json`;
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
};
```

**Adapt for patches**:
- Use ISO timestamp format instead of `Date.now()` for better human readability
- Use `.oscilla.json` extension to distinguish from other JSON files
- Add error handling for serialization failures (try/catch around toJSON)

##### Acceptance Criteria
- [ ] Save button is enabled in SettingsToolbar
- [ ] Clicking Save triggers file download with current patch data
- [ ] Downloaded file is valid JSON matching Patch type schema (version: 2)
- [ ] Filename format is `patch-YYYY-MM-DD-HHmmss.oscilla.json`
- [ ] JSON is pretty-printed (indented) for human readability
- [ ] Download works in Chrome, Firefox, Safari
- [ ] Error handling: If toJSON() throws, show user-friendly error message
- [ ] Object URL is properly cleaned up after download

---

#### P0.2: Implement Load from File

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0.1 (for testing round-trip)
**Spec Reference**: STATUS § "What's Missing" (lines 155-174) • PathManagerModal.tsx reference (lines 83-106)

##### Description
Enable the Load button to open a file picker, read a JSON patch file, validate it, and load it into the editor using `RootStore.loadPatch()`. Show confirmation dialog before clearing current patch.

##### Implementation Notes
- Remove `disabled` attribute from Load button
- Add hidden `<input type="file" accept=".json,.oscilla.json">` element
- Create `handleLoadPatch()` handler that triggers file picker
- Use FileReader to read file as text
- Parse JSON and validate basic structure (version field, blocks array, etc.)
- Show confirmation dialog: "Load this patch? Current patch will be replaced. Unsaved changes will be lost."
- On confirm, call `rootStore.loadPatch(patch)`
- On cancel, do nothing
- Reset file input value after load (to allow reloading same file)

**Pattern from PathManagerModal.tsx:83-106**:
```typescript
const handleFileUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
  const file = e.target.files?.[0];
  if (file === undefined) return;

  const reader = new FileReader();
  reader.onload = (event) => {
    const text = (event.target?.result as string) ?? '';
    // ... process text
  };
  reader.onerror = () => {
    setError('Failed to read file. Please try again.');
  };
  reader.readAsText(file);
};
```

**Validation strategy**:
- Check `typeof patch === 'object'`
- Check `typeof patch.version === 'number'`
- Check `Array.isArray(patch.blocks)`
- Check `Array.isArray(patch.connections)`
- More detailed validation is handled by `loadPatch()` itself (with defaults for missing fields)

##### Acceptance Criteria
- [ ] Load button is enabled in SettingsToolbar
- [ ] Clicking Load opens native file picker dialog
- [ ] File picker accepts `.json` and `.oscilla.json` files
- [ ] On file selection, confirmation dialog appears with warning about replacing current patch
- [ ] On cancel, file picker closes and current patch remains unchanged
- [ ] Error handling: Invalid JSON shows clear error message
- [ ] Error handling: Missing required fields shows clear error message
- [ ] File input is reset after load to allow reloading same file
- [ ] Round-trip test: Save a patch, load it back, verify all state matches

---

### P1 (High): User Experience Enhancements

#### P1.1: Add Keyboard Shortcuts

**Status**: Not Started
**Effort**: Small (1 day)
**Dependencies**: P0.1, P0.2
**Spec Reference**: General UX best practice

##### Description
Add standard keyboard shortcuts for save/load operations to improve user workflow efficiency.

##### Implementation Notes
- Cmd/Ctrl+S → Save
- Cmd/Ctrl+O → Load
- Check if any input/textarea is focused before triggering (to avoid conflicts)
- Show shortcuts in button tooltips

##### Acceptance Criteria
- [ ] Cmd/Ctrl+S triggers save operation (same as clicking Save button)
- [ ] Cmd/Ctrl+O triggers load operation (same as clicking Load button)
- [ ] Shortcuts do NOT trigger when typing in input fields or textareas
- [ ] Button tooltips include keyboard shortcuts (e.g., "Save patch (Cmd+S)")
- [ ] Shortcuts work consistently across Chrome, Firefox, Safari

---

#### P1.2: Improved Error Messages

**Status**: Not Started
**Effort**: Small (1 day)
**Dependencies**: P0.1, P0.2
**Spec Reference**: STATUS § "Risks" (lines 206-227)

##### Description
Add comprehensive error handling with clear, actionable error messages for common failure cases.

##### Implementation Notes
- Wrap file operations in try/catch
- Distinguish between different error types:
  - File read failed (FileReader error)
  - Invalid JSON syntax (JSON.parse error)
  - Invalid patch structure (validation error)
  - Serialization failed (toJSON error)
- Show error messages in a visible UI element (toast notification or inline message)
- Auto-dismiss after 5 seconds or allow manual dismiss

**Error scenarios to handle**:
1. File too large (localStorage size limit)
2. Malformed JSON
3. Missing required fields
4. Unknown version number (future-proofing)
5. Browser storage quota exceeded

##### Acceptance Criteria
- [ ] File read errors show message: "Failed to read file. Please try again."
- [ ] JSON parse errors show message: "Invalid JSON file. Please check the file format."
- [ ] Validation errors show message: "Invalid patch file. Missing required fields: [field names]"
- [ ] Unknown version shows message: "Unsupported patch version: X. This file may have been created by a newer version."
- [ ] All errors are logged to console for debugging
- [ ] Error messages auto-dismiss after 5 seconds
- [ ] Error messages can be manually dismissed via close button

---

### P2 (Medium): localStorage Auto-Save/Recovery

#### P2.1: Auto-Save to localStorage

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: P0.1, P0.2
**Spec Reference**: STATUS § "localStorage Auto-Save" (lines 176-183) • pathLibrary/storage.ts pattern

##### Description
Automatically save the current patch to localStorage as a recovery mechanism. Debounce saves to avoid performance issues. This is NOT a replacement for manual Save—it's a recovery feature for browser crashes or accidental tab closures.

##### Implementation Notes
- Create `src/editor/stores/patchPersistence.ts` following pathLibrary/storage.ts pattern
- Storage key: `'loom99-current-patch-autosave'`
- Stored format:
  ```typescript
  interface AutoSavedPatch {
    version: number;  // autosave format version (1)
    timestamp: number;  // Date.now() when saved
    patch: Patch;
  }
  ```
- Add MobX reaction in RootStore to watch for changes (blocks, connections, buses, etc.)
- Debounce saves with 2-second delay after last change
- Add size check before saving (if JSON exceeds 4MB, skip and warn in console)
- Gracefully handle localStorage quota exceeded errors

**Storage module structure** (following pathLibrary/storage.ts):
```typescript
// src/editor/stores/patchPersistence.ts
const AUTOSAVE_KEY = 'loom99-current-patch-autosave';
const MAX_SIZE_MB = 4;

export function saveAutosave(patch: Patch): void {
  try {
    const stored = {
      version: 1,
      timestamp: Date.now(),
      patch,
    };
    const json = JSON.stringify(stored);

    // Size check
    if (json.length > MAX_SIZE_MB * 1024 * 1024) {
      console.warn('Autosave skipped: patch too large');
      return;
    }

    localStorage.setItem(AUTOSAVE_KEY, json);
  } catch (err) {
    console.error('Autosave failed:', err);
  }
}

export function loadAutosave(): { patch: Patch; timestamp: number } | null {
  // ... similar to pathLibrary/storage.ts loadLibrary()
}

export function clearAutosave(): void {
  localStorage.removeItem(AUTOSAVE_KEY);
}
```

**MobX reaction setup** (in RootStore):
```typescript
// Add to RootStore constructor
makeAutoObservable(this);

// Debounced autosave reaction
let autosaveTimer: NodeJS.Timeout | null = null;
reaction(
  () => this.toJSON(),  // Observe entire patch
  (patch) => {
    if (autosaveTimer) clearTimeout(autosaveTimer);
    autosaveTimer = setTimeout(() => {
      saveAutosave(patch);
    }, 2000);
  },
  { delay: 100 }  // Additional debounce at reaction level
);
```

##### Acceptance Criteria
- [ ] Auto-save is debounced with 2-second delay after last change
- [ ] Auto-save stores patch in localStorage under key `loom99-current-patch-autosave`
- [ ] Stored data includes timestamp and patch version
- [ ] Patches larger than 4MB are NOT auto-saved (logged to console instead)
- [ ] localStorage quota errors are caught and logged (no user-facing error)
- [ ] Auto-save does NOT interfere with manual Save operation
- [ ] Auto-save does NOT fire during patch load operation (avoid save-load loop)

---

#### P2.2: Auto-Recovery on App Load

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: P2.1
**Spec Reference**: STATUS § "localStorage Auto-Save" (lines 176-183)

##### Description
Check for auto-saved patch on app startup and offer to restore it if found. Show a modal or banner with restore/discard options.

##### Implementation Notes
- On RootStore initialization, check for autosave in localStorage
- If found, show modal/banner with:
  - "Restore unsaved patch from [timestamp]?"
  - "Restore" button → `loadPatch(autosave.patch)`, then clear autosave
  - "Discard" button → clear autosave, continue with default empty patch
- If user loaded a patch via Load button, clear autosave automatically
- If autosave is older than 7 days, auto-discard (prevent stale recovery prompts)

**Modal UI**:
```typescript
interface RecoveryModalProps {
  timestamp: number;
  onRestore: () => void;
  onDiscard: () => void;
}
```

**Age check**:
```typescript
const MAX_AUTOSAVE_AGE_MS = 7 * 24 * 60 * 60 * 1000;  // 7 days
const autosave = loadAutosave();
if (autosave && Date.now() - autosave.timestamp > MAX_AUTOSAVE_AGE_MS) {
  clearAutosave();
  autosave = null;
}
```

##### Acceptance Criteria
- [ ] On app load, if autosave exists, modal appears with restore/discard options
- [ ] Modal shows human-readable timestamp (e.g., "2 hours ago", "yesterday")
- [ ] "Restore" button loads autosaved patch and clears autosave from localStorage
- [ ] "Discard" button clears autosave and continues with empty patch
- [ ] Modal does NOT appear if autosave is older than 7 days
- [ ] Autosaves older than 7 days are automatically deleted
- [ ] If user manually loads a patch, autosave is cleared automatically
- [ ] If user saves a patch, autosave remains (for recovery after save)

---

### P3 (Low): Testing and Documentation

#### P3.1: Round-Trip Serialization Tests

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: P0.1, P0.2
**Spec Reference**: STATUS § "Tests for Serialization Round-Trip" (lines 185-193)

##### Description
Add comprehensive unit tests for `toJSON()` and `loadPatch()` to ensure serialization is lossless and handles all entity types correctly.

##### Implementation Notes
- Create `src/editor/stores/__tests__/RootStore.serialization.test.ts`
- Test cases:
  1. Empty patch round-trip
  2. Patch with blocks only
  3. Patch with blocks and connections
  5. Patch with defaultSources
  6. Patch with all entity types
  7. Missing optional fields (defaulted correctly)
  8. Version field handling
- Use `expect(loadPatch(toJSON(original))).toEqual(original)` pattern
- Test ID counter adjustment (ensure new blocks get non-conflicting IDs)
- Test event emission (PatchLoaded event)

**Test structure**:
```typescript
describe('RootStore serialization', () => {
  let rootStore: RootStore;

  beforeEach(() => {
    rootStore = new RootStore();
  });

  it('round-trips empty patch', () => {
    const json = rootStore.toJSON();
    rootStore.loadPatch(json);
    expect(rootStore.toJSON()).toEqual(json);
  });

  it('round-trips patch with blocks and connections', () => {
    // Add blocks, connections
    const original = rootStore.toJSON();
    rootStore.loadPatch(original);
    const restored = rootStore.toJSON();
    expect(restored).toEqual(original);
  });

  // ... more test cases
});
```

##### Acceptance Criteria
- [ ] Test file `RootStore.serialization.test.ts` exists with 8+ test cases
- [ ] All tests pass (`just test`)
- [ ] Empty patch serialization is tested
- [ ] Patch with blocks/connections is tested
- [ ] Patch with defaultSources is tested
- [ ] Full patch with all entity types is tested
- [ ] Missing optional fields are tested (verify defaults applied)
- [ ] Version field is tested
- [ ] ID counter adjustment is tested
- [ ] Test coverage for RootStore.toJSON and RootStore.loadPatch is >90%

---

#### P3.2: E2E Persistence Smoke Test

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: P0.1, P0.2
**Spec Reference**: STATUS § "Missing Persistent Checks" (lines 263-270)

##### Description
Add end-to-end test using Chrome DevTools MCP to verify save/load UI workflow in a real browser.

##### Implementation Notes
- Create `tests/e2e/persistence.test.ts`
- Test steps:
  1. Open app in browser
  2. Create a simple patch (add blocks, connections)
  3. Click Save button, verify file download
  4. Click Load button, select saved file, verify patch restored
  5. Verify all blocks, connections, state match original
- Use Chrome DevTools MCP tools for UI interaction
- Verify downloaded file content matches `RootStore.toJSON()` output

**NOTE**: E2E tests may require manual verification initially (Chrome DevTools MCP is a new capability). If automation is complex, defer to P3 and use manual testing checklist instead.

##### Acceptance Criteria
- [ ] E2E test file `tests/e2e/persistence.test.ts` exists OR manual test checklist is documented
- [ ] Test covers: create patch → save → load → verify state restored
- [ ] Test verifies Save button triggers file download
- [ ] Test verifies Load button opens file picker and loads patch
- [ ] Test verifies round-trip integrity (state before save === state after load)
- [ ] Test runs successfully in Chrome (automated or manual)

---

## Dependency Graph

```
P0.1 (Save to File)
  ↓
P0.2 (Load from File) ────┐
  ↓                        ↓
P1.1 (Keyboard Shortcuts)  P1.2 (Error Messages)
  ↓                        ↓
P2.1 (Auto-Save) ──────────┘
  ↓
P2.2 (Auto-Recovery)
  ↓
P3.1 (Unit Tests)  P3.2 (E2E Tests)
```

**Critical Path**: P0.1 → P0.2 → P2.1 → P2.2
**Parallel Work**: P1.1 and P1.2 can be done in parallel after P0.2

---

## Recommended Sprint Planning

### Sprint 1: Core Functionality (3-5 days)
**Goal**: Users can save and load patches via UI buttons

**Deliverables**:
- P0.1: Save to File
- P0.2: Load from File
- P1.1: Keyboard Shortcuts
- P1.2: Error Messages

**Why this grouping**: These form a complete, usable feature. User can save work and reload it. Keyboard shortcuts and error handling are essential for good UX.

**Done when**:
- [ ] Save button downloads valid JSON file
- [ ] Load button opens file picker and restores patch
- [ ] Cmd/Ctrl+S and Cmd/Ctrl+O work
- [ ] Error messages show for common failures
- [ ] Manual testing confirms round-trip works

---

### Sprint 2: Auto-Recovery (Optional, 4-6 days)
**Goal**: Users don't lose work on browser crash or accidental tab close

**Deliverables**:
- P2.1: Auto-Save to localStorage
- P2.2: Auto-Recovery on App Load

**Why defer**: Auto-save is valuable but not essential for MVP. Can be added after core save/load is stable. Requires more complex state management (debouncing, MobX reactions).

**Done when**:
- [ ] Changes auto-save to localStorage after 2s debounce
- [ ] App startup checks for autosave and offers to restore
- [ ] Autosave doesn't interfere with manual save/load
- [ ] Old autosaves (7+ days) are auto-discarded

---

### Sprint 3: Testing and Hardening (3-5 days)
**Goal**: High confidence in serialization correctness

**Deliverables**:
- P3.1: Round-Trip Serialization Tests
- P3.2: E2E Persistence Smoke Test

**Why defer**: Core functionality should be manually tested first. Once stable, add automated tests for regression prevention.

**Done when**:
- [ ] Unit tests cover all entity types (blocks, connections, buses, etc.)
- [ ] E2E test (or manual checklist) verifies save/load UI workflow
- [ ] All tests pass in CI

---

## Risk Assessment

### High Confidence (Low Risk)
- **Browser File APIs**: Well-understood, cross-browser compatible
- **Serialization**: Already implemented and tested (toJSON/loadPatch)
- **Reference Implementation**: PathManagerModal provides proven patterns

### Medium Confidence (Medium Risk)
- **localStorage Size Limits**: Large patches may exceed 5-10MB quota
  - **Mitigation**: Size check before autosave, warn user, skip if too large
  - **Mitigation**: Recommend manual Save for large patches
- **Auto-Save Performance**: Frequent serialization could impact editor responsiveness
  - **Mitigation**: Debounce saves (2s delay)
  - **Mitigation**: Profile performance, adjust debounce if needed

### Low Confidence (High Risk)
- **Version Migration**: No v1 patches exist, but future versions will need migration logic
  - **Mitigation**: Document version 2 format in code comments
  - **Mitigation**: Add migration infrastructure when v3 is needed (future sprint)

---

## Blockers and Questions

**None identified.** All required infrastructure exists, patterns are proven, and scope is well-defined.

**Clarifications for user** (if needed):
1. **Export button behavior**: Should "Export" remain disabled? Or should it export SVG/video (separate from JSON save)?
   - **Assumption**: Export is deferred to future sprint (animation/video export)
2. **Autosave scope**: Should autosave fire on every change or only on "significant" changes (e.g., block added/removed)?
   - **Assumption**: Autosave on all changes (debounced), for maximum safety

---

## Files to Create/Modify

### Create
- `src/editor/stores/patchPersistence.ts` (P2.1) - localStorage auto-save module
- `src/editor/stores/__tests__/RootStore.serialization.test.ts` (P3.1) - Unit tests
- `tests/e2e/persistence.test.ts` (P3.2) - E2E test or manual checklist

### Modify
- `src/editor/SettingsToolbar.tsx` (P0.1, P0.2, P1.1) - Enable buttons, add handlers, keyboard shortcuts
- `src/editor/stores/RootStore.ts` (P2.1) - Add MobX reaction for auto-save

---

## Definition of Done (Sprint 1)

See separate file: `DOD-2025-12-27-032100.md`

**Sprint 1 Success Criteria**:
- User can save current patch as JSON file to disk
- User can load patch from JSON file via file picker
- User can use Cmd/Ctrl+S and Cmd/Ctrl+O shortcuts
- Errors are handled gracefully with clear messages
- Round-trip test confirms state integrity (manual verification)

**Out of Scope for Sprint 1**:
- localStorage auto-save/recovery (Sprint 2)
- Automated tests (Sprint 3)
- Export button (future sprint - animation export)
- Cloud storage (future sprint)

---

## Technical Notes

### File Naming Convention
Use ISO timestamp format for human readability:
```typescript
const now = new Date();
const timestamp = now.toISOString()
  .replace(/[:.]/g, '-')
  .replace('T', '-')
  .slice(0, 19);  // "YYYY-MM-DD-HH-mm-ss"
const filename = `patch-${timestamp}.oscilla.json`;
```

### Confirmation Dialog UX
Use native `window.confirm()` for simplicity in MVP. Future improvement: custom modal with better styling.

### localStorage Key Naming
Follow existing convention from pathLibrary:
- `loom99-current-patch-autosave` (autosave)
- `loom99-patch-library` (future: patch library)

### Error Logging
Always log to console for developer debugging, even when showing user-friendly messages:
```typescript
catch (err) {
  console.error('Failed to save patch:', err);
  showError('Failed to save patch. Please try again.');
}
```

---

## Success Metrics

**Sprint 1 (MVP)**:
- [ ] 100% of manual save operations succeed (excluding disk full errors)
- [ ] 100% of manual load operations succeed for valid patch files
- [ ] Round-trip test passes: save → load → verify state matches

**Sprint 2 (Auto-Recovery)**:
- [ ] Autosave triggers within 2 seconds of last change
- [ ] Recovery modal appears on next app load after autosave
- [ ] Zero data loss in manual testing (browser crash scenarios)

**Sprint 3 (Testing)**:
- [ ] >90% test coverage for toJSON/loadPatch
- [ ] All unit tests pass
- [ ] E2E test passes (or manual checklist 100% verified)

---

## References

- **STATUS-2025-12-27-032100.md**: Source evaluation with current state analysis
- **RootStore.ts:194-276**: Existing toJSON/loadPatch implementation
- **PathManagerModal.tsx:83-106, 295-308**: Reference patterns for file upload/download
- **pathLibrary/storage.ts**: Reference pattern for localStorage persistence
- **CLAUDE.md**: Project architecture and type system
