# Definition of Done: Phase 6 Sprint 3 - executeNodeEval + executeRenderAssemble + Hot-swap

**Generated:** 2025-12-26-102151
**Plan:** PLAN-2025-12-26-102151.md
**Status:** STATUS-2025-12-26-102151.md

---

## Sprint Scope

This sprint delivers **execution completeness and jank-free live editing**:

1. **executeRenderAssemble** - Stable finalization boundary for render tree assembly
2. **Hot-swap State Preservation** - Preserve state/time continuity across program recompilation
3. **executeNodeEval** (CONDITIONAL) - Node evaluation dispatch (IF verified as necessary)

**Deferred:**
- executeDebugProbe implementation (Phase 7)
- Legacy runtime removal (post-Sprint 3)
- Performance validation (post-Sprint 3)

---

## Acceptance Criteria

### Deliverable 1: executeRenderAssemble Implementation

**File:** `src/editor/runtime/executor/steps/executeRenderAssemble.ts`

#### Core Functionality
- [ ] executeRenderAssemble reads render tree from step.rootNodeIndex output slot (or derives from step.outSlot metadata)
- [ ] Render tree is written to step.outSlot (if not already there)
- [ ] Implementation acts as stable finalization boundary (no transforms, just boundary marker)

#### Error Handling
- [ ] Missing rootNodeIndex throws clear error: "StepRenderAssemble missing rootNodeIndex"
- [ ] Invalid slot reference throws clear error: "Invalid slot reference in StepRenderAssemble: {slot}"
- [ ] Missing render tree value handled gracefully (error or default)

#### Validation (Optional)
- [ ] Optional: Render tree structure sanity checks (non-null, expected type)
- [ ] Optional: Log warning if render tree is null/undefined

#### Integration
- [ ] ScheduleExecutor.executeStep() dispatches to executeRenderAssemble correctly (no changes needed - already wired)
- [ ] executeFrame() integration test: render assembly step executes in correct position (after all other steps)

#### Testing
- [ ] Unit tests: 8-10 tests covering:
  - Slot read from rootNodeIndex output
  - Slot write to step.outSlot
  - Validation (if implemented)
  - Error cases (missing rootNodeIndex, invalid slot)
  - Integration with ScheduleExecutor
- [ ] All existing 1795 tests still pass
- [ ] No new TypeScript errors

---

### Deliverable 2: Hot-swap State Preservation

#### 2A: StateSwap Module

**File:** `src/editor/runtime/executor/StateSwap.ts` (NEW)

##### Core Algorithm
- [ ] `preserveState(oldRuntime, newRuntime, oldProgram, newProgram)` function implemented
- [ ] buildStableKeyMap(stateLayout): Map<stableKey, CellMetadata> helper function
  - [ ] Extracts stable keys from StateLayout IR
  - [ ] Returns map of stableKey → {stateId, layoutHash, cellOffset, cellSize}
- [ ] copyStateCells(oldBuffer, newBuffer, oldCell, newCell) helper function
  - [ ] Copies typed array cells from old to new buffer
  - [ ] Handles different cell types (f64, f32, i32, u32)
- [ ] initializeStateCell(buffer, cell, constPool) helper function
  - [ ] Initializes new state cells with defaults from const pool
  - [ ] Falls back to zero if no default available

##### State Preservation Contract
- [ ] For matching (stableKey, layoutHash): state cells copied from old to new
- [ ] For new keys (in new but not old): cells initialized with defaults
- [ ] For removed keys (in old but not new): cells dropped (no action, no error)
- [ ] Layout hash mismatch: cell treated as new (re-initialized, not copied)

##### StableKey Structure
- [ ] StableKey includes: blockId, portId, statefulRole, optional userName
- [ ] StableKey serialized as string for Map key (e.g., JSON.stringify or custom format)
- [ ] StableKey uniquely identifies state cell across program versions

##### Error Handling
- [ ] Invalid StateLayout (missing fields) throws clear error
- [ ] Buffer size mismatch (cell offset exceeds buffer length) throws clear error
- [ ] Missing const pool entry logs warning and uses zero default

##### Testing
- [ ] Unit tests: 10-15 tests covering:
  - Matching keys preserved (copy old to new)
  - New keys initialized with defaults
  - Removed keys dropped (no error)
  - Layout hash mismatch (re-initialized)
  - Error cases (invalid layout, buffer overflow)
  - Different state cell types (scalar, ring buffer)

---

#### 2B: RuntimeState.hotSwap() Method

**File:** `src/editor/runtime/executor/RuntimeState.ts` (UPDATE)

##### Core Functionality
- [ ] `hotSwap(newProgram): RuntimeState` method added to RuntimeState
- [ ] Creates newRuntime from newProgram (call createRuntimeState)
- [ ] Calls StateSwap.preserveState(this, newRuntime, oldProgram, newProgram)
- [ ] Invalidates FrameCache: newRuntime.frameCache.invalidate()
- [ ] Preserves time continuity: copy tAbsMs from old to new (if tracked)
- [ ] Preserves frameId: copy from old to new (monotonic frame counter)
- [ ] Returns newRuntime (fully initialized with preserved state)

##### Time Continuity
- [ ] tAbsMs preserved across swap (not reset to 0)
- [ ] frameId preserved (or incremented, not reset)
- [ ] TimeModel continuity: new program's timeModel used for derivation (old tAbsMs applied)

##### Cache Policy
- [ ] Per-frame caches (FrameCache.sigStamp, FrameCache.fieldStamp) invalidated (zeros)
- [ ] Buffer pool (FrameCache.fieldBuffers) cleared
- [ ] frameId incremented (or preserved) to invalidate cached stamps

##### Program Reference
- [ ] RuntimeState may need to track oldProgram for StateSwap call
- [ ] OR: StateSwap derives metadata from program passed as parameter

##### Testing
- [ ] Unit tests: 8-12 tests covering:
  - State preservation (matching keys)
  - Time continuity (tAbsMs preserved)
  - Cache invalidation (FrameCache cleared)
  - FrameId continuity (not reset)
  - Program reference updated
  - Integration: swap → execute → verify state

---

#### 2C: ScheduleExecutor.swapProgram() Method

**File:** `src/editor/runtime/executor/ScheduleExecutor.ts` (UPDATE)

##### Core Functionality
- [ ] `swapProgram(newProgram): void` method added to ScheduleExecutor
- [ ] Calls this.runtime.hotSwap(newProgram) (or similar API)
- [ ] Updates internal this.program reference to newProgram
- [ ] Returns void (side-effect only)

##### Integration
- [ ] swapProgram() can be called between executeFrame() calls
- [ ] State preserved across swap: executeFrame(old) → swapProgram(new) → executeFrame(new) maintains state

##### Testing
- [ ] Unit tests: 3-5 tests covering:
  - Program reference updated
  - State continuity across executeFrame calls
  - Hot-swap mid-execution (swap between frames)

---

#### 2D: StableKey Verification (Research Task)

##### Verification Steps
- [ ] Search StateLayout IR types for stable key fields (stableKey, blockId, etc.)
- [ ] Check compiler passes for stable key generation
- [ ] Document location of stable key in IR

##### Outcomes
- [ ] IF stable keys exist: Document location, wire into StateSwap
- [ ] IF stable keys missing: Add stable key generation to compiler (estimated 60-80 lines)
- [ ] StableKey structure matches spec definition (§9.2): blockId, portId, statefulRole, userName

---

#### 2E: Overall Hot-swap Integration

##### End-to-End Tests
- [ ] Integration test: compile program → execute frame → swap program → execute frame → verify state preserved
- [ ] Integration test: stateful node (integrate) preserves accumulator across swap
- [ ] Integration test: new stateful node initialized with defaults
- [ ] Integration test: removed stateful node dropped without error
- [ ] Integration test: time continuity (tAbsMs preserved across swap)

##### Test Coverage
- [ ] 18-27 total new tests for hot-swap (StateSwap + RuntimeState + ScheduleExecutor + integration)
- [ ] All existing 1795 tests still pass
- [ ] No new TypeScript errors

---

### Deliverable 3 (CONDITIONAL): executeNodeEval Implementation

**CRITICAL: This deliverable is CONDITIONAL on verification.**

#### Verification Requirement (MUST COMPLETE FIRST)
- [ ] **VERIFICATION COMPLETE:** Searched compiled IR test fixtures for `kind: "nodeEval"` in schedule.steps
- [ ] **VERIFICATION COMPLETE:** Searched compiler passes for StepNodeEval emission
- [ ] **DECISION DOCUMENTED:** Compiler DOES emit NodeEval steps (evidence: {file/line}) → IMPLEMENT
  - OR: Compiler does NOT emit NodeEval steps → DEPRECATE (skip implementation, document in code)

**IF VERIFICATION SHOWS NODEEVAL IS NOT NEEDED:**
- [ ] Mark executeNodeEval.ts as DEPRECATED in code comments
- [ ] Document: "StepNodeEval not emitted by current compiler - high-level steps (BusEval, Materialize) used instead"
- [ ] No implementation work required
- [ ] Sprint 3 complete with 2 deliverables

**IF VERIFICATION SHOWS NODEEVAL IS NEEDED:**

**File:** `src/editor/runtime/executor/steps/executeNodeEval.ts` (UPDATE)

#### Core Functionality
- [ ] executeNodeEval dispatches to SigEvaluator.evalSig() for signal nodes
- [ ] executeNodeEval dispatches to FieldMaterializer for field nodes (if applicable)
- [ ] inputSlots mapped to evaluator inputs (read from ValueStore)
- [ ] Evaluator outputs mapped to outputSlots (write to ValueStore)

#### Opcode Dispatch
- [ ] Dispatch based on node kind (read from program.nodes[step.nodeIndex])
- [ ] Signal nodes: create SigEnv, call evalSig(nodeId, env, program.signalExprs)
- [ ] Field nodes (if applicable): call FieldMaterializer or mark as unsupported

#### State Integration
- [ ] stateReads wired to StateBuffer (if step.stateReads defined)
- [ ] stateWrites wired to StateBuffer (if step.stateWrites defined)
- [ ] State cells read before evaluation, written after

#### Error Handling
- [ ] Unknown node kind throws clear error: "Unknown node kind in StepNodeEval: {kind}"
- [ ] Missing input slots throws clear error
- [ ] Invalid nodeIndex throws clear error

#### Testing
- [ ] Unit tests: 25-30 tests covering:
  - Signal node dispatch (all major opcodes)
  - Input slot read, output slot write
  - State reads/writes (if applicable)
  - Error cases (unknown kind, missing inputs)
  - Integration with ScheduleExecutor

---

## Overall Sprint Success Criteria

### Test Coverage
- [ ] **50+ new tests minimum** (8-10 render + 18-27 hot-swap)
- [ ] **75+ new tests if NodeEval implemented** (50 + 25-30 NodeEval)
- [ ] All existing 1795 tests pass
- [ ] No new TypeScript errors

### Code Quality
- [ ] All new functions have JSDoc comments
- [ ] Error messages are clear and actionable
- [ ] Follows existing code style (see executeBusEval.ts for reference)
- [ ] No console.log statements (use proper error handling)

### Functional Completeness
- [ ] executeRenderAssemble acts as stable finalization boundary (per spec §12.2 Step 5)
- [ ] Hot-swap preserves state across program recompilation (per spec §9)
- [ ] Time continuity maintained: tAbsMs not reset (per spec §22.1)
- [ ] Cache invalidation works correctly: FrameCache cleared on swap (per spec §9.3)
- [ ] executeNodeEval implemented OR deprecated (based on verification)

### Documentation
- [ ] Hot-swap algorithm documented in StateSwap.ts (JSDoc with spec references)
- [ ] StableKey structure documented (from spec §9.2)
- [ ] All public APIs have JSDoc comments with @param, @returns, @throws
- [ ] Code comments explain non-obvious logic (especially stable key matching)

### Integration
- [ ] ScheduleExecutor.executeFrame() works with executeRenderAssemble
- [ ] ScheduleExecutor.swapProgram() performs jank-free program replacement
- [ ] End-to-end test: compile → execute → swap → execute → verify state
- [ ] No visual jank (state continuity verified in tests)

---

## Sprint Completion Checklist

- [ ] Deliverable 1 COMPLETE: executeRenderAssemble (8-10 tests)
- [ ] Deliverable 2 COMPLETE: Hot-swap State Preservation (18-27 tests)
- [ ] Deliverable 3 DECISION: NodeEval verified → implemented OR deprecated
- [ ] Test suite: 50+ new tests passing (or 75+ if NodeEval implemented)
- [ ] All existing 1795 tests passing
- [ ] Zero new TypeScript errors
- [ ] Code review: follows style guide, JSDoc complete
- [ ] Integration tests: end-to-end hot-swap verified
- [ ] Documentation: hot-swap API documented

---

## Notes

**Non-negotiable Requirements (from spec):**
1. executeRenderAssemble must exist as stable finalization boundary (spec §12.2 Step 5)
2. Hot-swap must preserve state and time continuity (spec §9, §22)
3. Cache invalidation must work correctly (spec §9.3)

**Conditional Requirement:**
- executeNodeEval implementation depends on compiler verification

**Deferred to Phase 7:**
- executeDebugProbe implementation
- Trace event emission in executeRenderAssemble

**Post-Sprint 3:**
- Legacy runtime removal
- Performance validation (hot-swap should be <16ms for 60fps)
