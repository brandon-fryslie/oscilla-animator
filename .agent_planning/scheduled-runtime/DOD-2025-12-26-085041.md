# Definition of Done: Phase 6 Sprint 1 - ValueStore + StateBuffer Foundation
Generated: 2025-12-26-085041
Plan: PLAN-2025-12-26-085041.md

## Acceptance Criteria

### ValueStore Implementation

#### Allocation
- [ ] `createValueStore(slotMeta)` allocates typed arrays with correct sizes
  - f64 array size = max(offset+1) for slots with storage="f64"
  - f32 array size = max(offset+1) for slots with storage="f32"
  - i32 array size = max(offset+1) for slots with storage="i32"
  - u32 array size = max(offset+1) for slots with storage="u32"
  - objects array size = max(offset+1) for slots with storage="object"

#### Write Operations
- [ ] `write(slot, value)` stores value at correct (array, offset) per slotMeta[slot]
  - Numeric values go to correct typed array at correct offset
  - Non-numeric values (FieldHandles, buffers, etc.) go to objects array
- [ ] `write(slot, value)` enforces single-writer: throws error if slot written twice in same frame
  - Error message includes slot index for debugging
  - Write tracking resets on `clear()`

#### Read Operations
- [ ] `read(slot)` retrieves value from correct (array, offset) per slotMeta[slot]
  - Returns correct value type (number for typed arrays, object for object array)

#### Frame Management
- [ ] `clear()` resets write tracking for new frame
  - Write tracking set emptied
  - Values in arrays NOT cleared (optimization: old values overwritten on next write)

#### Testing
- [ ] Unit tests (20+):
  - Allocation from various slotMeta configurations
  - Write to each storage type (f64, f32, i32, u32, object)
  - Read after write returns correct value
  - Single-writer enforcement catches duplicate writes
  - Clear resets write tracking
  - Empty slotMeta (no slots) works without error

---

### StateBuffer Implementation

#### Allocation
- [ ] `createStateBuffer(layout)` allocates typed arrays with sizes from layout
  - buffer.f64 is Float64Array(layout.f64Size)
  - buffer.f32 is Float32Array(layout.f32Size)
  - buffer.i32 is Int32Array(layout.i32Size)
  - Zero-length arrays if size is 0 (no state of that type)

#### Initialization
- [ ] `initializeState(buffer, layout, constPool)` sets initial values for all state cells
  - If `cell.initialConstId` is defined: read value from constPool, write to buffer[cell.storage][cell.offset..offset+size]
  - If `cell.initialConstId` is undefined: write zeros (default)
  - Handles scalar cells (size=1) and array cells (size>1, e.g., ring buffers)

#### Storage Routing
- [ ] Correct storage type routing:
  - f64 cells write to buffer.f64
  - f32 cells write to buffer.f32
  - i32 cells write to buffer.i32

#### Testing
- [ ] Unit tests (10+):
  - Allocation with various layout sizes (f64Size, f32Size, i32Size)
  - Allocation with zero sizes (empty state)
  - Initialization with const pool values
  - Initialization without initialConstId (defaults to zero)
  - Ring buffer initialization (size > 1)
  - Mixed storage types in single layout

---

### RuntimeState Integration

#### Factory Function
- [ ] `createRuntimeState(program)` calls `createValueStore()` with extracted slotMeta
  - If compiler doesn't emit slotMeta yet: use placeholder extraction (empty array or minimal test data)
- [ ] `createRuntimeState(program)` calls `createStateBuffer(program.stateLayout)`
  - StateLayout already exists in CompiledProgramIR schema
- [ ] `createRuntimeState(program)` calls `initializeState(state, stateLayout, program.constants)`

#### Regression Testing
- [ ] Existing ScheduleExecutor tests pass with real stores (no behavioral change, just swapping implementation)

#### Integration Testing
- [ ] Unit tests (5+):
  - RuntimeState creation with minimal program (empty stateLayout, empty slotMeta)
  - RuntimeState creation with non-trivial program (multiple state cells, multiple slots)
  - State initialization from program const pool

---

## Sprint Scope

### This Sprint Delivers:
1. ValueStore implementation with typed array allocation and single-writer enforcement
2. StateBuffer implementation with state cell allocation and initialization
3. RuntimeState integration using real stores instead of stubs

### Deferred to Future Sprints:
- FrameCache system (Sprint 2)
- NodeEval/BusEval step executors (Sprint 2)
- Materialize/RenderAssemble step executors (Sprint 2-3)
- Hot-swap semantics (Sprint 3)
- Determinism enforcement (Sprint 4)
- Legacy runtime removal (Sprint 4)

---

## Test Coverage Requirements

**Minimum Tests:** 35 new tests
- ValueStore: 20+ tests
- StateBuffer: 10+ tests
- RuntimeState: 5+ tests

**All Existing Tests Must Pass:** 1660+ tests (no regressions)

---

## Code Quality Requirements

- [ ] All new code has inline documentation
- [ ] Type safety: no `any` types (use `unknown` with guards)
- [ ] Error messages are clear and include context (slot indices, storage types)
- [ ] No performance regressions in existing tests
- [ ] Follow existing code style (prettier, eslint)

---

## Completion Checklist

- [ ] All acceptance criteria above are checked
- [ ] 35+ new tests added and passing
- [ ] All existing 1660+ tests still pass
- [ ] ScheduleExecutor runs with real ValueStore and StateBuffer (verified by tests)
- [ ] Code reviewed (self-review minimum, pair review if available)
- [ ] No TODOs or FIXMEs in production code (tests can have TODOs for future improvements)

**Sprint 1 is DONE when all boxes above are checked.**
