# Debugger Initiative Status
**Timestamp**: 2025-12-26T20:15:00
**Scope**: initiative/debugger
**Confidence**: FRESH

## Executive Summary

**Overall Completion**: ~20%
**Critical Gap**: No runtime-to-UI data flow for port/bus values
**User Immediate Need**: "See actual values being sent across ports at 3-4fps"

The debugger has substantial type infrastructure and ring buffer primitives, but NO WORKING END-TO-END FLOW for showing live values. The core gap is between runtime evaluation and UI display.

---

## What Exists (with file:line references)

### 1. ValueSummary Types [COMPLETE]
**File**: `src/editor/debug/types.ts:22-31`
```typescript
export type ValueSummary =
  | { t: 'num'; v: number }
  | { t: 'phase'; v: number }
  | { t: 'bool'; v: boolean }
  | { t: 'color'; v: number }
  | { t: 'vec2'; x: number; y: number }
  | { t: 'trigger'; fired: boolean }
  | { t: 'none' }
  | { t: 'err'; code: 'nan' | 'inf' | 'unknown' };
```

**Also exists**:
- `summarize()` function (lines 35-98)
- `formatValueSummary()` (lines 103-126)
- `getNumericValue()` (lines 132-144)

### 2. Probe Types [COMPLETE]
**File**: `src/editor/debug/types.ts:150-208`
- `ProbeTarget` union type (block, bus, binding)
- `Sample` interface (timestamp, tMs, value)
- `Probe` interface (id, target, history, etc.)
- `createProbeId()` helper

### 3. DebugLevel Type [COMPLETE]
**File**: `src/editor/debug/types.ts:217`
```typescript
export type DebugLevel = 'off' | 'basic' | 'trace' | 'full';
```

### 4. Ring Buffer Infrastructure [COMPLETE]
**Directory**: `src/editor/debug/`

| File | Purpose | Status |
|------|---------|--------|
| `RingBuffer.ts` | Generic ring buffer | COMPLETE |
| `ValueRing.ts` | Zero-alloc typed array ring (32B records) | COMPLETE |
| `SpanRing.ts` | Zero-alloc span ring (64B records) | COMPLETE |
| `DebugIndex.ts` | String interning for IDs | COMPLETE |
| `TypeKeyEncoding.ts` | TypeDesc -> u16 compact encoding | COMPLETE |
| `ValueRecord.ts` | ValueRecord32 structure | COMPLETE |
| `SpanTypes.ts` | SpanId, SpanKind definitions | COMPLETE |
| `TraceController.ts` | Mode control (off/timing/full) | COMPLETE |
| `TraceContext.ts` | Context for instrumentation | EXISTS |
| `instrumentClosure.ts` | Closure wrapping for tracing | EXISTS |

### 5. DebugStore [PARTIALLY COMPLETE]
**File**: `src/editor/stores/DebugStore.ts`

**What works**:
- Probe management (addProbe, removeProbe, toggleBlockProbe)
- Console/REPL interface with commands (help, blocks, buses, etc.)
- Sample history in bounded arrays (line 244-248)
- Command execution (executeCommand)
- Legacy API compatibility (setEntry, etc.)

**What's missing**:
- NOT connected to actual runtime values
- Probes receive values only through legacy `setEntry()` path
- No bus value sampling
- No binding value sampling

### 6. RuntimeHealthSnapshot [BASIC]
**File**: `src/editor/runtime/player.ts:424-457`

Player emits `RuntimeHealthSnapshot` event at 4Hz with:
- FPS estimate, avgFrameMs, worstFrameMs
- nanCount, infCount (basic health)
- fieldMaterializations: always 0 (NOT TRACKED)

### 7. DiagnosticHub [PARTIAL]
**File**: `src/editor/diagnostics/DiagnosticHub.ts`

- Processes RuntimeHealthSnapshot events (line 142)
- Creates diagnostics for NaN/Inf/frame budget
- Snapshot semantics with patchRevision
- Runtime diagnostics with expiry (5 seconds)

### 8. debugSampler [LEGACY - PARTIALLY WORKING]
**File**: `src/editor/compiler/debugSampler.ts`

This is the OLD approach:
- Wraps program to sample block outputs
- Throttled to 333ms (~3fps)
- Only samples Signal:number and Signal:phase
- Uses legacy `debugStore.setEntry()` API

**Problem**: Only works for block output sampling, NOT for bus/binding values

### 9. executeDebugProbe Step [STUB ONLY]
**File**: `src/editor/runtime/executor/steps/executeDebugProbe.ts`
```typescript
export function executeDebugProbe(_step: StepDebugProbe, _runtime: RuntimeState): void {
  // Stub: No-op - debug probes disabled in Sprint 1
}
```

---

## What's Missing (from design spec)

### Critical Path (Required for MVP)

| Component | Design Doc Ref | Status | Priority |
|-----------|----------------|--------|----------|
| **DebugGraph** | 2-NonTech-Arch.md | NOT STARTED | P0 |
| **DebugSnapshot at 10-15Hz** | 3-NonTech-LowLevel.md | NOT STARTED | P0 |
| **DebugTap interface** | 3-NonTech-LowLevel.md | NOT STARTED | P0 |
| **DebugRecorder** | 3-NonTech-LowLevel.md | NOT STARTED | P0 |
| **DebugService** | 3-NonTech-LowLevel.md | NOT STARTED | P1 |
| **BusRuntime instrumentation** | 3-NonTech-LowLevel.md | NOT STARTED | P0 |

### Secondary (Required for Full Debugger)

| Component | Design Doc Ref | Status |
|-----------|----------------|--------|
| Probe Mode UI | 4-NonTech-UI-Spec.md | NOT STARTED |
| Probe Cards | 4-NonTech-UI-Spec.md | NOT STARTED |
| Trace View | 4-NonTech-UI-Spec.md | NOT STARTED |
| Diagnostics Rules Engine | 5-NonTech-RulesEngine.md | NOT STARTED |
| Fix Actions | 4-NonTech-UI-Spec.md | NOT STARTED |
| Bus meters in BusBoard | 6-NonTech-MainUI.md | NOT STARTED |
| Block activity halo | 6-NonTech-MainUI.md | NOT STARTED |
| Health bar | 6-NonTech-MainUI.md | NOT STARTED |

---

## Dependency Graph for MVP

```
                    DebugGraph
                         |
                         v
    DebugTap <----- Compiler Integration
         |
         v
    BusRuntime ----> recordBusNow() --> DebugRecorder
         |                                    |
         v                                    v
    recordBindingNow()              DebugSnapshot (10-15Hz)
                                              |
                                              v
                                    DebugService.pushSnapshot()
                                              |
                                              v
                                         DebugStore
                                              |
                                              v
                                    UI Components (meters, probes)
```

### Critical Path Steps (in order):

1. **DebugTap Interface**: Define the hook interface for compiler/runtime
2. **DebugGraph Generation**: Compiler emits static graph structure
3. **BusRuntime Instrumentation**: Add `recordBusNow()` calls at bus evaluation points
4. **DebugRecorder**: Collect samples into ring buffers at sample rate
5. **DebugSnapshot Emission**: Emit snapshots at 10-15Hz (not per-frame)
6. **DebugService API**: Central query API for UI
7. **Wire to DebugStore**: Feed samples to existing probe infrastructure
8. **Basic UI**: Show meters in BusBoard rows

---

## User's Immediate Need: Port Value Display

The user wants to **see actual values being sent across ports at 3-4fps**.

### Minimum Implementation Path:

1. **Extend RuntimeHealthSnapshot** to include bus values
   - Add `busValues: Record<BusId, ValueSummary>` to existing event
   - Sample at existing 4Hz rate

2. **Create BusValueSampler** in runtime
   - After bus evaluation, summarize all bus values
   - Include in next health snapshot

3. **Display in BusBoard UI**
   - Add mini-meter component to each bus row
   - Subscribe to RuntimeHealthSnapshot events
   - Update meters from `busValues` payload

This is NOT the full DebugGraph architecture, but achieves the immediate goal.

---

## Risks and Ambiguities

### Architectural Ambiguities

1. **Where is "bus evaluation"?**
   - Design docs assume a `BusRuntime` layer that evaluates all buses
   - Current architecture: buses are evaluated lazily during block compilation
   - **Need clarification**: Should we add a BusRuntime, or tap into existing evaluation?

2. **IR vs Legacy Compiler Path**
   - New IR path: uses ScheduleExecutor with step-based execution
   - Legacy path: uses debugSampler wrapping
   - **Question**: Which path should debugger target first?

3. **Snapshot vs Probe Model**
   - Design docs: DebugSnapshot emitted at 10-15Hz globally
   - Current debugSampler: per-block probes with individual sampling
   - **Conflict**: Should probes be per-target or global snapshot-based?

### Implementation Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| Performance overhead at 10-15Hz | Could affect animation smoothness | Start with 4Hz (existing rate), tune later |
| Memory from ring buffers | Could grow large with many buses | Bounded by design (fixed capacity) |
| Object allocation in hot path | GC pressure during animation | TypedArray ring buffers already exist |
| UI update frequency | React re-renders at sample rate | Use MobX computed with throttle |

### Design Doc vs Reality Gaps

1. **DebugGraph.byPort lookup**: Requires compiler to emit port->binding mappings
   - Current compiler does NOT emit this
   - Would need significant compiler changes

2. **DebugPipeline per binding**: Requires adapter/lens chain materialization
   - Design assumes chains are precomputed
   - Current: resolved lazily during evaluation

3. **Fix Actions**: Require undoable transactions
   - Current store has limited transaction support
   - Would need TransactionBuilder integration

---

## Test Infrastructure Assessment

### Existing Debug Tests

| File | Coverage |
|------|----------|
| `debug/__tests__/DebugIndex.test.ts` | String interning |
| `debug/__tests__/SpanRing.test.ts` | Span ring buffer |
| `debug/__tests__/ValueRing.test.ts` | Value ring buffer |
| `debug/__tests__/TypeKeyEncoding.test.ts` | Type encoding |
| `debug/__tests__/instrumentClosure.test.ts` | Closure wrapping |
| `debug/__tests__/TraceController.test.ts` | Mode control |

**Missing Tests**:
- No tests for DebugStore probe management
- No tests for end-to-end value flow
- No tests for RuntimeHealthSnapshot integration

---

## Recommendations

### For MVP (User's Immediate Need)

**Approach: Extend existing RuntimeHealthSnapshot**

1. Add `busValues: Record<string, ValueSummary>` to RuntimeHealthSnapshot
2. In Player.emitHealthSnapshot(), sample all bus current values
3. Add simple meter UI to BusBoard rows
4. Subscribe to events and update meters

**Estimated complexity**: Medium (2-3 days)
**Reuses**: Existing event system, ValueSummary, formatValueSummary

### For Full Debugger

**Approach: Implement DebugGraph + DebugTap architecture**

1. Create DebugTap interface (Sprint 1.1 from PreworkPlan)
2. Extend compiler to emit DebugGraph (Sprint 2)
3. Implement DebugRecorder with existing ring buffers
4. Create DebugService facade
5. Build Probe Mode UI

**Estimated complexity**: High (2-3 weeks)
**Blockers**: Need to understand current bus evaluation flow

### Questions for User

1. **Priority**: Quick MVP (bus meters) or full DebugGraph architecture?
2. **Scope**: Port values only, or also binding values (post-adapter/lens)?
3. **IR Path**: Should this work with new IR runtime or legacy path?

---

## Workflow Recommendation

- [x] CONTINUE - MVP path is clear, can proceed with bus value sampling
- [ ] PAUSE - If full DebugGraph architecture is required, need architecture decisions

**Next Steps**:
1. Confirm MVP approach with user
2. Implement bus value sampling in RuntimeHealthSnapshot
3. Add meters to BusBoard UI
4. Document learnings for full debugger implementation
