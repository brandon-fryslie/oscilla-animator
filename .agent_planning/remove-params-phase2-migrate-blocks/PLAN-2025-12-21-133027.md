# Phase 2: Migrate All Blocks from paramSchema to Input Slots

**Generated**: 2025-12-21 13:30:27
**Source STATUS**: `.agent_planning/ui-refactor-prep/STATUS-2025-12-21.md`
**Design Doc**: `design-docs/10-Refactor-for-UI-prep/14-RemoveParams.md`
**Phase**: 2 of 3 (Block Migration)

---

## Executive Summary

This plan details the migration of **28 blocks** with **79 total parameters** from the legacy `paramSchema` system to proper input slots with default sources. This is Phase 2 of the "Remove Parameters" refactor, following Phase 1 (Slot interface extension) and preceding Phase 3 (Compiler and UI updates).

**Scope**: Convert all `paramSchema` entries across 5 files into input slots with default source metadata.

**Complexity**: MEDIUM (7-10 days)
- 28 blocks to migrate
- 79 parameters to classify and convert
- Backward compatibility with saved patches required
- Test suite must remain green throughout

---

## Current State Analysis

### Files With paramSchema

| File | Blocks | Total Params | Avg Params/Block |
|------|--------|--------------|------------------|
| `domain.ts` | 15 | 48 | 3.2 |
| `signal.ts` | 5 | 14 | 2.8 |
| `time-root.ts` | 3 | 4 | 1.3 |
| `field-primitives.ts` | 2 | 6 | 3.0 |
| `rhythm.ts` | 2 | 4 | 2.0 |
| `factory.ts` | 1 | 3 | 3.0 |
| **TOTAL** | **28** | **79** | **2.8** |

### Parameter Type Distribution

| Type | Count | % | Examples |
|------|-------|---|----------|
| `number` | 57 | 72% | amplitude, spacing, radius |
| `select` | 14 | 18% | shape, mode, fn |
| `color` | 6 | 8% | base, colorA, colorB |
| `boolean` | 1 | 1% | glow |
| `string` | 1 | 1% | asset |

---

## Parameter Classification Framework

### World Assignment

**Signal Parameters** (continuous modulation makes sense):
- Amplitude, bias, radius, spacing, offset
- Opacity, intensity, amount
- Position coordinates (originX, centerX, etc.)
- Timing values (duration, period, attack, decay)

**Config Parameters** (enum/mode selection, triggers hot-swap):
- Shape, mode, function selection (select types)
- Distribution, winding, order
- Boolean flags (glow)

**Scalar Parameters** (compile-time constants):
- Seed values (deterministic randomness)
- Count values (n, rows, cols, sampleCount, divisions)
- Asset paths (string)

### Tier Assignment

**Primary** (commonly tweaked, show on block face):
- First 1-2 params of each block
- Core behavior controls (shape, amplitude, radius)
- Spatial fundamentals (centerX/Y for layouts)

**Secondary** (tucked under "More"):
- Fine-tuning params (bias, offset, glowIntensity)
- Advanced options (distribution, order, winding)
- Uncommon adjustments (attack/decay for envelopes)

---

## Block-by-Block Migration Strategy

### Category 1: Signal Processors (5 blocks, 14 params)

#### 1.1 Oscillator (3 params)
```typescript
// BEFORE
paramSchema: [
  { key: 'shape', type: 'select', options: [...], defaultValue: 'sine' },
  { key: 'amplitude', type: 'number', min: 0, max: 10, defaultValue: 1 },
  { key: 'bias', type: 'number', min: -10, max: 10, defaultValue: 0 },
]

// AFTER
inputs: [
  input('phase', 'Phase', 'Signal<phase>'),
  input('shape', 'Waveform', 'Config<enum>', {
    tier: 'primary',
    defaultSource: { type: 'const', value: 'sine' },
    uiHint: { type: 'dropdown', options: ['sine', 'cosine', 'triangle', 'saw'] }
  }),
  input('amplitude', 'Amplitude', 'Signal<number>', {
    tier: 'primary',
    defaultSource: { type: 'const', value: 1.0 },
    uiHint: { type: 'slider', min: 0, max: 10, step: 0.1 }
  }),
  input('bias', 'Bias', 'Signal<number>', {
    tier: 'secondary',
    defaultSource: { type: 'const', value: 0.0 },
    uiHint: { type: 'slider', min: -10, max: 10, step: 0.1 }
  }),
],
```

**Classification**:
- `shape`: Config (enum selection, triggers recompile)
- `amplitude`: Signal (continuous modulation sensible)
- `bias`: Signal (continuous modulation sensible)

**Migration Notes**:
- `shape` becomes Config input (not Signal)
- Changing shape triggers hot-swap (crossfade)
- Amplitude/bias can be animated via bus or wire

---

#### 1.2 Shaper (2 params)
**Classification**:
- `kind`: Config (enum, triggers recompile)
- `amount`: Signal (continuous modulation)

**Tiers**: Both primary (only 2 params)

---

#### 1.3 ColorLFO (4 params)
**Classification**:
- `base`: Signal (color modulation via ColorBus)
- `hueSpan`: Signal (continuous)
- `sat`: Signal (continuous)
- `light`: Signal (continuous)

**Tiers**:
- Primary: base, hueSpan
- Secondary: sat, light

---

#### 1.4 ClampSignal (2 params)
**Classification**:
- `min`: Signal (dynamic clamping)
- `max`: Signal (dynamic clamping)

**Tiers**: Both primary

---

#### 1.5 PhaseClockLegacy (3 params) - DEPRECATED
**Classification**:
- `duration`: Signal (but this block is deprecated)
- `mode`: Config (enum)
- `offset`: Signal

**Migration Notes**:
- Keep as-is for backward compat
- Do not promote usage
- Eventually remove when all patches use TimeRoot

---

### Category 2: Domain Sources (15 blocks, 48 params)

#### 2.1 DomainN (2 params)
**Classification**:
- `n`: Scalar (element count, compile-time)
- `seed`: Scalar (deterministic IDs)

**Tiers**: Both primary (fundamental controls)

**Migration Notes**:
- `n` could become Signal input to allow dynamic population (future)
- For now: Scalar (changing triggers full domain rebuild)

---

#### 2.2 GridDomain (5 params)
**Classification**:
- `rows`: Scalar (compile-time grid structure)
- `cols`: Scalar (compile-time grid structure)
- `spacing`: Signal (animated grid breathing)
- `originX`: Signal (pan animation)
- `originY`: Signal (pan animation)

**Tiers**:
- Primary: rows, cols, spacing
- Secondary: originX, originY

---

#### 2.3 SVGSampleDomain (4 params)
**Classification**:
- `asset`: Scalar (path to SVG)
- `sampleCount`: Scalar (compile-time)
- `seed`: Scalar (deterministic)
- `distribution`: Config (sampling algorithm)

**Tiers**: All primary (all fundamental)

---

#### 2.4 StableIdHash (1 param)
**Classification**:
- `salt`: Scalar (deterministic hash variation)

**Tiers**: Primary

---

#### 2.5 PositionMapGrid (6 params)
**Classification**:
- `rows`: Scalar (structure)
- `cols`: Scalar (structure)
- `spacing`: Signal (animated)
- `originX`: Signal (animated)
- `originY`: Signal (animated)
- `order`: Config (layout algorithm)

**Tiers**:
- Primary: rows, cols, spacing
- Secondary: originX, originY, order

---

#### 2.6 PositionMapCircle (6 params)
**Classification**:
- `centerX`: Signal (animated center)
- `centerY`: Signal (animated center)
- `radius`: Signal (animated radius)
- `startAngle`: Signal (animated rotation)
- `winding`: Config (direction, enum)
- `distribution`: Config (algorithm, enum)

**Tiers**:
- Primary: centerX, centerY, radius
- Secondary: startAngle, winding, distribution

---

#### 2.7 PositionMapLine (5 params)
**Classification**:
- `ax`, `ay`, `bx`, `by`: Signal (animated endpoints)
- `distribution`: Config (algorithm)

**Tiers**:
- Primary: ax, ay, bx, by
- Secondary: distribution

---

#### 2.8 FieldConstNumber (1 param)
**Classification**:
- `value`: Signal (broadcast constant)

**Tiers**: Primary

**Migration Notes**:
- This block becomes less useful when everything is an input
- Could deprecate in favor of direct default sources

---

#### 2.9 FieldConstColor (1 param)
**Classification**:
- `color`: Signal (broadcast color)

**Tiers**: Primary

---

#### 2.10 FieldHash01ById (1 param)
**Classification**:
- `seed`: Scalar (deterministic)

**Tiers**: Primary

---

#### 2.11 FieldMapNumber (4 params)
**Classification**:
- `fn`: Config (function selection)
- `k`: Signal (function parameter)
- `a`: Signal (range min)
- `b`: Signal (range max)

**Tiers**:
- Primary: fn, k
- Secondary: a, b

---

#### 2.12 FieldMapVec2 (8 params - MOST COMPLEX)
**Classification**:
- `fn`: Config (transform type)
- `angle`: Signal (rotation)
- `scaleX`: Signal (scaling)
- `scaleY`: Signal (scaling)
- `offsetX`: Signal (translation)
- `offsetY`: Signal (translation)
- `centerX`: Signal (transform origin)
- `centerY`: Signal (transform origin)

**Tiers**:
- Primary: fn, angle, scaleX, scaleY
- Secondary: offsetX, offsetY, centerX, centerY

**Migration Notes**:
- Most params unused for most `fn` selections
- UI should show/hide based on selected function
- Consider splitting into RotateVec2, ScaleVec2, TranslateVec2 blocks (future)

---

#### 2.13 FieldZipNumber (1 param)
**Classification**:
- `op`: Config (operation selection)

**Tiers**: Primary

---

#### 2.14 JitterFieldVec2 (2 params)
**Classification**:
- `amount`: Signal (animated jitter intensity)
- `frequency`: Signal (animated jitter speed)

**Tiers**: Both primary

---

#### 2.15 FieldZipSignal (1 param)
**Classification**:
- `fn`: Config (operation selection)

**Tiers**: Primary

---

#### 2.16 RenderInstances2D (3 params)
**Classification**:
- `opacity`: Signal (animated transparency)
- `glow`: Config (boolean toggle, triggers shader change)
- `glowIntensity`: Signal (animated glow)

**Tiers**:
- Primary: opacity
- Secondary: glow, glowIntensity

**Migration Notes**:
- `glowIntensity` only relevant when `glow: true`
- UI should gray out intensity when glow disabled

---

### Category 3: Field Styling (2 blocks, 6 params)

#### 3.1 FieldColorize (3 params)
**Classification**:
- `colorA`: Signal (animated gradient start)
- `colorB`: Signal (animated gradient end)
- `mode`: Config (interpolation algorithm)

**Tiers**:
- Primary: colorA, colorB
- Secondary: mode

---

#### 3.2 FieldOpacity (3 params)
**Classification**:
- `min`: Signal (dynamic range)
- `max`: Signal (dynamic range)
- `curve`: Config (mapping function)

**Tiers**:
- Primary: min, max
- Secondary: curve

---

### Category 4: Rhythm & Events (2 blocks, 4 params)

#### 4.1 PulseDivider (1 param)
**Classification**:
- `divisions`: Scalar (beat subdivisions, structural)

**Tiers**: Primary

**Migration Notes**:
- Could become Signal for dynamic polyrhythms (future)
- For now: Scalar (changing triggers event recalculation)

---

#### 4.2 EnvelopeAD (3 params)
**Classification**:
- `attack`: Signal (animated envelope shape)
- `decay`: Signal (animated envelope shape)
- `peak`: Signal (animated peak level)

**Tiers**:
- Primary: attack, decay
- Secondary: peak

---

### Category 5: TimeRoot (3 blocks, 4 params)

#### 5.1 FiniteTimeRoot (1 param)
**Classification**:
- `durationMs`: Config (timeline length, triggers time model rebuild)

**Tiers**: Primary

**Migration Notes**:
- Changing duration = fundamental time topology change
- Triggers Player.applyTimeModel() hot-swap

---

#### 5.2 CycleTimeRoot (2 params)
**Classification**:
- `periodMs`: Config (cycle length, topology)
- `mode`: Config (loop vs pingpong)

**Tiers**: Both primary

**Migration Notes**:
- Period changes should snap to pulse boundary (per spec)
- Mode change triggers topology rebuild

---

#### 5.3 InfiniteTimeRoot (1 param)
**Classification**:
- `windowMs`: Config (preview window, UI-only)

**Tiers**: Primary

**Migration Notes**:
- Only affects UI scrubber range, not runtime

---

## Detailed Migration Examples

### Example A: Simple Numeric Signal Parameter

**Block**: `JitterFieldVec2`
**Parameter**: `amount`

```typescript
// BEFORE (Phase 1)
export const JitterFieldVec2 = createBlock({
  type: 'JitterFieldVec2',
  // ... other fields
  inputs: [
    input('idRand', 'Random', 'Field<number>'),
    input('phase', 'Phase', 'Signal<phase>'),
  ],
  paramSchema: [
    {
      key: 'amount',
      label: 'Amount',
      type: 'number',
      min: 0,
      max: 100,
      step: 1,
      defaultValue: 5,
    },
  ],
});

// AFTER (Phase 2)
export const JitterFieldVec2 = createBlock({
  type: 'JitterFieldVec2',
  // ... other fields
  inputs: [
    input('idRand', 'Random', 'Field<number>'),
    input('phase', 'Phase', 'Signal<phase>'),
    input('amount', 'Amount', 'Signal<number>', {
      tier: 'primary',
      defaultSource: {
        type: 'constant',
        world: 'signal',
        value: 5,
      },
      uiHint: {
        control: 'slider',
        min: 0,
        max: 100,
        step: 1,
      },
    }),
    input('frequency', 'Frequency', 'Signal<number>', {
      tier: 'primary',
      defaultSource: {
        type: 'constant',
        world: 'signal',
        value: 1,
      },
      uiHint: {
        control: 'slider',
        min: 0.1,
        max: 10,
        step: 0.1,
      },
    }),
  ],
  // Remove paramSchema entirely
});
```

**Key Changes**:
1. `amount` moves from `paramSchema` to `inputs`
2. Gains `defaultSource` metadata (constant signal producing 5)
3. Gains `uiHint` for inspector rendering
4. Gains `tier: 'primary'` for UI placement
5. Type is `Signal<number>` (not Config, allows animation)

---

### Example B: Config Enum Parameter

**Block**: `Oscillator`
**Parameter**: `shape`

```typescript
// AFTER (Phase 2)
input('shape', 'Waveform', 'Config<enum>', {
  tier: 'primary',
  defaultSource: {
    type: 'constant',
    world: 'config',
    value: 'sine',
  },
  uiHint: {
    control: 'dropdown',
    options: [
      { value: 'sine', label: 'Sine' },
      { value: 'cosine', label: 'Cosine' },
      { value: 'triangle', label: 'Triangle' },
      { value: 'saw', label: 'Sawtooth' },
    ],
  },
  hotSwapBehavior: 'crossfade', // Changing this triggers safe hot-swap
}),
```

**Key Differences from Signal**:
- World is `Config<enum>` not `Signal<T>`
- Changes trigger hot-swap path (not per-frame eval)
- Cannot be driven by buses (config is stepwise, not continuous)

---

### Example C: Color Parameter

**Block**: `ColorLFO`
**Parameter**: `base`

```typescript
input('base', 'Base Color', 'Signal<color>', {
  tier: 'primary',
  defaultSource: {
    type: 'constant',
    world: 'signal',
    value: '#3B82F6', // CSS hex string
  },
  uiHint: {
    control: 'colorPicker',
  },
  busEligible: true, // Can subscribe to 'palette' bus
}),
```

**Migration Notes**:
- Color is Signal, not Config (can animate via ColorBus)
- Default value stored as CSS hex string
- UI shows color picker when in default mode
- Collapses to bus chip when driven

---

### Example D: Complex Multi-Function Block

**Block**: `FieldMapVec2` (8 params, function-dependent)

```typescript
inputs: [
  input('vec', 'Input', 'Field<vec2>'),
  input('fn', 'Function', 'Config<enum>', {
    tier: 'primary',
    defaultSource: { type: 'constant', world: 'config', value: 'rotate' },
    uiHint: {
      control: 'dropdown',
      options: [
        { value: 'rotate', label: 'Rotate' },
        { value: 'scale', label: 'Scale' },
        { value: 'translate', label: 'Translate' },
        { value: 'reflect', label: 'Reflect' },
      ],
    },
  }),
  // Rotation params (only for fn='rotate')
  input('angle', 'Angle (deg)', 'Signal<number>', {
    tier: 'primary',
    defaultSource: { type: 'constant', world: 'signal', value: 0 },
    uiHint: { control: 'slider', min: -360, max: 360, step: 15 },
    visibleWhen: { input: 'fn', value: 'rotate' }, // Conditional visibility
  }),
  input('centerX', 'Center X', 'Signal<number>', {
    tier: 'secondary',
    defaultSource: { type: 'constant', world: 'signal', value: 400 },
    uiHint: { control: 'slider', min: 0, max: 1000, step: 10 },
    visibleWhen: { input: 'fn', value: 'rotate' },
  }),
  // ... (scale, translate params similar)
],
```

**Migration Notes**:
- Most complex case (8 params, context-dependent)
- Use `visibleWhen` to show/hide params based on `fn` selection
- Consider future refactor: split into separate blocks (RotateVec2, etc.)

---

## TypeScript Interface Extensions

### Slot Interface (from Phase 1)

```typescript
export interface Slot {
  id: string;
  label: string;
  direction: 'input' | 'output';
  slotType: string;

  // NEW in Phase 1:
  tier?: 'primary' | 'secondary';
  defaultSource?: DefaultSource;
  uiHint?: UIHint;
  hotSwapBehavior?: 'crossfade' | 'freeze-fade' | 'instant';
  visibleWhen?: ConditionalVisibility;
  busEligible?: boolean;
}

export interface DefaultSource {
  type: 'constant' | 'expression' | 'blockRef';
  world: 'signal' | 'field' | 'scalar' | 'config';
  value?: unknown; // For type='constant'
  expr?: string;   // For type='expression'
  blockId?: string; // For type='blockRef'
}

export interface UIHint {
  control: 'slider' | 'dropdown' | 'colorPicker' | 'toggle' | 'textInput';
  min?: number;
  max?: number;
  step?: number;
  options?: Array<{ value: string | number; label: string }>;
}

export interface ConditionalVisibility {
  input: string; // Input ID to check
  value: unknown; // Value that makes this visible
}
```

---

## Backward Compatibility Strategy

### Patch File Migration

**Problem**: Existing patches store block params like:
```json
{
  "blockId": "block-123",
  "type": "Oscillator",
  "params": {
    "shape": "sine",
    "amplitude": 1.0,
    "bias": 0.0
  }
}
```

**Solution**: Migration in PatchStore.loadPatch()

```typescript
function migrateBlockParams(block: BlockInstance): BlockInstance {
  const def = getBlockDefinition(block.type);
  if (!def) return block;

  // If block has params but definition has no paramSchema, migrate
  if (block.params && Object.keys(block.params).length > 0 && def.paramSchema.length === 0) {
    // Create default source overrides for each param
    const inputOverrides = {};

    for (const [key, value] of Object.entries(block.params)) {
      const inputSlot = def.inputs.find(s => s.id === key);
      if (inputSlot && inputSlot.defaultSource) {
        inputOverrides[key] = {
          ...inputSlot.defaultSource,
          value, // Override with saved value
        };
      }
    }

    return {
      ...block,
      params: {}, // Clear old params
      inputOverrides, // New format
    };
  }

  return block;
}
```

**Serialization**: New format
```json
{
  "blockId": "block-123",
  "type": "Oscillator",
  "inputOverrides": {
    "shape": { "type": "constant", "world": "config", "value": "sine" },
    "amplitude": { "type": "constant", "world": "signal", "value": 1.0 }
  }
}
```

---

## Migration Sequence

### Step 1: Extend Slot Interface (DONE in Phase 1)
- Add `tier`, `defaultSource`, `uiHint` fields
- Update `input()` helper to accept metadata

### Step 2: Migrate Blocks (This Phase)

**2.1 Pilot Migration** (1 day)
- Migrate 1 simple block (JitterFieldVec2)
- Verify compiler still works
- Verify UI still renders
- Create migration template

**2.2 Batch Migration by Category** (4 days)
- Day 1: Signal processors (5 blocks)
- Day 2: Domain sources Part 1 (8 blocks)
- Day 3: Domain sources Part 2 (7 blocks)
- Day 4: Field styling, rhythm, TimeRoot (7 blocks)

**2.3 Remove paramSchema Infrastructure** (1 day)
- Delete `ParamSchema` type
- Remove `paramSchema` from `BlockDefinition`
- Remove `defaultParams` field
- Update factory.ts to error if paramSchema provided

**2.4 Test & Fix** (2 days)
- Run full test suite
- Fix any regressions
- Update tests that inspect paramSchema

### Step 3: Compiler Updates (Phase 3)
- Update block compilers to read from inputs
- Update hot-swap logic for Config inputs
- Remove param resolution code

### Step 4: UI Updates (Phase 3)
- Update Inspector to render input tiers
- Add default source inline controls
- Add "Drive..." button for bus/wire binding

---

## Testing Strategy

### Unit Tests

**Test 1: Default Source Materialization**
```typescript
test('JitterFieldVec2 uses default amount when no connection', () => {
  const block = createBlockInstance('JitterFieldVec2', { id: 'jit-1' });
  const program = compileBlock(block, context);

  // Should use amount=5 (default)
  const drift = program.field(seed, 10, ctx);
  expect(drift.length).toBe(10);
  // Verify drift magnitude matches amount=5
});
```

**Test 2: Config Input Triggers Hot-Swap**
```typescript
test('Oscillator shape change triggers hot-swap', () => {
  const patch = createPatch([
    { type: 'Oscillator', id: 'osc-1', inputOverrides: { shape: { value: 'sine' } } },
  ]);

  const compiled1 = compilePatch(patch);

  // Change shape
  patch.blocks[0].inputOverrides.shape.value = 'triangle';
  const compiled2 = compilePatch(patch);

  const changeType = classifyChange(compiled1, compiled2);
  expect(changeType).toBe('topology'); // Triggers hot-swap
});
```

**Test 3: Signal Input Allows Animation**
```typescript
test('Oscillator amplitude can be driven by bus', () => {
  const patch = createPatch([
    { type: 'CycleTimeRoot', id: 'time-1' },
    { type: 'Oscillator', id: 'osc-1' },
  ]);

  // Subscribe amplitude to energy bus
  patch.busListeners.push({
    busName: 'energy',
    targetBlockId: 'osc-1',
    targetSlotId: 'amplitude',
  });

  const program = compilePatch(patch);
  // Verify amplitude varies with energy bus value
});
```

### Integration Tests

**Test 4: Patch Migration**
```typescript
test('Legacy patch params migrate to inputOverrides', () => {
  const legacyPatch = {
    blocks: [
      { id: 'osc-1', type: 'Oscillator', params: { shape: 'triangle', amplitude: 2.5 } },
    ],
  };

  const migrated = loadPatch(legacyPatch);

  expect(migrated.blocks[0].params).toEqual({});
  expect(migrated.blocks[0].inputOverrides.shape.value).toBe('triangle');
  expect(migrated.blocks[0].inputOverrides.amplitude.value).toBe(2.5);
});
```

**Test 5: Backward Compat with Old Patches**
```typescript
test('Patches saved before migration still load', () => {
  const oldPatch = loadFixture('patches/breathing-grid-v1.json');

  expect(() => loadPatch(oldPatch)).not.toThrow();
  const program = compilePatch(oldPatch);
  expect(program).toBeDefined();
});
```

---

## Risk Assessment

### High Risk Areas

**Risk 1: Compiler Breakage**
- **Impact**: All patches fail to compile
- **Mitigation**: Migrate one block at a time, test after each
- **Rollback**: Git revert, phase is atomic

**Risk 2: Saved Patch Incompatibility**
- **Impact**: Users lose work
- **Mitigation**:
  - Implement migration in loadPatch() FIRST
  - Test with real patch files from fixtures/
  - Add version field to patch schema
- **Rollback**: Keep migration code even if implementation changes

**Risk 3: UI Rendering Errors**
- **Impact**: Inspector crashes or shows blank
- **Mitigation**: Inspector updates in Phase 3, not Phase 2
- **Current**: Inspector still reads paramSchema (no breakage yet)

### Medium Risk Areas

**Risk 4: Test Suite Failures**
- **Impact**: 738 tests → hundreds failing
- **Mitigation**:
  - Run tests after each block migration
  - Fix tests that inspect block structure
  - Use test-watch mode during migration

**Risk 5: Hot-Swap Behavior Changes**
- **Impact**: Config changes cause flicker instead of smooth swap
- **Mitigation**:
  - Document hot-swap behavior per input
  - Ensure change classifier respects Config world
  - Test with visual inspection (not just unit tests)

### Low Risk Areas

**Risk 6: Performance Regression**
- **Impact**: Compilation slower due to default source resolution
- **Likelihood**: Low (default sources are simple constants)
- **Mitigation**: Benchmark compile times before/after

---

## Definition of Done

### Phase 2 Complete When:

1. ✅ All 28 blocks migrated (paramSchema → inputs)
2. ✅ `ParamSchema` type removed from codebase
3. ✅ Test suite green (738+ tests passing)
4. ✅ Patch migration tested with real fixtures
5. ✅ Default source values match old param defaults exactly
6. ✅ No compiler errors or warnings
7. ✅ Git history clean (one commit per category)
8. ✅ Documentation updated:
   - Block definitions comments
   - Migration guide for future blocks
   - CHANGELOG entry

### Ready for Phase 3 When:

9. ✅ Compiler reads inputs instead of params (compileBusAware.ts)
10. ✅ Inspector renders input tiers (Inspector.tsx)
11. ✅ Default source inline controls work (UI components)
12. ✅ Bus/wire binding replaces defaults correctly

---

## Open Questions

### Q1: Should Scalar inputs allow Signal upgrade?
**Example**: `DomainN.n` (element count)

**Option A**: Strict Scalar (compile-time only)
- Changing `n` triggers full domain rebuild
- Cannot animate element count

**Option B**: Allow Signal upgrade
- `n` can be driven by Signal<number>
- Changing `n` per frame = rebuild per frame (expensive!)
- Useful for "breathing" domains (particle birth/death)

**Recommendation**: Start with Strict Scalar, allow upgrade in future if use case emerges.

---

### Q2: How to handle FieldMapVec2 param visibility?
**Problem**: 8 params, most irrelevant for selected function

**Option A**: Show all, gray out irrelevant
**Option B**: Hide irrelevant (visibleWhen)
**Option C**: Split into separate blocks (RotateVec2, ScaleVec2, etc.)

**Recommendation**: Option B for Phase 2, consider Option C for future refactor.

---

### Q3: Should FieldConstNumber/FieldConstColor be deprecated?
**Rationale**: With default sources, every input is a "const field" by default

**Recommendation**: Keep for now (backward compat), mark deprecated, remove in v2.0.

---

### Q4: Config inputs and buses - allow or forbid?
**Example**: Can `Oscillator.shape` subscribe to a "ShapeBus"?

**Option A**: Forbid (Config is local, not busable)
**Option B**: Allow (bus emits stepwise changes, triggers hot-swap)

**Recommendation**: Forbid for Phase 2 (simplicity), reconsider if compelling use case.

---

## Success Metrics

### Quantitative

- **Code Reduction**: Delete ~500 lines of paramSchema definitions
- **Type Safety**: 79 params gain TypeScript type checking via Slot.slotType
- **Test Coverage**: Maintain 738+ passing tests (no regressions)
- **Compile Time**: <5% increase (default source overhead negligible)

### Qualitative

- **Conceptual Clarity**: "Parameters" no longer exist as separate concept
- **UI Consistency**: All block controls follow same pattern (inputs with defaults)
- **Modulability**: Every control can be animated/bussed (if Signal world)
- **Hot-Swap Safety**: Config changes trigger safe crossfade (no flicker)

---

## Appendices

### Appendix A: Full Block Inventory

| # | Block | File | Params | Classification |
|---|-------|------|--------|----------------|
| 1 | Oscillator | signal.ts | 3 | 1 Config, 2 Signal |
| 2 | Shaper | signal.ts | 2 | 1 Config, 1 Signal |
| 3 | ColorLFO | signal.ts | 4 | 4 Signal |
| 4 | ClampSignal | signal.ts | 2 | 2 Signal |
| 5 | PhaseClockLegacy | signal.ts | 3 | 1 Config, 2 Signal |
| 6 | DomainN | domain.ts | 2 | 2 Scalar |
| 7 | GridDomain | domain.ts | 5 | 2 Scalar, 3 Signal |
| 8 | SVGSampleDomain | domain.ts | 4 | 3 Scalar, 1 Config |
| 9 | StableIdHash | domain.ts | 1 | 1 Scalar |
| 10 | PositionMapGrid | domain.ts | 6 | 2 Scalar, 3 Signal, 1 Config |
| 11 | PositionMapCircle | domain.ts | 6 | 4 Signal, 2 Config |
| 12 | PositionMapLine | domain.ts | 5 | 4 Signal, 1 Config |
| 13 | FieldConstNumber | domain.ts | 1 | 1 Signal |
| 14 | FieldConstColor | domain.ts | 1 | 1 Signal |
| 15 | FieldHash01ById | domain.ts | 1 | 1 Scalar |
| 16 | FieldMapNumber | domain.ts | 4 | 1 Config, 3 Signal |
| 17 | FieldMapVec2 | domain.ts | 8 | 1 Config, 7 Signal |
| 18 | FieldZipNumber | domain.ts | 1 | 1 Config |
| 19 | JitterFieldVec2 | domain.ts | 2 | 2 Signal |
| 20 | FieldZipSignal | domain.ts | 1 | 1 Config |
| 21 | RenderInstances2D | domain.ts | 3 | 1 Config, 2 Signal |
| 22 | FieldColorize | field-primitives.ts | 3 | 1 Config, 2 Signal |
| 23 | FieldOpacity | field-primitives.ts | 3 | 1 Config, 2 Signal |
| 24 | PulseDivider | rhythm.ts | 1 | 1 Scalar |
| 25 | EnvelopeAD | rhythm.ts | 3 | 3 Signal |
| 26 | FiniteTimeRoot | time-root.ts | 1 | 1 Config |
| 27 | CycleTimeRoot | time-root.ts | 2 | 2 Config |
| 28 | InfiniteTimeRoot | time-root.ts | 1 | 1 Config |

**Totals**:
- **Config**: 17 params (21.5%)
- **Signal**: 44 params (55.7%)
- **Scalar**: 18 params (22.8%)

---

### Appendix B: Migration Template

**File**: `scripts/migrate-block-params.template.ts`

```typescript
// TEMPLATE: Migrate block from paramSchema to inputs

// BEFORE
export const MyBlock = createBlock({
  type: 'MyBlock',
  inputs: [
    input('existingInput', 'Label', 'Signal<number>'),
  ],
  paramSchema: [
    {
      key: 'myParam',
      label: 'My Parameter',
      type: 'number',
      min: 0,
      max: 10,
      step: 0.1,
      defaultValue: 5,
    },
  ],
});

// AFTER
export const MyBlock = createBlock({
  type: 'MyBlock',
  inputs: [
    input('existingInput', 'Label', 'Signal<number>'),
    input('myParam', 'My Parameter', 'Signal<number>', {
      tier: 'primary', // or 'secondary'
      defaultSource: {
        type: 'constant',
        world: 'signal', // or 'config', 'scalar'
        value: 5,
      },
      uiHint: {
        control: 'slider',
        min: 0,
        max: 10,
        step: 0.1,
      },
    }),
  ],
  // DELETE paramSchema entirely
});
```

---

### Appendix C: Dependencies on Other Work

**Blocked By**:
- Phase 1: Slot Interface Extension (MUST be complete first)

**Blocks**:
- Phase 3: Compiler updates (cannot read inputs until Phase 2 defines them)
- Phase 3: UI updates (Inspector expects inputs to have metadata)

**Related Work**:
- Port Identity (#1): Inputs use slotId canonical identity
- Shared Validation (#4): Validator checks input connections
- Bus Semantics (#5): Bus listeners reference input slotIds

**Timeline**:
```
Week 1: Phase 1 (Slot Interface) ✅
Week 2: Phase 2 (This Plan)      ← WE ARE HERE
Week 3: Phase 3 (Compiler/UI)
Week 4: Integration & Testing
```

---

## Next Steps

1. **Review this plan** with team/stakeholders
2. **Answer open questions** (Q1-Q4 above)
3. **Create beads issues** for each migration batch
4. **Begin pilot migration** (JitterFieldVec2)
5. **Iterate on template** based on pilot learnings
6. **Execute batch migrations** per schedule
7. **Update STATUS** file when complete

---

**END OF PLAN**
