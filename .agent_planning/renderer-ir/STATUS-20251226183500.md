# Status Report - IR Rendering Pipeline Integration
**Timestamp:** 2025-12-26-183500
**Scope:** project/focused (renderer-ir pipeline)
**Confidence:** FRESH

## Executive Summary

**Overall: 60% infrastructure exists, 0% pipeline wired end-to-end**

The Renderer IR system has significant infrastructure in place from Phases A-D, but **the critical wiring is missing**. The pipeline components exist in isolation but are not connected:

1. Blocks emit `renderSink` to IRBuilder, but **do not emit StepMaterializeColor/Path steps**
2. `executeMaterializeColor.ts` and `executeMaterializePath.ts` exist and work **but are never called**
3. `executeRenderAssemble.ts` creates an empty stub RenderFrameIR **but doesn't assemble real passes**
4. `Canvas2DRenderer.renderFrame()` exists and can consume RenderFrameIR **but PreviewPanel calls render() instead**
5. The `IRRuntimeAdapter` uses **legacy bridge mode** with closure-based rendering

**Critical Gap:** The "last mile" wiring from blocks -> schedule -> execution -> render is completely missing.

---

## Runtime Check Results

| Check | Status | Output |
|-------|--------|--------|
| `just test` | FAIL | 9 files failed, 34 tests failed (mostly ScheduleExecutor/stepDispatch tests) |
| `just check` | FAIL | 550 lint errors (mostly strict-boolean-expressions) |
| `just typecheck` | PASS (inferred from test run) | Tests execute, indicating compilation works |

**Key Test Failures:**
- `ScheduleExecutor.test.ts`: 3 failures - executeFrame returns undefined instead of RenderTree
- `stepDispatch.test.ts`: 1 failure - executeNodeEval crashes on empty inputs

---

## Existing Infrastructure (Phases A-D)

### [FRESH] Phase A - IR Type Definitions: COMPLETE

**Evidence:** `/src/editor/compiler/ir/renderIR.ts` (595 lines)

All RenderFrameIR types are defined:
- `RenderFrameIR` (root structure)
- `Instances2DPassIR` with `InstanceBufferSetIR`, `InstanceMaterialIR`, `InstanceSortIR`
- `Paths2DPassIR` with `PathGeometryBufferIR`, `PathStyleIR`, `PathEncodingIR`
- `BufferRefIR`, `ScalarF32IR/U32IR/U16IR` (scalar broadcasts)
- `RenderPassHeaderIR`, `ClearSpecIR`, `BlendSpecIR`, `ClipSpecIR`, `Mat3x2IR`

### [FRESH] Phase B - Schedule Types for Materialization: COMPLETE

**Evidence:** `/src/editor/compiler/ir/schedule.ts` (lines 340-441)

- `StepMaterializeColor` interface defined (lines 363-387)
- `StepMaterializePath` interface defined (lines 414-441)
- Both added to `StepIR` union (lines 114-115)

### [FRESH] Phase C/D - Step Executors: IMPLEMENTED BUT UNUSED

**Evidence:** Step executors exist and are wired into ScheduleExecutor dispatch:

| Executor | File | Status |
|----------|------|--------|
| `executeMaterializeColor` | `/src/editor/runtime/executor/steps/executeMaterializeColor.ts` | COMPLETE (154 lines) |
| `executeMaterializePath` | `/src/editor/runtime/executor/steps/executeMaterializePath.ts` | COMPLETE (245 lines) |
| `executeRenderAssemble` | `/src/editor/runtime/executor/steps/executeRenderAssemble.ts` | STUB ONLY (122 lines) |

**ScheduleExecutor dispatch handles all step types:**
```typescript
// ScheduleExecutor.ts lines 175-213
case "materializeColor":
  executeMaterializeColor(step, program, runtime);
  break;
case "materializePath":
  executeMaterializePath(step, program, runtime);
  break;
```

### [FRESH] Render Pass Executors: COMPLETE

**Evidence:** `/src/editor/runtime/renderPassExecutors.ts` (651 lines)

- `renderInstances2DPass()` - reads buffers from ValueStore, renders to Canvas
- `renderPaths2DPass()` - decodes command streams, renders to Canvas
- Both handle scalar broadcasts and buffer refs properly

### [FRESH] Canvas2DRenderer.renderFrame(): IMPLEMENTED

**Evidence:** `/src/editor/runtime/canvasRenderer.ts` (lines 188-230)

```typescript
renderFrame(frame: RenderFrameIR, valueStore: ValueStore): RenderStats {
  // Clears canvas
  // Iterates passes and calls renderInstances2DPass/renderPaths2DPass
  // Returns stats
}
```

---

## What's Missing to Complete the Pipeline

### GAP 1: Block Lowering Does NOT Emit Materialize Steps

**Location:** `/src/editor/compiler/blocks/domain/RenderInstances2D.ts`

**Current behavior (lines 48-97):**
```typescript
const lowerRenderInstances2D: BlockLowerFn = ({ ctx, inputs, config }) => {
  // Validates inputs
  // Creates sinkInputs object
  ctx.b.renderSink('instances2d', sinkInputs);  // <-- Just registers a sink
  return {
    outputs: [],
    declares: { renderSink: { sinkId: 0 } },  // <-- No materialize steps!
  };
};
```

**What's needed:**
- Block lowering must emit `StepMaterializeColor` for color field inputs
- Block lowering must create buffer slots and register them
- The schedule must include these steps BEFORE `StepRenderAssemble`

### GAP 2: executeRenderAssemble Creates Empty Stub

**Location:** `/src/editor/runtime/executor/steps/executeRenderAssemble.ts`

**Current behavior (lines 73-121):**
```typescript
export function executeRenderAssemble(step, _program, runtime): void {
  try {
    const renderTree = runtime.values.read(step.outSlot);
    // If exists, validation passes - done
    return;
  } catch (_error) {
    // Create EMPTY stub RenderFrameIR
    const stubFrame: RenderFrameIR = {
      version: 1,
      clear: { mode: "none" },
      passes: [],  // <-- EMPTY! No real passes assembled
    };
    runtime.values.write(step.outSlot, stubFrame);
  }
}
```

**What's needed:**
- Read materialized buffers from step metadata or ValueStore
- Call `assembleInstanceBuffers()` to create `Instances2DPassIR`
- Call `assemblePathGeometry()` to create `Paths2DPassIR`
- Build actual `RenderFrameIR` with populated passes

### GAP 3: PreviewPanel Uses Legacy render() Path

**Location:** `/src/editor/PreviewPanel.tsx` (lines 300-353)

**Current behavior:**
```typescript
// Canvas render loop (lines 310-342)
if (renderTree) {
  canvasRenderer.render(renderTree as Parameters<typeof canvasRenderer.render>[0]);
  // ^^ Calls render() which expects legacy RenderTree/RenderCmd
}
```

**What's needed:**
```typescript
// Should call:
const frameIR = runtime.values.read(renderAssembleSlot) as RenderFrameIR;
canvasRenderer.renderFrame(frameIR, runtime.values);
```

### GAP 4: IRRuntimeAdapter Uses Bridge Mode

**Location:** `/src/editor/runtime/executor/IRRuntimeAdapter.ts` (lines 84-120)

**Current behavior:**
```typescript
createProgram(): Program<RenderTree> {
  return {
    signal: (tMs: number, runtimeCtx: RuntimeCtx): RenderTree => {
      this.executor.executeFrame(this.program, this.runtime, tMs);

      // BRIDGE MODE: Uses legacy closure for actual rendering
      if (this.legacyRenderFn !== null) {
        return this.legacyRenderFn(tMs, runtimeCtx) as unknown as RenderTree;
      }

      // Pure IR mode: Falls through to empty tree
      return { cmds: [] } as unknown as RenderTree;
    },
  };
}
```

**What's needed:**
- Pure IR mode should extract `RenderFrameIR` from `executeRenderAssemble` output
- Return format needs to be compatible with `renderFrame()` path

### GAP 5: pass9-codegen.ts.wip is Incomplete

**Location:** `/src/editor/compiler/passes/pass9-codegen.ts.wip`

**Current behavior (lines 408-432):**
- Iterates renderSinks but only creates generic `materialize` steps
- Does NOT emit `StepMaterializeColor` or `StepMaterializePath`
- Does NOT create proper buffer slots for IR path

---

## Dependencies and Blockers

### Critical Dependencies (Must Fix First)

1. **Block lowering** - RenderInstances2D/Paths2D must emit materialize steps
2. **Schedule generation** - pass9-codegen must include materialize steps
3. **executeRenderAssemble** - must actually assemble passes from buffers

### Not Blocking (Can Proceed)

- Lint errors (550) - cosmetic, don't affect functionality
- Test failures (34) - mostly related to incomplete ScheduleExecutor wiring

---

## Ambiguities Found

| Area | Question | How It Was Guessed | Impact |
|------|----------|-------------------|--------|
| Buffer slot allocation | How are buffer slots assigned for materialize outputs? | Not addressed - pass9 uses string placeholders | HIGH - breaks data flow |
| Render sink → pass mapping | How does a renderSink('instances2d') become an Instances2DPassIR? | Not implemented | CRITICAL - pipeline broken |
| Per-instance attribute routing | How do field inputs (color, positions) connect to buffer slots? | Block lowering creates sinkInputs but no slots | HIGH - no data path |
| Time resolution for bridge mode | Should IR path own time or defer to legacy? | Currently defers via legacyRenderFn | MEDIUM - works but confusing |

---

## Data Flow Verification

The intended data flow:

```
RenderInstances2D block
        ↓
lowerRenderInstances2D (should emit StepMaterializeColor for color field)
        ↓
ScheduleIR (should include materializeColor step)
        ↓
ScheduleExecutor.executeStep("materializeColor")
        ↓
executeMaterializeColor writes Uint8Array to bufferSlot
        ↓
ScheduleExecutor.executeStep("renderAssemble")
        ↓
executeRenderAssemble reads buffers, creates Instances2DPassIR
        ↓
PreviewPanel/IRRuntimeAdapter gets RenderFrameIR
        ↓
Canvas2DRenderer.renderFrame(frame, valueStore)
```

**Current Flow Breakage:**

| Step | Expected | Actual | Status |
|------|----------|--------|--------|
| Block lowering | Emit StepMaterializeColor | Only emits renderSink | BROKEN |
| Schedule | Include materializeColor steps | No materialize steps | BROKEN |
| executeMaterializeColor | Called by executor | Never called | BROKEN |
| executeRenderAssemble | Assemble real passes | Creates empty stub | BROKEN |
| PreviewPanel | Call renderFrame() | Calls render() | BROKEN |

---

## Test Suite Assessment

**Quality Score: 2/5**

| Question | Answer |
|----------|--------|
| If I delete implementation and leave stubs, do tests fail? | PARTIALLY - some tests fail on type errors |
| If I introduce an obvious bug, do tests catch it? | UNLIKELY - tests don't exercise end-to-end pipeline |
| Do tests exercise real user flows end-to-end? | NO - no e2e tests for RenderFrameIR path |
| Do tests use real systems or mock everything? | MOSTLY MOCKS - no integration tests |
| Do tests cover error conditions users will hit? | PARTIALLY |

**Coverage Gaps:**
- No tests for StepMaterializeColor/Path being emitted by blocks
- No tests for executeRenderAssemble producing real passes
- No tests for renderFrame() being called from PreviewPanel
- No e2e test: patch -> compile -> schedule -> execute -> render

---

## Missing Persistent Checks (Implementer Should Create)

### 1. E2E Render Pipeline Test
```bash
# Should be: just test:render-ir-e2e
# Test: Compile simple patch with RenderInstances2D
# Verify: Schedule includes materializeColor step
# Verify: RenderFrameIR has Instances2DPassIR with buffers
# Verify: Canvas2DRenderer.renderFrame() draws correctly
```

### 2. Block Lowering Test for Materialize Steps
```bash
# Should be: just test:block-materialize
# Test: RenderInstances2D lowering emits correct steps
# Verify: StepMaterializeColor created for color input
# Verify: Buffer slots assigned and wired
```

### 3. Visual Smoke Test
```bash
# Should be: just smoke:render-ir
# Test: 100 colored circles via pure IR path (no legacy bridge)
# Verify: Circles visible, colors correct
# Verify: 60fps performance
```

---

## Recommendations (Priority Ordered)

### P0: Complete Block Lowering to Emit Materialize Steps

**File:** `/src/editor/compiler/blocks/domain/RenderInstances2D.ts`

The block's `lowerRenderInstances2D` function must:
1. Allocate buffer slots for each field input (color, positions, etc.)
2. Create `StepMaterializeColor` for color field
3. Return these steps as part of the lowering result

### P0: Complete executeRenderAssemble

**File:** `/src/editor/runtime/executor/steps/executeRenderAssemble.ts`

Must:
1. Accept step metadata that lists which buffer slots to read
2. Assemble `InstanceBufferSetIR` from those buffers
3. Create `Instances2DPassIR` with proper header, material, count
4. Write complete `RenderFrameIR` to output slot

### P0: Wire PreviewPanel to Call renderFrame()

**File:** `/src/editor/PreviewPanel.tsx`

In the IR path, instead of:
```typescript
canvasRenderer.render(renderTree);
```

Should be:
```typescript
const frameIR = adapter.getRenderFrameIR();  // New method needed
canvasRenderer.renderFrame(frameIR, valueStore);
```

### P1: Complete pass9-codegen.ts.wip

The schedule generation pass needs to emit proper `StepMaterializeColor` and `StepMaterializePath` steps based on render sink inputs.

### P1: Remove Bridge Mode Fallback

Once IR path works, remove the `legacyRenderFn` bridge in IRRuntimeAdapter.

---

## Files Summary

### Infrastructure (EXISTS - COMPLETE)
- `/src/editor/compiler/ir/renderIR.ts` - All IR types
- `/src/editor/compiler/ir/schedule.ts` - StepMaterializeColor/Path types
- `/src/editor/runtime/executor/steps/executeMaterializeColor.ts` - Executor
- `/src/editor/runtime/executor/steps/executeMaterializePath.ts` - Executor
- `/src/editor/runtime/renderPassExecutors.ts` - Canvas pass renderers
- `/src/editor/runtime/canvasRenderer.ts` - Has renderFrame() method

### Wiring (EXISTS - INCOMPLETE)
- `/src/editor/compiler/blocks/domain/RenderInstances2D.ts` - Needs materialize step emission
- `/src/editor/runtime/executor/steps/executeRenderAssemble.ts` - Needs real assembly
- `/src/editor/runtime/executor/IRRuntimeAdapter.ts` - Bridge mode, needs pure IR path
- `/src/editor/PreviewPanel.tsx` - Calls render() not renderFrame()
- `/src/editor/compiler/passes/pass9-codegen.ts.wip` - Incomplete schedule generation

---

## Workflow Recommendation

- [x] CONTINUE - Issues are clear, implementer can fix

The gaps are well-defined:
1. Block lowering must emit StepMaterializeColor/Path
2. executeRenderAssemble must assemble real passes
3. PreviewPanel must call renderFrame()

No fundamental ambiguities block progress. The infrastructure is solid; only the wiring is missing.
