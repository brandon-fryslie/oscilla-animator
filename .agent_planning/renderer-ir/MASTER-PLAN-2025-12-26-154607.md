# Master Plan: Renderer IR System
**Generated:** 2025-12-26-154607
**Source STATUS:** STATUS-20251226160000.md
**Scope:** Complete implementation of hybrid 2D/3D renderer IR system

---

## Executive Summary

The Renderer IR system represents the largest architectural addition to Oscilla since the compiler rewrite. It introduces a deterministic, cache-aware, buffer-oriented rendering pipeline that supports both high-volume instance rendering (thousands of particles) and expressive vector path rendering (morphing line art, glyphs).

**Core Innovation:** Hybrid architecture treating Instances2D and Paths2D as peer rendering primitives, both compiled to typed buffer references consumed by Canvas2D renderer (with future WebGPU migration path).

**Key Design Principles:**
- Renderer consumes typed buffers, never objects or closures
- All materialization (color quantization, path flattening) is scheduled and cacheable
- Deterministic across hot-swaps via stable cache keys
- Rust/WASM compatible encoding (u8x4 color, u16 path commands, LE byte order)
- 3D projection as prepass emitting 2D drawables (no full 3D engine)

**Estimated Scope:** 14-16 sprints (10-11 for 2D only, 4-5 for 3D additions)

---

## Phase Overview

| Phase | Name | Sprints | Deps | Description |
|-------|------|---------|------|-------------|
| **A** | IR Type Definitions | 2 | Phase 6 partial | Define all RenderFrameIR, pass, buffer, material types as pure TS interfaces |
| **B** | Color & Encoding Foundation | 1 | A | u8x4 color migration, TypeDesc/BufferDesc split, quantization kernels |
| **C** | Instances2D Runtime | 2 | A, B | End-to-end instance buffer pipeline: materialize → assemble → render |
| **D** | Paths2D Runtime | 2 | A, B | Path geometry buffers, command streams, flattening infrastructure |
| **E** | Caching Infrastructure | 2-3 | C, D | CacheKeySpec, policies, budgets, eviction, fingerprinting |
| **F** | Canvas Renderer Rewrite | 1 | C, D, E | New Canvas2D renderer consuming RenderFrameIR |
| **G** | 3D Camera & Mesh | 2 | F | CameraIR, MeshIR, stores, CameraEval, mesh materialization |
| **H** | 3D Projection Pipeline | 2-3 | G | Instances3D_ProjectTo2D, schedule integration, projection step |
| | **TOTAL (2D complete)** | **10-11** | | Fully functional 2D renderer IR |
| | **TOTAL (with 3D)** | **14-16** | | Complete renderer IR system |

---

## Design Document Coverage Matrix

| Doc | Title | Topics Covered | Phases |
|-----|-------|----------------|--------|
| 00 | Overview & Context | Renderer responsibilities, hybrid model, pass types | A, C, D |
| 01 | RenderFrameIR | All IR types, buffer refs, materials, pass structures | A, C, D |
| 03 | Decisions | Color u8x4, path u16, flattening policy, 3D model | B, D, G |
| 04 | Decision-to-IR | ColorBufferDesc, PathCommandStreamDesc, FlattenPolicy | B, D |
| 05 | Upstream Impacts | Type system split, materialization step, cache keys, debugger | B, E |
| 06 | 3D Again | (empty file) | — |
| 07 | 3D Canonical | TypeDomain extensions, CameraIR, MeshIR, projection | G, H |
| 08 | Caching Spec | CachePolicy, CacheKeySpecIR, SlotFingerprint, eviction | E |

### Requirement Traceability (All Design Docs)

**Phase A (IR Types):**
- Doc 01: RenderFrameIR, RenderPassIR, Instances2DPassIR, Paths2DPassIR
- Doc 01: BufferRefIR, ScalarF32IR/U32IR/U16IR
- Doc 01: RenderPassHeaderIR (z, blend, clip, view)
- Doc 01: InstanceMaterialIR, InstanceBufferSetIR, InstanceSortIR
- Doc 01: PathGeometryBufferIR, PathEncodingIR, PathStyleIR
- Doc 01: ClearSpecIR, BlendSpecIR, ClipSpecIR, Mat3x2IR

**Phase B (Color/Encoding):**
- Doc 03: Color u8x4 premultiplied linear RGBA decision
- Doc 04: ColorBufferDesc with encoding contract
- Doc 04: PathCommandStreamDesc (u16, LE)
- Doc 05: Type system split (authoring vs storage)
- Doc 05: Materialization as scheduled step

**Phase C (Instances2D):**
- Doc 00: Instances2D as fast path for particles/sprites
- Doc 01: Complete Instances2D pipeline spec
- Doc 05: Materialization step integration

**Phase D (Paths2D):**
- Doc 00: Paths2D as peer for vector art
- Doc 01: Path geometry buffer specification
- Doc 03: Path commands u16, flattening policy
- Doc 04: FlattenPolicy, CANONICAL_FLATTEN_TOL_PX
- Doc 05: Path materialization kernel

**Phase E (Caching):**
- Doc 08: ALL sections (entire caching spec)
  - CachePolicy enum (none/perFrame/perTime/persistent)
  - TimeQuantization (exact/frame/ms/phase)
  - CacheStorage (localStep/globalShared)
  - CacheClass enum (all 11 classes)
  - CacheKeySpecIR complete structure
  - SlotFingerprint by ValueKind
  - RuntimeEpochs (viewport/assets/external/program)
  - Cache budgets per class
  - LRU eviction policies
  - Pinning rules
  - MissReasonCode diagnostics
  - Cache key hash algorithm (xxHash64/wyhash)
  - Hot-swap persistence rules
- Doc 05: Cache keys include encoding/policy
- Doc 05: Debugger instrumentation

**Phase F (Canvas Renderer):**
- Doc 00: Renderer responsibilities (what it must/must not do)
- Doc 01: Canvas renderer consuming RenderFrameIR

**Phase G (3D Camera/Mesh):**
- Doc 07: TypeDomain extensions (vec3, quat, mat4, mesh, camera)
- Doc 07: CameraIR complete specification
- Doc 07: CameraEval (viewMat4, projMat4, viewportKey)
- Doc 07: CameraTable program-level registry
- Doc 07: MeshIR (ExtrudeProfile2D, ExtrudeKind)
- Doc 07: MeshTable program-level registry
- Doc 07: MeshBufferRef materialized buffers
- Doc 07: CameraStore, MeshStore runtime stores

**Phase H (3D Projection):**
- Doc 03: 3D projection prepass model
- Doc 07: Instance2DBufferRef (split RGBA channels)
- Doc 07: StepPerfCounters (cpuMs, cacheHit, bytesWritten)
- Doc 07: New schedule dependencies (CameraEval → Projection → Render)
- Doc 07: Phase partitioning (cameraEval, meshMaterialize, projection)
- Doc 07: New opcodes (CameraEval, MeshMaterialize, Instances3D_ProjectTo2D)

---

## Dependency Graph

```
Phase 6 (Runtime)
    ↓
Phase A: IR Types (pure types, no runtime)
    ↓
    ├─→ Phase B: Color/Encoding ─┐
    │                             ↓
    ├─→ Phase C: Instances2D ←────┤
    │                             │
    └─→ Phase D: Paths2D ←────────┘
            ↓           ↓
        Phase E: Caching Infrastructure
            ↓           ↓
        Phase F: Canvas Renderer Rewrite
                ↓
        Phase G: 3D Camera/Mesh
                ↓
        Phase H: 3D Projection
```

**Critical Path:** A → B → C → E → F (minimum viable 2D)

**Parallel Opportunities:**
- Phases C and D can proceed in parallel after B completes
- Phase E can start once C or D has a working pipeline
- Phases G and H are independent of ongoing 2D work

---

## Risk Matrix

### High-Risk Areas

| Risk | Impact | Mitigation | Phases |
|------|--------|------------|--------|
| **Type System Split** | Pervasive changes to TypeDesc, IR, blocks | Design carefully in Phase B, isolated sprint, comprehensive tests | B |
| **Color Encoding Migration** | All blocks producing colors must change | Introduce ColorBufferDesc as new type, migrate gradually, dual-emit initially | B, C |
| **Path Geometry System** | Completely new data structure, no existing code | Build from scratch, test with simple paths first, validate encoding | D |
| **Cache Key Correctness** | Wrong keys cause incorrect reuse, visual bugs | Implement fingerprinting rigorously, test hot-swap continuity | E |
| **3D Projection Pipeline** | Largest single addition (4-5 sprints) | Defer until 2D stable, build incrementally, thorough e2e tests | G, H |
| **Performance Regression** | New pipeline could be slower than legacy | Benchmark early, profile Canvas ops, optimize batching | C, D, F |
| **Hot-Swap Continuity** | Caches invalidated incorrectly on code changes | Test with StepId stability, validate persistent cache reuse | E |

### Medium-Risk Areas

| Risk | Impact | Mitigation | Phases |
|------|--------|------------|--------|
| **Phase 6 Dependencies** | Incomplete executeNodeEval/renderAssemble blocks work | Complete Phase 6 stubs before starting Phase C | A, C |
| **Flattening Tolerance** | Pixel-based tolerance interacts with zoom/DPR | Lock canonical tolerance early, document viewport dependency | D |
| **Buffer Pool Exhaustion** | Arena allocation fails under load | Implement budget limits, test with high instance counts | C, D, E |
| **Canvas API Quirks** | Browser differences in rendering behavior | Normalize via strict conventions, test across browsers | F |
| **Determinism Drift** | Float precision differences between runs | Use float32 consistently, test determinism with snapshots | B, C, D |

### Ambiguities Requiring Clarification

| Question | Impact | Default Assumption | Resolution Phase |
|----------|--------|-------------------|------------------|
| Preserve legacy RenderCmd during migration? | Major - affects dual-emit strategy | Yes - dual-emit pattern for safety | A, C |
| Flattening tolerance screen-space or world-space? | Cache keys, viewport dependency | Screen-space (pixel-based) | D |
| Priority of 3D vs 2D optimization? | Scope and sprint ordering | 2D first, 3D deferred | All |
| Export pipeline in initial scope? | Scope creep risk | No - separate phase after H | Deferred |
| Legacy Canvas2DRenderer removal timing? | Migration risk | After F proves stable (1-2 sprints) | F |

---

## Workflow and Verification Strategy

### Per-Phase Checks

**Phase A (IR Types):**
- `just typecheck` must pass with all new types
- No runtime changes yet - purely additive type definitions
- Review: every type matches design doc 01-RendererIR.md exactly

**Phase B (Color/Encoding):**
- `just test:color-quantize` - color quantization kernel tests
- Verify u8x4 encoding matches spec (linear premul RGBA)
- Check TypeDesc/BufferDesc separation compiles cleanly

**Phase C (Instances2D):**
- `just test:instances2d` - materialize → render pipeline
- Visual smoke test: 1000 circles with colors render correctly
- Benchmark: instances2d vs legacy RenderCmd performance

**Phase D (Paths2D):**
- `just test:paths2d` - geometry buffers, command streams
- Visual smoke test: simple path with curves renders
- Test flattening: on/off produces different buffer sizes

**Phase E (Caching):**
- `just test:cache-policy` - key computation, hit/miss
- Test hot-swap: cache persists across program recompile
- Verify eviction: LRU drops oldest entries when budget exceeded

**Phase F (Canvas Renderer):**
- `just smoke:render-ir` - end-to-end compile → IR → Canvas
- Visual regression: "Breathing Constellation" renders identically
- Performance: new renderer ≥ 90% of legacy speed

**Phases G/H (3D):**
- `just test:camera-eval` - matrix computation determinism
- `just test:projection` - 3D→2D projection correctness
- Visual: spinning extruded circles project correctly

### Persistent Checks (Always Run)

```bash
just check        # Typecheck + lint + test (must pass before any commit)
just test:field   # Field materialization (dependency - must stay green)
just test:signal  # Signal evaluation (dependency - must stay green)
```

### Definition of Done (Master Plan)

All phases complete when:
- [ ] All 8 design documents have corresponding implementation
- [ ] `just check` passes with zero warnings
- [ ] Visual regression suite includes renderer IR examples
- [ ] Performance benchmark shows ≤10% regression vs legacy
- [ ] Hot-swap cache reuse verified in production patches
- [ ] Documentation updated (memory files, architecture docs)
- [ ] Legacy RenderCmd/Canvas2DRenderer removed (post-F stabilization)

---

## Sprint Planning Guidance

### Recommended Sprint Groupings

**Sprint 1-2 (Phase A):** IR type definitions only - low risk, high value for downstream phases

**Sprint 3 (Phase B):** Color encoding - requires careful design but isolated impact

**Sprint 4-5 (Phase C):** Instances2D end-to-end - first visual payoff, validates architecture

**Sprint 6-7 (Phase D):** Paths2D geometry - complex but parallel-able with ongoing C work

**Sprint 8-10 (Phase E):** Caching infrastructure - large, complex, requires C and D complete

**Sprint 11 (Phase F):** Canvas renderer rewrite - payoff sprint, unifies work

**Sprint 12-13 (Phase G):** 3D Camera/Mesh - pure additive, no 2D disruption

**Sprint 14-16 (Phase H):** 3D Projection - final integration, most complex 3D work

### Sprint Size Expectations

- **Small sprint (1):** 2-3 deliverables, 5-8 work items, mostly type definitions
- **Medium sprint (2):** 2-3 deliverables, 8-12 work items, runtime implementation
- **Large sprint (2-3):** 3-4 deliverables, 12-18 work items, infrastructure + integration

### Iteration Strategy

1. **Start with Phase A** - Unblocks all downstream work
2. **Validate early in Phase C** - Build simplest end-to-end pipeline first
3. **Defer 3D (Phases G-H)** - Complete 2D renderer before 3D work
4. **Continuous integration** - Keep legacy path working until Phase F proves stable

---

## Success Criteria

**Technical:**
- RenderFrameIR emitted by ScheduleExecutor every frame
- Canvas renderer draws 10k+ particles at 60fps (no regressions)
- Hot-swap preserves caches correctly (visual continuity)
- All tests pass with deterministic snapshots

**Architectural:**
- Zero "hidden inputs" - all cache keys explicit
- Type system cleanly separates authoring (TypeDesc) from storage (BufferDesc)
- Renderer consumes only typed buffers - no objects, no closures
- Rust/WASM compatibility verified (encoding matches spec)

**User-Facing:**
- "Breathing Constellation" patch renders identically
- No visual artifacts on hot-swap (stable cache keys)
- Debugger shows materialization costs and cache hit rates
- Path morphing example (glyphs → dots → glyphs) works smoothly

---

## Deferred / Out of Scope

**Explicitly deferred to later work:**
- Export pipeline (SVG, video, LED) - separate initiative
- WebGPU renderer - replaces Canvas2D, reuses IR
- Full 3D mesh support - current scope is extrusion-only
- Texture atlasing - optimization for later
- Advanced path operations (boolean ops, variable-width strokes)
- Gradient/pattern caching - can use Path2D patterns initially

**Not in scope (never planned):**
- Full 3D engine (lighting, shadows, PBR) - Oscilla is 2D-first
- Arbitrary triangle mesh authoring - extrusion only
- Runtime shader compilation - Canvas2D and future WebGPU compute
- Video input textures - separate feature

---

## Next Steps

**Immediate (before Phase A):**
1. Complete Phase 6 executeNodeEval and executeRenderAssemble stubs
2. Review and approve this master plan
3. Generate Phase A detailed sprint plan (PLAN-PHASE-A-*.md)
4. Set up test infrastructure (`just test:renderer-ir` skeleton)

**After Phase A completes:**
1. Generate Phase B plan
2. Validate type definitions with small prototype
3. Begin color encoding migration design

**After Phase F completes (2D done):**
1. Evaluate 3D priority (Phases G-H) vs other roadmap items
2. Consider export pipeline vs 3D as next initiative
3. Plan WebGPU migration if 2D renderer proves stable
