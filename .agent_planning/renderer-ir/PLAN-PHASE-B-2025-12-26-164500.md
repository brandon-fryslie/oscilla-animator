# Sprint Plan: Phase B - Color & Encoding Foundation
**Generated:** 2025-12-26-164500
**Source STATUS:** STATUS-20251226160000.md
**Source Specs:** Doc 03, Doc 04, Doc 05
**Prerequisites:** Phase A (IR Type Definitions) COMPLETE
**Estimated Complexity:** MEDIUM (1 sprint)

---

## Sprint Goal

Establish the foundational encoding contracts for color and path data that all downstream phases (C-F) will depend on. This sprint creates the authoritative boundary between "authoring types" (what users work with) and "storage encodings" (what renderers consume), ensuring determinism, Rust/WASM compatibility, and cache correctness.

**Success Criteria:**
- TypeDesc/BufferDesc separation compiles cleanly
- u8x4 color quantization produces deterministic output
- ColorBufferDesc and PathCommandStreamDesc types are authoritative
- All encoding decisions are locked and documented

---

## In Scope

### Deliverable 1: Type System Split (TypeDesc vs BufferDesc)
Separate authoring types from storage encodings to prevent "semantic types leaking into physical storage."

### Deliverable 2: Color Encoding Migration
Migrate from float RGBA (0-1 range) to u8x4 premultiplied linear RGBA with quantization kernels.

### Deliverable 3: Path Encoding Specification
Define PathCommandStreamDesc (u16 opcodes, LE byte order) and FlattenPolicy contracts.

### Deliverable 4: Foundation for Materialization Step
Prepare for color/path materialization as explicit scheduled steps (not renderer internals).

---

## Out of Scope

- **Runtime implementation of materialization steps** - Phase C/D work
- **Actual color conversion in blocks** - Dual-emit pattern deferred
- **Path flattening implementation** - Phase D only
- **Cache key implementation** - Phase E work (this phase defines requirements only)
- **3D color/geometry additions** - Phase G-H
- **Export pipeline** - Separate initiative

---

## Work Items

### P0: Critical Foundation

#### P0.1: Define BufferDesc Type Hierarchy

**Status:** Not Started
**Effort:** SMALL
**Dependencies:** Phase A complete
**Spec Reference:** Doc 04 (ColorBufferDesc, PathCommandStreamDesc) • Doc 05 (storage vs authoring split)
**Status Reference:** STATUS-20251226160000.md section "Doc 04: Decision-to-IR Mapping"

##### Description
Create a new `BufferDesc` type hierarchy parallel to `TypeDesc` that describes physical storage layouts rather than semantic types. This is the authoritative contract for what renderers and exporters consume.

##### Acceptance Criteria
- [ ] `BufferDesc` base interface defined in `src/editor/ir/types/BufferDesc.ts`
- [ ] Clear documentation of authoring vs storage type distinction
- [ ] `BufferDesc` includes: `kind`, `encoding`, `strideBytes`, `endianness` (where applicable)
- [ ] TypeScript compilation passes with zero errors
- [ ] Unit test: BufferDesc type guards work correctly

##### Technical Notes
- Keep `BufferDesc` in separate file from `TypeDesc.ts` to emphasize the split
- `TypeDesc` = what blocks/lenses operate on (field&lt;color&gt;, signal&lt;vec2&gt;)
- `BufferDesc` = what caches/renderer store (u8x4 linear premul RGBA, f32x2 LE)
- This prevents "phase is just a number" style confusion from leaking into render storage

---

#### P0.2: Define ColorBufferDesc Contract

**Status:** Not Started
**Effort:** SMALL
**Dependencies:** P0.1
**Spec Reference:** Doc 03 (u8x4 decision) • Doc 04 (ColorBufferDesc spec)
**Status Reference:** STATUS-20251226160000.md section "Doc 03: Decisions"

##### Description
Create the canonical color buffer encoding specification: `linear_premul_rgba8` as the one and only accepted render color format. This locks down the color representation to prevent random engineers inventing their own encodings.

##### Acceptance Criteria
- [ ] `ColorBufferDesc` interface defined with fixed contract:
  - `kind: "u8x4"`
  - `encoding: "linear_premul_rgba8"` (only valid value)
  - `channelOrder: "RGBA"` (fixed)
  - `strideBytes: 4` (fixed)
- [ ] `ColorEncoding` type defined as literal `"linear_premul_rgba8"`
- [ ] Documentation explains: premultiplied, linear (not sRGB), RGBA order, u8 per channel
- [ ] Type enforces immutability of encoding constants
- [ ] Unit test: ColorBufferDesc construction validates encoding

##### Technical Notes
- **Premultiplied:** alpha already applied to RGB (required for correct blending)
- **Linear:** not sRGB gamma (allows correct color math, Canvas2D handles conversion)
- **u8x4:** 4 bytes per color (RGBA), compact and cache-friendly
- **LED-safe:** external outputs use OutputAdapter to map RGBA → hardware format
- This encoding is Rust/WASM compatible and deterministic

---

#### P0.3: Define PathCommandStreamDesc Contract

**Status:** Not Started
**Effort:** SMALL
**Dependencies:** P0.1
**Spec Reference:** Doc 03 (u16 decision) • Doc 04 (PathCommandStreamDesc spec)
**Status Reference:** STATUS-20251226160000.md section "Doc 03: Decisions"

##### Description
Lock the path command stream encoding to u16 opcodes with little-endian byte order, ensuring Rust/WASM portability and future opcode space for 3D additions.

##### Acceptance Criteria
- [ ] `PathCommandStreamDesc` interface defined with fixed contract:
  - `opcodeWidth: 16` (u16, fixed)
  - `endianness: "LE"` (little-endian, fixed)
- [ ] Documentation explains: Uint16Array commands, LE byte order for serialization
- [ ] Path cache resources reference this descriptor (not inline magic numbers)
- [ ] Type enforces immutability of width and endianness
- [ ] Unit test: PathCommandStreamDesc validates fixed values

##### Technical Notes
- **u16 opcodes:** 65,536 opcode space (plenty for 2D + 3D + extensions)
- **LE byte order:** matches JS typed arrays, Rust default on x86/ARM, WASM standard
- **Point arity:** separate table defines points-per-opcode (not in stream descriptor)
- Future opcodes: MoveTo, LineTo, QuadTo, CubicTo, Close, ArcTo, BooleanOps, 3D extensions
- Commands stream is separate from points stream (command → point index mapping)

---

#### P0.4: Implement Color Quantization Kernel

**Status:** Not Started
**Effort:** MEDIUM
**Dependencies:** P0.2
**Spec Reference:** Doc 04 (quantization as materialization) • Doc 05 (kernel determinism)
**Status Reference:** STATUS-20251226160000.md section "Doc 05: Upstream Impacts (Item 2)"

##### Description
Create a deterministic kernel that converts float RGBA (0-1) to u8x4 premultiplied linear RGBA. This is the authoritative color quantization algorithm that must produce identical results in TS and future Rust implementations.

##### Acceptance Criteria
- [ ] `quantizeColorRGBA()` function in `src/editor/runtime/kernels/ColorQuantize.ts`
- [ ] Signature: `(r: number, g: number, b: number, a: number) => Uint8Array` (4 bytes)
- [ ] Premultiply RGB by alpha before quantization: `[r*a, g*a, b*a, a]`
- [ ] Clamp inputs to [0, 1] before scaling to [0, 255]
- [ ] Use Math.round() for deterministic rounding (not floor/ceil)
- [ ] Unit tests:
  - [ ] Fully opaque white (1,1,1,1) → [255, 255, 255, 255]
  - [ ] Half-transparent red (1,0,0,0.5) → [128, 0, 0, 128]
  - [ ] Fully transparent → [0, 0, 0, 0]
  - [ ] Out-of-range values clamped correctly
  - [ ] Determinism: same input always produces same output (100 iterations)

##### Technical Notes
- **Premultiplication order matters:** apply alpha BEFORE quantization to avoid precision loss
- **Rounding:** Math.round() ensures determinism across platforms (floor/ceil differ on 0.5)
- **Clamping:** prevents overflows from HDR values or shader bugs
- **Rust compatibility:** document exact algorithm for future Rust port
- This kernel is called during materialization, NOT during rendering

---

### P1: High Priority

#### P1.1: Define FlattenPolicy Type

**Status:** Not Started
**Effort:** SMALL
**Dependencies:** None
**Spec Reference:** Doc 04 (FlattenPolicy spec)
**Status Reference:** STATUS-20251226160000.md section "Doc 04: Decision-to-IR Mapping"

##### Description
Define the flattening policy type that controls whether path curves are converted to polylines, and establish the canonical tolerance constant. This becomes part of cache keys in Phase E.

##### Acceptance Criteria
- [ ] `FlattenPolicy` discriminated union type defined:
  - `{ kind: "off" }` - keep curves (default)
  - `{ kind: "on"; tolerancePx: number }` - flatten with tolerance
- [ ] `CANONICAL_FLATTEN_TOL_PX` constant defined (value: 0.75px)
- [ ] Documentation explains:
  - Tolerance is in screen pixels (view-dependent)
  - Only canonical tolerance is permitted (no arbitrary values)
  - "off" preserves curves for quality/morphing
  - "on" generates polylines for performance
- [ ] Type guard functions: `isFlattenOff()`, `isFlattenOn()`
- [ ] Unit test: FlattenPolicy type guards work correctly

##### Technical Notes
- **Canonical tolerance:** 0.75px chosen as perceptually invisible at typical DPR
- **Screen-space tolerance:** means cache keys include viewport/DPR (accepted tradeoff)
- **Why one canonical value:** prevents cache fragmentation, simplifies debugging
- **World-space alternative:** would be DPR-independent but harder to reason about
- Flattening implementation is Phase D; this is type definition only

---

#### P1.2: Update TypeDesc Documentation for Authoring vs Storage Split

**Status:** Not Started
**Effort:** SMALL
**Dependencies:** P0.1
**Spec Reference:** Doc 05 (type system split)
**Status Reference:** STATUS-20251226160000.md section "Doc 05: Upstream Impacts (Item 1)"

##### Description
Add clear documentation to `TypeDesc.ts` explaining that TypeDesc represents authoring-time semantics, while BufferDesc (new) represents storage-time encodings. Prevents future confusion about "what type means what."

##### Acceptance Criteria
- [ ] JSDoc comment at top of `TypeDesc.ts` explains authoring vs storage split
- [ ] Examples: `field<color>` (TypeDesc) vs `linear_premul_rgba8` (BufferDesc)
- [ ] Cross-reference to `BufferDesc.ts` in documentation
- [ ] No changes to TypeDesc runtime behavior (documentation only)
- [ ] Memory file `02-type-system.md` updated with authoring/storage distinction

##### Technical Notes
- TypeDesc = "what does this value mean?" (semantic)
- BufferDesc = "how is this value stored?" (physical)
- Example: `field<color>` can materialize to different BufferDescs (u8x4, f32x4) depending on use
- This split enables future export formats to request different encodings

---

#### P1.3: Document Materialization Step Requirements

**Status:** Not Started
**Effort:** SMALL
**Dependencies:** P0.2, P0.4
**Spec Reference:** Doc 05 (materialization as scheduled step)
**Status Reference:** STATUS-20251226160000.md section "Doc 05: Upstream Impacts (Item 2)"

##### Description
Create design document specifying how color/path materialization becomes a first-class scheduled step. This is preparatory work for Phase C/D implementation.

##### Acceptance Criteria
- [ ] Document created: `design-docs/13-Renderer/09-Materialization-Steps.md`
- [ ] Specifies MaterializeColor and MaterializePath as schedule step types
- [ ] Lists required inputs: ValueSlot refs, BufferDesc targets, cache policy
- [ ] Lists outputs: BufferRefIR with typed array payload
- [ ] Explains why materialization is NOT a renderer responsibility
- [ ] Cache key requirements documented (encoding + policy fields)
- [ ] Performance counter requirements: cpuMs, bytesWritten, cacheHit

##### Technical Notes
- Materialization happens BEFORE rendering, not during
- Each materialization step is cacheable with explicit cache keys
- Debugger must attribute materialization costs separately from rendering
- Phase C/D will implement these steps; this phase defines contracts only

---

### P2: Medium Priority

#### P2.1: Create Color Quantization Benchmarks

**Status:** Not Started
**Effort:** SMALL
**Dependencies:** P0.4
**Spec Reference:** Doc 05 (runtime memory layout)
**Status Reference:** STATUS-20251226160000.md section "Doc 05: Upstream Impacts (Item 6)"

##### Description
Benchmark color quantization kernel to ensure it meets performance requirements for high instance counts (10k+ particles). Validates that quantization cost is negligible compared to rendering.

##### Acceptance Criteria
- [ ] Benchmark script in `scripts/bench-color-quantize.ts`
- [ ] Measures quantization throughput: colors/second
- [ ] Test cases:
  - [ ] 1k colors (typical single frame)
  - [ ] 10k colors (heavy particle system)
  - [ ] 100k colors (stress test)
- [ ] Baseline: quantization must be <1ms for 10k colors on reference hardware
- [ ] Results documented in benchmark output

##### Technical Notes
- Quantization is per-instance, so 10k particles = 10k quantizations per frame
- If quantization is too slow, consider SIMD or GPU compute (future optimization)
- Cache hit rate will reduce actual quantization calls (most frames reuse)

---

#### P2.2: Validate Rust/WASM Compatibility (Documentation)

**Status:** Not Started
**Effort:** SMALL
**Dependencies:** P0.2, P0.3, P0.4
**Spec Reference:** Doc 05 (Rust/WASM compatibility)
**Status Reference:** STATUS-20251226160000.md section "Doc 05: Upstream Impacts (Item 7)"

##### Description
Document the determinism guarantees and encoding contracts required for future Rust/WASM implementations. No Rust code written yet; this is specification only.

##### Acceptance Criteria
- [ ] Document created: `design-docs/13-Renderer/10-Rust-WASM-Compatibility.md`
- [ ] Specifies endianness (LE), numeric types (u8, u16, f32), rounding rules
- [ ] ColorQuantize algorithm documented with exact steps
- [ ] PathCommandStream encoding documented with opcode table stub
- [ ] Float precision requirements: use f32 (not f64) for determinism
- [ ] Saturation rules: clamp-to-range (not wraparound)

##### Technical Notes
- Rust port is future work; this ensures we design for it now
- Determinism = same program + same inputs → same bytes on TS and Rust
- Critical for hot-swap: cache keys must match across implementations

---

#### P2.3: Update Memory Files with Encoding Decisions

**Status:** Not Started
**Effort:** SMALL
**Dependencies:** All P0 items
**Spec Reference:** N/A (documentation)
**Status Reference:** N/A

##### Description
Update `claude_memory/02-type-system.md` with authoring vs storage split and encoding contracts. Ensures future Claude Code sessions know about these decisions.

##### Acceptance Criteria
- [ ] Section added to `02-type-system.md`: "Authoring vs Storage Types"
- [ ] ColorBufferDesc contract documented
- [ ] PathCommandStreamDesc contract documented
- [ ] FlattenPolicy explained
- [ ] Examples: field&lt;color&gt; → linear_premul_rgba8
- [ ] Cross-references to design docs 03, 04, 05

##### Technical Notes
- Memory files are authoritative for Claude Code context
- Keep synced with design docs to prevent drift

---

## Dependency Graph

```
P0.1 (BufferDesc hierarchy)
  ├─→ P0.2 (ColorBufferDesc)
  │     └─→ P0.4 (Quantization kernel)
  │           ├─→ P2.1 (Benchmarks)
  │           └─→ P2.2 (Rust/WASM docs)
  ├─→ P0.3 (PathCommandStreamDesc)
  │     └─→ P2.2 (Rust/WASM docs)
  └─→ P1.2 (TypeDesc docs)

P1.1 (FlattenPolicy) → independent

P0.2 + P0.4 → P1.3 (Materialization docs)

All P0 → P2.3 (Memory file updates)
```

---

## Risks and Mitigations

### High Risk: Type System Changes Break Existing Code

**Impact:** TypeDesc modifications could affect Phase 1-6 work
**Likelihood:** MEDIUM
**Mitigation:**
- Keep TypeDesc.ts changes documentation-only (no runtime changes)
- BufferDesc is new file, zero impact on existing code
- Phase A IR types are additive, not modifying existing types

### Medium Risk: Color Quantization Introduces Visual Artifacts

**Impact:** u8x4 quantization loses precision vs float
**Likelihood:** LOW
**Mitigation:**
- Premultiplication before quantization preserves alpha blending correctness
- Math.round() prevents banding (better than floor/ceil)
- Benchmark validates quality with visual tests
- If needed, Phase C can introduce f32x4 as alternative BufferDesc (opt-in)

### Low Risk: Canonical Flatten Tolerance Too Coarse

**Impact:** 0.75px might be visible on high-DPR displays
**Likelihood:** LOW
**Mitigation:**
- Default policy is "off" (keep curves)
- Flatten is opt-in per PathCache (Phase D)
- Can adjust constant if needed (single source of truth)

---

## Testing Strategy

### Unit Tests (New)
- `BufferDesc.test.ts` - type guards, validation
- `ColorBufferDesc.test.ts` - encoding validation
- `PathCommandStreamDesc.test.ts` - width/endianness validation
- `ColorQuantize.test.ts` - quantization correctness + determinism
- `FlattenPolicy.test.ts` - type guards

### Persistent Checks (Must Pass)
```bash
just check        # Typecheck + lint + test
just test:field   # Field materialization (dependency)
just test:signal  # Signal evaluation (dependency)
```

### New Check (Created This Sprint)
```bash
just test:encoding  # All encoding-related tests
```

---

## Definition of Done

### Sprint Complete When:
- [ ] All P0 work items complete with passing acceptance criteria
- [ ] All P1 work items complete OR explicitly deferred with documented reason
- [ ] `just check` passes with zero errors or warnings
- [ ] All unit tests pass with 100% determinism
- [ ] Color quantization benchmark meets <1ms for 10k colors
- [ ] Memory files updated
- [ ] Design docs 09-Materialization and 10-Rust-WASM created
- [ ] No regression in existing Phase 1-6 tests

### Deliverables:
1. **Type Definitions:** BufferDesc.ts, ColorBufferDesc, PathCommandStreamDesc, FlattenPolicy
2. **Kernel Implementation:** quantizeColorRGBA() with tests
3. **Documentation:** Materialization steps spec, Rust/WASM compatibility spec
4. **Memory Files:** Updated 02-type-system.md

---

## Next Steps After Phase B

**Phase C: Instances2D Runtime** (2 sprints)
- Implement MaterializeColor as scheduled step
- Build InstanceBufferSetIR materialization pipeline
- Create end-to-end instances2d test: color quantization → buffer assembly → render
- Validate color encoding with visual smoke test (1000 colored circles)

**Phase D: Paths2D Runtime** (2 sprints)
- Implement path command stream builder
- Implement path flattening kernel (uses FlattenPolicy from Phase B)
- Build PathGeometryBufferIR materialization pipeline
- Validate path encoding with visual test (simple curves)

---

## File References

### Will Create:
- `src/editor/ir/types/BufferDesc.ts`
- `src/editor/runtime/kernels/ColorQuantize.ts`
- `src/editor/runtime/kernels/__tests__/ColorQuantize.test.ts`
- `scripts/bench-color-quantize.ts`
- `design-docs/13-Renderer/09-Materialization-Steps.md`
- `design-docs/13-Renderer/10-Rust-WASM-Compatibility.md`

### Will Modify:
- `src/editor/ir/types/TypeDesc.ts` (documentation only)
- `claude_memory/02-type-system.md` (new section)

### Will Read (Reference):
- `design-docs/13-Renderer/03-Decisions-Color-PathFlattening-Basic3d.md`
- `design-docs/13-Renderer/04-Decision-to-IR.md`
- `design-docs/13-Renderer/05-Decisions-Upstream-Impacts.md`
- `src/editor/compiler/ir/stores.ts` (ValueStore/StateBuffer contracts)
- `src/editor/runtime/field/Materializer.ts` (existing materialization patterns)

---

**END OF PHASE B PLAN**
