# Definition of Done: IR Primitives Complete
**Generated**: 2025-12-30-162500
**Plan**: PLAN-2025-12-30-162500.md
**Topic**: ir-primitives-complete

---

## Phase 1: Make IR Execute (Sprints 1-6)

### Sprint 1: Time Architecture Foundation

**Deliverables**: TimeRoot config flows to IRBuilder, TimeModel available in Schedule, wrap detection uses actual delta

#### Acceptance Criteria

**1. TimeRoot Extraction**
- [ ] Pass 3 exists and runs in compiler pipeline
- [ ] Pass 3 extracts TimeModel from FiniteTimeRoot block: `{ kind: 'finite', durationMs: N }`
- [ ] Pass 3 extracts TimeModel from InfiniteTimeRoot block: `{ kind: 'infinite' }`
- [ ] Compile error emitted if zero TimeRoot blocks in patch
- [ ] Compile error emitted if multiple TimeRoot blocks in patch
- [ ] Error message clearly states "Exactly one TimeRoot required"

**2. TimeModel Threading**
- [ ] TimeModel stored in CompilerContext after Pass 3
- [ ] TimeModel passed to IRBuilder from CompilerContext
- [ ] Schedule type includes `timeModel: TimeModel` field
- [ ] Schedule populated with TimeModel from compilation
- [ ] Executor receives TimeModel from Schedule

**3. Wrap Detection with Delta**
- [ ] Cycle lane evaluation computes `prevPhase` and `currentPhase`
- [ ] Wrap detected when `currentPhase < prevPhase && dt > 0`
- [ ] Wrap event emitted with actual delta (not assumed constant)
- [ ] Wrap event includes direction metadata (forward/backward)
- [ ] No hardcoded infinite time assumptions in wrap logic

**4. Tests Pass**
- [ ] `pass3-timeroot.test.ts` passes (extraction + validation)
- [ ] `time-model-finite.test.ts` passes (finite duration behavior)
- [ ] `time-model-infinite.test.ts` passes (infinite time behavior)
- [ ] `wrap-detection.test.ts` passes (correct delta in events)
- [ ] `just check` passes (no TypeScript errors, lint, tests)

---

### Sprint 2: Default Sources & TimeModel Integration

**Deliverables**: Optional inputs work, TimeModel available in block lowering, time-based blocks emit real IR

#### Acceptance Criteria

**1. Default Source Materialization**
- [ ] Unwired optional port with scalar default uses default value
- [ ] Unwired optional port with Vec2 default uses Vec2 constant
- [ ] Unwired optional port with Color default uses Color constant
- [ ] Domain-aware default (e.g., field index) materializes correctly
- [ ] Dynamic default (e.g., TimeModel duration) computes from context

**2. Default Source Validation**
- [ ] Compile error if default source type mismatches port type
- [ ] Compile error if domain-aware default has invalid domain
- [ ] Compile warning if default source creates unexpected cycle
- [ ] Pass 4 validates default sources don't create illegal cycles

**3. TimeModel in Block Lowering**
- [ ] Block compilers receive TimeModel from IRBuilder
- [ ] SawOsc block uses TimeModel for wrap calculations
- [ ] TriOsc block uses TimeModel for wrap calculations
- [ ] SinOsc block uses TimeModel for wrap calculations
- [ ] No `sigTimeAbsMs()` placeholders in SawOsc/TriOsc/SinOsc lowering

**4. Tests Pass**
- [ ] `default-sources.test.ts` passes (various types work)
- [ ] `default-source-validation.test.ts` passes (type/domain errors)
- [ ] `dynamic-defaults.test.ts` passes (TimeModel-based defaults)
- [ ] `optional-ports.test.ts` passes (unwired ports work)
- [ ] `just check` passes

---

### Sprint 3: Bus System Revival

**Deliverables**: Buses actually evaluate, non-numeric bus combine works

#### Acceptance Criteria

**1. BusEval Steps Emitted**
- [ ] Schedule contains `StepBusEval` entry for each signal bus
- [ ] StepBusEval appears before first consumer in schedule order
- [ ] StepEventBusEval emitted for event buses (basic support)
- [ ] Bus ordering respects dependencies (publishers before consumers)

**2. Bus Evaluation Execution**
- [ ] Executor handles StepBusEval steps
- [ ] Executor reads all publisher slots for a bus
- [ ] Executor applies combine rule: sum works
- [ ] Executor applies combine rule: multiply works
- [ ] Executor applies combine rule: last works
- [ ] Executor writes combined value to bus slot

**3. Non-Numeric Bus Combine**
- [ ] Vec2 bus with sum combine: component-wise addition works
- [ ] Vec2 bus with multiply combine: component-wise multiply works
- [ ] Vec2 bus with last combine: uses last publisher value
- [ ] Color bus with blend combine: alpha composite works
- [ ] Color bus with multiply combine: color multiply works
- [ ] Color bus with last combine: uses last publisher color

**4. Pass 8 Link Resolution**
- [ ] All bus links resolved (publisher → bus → consumer)
- [ ] No orphaned bus references in IR
- [ ] Validation error if bus has consumers but no publishers

**5. Tests Pass**
- [ ] `bus-eval-emission.test.ts` passes (steps in schedule)
- [ ] `bus-combine-numeric.test.ts` passes (sum/multiply/last)
- [ ] `bus-combine-vec2.test.ts` passes (vec2 combines)
- [ ] `bus-combine-color.test.ts` passes (color blends)
- [ ] `bus-execution.test.ts` passes (end-to-end publish/subscribe)
- [ ] `just check` passes

---

### Sprint 4: Field-Signal Combination Primitives

**Deliverables**: JitterVec2, FieldMapVec2, FieldHueGradient work

#### Acceptance Criteria

**1. FieldExprZipSig Implementation**
- [ ] `FieldExprZipSig` IR node type defined
- [ ] FieldExprZipSig evaluator materializes field per element
- [ ] FieldExprZipSig evaluator evaluates signals once per frame
- [ ] FieldExprZipSig evaluator calls kernel with (fieldValue, ...signalValues)
- [ ] IRBuilder API includes method to create FieldExprZipSig nodes

**2. FieldExprMapIndexed Implementation**
- [ ] `FieldExprMapIndexed` IR node type defined
- [ ] FieldExprMapIndexed evaluator materializes domain to get count
- [ ] FieldExprMapIndexed evaluator calls kernel with (index, count, fieldValue)
- [ ] FieldExprMapIndexed evaluator returns transformed values
- [ ] IRBuilder API includes method to create FieldExprMapIndexed nodes

**3. Kernel Library Extension**
- [ ] `jitterVec2` kernel implemented: (pos: Vec2, amount: number, seed: number) => Vec2
- [ ] `fieldMapVec2` kernel implemented: (base: Vec2, offsetX: number, offsetY: number) => Vec2
- [ ] `hueGradient` kernel implemented: (index: number, count: number, hue: number) => Color
- [ ] Kernels registered in kernel table with TypeScript signatures

**4. Vec2 Field Opcodes**
- [ ] `fieldVec2Add` opcode works (vec2 + vec2)
- [ ] `fieldVec2Sub` opcode works (vec2 - vec2)
- [ ] `fieldVec2Mul` opcode works (vec2 * scalar or vec2 * vec2)
- [ ] `fieldVec2Dot` opcode works (vec2 · vec2 → scalar)
- [ ] `fieldVec2Length` opcode works (|vec2| → scalar)
- [ ] `fieldVec2Normalize` opcode works (vec2 / |vec2|)

**5. Block Compilation**
- [ ] JitterVec2 block compiles to FieldExprZipSig with jitterVec2 kernel
- [ ] FieldMapVec2 block compiles to FieldExprZipSig with fieldMapVec2 kernel
- [ ] FieldHueGradient block compiles to FieldExprMapIndexed with hueGradient kernel
- [ ] All three blocks produce correct output when executed

**6. Tests Pass**
- [ ] `field-expr-zip-sig.test.ts` passes (evaluation correct)
- [ ] `field-expr-map-indexed.test.ts` passes (indexed ops)
- [ ] `kernel-library.test.ts` passes (all kernels)
- [ ] `vec2-field-ops.test.ts` passes (arithmetic)
- [ ] `jitter-vec2-block.test.ts` passes (block works)
- [ ] `field-hue-gradient-block.test.ts` passes (block works)
- [ ] `just check` passes

---

### Sprint 5: Transform Chains & Field Reduce

**Deliverables**: Field adapters/lenses work, field aggregation works

#### Acceptance Criteria

**1. Transform Chain Evaluation**
- [ ] Transform chain evaluation no longer throws error
- [ ] ScaleBias transform: `(x) => x * scale + bias` works
- [ ] Map transform: `lerp(inMin, inMax, outMin, outMax, x)` works
- [ ] Clamp transform: `clamp(x, min, max)` works
- [ ] Wrap transform: `wrap(x, min, max)` works
- [ ] Multiple transform steps chain correctly (compose right-to-left)

**2. Transform Chain Types**
- [ ] Scalar transform chains work on numeric fields
- [ ] Vec2 transform chains work on vec2 fields
- [ ] Color transform chains work on color fields
- [ ] Identity transforms detected and optimized away
- [ ] Constant transform chains folded at compile time

**3. Field Reduce Implementation**
- [ ] Field reduce sum: materializes field and computes sum signal
- [ ] Field reduce average: computes average signal
- [ ] Field reduce min: computes minimum signal
- [ ] Field reduce max: computes maximum signal
- [ ] Field reduce product: computes product signal
- [ ] Vec2 field reduce: component-wise reduction works

**4. Placeholder Removal**
- [ ] No `fieldConst(0)` placeholders in FieldScaleBias block
- [ ] No `fieldConst(0)` placeholders in FieldMap block
- [ ] No `fieldConst(0)` placeholders in FieldReduce block
- [ ] Transform/reduce blocks emit actual IR nodes

**5. Tests Pass**
- [ ] `transform-chain-scalar.test.ts` passes (scaleBias, map, clamp, wrap)
- [ ] `transform-chain-vec2.test.ts` passes (vec2 transforms)
- [ ] `transform-chain-compose.test.ts` passes (multiple steps)
- [ ] `field-reduce-sum.test.ts` passes (sum reduction)
- [ ] `field-reduce-avg.test.ts` passes (average reduction)
- [ ] `field-reduce-minmax.test.ts` passes (min/max)
- [ ] `just check` passes

---

### Sprint 6: Type System Unification

**Deliverables**: Type system coherent, auto-coercion works

#### Acceptance Criteria

**1. TypeDesc Unification**
- [ ] Only one TypeDesc definition exists in codebase
- [ ] Canonical TypeDesc in `src/editor/ir/types.ts` (or designated file)
- [ ] Duplicate TypeDesc file deleted or merged
- [ ] All imports updated to use canonical TypeDesc
- [ ] `grep -r "interface TypeDesc" src/` shows only one definition

**2. Adapters Applied During Lowering**
- [ ] Number → Vec2 adapter (broadcast): automatically inserted
- [ ] Vec2 → Number adapter (magnitude): automatically inserted
- [ ] Number → Color adapter (grayscale): automatically inserted
- [ ] HSL → RGB adapter: automatically inserted
- [ ] Adapters wrap values in SignalExprTransform or FieldExprTransform
- [ ] Adapter table consulted for all type mismatches

**3. Lenses Applied During Lowering**
- [ ] Vec2.x lens: extracts x component from Vec2
- [ ] Vec2.y lens: extracts y component from Vec2
- [ ] Color.r lens: extracts red channel from Color
- [ ] Color.hue lens: extracts hue from Color (HSL)
- [ ] Vec2(x, y) constructor lens: builds Vec2 from components
- [ ] Color.rgb(r, g, b) constructor lens: builds Color from RGB

**4. World Promotion Rules**
- [ ] Scalar promotes to Signal (constant signal) automatically
- [ ] Scalar promotes to Field (constant field) automatically
- [ ] Signal promotes to Field (broadcast to all elements) automatically
- [ ] Field → Signal without explicit reduce emits compile error
- [ ] Error message suggests using field reduce operation

**5. Type Validation**
- [ ] Pass 4 validates all wire types match or have valid adapter
- [ ] Type mismatch error shows expected vs actual type
- [ ] Type mismatch error suggests available adapters
- [ ] Type mismatch error shows wire source and destination blocks

**6. Tests Pass**
- [ ] `type-desc-unified.test.ts` passes (single definition)
- [ ] `adapter-auto-apply.test.ts` passes (adapters inserted)
- [ ] `lens-extract.test.ts` passes (Vec2.x, Color.hue)
- [ ] `lens-construct.test.ts` passes (Vec2(x,y), Color.rgb)
- [ ] `world-promotion.test.ts` passes (Scalar→Signal, Signal→Field)
- [ ] `type-validation.test.ts` passes (clear errors)
- [ ] `just check` passes

---

## Phase 2: Complete Core Features (Sprints 7-10)

### Sprint 7: Stateful Signal Evaluators

**Deliverables**: PulseDivider, EnvelopeAD, delays work

#### Acceptance Criteria

**1. State Allocation**
- [ ] StateId allocated for each stateful signal block during compilation
- [ ] State schema declared (type, initial value) in Program IR
- [ ] StateBuffer created in executor with allocated slots
- [ ] StateId → slot mapping stable and deterministic

**2. DelayFrames Implementation**
- [ ] DelayFrames allocates circular buffer state (size N)
- [ ] DelayFrames writes current value to buffer each frame
- [ ] DelayFrames reads value from N frames ago
- [ ] Delayed signal lags input by exactly N frames

**3. PulseDivider Implementation**
- [ ] PulseDivider allocates counter state (int)
- [ ] PulseDivider increments counter on each input pulse
- [ ] PulseDivider emits output pulse when counter % divisor == 0
- [ ] PulseDivider with divisor=4 emits 1 pulse per 4 input pulses

**4. EnvelopeAD Implementation**
- [ ] EnvelopeAD allocates state: phase ('attack' | 'decay' | 'idle'), elapsedMs
- [ ] EnvelopeAD enters attack phase on trigger event
- [ ] EnvelopeAD outputs attack curve during attack phase
- [ ] EnvelopeAD transitions to decay phase after attack duration
- [ ] EnvelopeAD outputs decay curve during decay phase
- [ ] EnvelopeAD returns to idle after decay completes

**5. State Persistence and Migration**
- [ ] State persists across frames (values not reset each frame)
- [ ] On hot-swap: if StateId + type match, state value copied
- [ ] On hot-swap: if StateId or type differ, state reset to initial value
- [ ] State migration test: modify patch, state carries over correctly

**6. Time Derivation Fixes**
- [ ] `tAbsMs` is writable in signal evaluators (not read-only)
- [ ] Time-based stateful blocks write derived time correctly
- [ ] No crashes from attempting to write to read-only time

**7. Tests Pass**
- [ ] `delay-frames.test.ts` passes (N-frame delay)
- [ ] `pulse-divider.test.ts` passes (pulse division)
- [ ] `envelope-ad.test.ts` passes (attack/decay envelope)
- [ ] `integrate.test.ts` passes (accumulation over time)
- [ ] `state-buffer.test.ts` passes (allocation and persistence)
- [ ] `state-migration.test.ts` passes (hot-swap carryover)
- [ ] `just check` passes

---

### Sprint 8: Non-Numeric Signal & Field Support

**Deliverables**: Color/vec2 signals and fields work

#### Acceptance Criteria

**1. Non-Numeric Signal Slots**
- [ ] Vec2 signal stored in 2 consecutive float slots
- [ ] Vec3 signal stored in 3 consecutive float slots
- [ ] Color signal stored in 4 float slots (r, g, b, a)
- [ ] SlotId allocation tracks slot type and size
- [ ] Evaluators read/write multi-slot values correctly

**2. ColorHSLToRGB Kernel**
- [ ] ColorHSLToRGB kernel converts HSL to RGB correctly
- [ ] Kernel registered in kernel library
- [ ] Kernel has TypeScript signature for type checking
- [ ] ColorLFO block emits HSL signal + ColorHSLToRGB transform
- [ ] ColorLFO output is RGB color signal

**3. Non-Numeric Field Combine**
- [ ] Vec2 field combine with sum: component-wise addition
- [ ] Vec2 field combine with multiply: component-wise multiply
- [ ] Vec3 field combine: component-wise operations work
- [ ] Color field combine with alpha blend: correct alpha composite
- [ ] Color field combine with multiply: color multiply
- [ ] Color field combine with additive: additive blend
- [ ] Domain alignment validated for combined fields

**4. Tests Pass**
- [ ] `signal-vec2.test.ts` passes (Vec2 in ValueStore)
- [ ] `signal-color.test.ts` passes (Color in ValueStore)
- [ ] `color-hsl-to-rgb.test.ts` passes (HSL→RGB conversion)
- [ ] `color-lfo.test.ts` passes (ColorLFO produces RGB)
- [ ] `field-combine-vec2.test.ts` passes (Vec2 combine)
- [ ] `field-combine-color.test.ts` passes (Color blend)
- [ ] `just check` passes

---

### Sprint 9: Path Fields & Dynamic Operations

**Deliverables**: Path animations work

#### Acceptance Criteria

**1. Dynamic Path Fields**
- [ ] Circle path field accepts signal radius input
- [ ] Line path field accepts signal start/end inputs
- [ ] Path geometry rebuilds when signal inputs change
- [ ] Path geometry cached when signal inputs stable (optimization)
- [ ] Cache invalidated correctly when signals change

**2. Path Transform Operations**
- [ ] Path translate transform: offsets all points by Vec2
- [ ] Path rotate transform: rotates all points around center
- [ ] Path scale transform: scales all points from center
- [ ] Path transforms apply correctly to circle paths
- [ ] Path transforms apply correctly to line paths
- [ ] Path transforms apply correctly to polygon paths

**3. Path Transform Chaining**
- [ ] Multiple path transforms can be chained
- [ ] Chained transforms apply in correct order
- [ ] Example: translate → rotate → scale produces expected result

**4. Tests Pass**
- [ ] `path-field-circle.test.ts` passes (signal radius)
- [ ] `path-field-line.test.ts` passes (signal endpoints)
- [ ] `path-transform-translate.test.ts` passes (translate)
- [ ] `path-transform-rotate.test.ts` passes (rotate)
- [ ] `path-transform-scale.test.ts` passes (scale)
- [ ] `path-morph.test.ts` passes (morph between paths)
- [ ] `just check` passes

---

### Sprint 10: Event System & Discrete Signals

**Deliverables**: Clean event semantics, event buses work

#### Acceptance Criteria

**1. Event Store Separation**
- [ ] EventStore exists alongside ValueStore
- [ ] Events stored in EventStore (not ValueStore)
- [ ] Events cleared each frame (frame-latched)
- [ ] Events include trigger time within frame

**2. Wrap Event as Discrete Trigger**
- [ ] Wrap event emitted to EventStore (not ValueStore)
- [ ] Wrap event includes direction metadata (forward/backward)
- [ ] Wrap event includes delta value
- [ ] Event consumers read from EventStore for wrap events
- [ ] No false wrap events on scrub/seek

**3. Event Buses with Edge Detection**
- [ ] StepEventBusEval steps emitted in schedule
- [ ] Event bus collect all events in frame from publishers
- [ ] Rising edge detection: false → true transition detected
- [ ] Falling edge detection: true → false transition detected
- [ ] Any edge detection: any transition detected
- [ ] Combined event set delivered to subscribers

**4. Time-Driven Events**
- [ ] PulseDivider emits discrete pulse events (not continuous signal)
- [ ] EnvelopeAD emits attack complete event
- [ ] EnvelopeAD emits decay complete event
- [ ] ThresholdCross emits edge event when crossing threshold
- [ ] Events propagate through event buses correctly

**5. Tests Pass**
- [ ] `event-store.test.ts` passes (storage and retrieval)
- [ ] `wrap-event.test.ts` passes (wrap events work)
- [ ] `event-bus.test.ts` passes (bus combine and propagate)
- [ ] `edge-detection.test.ts` passes (rising/falling/any)
- [ ] `pulse-divider-event.test.ts` passes (pulse events)
- [ ] `threshold-cross-event.test.ts` passes (threshold events)
- [ ] `just check` passes

---

## Phase 3: Polish & Render Pipeline (Sprints 11-14)

### Sprint 11: Render Ordering & Attributes

**Deliverables**: Proper render order, rotation/scale work

#### Acceptance Criteria

**1. Z-Order Implementation**
- [ ] Render instances include z-order field
- [ ] Renderer sorts instances by z-order before drawing
- [ ] Static z-order (scalar) works
- [ ] Dynamic z-order from signal (per-frame) works
- [ ] Dynamic z-order from field (per-element) works
- [ ] Lower z-order renders behind higher z-order

**2. Extended Attributes**
- [ ] Instance buffer includes rotation field
- [ ] Instance buffer includes scale field (Vec2)
- [ ] Instance buffer includes opacity field
- [ ] Renderer applies rotation transform when drawing instances
- [ ] Renderer applies scale transform when drawing instances
- [ ] Renderer applies opacity when drawing instances

**3. Attribute Buffer Assembly**
- [ ] Attributes efficiently packed into typed arrays
- [ ] Optional attributes use defaults if not provided
- [ ] Default rotation: 0, default scale: (1, 1), default opacity: 1
- [ ] Optimized path for common case (position + color only)

**4. Tests Pass**
- [ ] `z-order-static.test.ts` passes (static z sorting)
- [ ] `z-order-field.test.ts` passes (per-element z)
- [ ] `rotation-attribute.test.ts` passes (rotation)
- [ ] `scale-attribute.test.ts` passes (scale)
- [ ] `opacity-attribute.test.ts` passes (opacity)
- [ ] `attribute-buffer.test.ts` passes (efficient packing)
- [ ] `just check` passes

---

### Sprint 12: Advanced Rendering

**Deliverables**: Bezier paths render, clipping works

#### Acceptance Criteria

**1. Curve Flattening**
- [ ] Quadratic bezier curves flatten to polyline approximation
- [ ] Cubic bezier curves flatten to polyline approximation
- [ ] Adaptive tessellation: subdivides until curvature below threshold
- [ ] Flatness test determines subdivision (not fixed subdivision)
- [ ] Flattened paths cached for reuse
- [ ] Cache invalidated when path changes

**2. Clipping/Masking Passes**
- [ ] ClipRegion IR type defined: rect, circle, path
- [ ] StepPushClip and StepPopClip steps in schedule
- [ ] Executor maintains clip stack
- [ ] Renderer applies rectangular clip regions
- [ ] Renderer applies circular clip regions
- [ ] Renderer applies path-based clip regions

**3. Clip Stack Management**
- [ ] Clip regions can be pushed (nested)
- [ ] Clip regions can be popped (restore previous)
- [ ] Multiple nested clip regions compose correctly (intersection)
- [ ] Clip stack empty at end of frame (balanced push/pop)

**4. Tests Pass**
- [ ] `curve-flatten-quadratic.test.ts` passes (quadratic bezier)
- [ ] `curve-flatten-cubic.test.ts` passes (cubic bezier)
- [ ] `curve-flatten-adaptive.test.ts` passes (adaptive subdivision)
- [ ] `clip-rect.test.ts` passes (rectangular clip)
- [ ] `clip-circle.test.ts` passes (circular clip)
- [ ] `clip-stack.test.ts` passes (nested clips)
- [ ] `just check` passes

---

### Sprint 13: PostFX & Materials

**Deliverables**: Post-processing effects, gradient fills

#### Acceptance Criteria

**1. PostFX Implementation**
- [ ] PostFX IR nodes defined: blur, bloom, sharpen, colorGrade
- [ ] Render pipeline renders to offscreen canvas
- [ ] Blur PostFX works with configurable radius
- [ ] Bloom PostFX works with threshold and intensity
- [ ] Sharpen PostFX works with configurable amount
- [ ] Color grade PostFX works (curves, saturation adjustments)

**2. PostFX Passes**
- [ ] Blur: Gaussian blur applied correctly
- [ ] Bloom: threshold → blur → additive blend sequence works
- [ ] Multiple PostFX passes compose correctly (sequential)
- [ ] Final composited result drawn to main canvas

**3. Material System**
- [ ] Material IR type defined: solid, linearGradient, radialGradient
- [ ] Solid color material works (existing)
- [ ] Linear gradient material renders correctly
- [ ] Radial gradient material renders correctly
- [ ] Conic gradient material renders correctly (bonus)
- [ ] Instances reference materials by MaterialId

**4. Tests Pass**
- [ ] `postfx-blur.test.ts` passes (blur effect)
- [ ] `postfx-bloom.test.ts` passes (bloom effect)
- [ ] `postfx-sharpen.test.ts` passes (sharpen effect)
- [ ] `postfx-color-grade.test.ts` passes (color grading)
- [ ] `material-linear-gradient.test.ts` passes (linear gradient)
- [ ] `material-radial-gradient.test.ts` passes (radial gradient)
- [ ] `just check` passes

---

### Sprint 14: Field Runtime Polish

**Deliverables**: Hot-swap stability, stable IDs, field buses

#### Acceptance Criteria

**1. Cache Invalidation on Hot-Swap**
- [ ] Field cache keys include schema version
- [ ] On hot-swap, schema changes detected (domain count, expression, slots)
- [ ] Cache entries invalidated when schema changes
- [ ] Cache entries reused when schema unchanged
- [ ] Fields re-materialized on next render after invalidation

**2. Domain Element ID Propagation**
- [ ] Domain elements have stable IDs
- [ ] Field expressions preserve element IDs through transforms
- [ ] Render instances tagged with element ID
- [ ] Element IDs stable across frames
- [ ] Element IDs enable per-element selection/history

**3. Complete Coercion Graph**
- [ ] Vec3 → Color coercion: maps XYZ to RGB
- [ ] Color → Vec3 coercion: maps RGB to XYZ
- [ ] Number → Boolean coercion: threshold (>0 = true)
- [ ] Boolean → Number coercion: 0/1
- [ ] String → Number coercion: parse (if valid)
- [ ] Coercion graph supports shortest path lookup

**4. Field Buses**
- [ ] Field buses support field values (not just signals)
- [ ] Field bus combine: element-wise combine with matching domains
- [ ] Domain mismatch in field bus emits compile error
- [ ] Error message shows mismatched domain sources
- [ ] Field bus use case: multiple position field publishers work

**5. Bus Ordering/Priority**
- [ ] Bus publishers have priority field
- [ ] Publishers sorted by priority before combine
- [ ] Last-wins combine respects priority (highest priority wins)
- [ ] Priority ordering deterministic

**6. Tests Pass**
- [ ] `cache-invalidation-hotswap.test.ts` passes (invalidation)
- [ ] `domain-element-id.test.ts` passes (stable IDs)
- [ ] `coercion-vec3-color.test.ts` passes (vec3 ↔ color)
- [ ] `coercion-number-bool.test.ts` passes (number ↔ bool)
- [ ] `field-bus.test.ts` passes (field bus combine)
- [ ] `bus-priority.test.ts` passes (priority ordering)
- [ ] `just check` passes

---

## Phase 4: Compiler Improvements (Sprints 15-16)

### Sprint 15: Compiler Pass Improvements

**Deliverables**: Better compile errors, feedback loop detection

#### Acceptance Criteria

**1. Enhanced Dependency Graph**
- [ ] Dependency graph includes time edges (derives from time)
- [ ] Dependency graph includes bus edges (depends on bus)
- [ ] Dependency graph includes state edges (previous frame state)
- [ ] Dependency graph includes memory edges (breaks cycles)
- [ ] Dependency graph visualizable for debugging (JSON export)

**2. SCC Analysis with Feedback Validation**
- [ ] Strongly connected components detected correctly
- [ ] Each SCC validated for at least one memory edge
- [ ] Pure cycle (no memory edge) emits clear compile error
- [ ] Error message shows cycle path (A → B → C → A)
- [ ] Error message suggests fix: "Add DelayFrames to break cycle"
- [ ] SCCs scheduled in topological order

**3. PhaseClock Semantic Alignment**
- [ ] PhaseClock block uses TimeModel for calculations
- [ ] PhaseClock respects finite vs infinite time mode
- [ ] PhaseClock validation ensures correct usage

**4. Scrub/Seek Handling**
- [ ] TimeCtx includes `scrubbed: boolean` field
- [ ] On scrub: `scrubbed` flag set to true
- [ ] Stateful nodes check `scrubbed` flag
- [ ] Stateful nodes handle scrub discontinuity (reset or interpolate)
- [ ] Event detection skips false edges during scrub

**5. Pass Timing Diagnostics**
- [ ] Each compiler pass instrumented with timing
- [ ] Pass timing reported in compile output (ms per pass)
- [ ] Slow passes identified (>100ms threshold)
- [ ] Timing diagnostics help optimize compiler

**6. Tests Pass**
- [ ] `dependency-graph-edges.test.ts` passes (edge types)
- [ ] `scc-valid-feedback.test.ts` passes (valid cycle)
- [ ] `scc-invalid-cycle.test.ts` passes (illegal cycle detected)
- [ ] `phase-clock-timemodel.test.ts` passes (uses TimeModel)
- [ ] `scrub-discontinuity.test.ts` passes (scrub handling)
- [ ] `pass-timing.test.ts` passes (timing reported)
- [ ] `just check` passes

---

### Sprint 16: Placeholder Elimination

**Deliverables**: All blocks emit real IR

#### Acceptance Criteria

**1. Comprehensive Placeholder Audit**
- [ ] `grep -r "sigTimeAbsMs()" src/editor/compiler/blocks/` executed
- [ ] `grep -r "fieldConst(0)" src/editor/compiler/blocks/` executed
- [ ] `grep -r "TODO.*placeholder" src/editor/compiler/blocks/` executed
- [ ] Complete list of blocks with placeholders created
- [ ] Placeholders categorized by reason and priority

**2. Signal Placeholders Fixed**
- [ ] All P0 signal placeholders replaced with real IR
- [ ] All P1 signal placeholders replaced with real IR
- [ ] Seeded PRNG used for random values (not Math.random)
- [ ] Signal operators used for math operations
- [ ] Each fixed block has unit test verifying real IR

**3. Field Placeholders Fixed**
- [ ] All P0 field placeholders replaced with real IR
- [ ] All P1 field placeholders replaced with real IR
- [ ] Field operators used for position/geometry/color
- [ ] Domain index mapping used where appropriate
- [ ] Each fixed block has unit test verifying real IR

**4. Block Lowering Tests**
- [ ] Each block in registry has lowering test
- [ ] Lowering test verifies block compiles without error
- [ ] Lowering test verifies IR is non-placeholder
- [ ] Lowering test verifies IR evaluates correctly
- [ ] Lowering test verifies output type matches expected

**5. Placeholder Audit Test**
- [ ] `placeholder-audit.test.ts` greps for placeholders
- [ ] Test fails if any production placeholders found
- [ ] Allowed placeholders: only in stubs or test fixtures
- [ ] Test passes: no `sigTimeAbsMs()` in production blocks
- [ ] Test passes: no `fieldConst(0)` in production blocks

**6. Tests Pass**
- [ ] `placeholder-audit.test.ts` passes (no production placeholders)
- [ ] Individual block lowering tests pass (TBD based on audit)
- [ ] `just check` passes

---

## Phase 5: Export & Determinism (Sprints 17-18)

### Sprint 17: Deterministic Replay Foundation

**Deliverables**: Reproducible animation output

#### Acceptance Criteria

**1. Seeded PRNG System**
- [ ] PRNG implementation (xorshift128+ or PCG) works
- [ ] PRNG produces same sequence given same seed
- [ ] PRNG state advances deterministically
- [ ] PRNG included in TimeCtx
- [ ] PRNG accessible to blocks needing randomness

**2. Replace Math.random() Usage**
- [ ] `grep -r "Math.random()" src/` executed
- [ ] All runtime `Math.random()` calls replaced with TimeCtx.prng
- [ ] Compile-time randomness uses seeded PRNG from patch seed
- [ ] Patch seed stored in patch metadata
- [ ] No non-deterministic randomness remains in production code

**3. State Serialization/Deserialization**
- [ ] StateBuffer serializes to JSON (all slots)
- [ ] Serialized state includes StateId, type, value
- [ ] StateBuffer deserializes from JSON
- [ ] Deserialized state restores to correct slots
- [ ] State migration handles schema changes gracefully

**4. Determinism Validation**
- [ ] Determinism test harness runs patch twice with same seed
- [ ] Output verified identical each frame (bit-for-bit)
- [ ] Test covers patches with random values
- [ ] Test covers patches with stateful nodes
- [ ] Test covers complex patches (many blocks)

**5. Tests Pass**
- [ ] `prng-deterministic.test.ts` passes (same sequence)
- [ ] `determinism-validation.test.ts` passes (identical output)
- [ ] `state-serialization.test.ts` passes (serialize/deserialize)
- [ ] `state-migration.test.ts` passes (schema change handling)
- [ ] `no-math-random.test.ts` passes (grep test: no Math.random)
- [ ] `just check` passes

---

### Sprint 18: Export Pipeline Implementation

**Deliverables**: Full export capability

#### Acceptance Criteria

**1. Image Sequence Export (PNG)**
- [ ] Export dialog UI allows PNG image sequence export
- [ ] User can configure frame range (start, end)
- [ ] User can configure frame rate (fps)
- [ ] User can configure resolution (width, height)
- [ ] Each frame rendered to canvas and exported to PNG blob
- [ ] All PNGs downloaded or zipped

**2. Image Sequence Export (WebP)**
- [ ] Export dialog allows WebP format selection
- [ ] WebP export works with configurable quality
- [ ] WebP files smaller than PNG (compression works)

**3. Video Export (WebCodecs)**
- [ ] Export dialog allows video export
- [ ] WebCodecs API availability detected
- [ ] Video export works if WebCodecs available
- [ ] Frames encoded to H.264 or VP9 stream
- [ ] Video exported as .mp4 or .webm
- [ ] Fallback: if WebCodecs unavailable, show image sequence option

**4. GIF Export**
- [ ] Export dialog allows GIF export
- [ ] Frames rendered and colors quantized (256 colors)
- [ ] GIF encoded with dithering option
- [ ] GIF export works with configurable quality
- [ ] GIF loops correctly

**5. Standalone HTML Player**
- [ ] Export dialog allows standalone player export
- [ ] Standalone player bundles patch IR + runtime
- [ ] Generated HTML file runs in browser without editor
- [ ] Player includes play/pause controls
- [ ] Player includes scrub bar
- [ ] Player respects autoplay and loop options

**6. Export UI**
- [ ] Export dialog shows progress bar during export
- [ ] Progress bar updates per frame
- [ ] Export can be cancelled
- [ ] Export can be paused and resumed (bonus)
- [ ] Preview shows first/last frame before export

**7. Determinism in Export**
- [ ] Exported image sequences are deterministic (same seed = same output)
- [ ] Exported videos are deterministic
- [ ] Exported GIFs are deterministic

**8. Tests Pass**
- [ ] `export-image-sequence.test.ts` passes (PNG/WebP)
- [ ] `export-video.test.ts` passes (if WebCodecs available)
- [ ] `export-gif.test.ts` passes (GIF)
- [ ] `export-standalone.test.ts` passes (player generation)
- [ ] `export-determinism.test.ts` passes (deterministic output)
- [ ] `just check` passes

---

## Phase 6: Debug System (Sprints 19-20)

### Sprint 19: IR-Compatible Debugging

**Deliverables**: Debug values visible in IR mode

#### Acceptance Criteria

**1. DebugDisplay IR Lowering**
- [ ] DebugDisplay block compiles to IR (not closure-only)
- [ ] DebugDisplay IR reads signal or field value
- [ ] DebugDisplay IR writes to debug probe registry
- [ ] DebugDisplay does not affect normal execution (non-intrusive)

**2. Debug Probe Registry**
- [ ] Global DebugProbeRegistry exists
- [ ] Probes registered with ProbeId, name, type, source
- [ ] Executor writes debug values to registry each frame
- [ ] UI reads debug values from registry via API
- [ ] Debug values shown in inspector panel

**3. StepDebugProbe Execution**
- [ ] StepDebugProbe steps emitted in schedule
- [ ] Executor handles StepDebugProbe steps
- [ ] Executor reads slot value for probe
- [ ] Executor writes value to debug registry
- [ ] Debug probes have minimal performance impact

**4. Debug API**
- [ ] `DebugAPI.getProbes()` returns list of all probes
- [ ] `DebugAPI.getProbeValue(probeId)` returns current value
- [ ] `DebugAPI.subscribe(probeId, callback)` calls callback on updates
- [ ] Debug API accessible from UI components

**5. Debug Inspector UI**
- [ ] Debug inspector panel shows all probes
- [ ] Each probe displays: name, type, current value
- [ ] Probe values update each frame
- [ ] Probes can be toggled on/off (disable/enable)

**6. Tests Pass**
- [ ] `debug-display-lowering.test.ts` passes (compiles to IR)
- [ ] `debug-probe-registry.test.ts` passes (registration/lookup)
- [ ] `debug-probe-execution.test.ts` passes (writes values)
- [ ] `debug-api.test.ts` passes (API reads values)
- [ ] `just check` passes

---

### Sprint 20: Advanced Visualization & Diagnostics

**Deliverables**: Comprehensive debugging tools

#### Acceptance Criteria

**1. Signal History Buffer + Waveform Viz**
- [ ] Debug registry maintains circular history buffer (last 500 frames)
- [ ] History buffer per debug probe (signal probes only)
- [ ] Waveform view component renders signal plot on mini canvas
- [ ] Waveform auto-scales or uses fixed range (user configurable)
- [ ] Scrub timeline to see historical signal values

**2. Field Visualization - Heatmap**
- [ ] Heatmap mode renders field values as color gradient
- [ ] Value range mapped to color scale (blue → green → yellow → red)
- [ ] User can configure value range (auto or manual)
- [ ] Heatmap updates each frame
- [ ] Heatmap works for numeric, vec2 (magnitude), color (brightness) fields

**3. Field Visualization - Histogram**
- [ ] Histogram mode shows distribution of field values
- [ ] Values bucketed into configurable number of bins
- [ ] Histogram displays as bar chart
- [ ] Histogram updates each frame
- [ ] Histogram helps identify outliers and distribution

**4. Field Inspector - Table View**
- [ ] Field inspector shows per-element values in table
- [ ] Table columns: element ID, index, value
- [ ] Table supports filter by value range
- [ ] Table supports sort by value
- [ ] Table pagination for large domains

**5. Runtime State Inspector**
- [ ] State inspector shows all StateBuffer slots
- [ ] Each slot displays: StateId, type, current value
- [ ] History graph for each stateful node (value over time)
- [ ] Reset button to reset individual state slots
- [ ] Export state to JSON button works
- [ ] Import state from JSON button works

**6. Compile Diagnostics Output**
- [ ] Compile output includes pass timings (from Sprint 15)
- [ ] Compile output includes node count (total nodes in patch)
- [ ] Compile output includes schedule size (total steps)
- [ ] Compile output includes warnings (unused nodes, etc.)
- [ ] Compile output includes optimization suggestions
- [ ] Diagnostics exportable to JSON

**7. Diagnostics Viewer UI**
- [ ] Diagnostics viewer panel displays compile diagnostics
- [ ] Pass timings shown in table or chart
- [ ] Warnings shown with severity (info, warning, error)
- [ ] Optimization suggestions actionable (links to docs)

**8. Tests Pass**
- [ ] `signal-history.test.ts` passes (history buffer)
- [ ] `waveform-viz.test.ts` passes (waveform rendering)
- [ ] `field-heatmap.test.ts` passes (heatmap visualization)
- [ ] `field-histogram.test.ts` passes (histogram computation)
- [ ] `state-inspector.test.ts` passes (inspection API)
- [ ] `compile-diagnostics.test.ts` passes (diagnostics output)
- [ ] `just check` passes

---

## Summary: Sprint Scope

**Phase 1 (Sprints 1-6)**: 30 deliverables, ~45-55 criteria
**Phase 2 (Sprints 7-10)**: 20 deliverables, ~40-50 criteria
**Phase 3 (Sprints 11-14)**: 16 deliverables, ~35-45 criteria
**Phase 4 (Sprints 15-16)**: 10 deliverables, ~25-30 criteria
**Phase 5 (Sprints 17-18)**: 12 deliverables, ~30-35 criteria
**Phase 6 (Sprints 19-20)**: 10 deliverables, ~25-30 criteria

**Total**: ~98 deliverables, ~220-245 acceptance criteria across 20 sprints

---

## Sprint Completion Definition

A sprint is considered **COMPLETE** when:
1. All deliverables implemented
2. All acceptance criteria met (checkboxes checked)
3. All tests pass
4. `just check` passes (typecheck + lint + test)
5. Manual smoke test confirms functionality
6. No regressions in existing features

A sprint is considered **BLOCKED** when:
- Dependencies not met
- Critical bug discovered
- Specification ambiguity requires clarification

A sprint is considered **AT RISK** when:
- Taking longer than estimated effort
- Significant technical challenges encountered
- Scope creep detected

---

## Verification Process

### Per Sprint Exit Criteria
1. Run `just check` - must pass
2. Run sprint-specific tests - all must pass
3. Manual verification of deliverables:
   - Create test patch exercising new feature
   - Verify output matches expected behavior
   - Test edge cases
4. Code review (if team size > 1)
5. Update sprint status in tracking system

### Per Phase Exit Criteria
1. All sprints in phase complete
2. Integration tests across phase features pass
3. Real-world patch using phase features works end-to-end
4. Performance acceptable (no major regressions, <16ms frame time target)
5. Documentation updated for new features

### Final Acceptance (All 20 Sprints)
1. IR mode feature parity with closure mode (except FieldFromExpression - documented limitation)
2. All 74 documented gaps addressed or explicitly marked won't-fix with rationale
3. Test coverage >90% on IR execution path
4. Export works deterministically (bit-for-bit identical output with same seed)
5. Debug tools functional and documented
6. User-facing documentation complete
7. Performance benchmarks met
8. No P0 or P1 bugs remaining

---

This Definition of Done provides concrete, testable criteria for every sprint and ensures rigorous completion standards throughout the 20-sprint roadmap.
