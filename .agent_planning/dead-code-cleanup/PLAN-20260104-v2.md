# Dead Code Migration Sprint - Focused Plan

**Generated**: 2026-01-04-005000
**Source**: EVALUATION-20260104.md
**Scope**: Complete adapter migration and compileBusAware migration, then remove deprecated modules

---

## Executive Summary

This sprint focuses on completing two critical migrations that will allow removal of deprecated compiler infrastructure:

1. **Adapter Migration** - Migrate `ModulationTableStore.ts` from deprecated `findAdapterPath` to `TRANSFORM_REGISTRY`, then remove `src/editor/adapters/` (2 files, 441 lines)

2. **compileBusAware Migration** - Migrate `compile.ts` from deprecated stub to actual pass-based compiler, then remove `compileBusAware.ts` (124 lines)

**Why This Matters**: These deprecated modules are stubs that return NotImplemented errors. They prevent the compiler from functioning correctly and represent incomplete migrations from an older architecture.

**Total Cleanup**: ~565 lines of deprecated code removed after successful migration.

---

## P0 (Critical) - Adapter Migration

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: None
**Spec Reference**: N/A - Internal refactoring
**Status Reference**: EVALUATION-20260104.md ยง "Deprecated Adapters Module"

### Description

`src/editor/adapters/autoAdapter.ts` (196 lines) implements deprecated adapter pathfinding logic. It's already been **ported** to `TRANSFORM_REGISTRY` - the deprecated version literally delegates to `TRANSFORM_REGISTRY.getAllAdapters()` internally.

**Only one caller remains**: `ModulationTableStore.ts:17` imports `findAdapterPath` and uses it to find adapter chains when binding cells.

**Migration Strategy**:
1. Replace `findAdapterPath(from, to, context)` call in ModulationTableStore with direct TRANSFORM_REGISTRY usage
2. TRANSFORM_REGISTRY already provides `findAdapters(from, to)` which returns adapters sorted by cost
3. Remove the policy checking logic (`isAutoAllowed`, `isSuggestAllowed`) - this is adapter-specific business logic, not core pathfinding
4. Delete `src/editor/adapters/` directory after migration

### Acceptance Criteria

- [ ] ModulationTableStore.bindCell() uses `TRANSFORM_REGISTRY.findAdapters()` instead of `findAdapterPath()`
- [ ] Policy checking logic (AUTO/SUGGEST/EXPLICIT) is reimplemented using TransformDef.policy field
- [ ] Adapter chain construction uses TransformDef interface, not legacy AdapterStep
- [ ] All existing modulation table bindings work identically to before migration
- [ ] `src/editor/adapters/autoAdapter.ts` deleted
- [ ] `src/editor/adapters/index.ts` deleted (if it exists)
- [ ] No imports of `src/editor/adapters/` remain in codebase
- [ ] `just check` passes (typecheck + lint + test)

### Technical Notes

**Current Code Flow**:
```typescript
// ModulationTableStore.ts:655
const result = findAdapterPath(column.type, row.type, 'listener');
if (!result.ok) { /* error */ }
adapterChain = result.chain;
```

**Target Code Flow**:
```typescript
const adapters = TRANSFORM_REGISTRY.findAdapters(column.type, row.type);
if (adapters.length === 0) { /* error */ }
// Build chain from TransformDef[]
const adapterChain = adapters.map(buildAdapterStep);
```

**Key Differences**:
- Old: Returns `AutoAdapterResult` with `ok/chain/reason/suggestions`
- New: Returns `TransformDef[]` sorted by cost
- Old: Policy checking (`AUTO/SUGGEST/EXPLICIT`) built into pathfinding
- New: Policy is `TransformDef.policy` field - check it separately

**Risk**: The deprecated `findAdapterPath` implements multi-hop pathfinding (can chain 2 adapters). Verify `TRANSFORM_REGISTRY.findAdapters()` supports this or add pathfinding logic if needed.

---

## P0 (Critical) - compileBusAware Migration

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: None
**Spec Reference**: design-docs/spec/compiler-architecture.md
**Status Reference**: EVALUATION-20260104.md ยง "Deprecated compileBusAware Module"

### Description

`src/editor/compiler/compileBusAware.ts` (124 lines) is a **stub** that returns NotImplemented errors. The comment block (lines 94-123) documents the original implementation structure and why it was removed.

**Two callers remain**:
1. `src/editor/compiler/index.ts:113` - re-exports `compileBusAwarePatch` for external consumers
2. `src/editor/compiler/compile.ts:38` - `compilePatch()` directly delegates to `compileBusAwarePatch()`

**This means `compilePatch()` currently NEVER succeeds** - it always returns compilation errors.

**Migration Strategy**:
1. Implement `compilePatch()` using the pass-based pipeline (passes 0-8)
2. Remove the `compileBusAwarePatch` delegation and stub
3. Delete `compileBusAware.ts` after migration

### Acceptance Criteria

- [ ] `compilePatch()` implemented using pass-based compiler pipeline:
  - [ ] Pass 0: Materialize (default sources)
  - [ ] Pass 1: Normalize (graph normalization)
  - [ ] Pass 2: Type Graph (type checking)
  - [ ] Pass 3: Time Topology
  - [ ] Pass 4: Dependency Graph
  - [ ] Pass 5: SCC Validation (cycle detection)
  - [ ] Pass 6: Block Lowering
  - [ ] Pass 8: Link Resolution (pass 7 removed - buses are just blocks)
- [ ] CompileResult returned matches expected signature (ok/errors/program/ir)
- [ ] Error aggregation from all passes works correctly
- [ ] IR emission controlled by `options.emitIR` flag
- [ ] `src/editor/compiler/compileBusAware.ts` deleted
- [ ] `src/editor/compiler/index.ts` removes re-export of `compileBusAwarePatch`
- [ ] Existing patches compile successfully (verify with test patches)
- [ ] `just check` passes (typecheck + lint + test)
- [ ] Browser runtime test: Load editor, create simple patch, verify it compiles

### Technical Notes

**Current Code Structure** (compile.ts:31-39):
```typescript
export function compilePatch(
  patch: CompilerPatch,
  registry: BlockRegistry,
  seed: Seed,
  ctx: CompileCtx,
  options?: { emitIR?: boolean }
): CompileResult {
  return compileBusAwarePatch(patch, registry, seed, ctx, options);
}
```

**Target Implementation**:
```typescript
export function compilePatch(
  patch: CompilerPatch,
  registry: BlockRegistry,
  seed: Seed,
  ctx: CompileCtx,
  options?: { emitIR?: boolean }
): CompileResult {
  const errors: CompileError[] = [];

  // Pass 0: Materialize
  // Pass 1: Normalize
  const normalized = pass1Normalize(patch, errors);
  if (!normalized) return { ok: false, errors };

  // Pass 2: Type checking
  const typed = pass2TypeGraph(normalized, errors);
  if (!typed) return { ok: false, errors };

  // Pass 3: Time topology
  const timeResolved = pass3TimeTopology(typed, errors);
  if (!timeResolved) return { ok: false, errors };

  // Pass 4: Dependency graph
  const depGraph = pass4DepGraph(timeResolved, errors);
  if (!depGraph) return { ok: false, errors };

  // Pass 5: SCC validation
  const validated = pass5CycleValidation(depGraph, errors);
  if (!validated) return { ok: false, errors };

  // Pass 6: Block lowering
  const lowered = pass6BlockLowering(validated, registry, seed, ctx, errors);
  if (!lowered) return { ok: false, errors };

  // Pass 8: Link resolution
  const linked = pass8LinkResolution(lowered, errors);
  if (!linked) return { ok: false, errors };

  // Build final program
  const program = buildProgramFromLinkedIR(linked, ctx);

  return {
    ok: true,
    errors: [],
    program,
    ir: options?.emitIR ? linked : undefined,
  };
}
```

**Critical Implementation Details**:

1. **Error Accumulation**: Each pass appends to `errors` array. If any pass returns null/undefined, compilation stops.

2. **Pass Signatures**: Check actual pass signatures in `src/editor/compiler/passes/` - the above is pseudocode. Some passes may have different parameter orders or return types.

3. **Pass 0 (Materialize)**: May not be a separate pass - might be integrated into Pass 1. Check `pass0-materialize.ts` to see if it's a real function or just docs.

4. **Seed/Registry/Ctx**: These parameters are used by Pass 6 (block lowering) for compiling block definitions. Ensure they're threaded through correctly.

5. **IR Emission**: The `options.emitIR` flag should include intermediate IR from pass 8 (LinkedGraphIR) in the result.

6. **Program Building**: There may be a separate step after pass 8 to build the final `Program<T>` object. Look for `buildSchedule` or similar in the passes directory.

**Testing Strategy**:

1. **Unit Tests**: Verify each pass is called with correct parameters
2. **Integration Tests**: Compile known-good patches and verify they produce expected programs
3. **Error Tests**: Compile invalid patches (missing TimeRoot, cycles, type errors) and verify correct error messages
4. **Browser Tests**: Use Chrome DevTools MCP to verify patches compile in the editor UI

**Migration Risk**: HIGH - This is core compiler infrastructure. The pass-based pipeline may have different semantics than the old `compileBusAware`. Thorough testing required.

---

## Recommended Sprint Execution Order

1. **Adapter Migration** (P0) - Lower risk, single caller, clear replacement API
2. **compileBusAware Migration** (P0) - Higher risk, core compiler, requires testing

---

## Risk Assessment

### High-Risk Items

**compileBusAware Migration**:
- **Risk**: Pass-based compiler may have incomplete implementation or different semantics
- **Mitigation**: Read all pass implementations before starting, verify each pass has tests, test incrementally

### Medium-Risk Items

**Adapter Migration**:
- **Risk**: TRANSFORM_REGISTRY may not support multi-hop pathfinding like old system
- **Mitigation**: Read TransformRegistry source, verify pathfinding capabilities, add if needed

### Dependencies

Both migrations are **independent** - they can be done in either order or in parallel.

---

## Success Metrics

- [ ] 565 lines of deprecated code removed
- [ ] Zero imports of `src/editor/adapters/` in codebase
- [ ] Zero imports of `compileBusAware.ts` in codebase
- [ ] Compiler functional (patches compile successfully)
- [ ] All tests pass (`just check`)
- [ ] Browser smoke test passes (load editor, create patch, verify compilation)
