# Comprehensive Sprint Plan: IR Compiler Migration & UI/UX Completion
**Generated**: 2025-12-28-035835
**Planner**: status-planner
**Source**: STATUS-2025-12-28-035835.md
**Provenance**: ROADMAP.md + topic STATUS files

---

## Executive Summary

This plan organizes **ALL incomplete work** across the IR Compiler Migration roadmap into **prioritized sprints**. The project is 75% complete on runtime infrastructure but has critical blockers preventing forward progress and deployment.

**Total Incomplete Work**: 31 items across 4 phases
**Estimated Total Effort**: 120-150 hours (15-19 working days)
**Critical Path**: Test stability → Runtime wiring → Undo-redo → UI architecture

**Priority Breakdown**:
- **P0 (Critical)**: 8 items - MUST fix for project to function
- **P1 (High)**: 9 items - Core features, blocks deployment
- **P2 (Medium)**: 9 items - Important enhancements
- **P3 (Low)**: 5 items - Nice-to-have polish

---

## Sprint 0: Foundation Stability (BLOCKER RESOLUTION)

**Goal**: Unblock all work by fixing test failures, wiring debug backend, and fixing critical undo bug

**Duration**: 12-16 hours (1.5-2 days)
**Dependencies**: NONE - these ARE the blockers
**Deliverables**: 3

---

### P0-1: Fix Test Failures (79 Tests)

**Status**: BLOCKER
**Effort**: Small (2-3 hours after clarification)
**Dependencies**: User clarification on TimeRoot spec
**Spec Reference**: design-docs/09-Blocks.md, design-docs/03-Buses.md • **Status Reference**: STATUS-2025-12-23-deep.md

#### Description
79 tests failing across 15 files, primarily due to TimeRoot refactoring (21 failures), missing exports (9 failures), and DiagnosticHub bugs (8 failures). Test failures block CI/CD and prevent confident deployment.

**Critical Ambiguity**: Spec says InfiniteTimeRoot should only have `systemTime` output, implementation has `phase`, `pulse`, `energy`. FiniteTimeRoot spec lists `localT`, implementation has `phase` instead. **User must clarify if spec or implementation is correct.**

#### Acceptance Criteria
- [ ] TimeRoot output specification ambiguity resolved (user decision documented)
- [ ] Export missing functions: extractTimeRootPorts, extractTimeRootAutoPublications, validateTimeRootDependencies
- [ ] Update TimeRoot test expectations to match chosen spec (21 tests fixed)
- [ ] Fix DiagnosticHub event subscription and disposal (2 tests fixed)
- [ ] Fix DiagnosticHub muting/unmuting logic (6 tests fixed)
- [ ] Implement exactly-one-TimeRoot validation (3 tests fixed)
- [ ] Fix ActionExecutor return value (1 test fixed)
- [ ] All 1956 tests passing (100% pass rate)
- [ ] Lint errors reduced below 100 (from 826)

#### Technical Notes
- If spec is authoritative: Implementation needs major refactor (remove extra outputs)
- If implementation is authoritative: Just update tests and docs (trivial fixes)
- DiagnosticHub.dispose() needs unsubscribe calls
- Validator integration incomplete - GraphCommitted events not triggering validation

---

### P0-2: Wire Debug HUD Backend

**Status**: BLOCKER for Phase 7
**Effort**: Medium (4-6 hours)
**Dependencies**: None
**Spec Reference**: design-docs/11-Debugger/1-NonTech-Overview.md • **Status Reference**: debugger/STATUS-2025-12-27-040000.md

#### Description
Debug HUD UI is 55% complete with all components rendered, but backend is 0% wired. Player.emitHealthSnapshot() never populates `busValues` field, so all value displays show "No value". Probe mode hover handlers don't exist.

**Critical Decision**: Where do bus values come from at runtime?
- Option A: BusStore.buses[].currentValue (requires adding field to Bus model)
- Option B: ScheduleExecutor.runtime.values slots (requires slot ID mapping)
- Recommendation: Option A (simplest for MVP)

#### Acceptance Criteria
- [ ] Determine bus value source (BusStore.currentValue or ScheduleExecutor slots)
- [ ] Add currentValue field to Bus model in BusStore (if Option A)
- [ ] Update ScheduleExecutor or runtime to populate Bus.currentValue
- [ ] Populate busValues in Player.emitHealthSnapshot() (iterate buses, call summarize())
- [ ] Add onMouseEnter/onMouseLeave handlers to BusChannel component
- [ ] Wire debugUIStore.setProbeTarget() on hover when probe mode active
- [ ] Add document-level mousemove listener for cursor position (throttled)
- [ ] Create unit tests for debug-ui components (6+ tests)
- [ ] Debug HUD shows live bus values (verified in DevTools)
- [ ] Probe mode highlights buses on hover with live value cards

#### Technical Notes
- ValueSummary type and summarize() function already exist in debug/types.ts
- BusBoard/BusChannel already render with probe-mode-aware classes
- DebugUIStore.updateHealthSnapshot() already subscribes to events
- Missing link: Player never provides the data

---

### P0-3: Fix replaceBlock() Undo Bug

**Status**: BROKEN - leaves orphaned blocks
**Effort**: Medium (6-8 hours)
**Dependencies**: None (critical path)
**Spec Reference**: Phase 9 undo-redo • **Status Reference**: undo-redo/STATUS-2025-12-27-phase3.md

#### Description
replaceBlock() is NOT migrated to runTx() but calls removeBlock() which IS migrated, creating double-transaction problem. Undo leaves orphaned new block in patch. This is a critical UX bug affecting block replacement workflow.

**Migration Strategy**: Single runTx that (1) adds new block, (2) copies preserved connections, (3) removes old block cascade.

#### Acceptance Criteria
- [ ] replaceBlock() migrated to use single runTx() transaction
- [ ] New block added via tx.add('blocks', newBlock)
- [ ] Connections copied via tx.add('connections', ...) for each
- [ ] Publishers/listeners copied via tx.add for each
- [ ] Old block removed via tx.removeBlockCascade(oldBlockId)
- [ ] BlockReplaced event emitted in correct order (before removeBlock for selection)
- [ ] suppressGraphCommitted pattern removed from connect/disconnect calls
- [ ] Undo replaceBlock → original block fully restored with all connections
- [ ] Redo replaceBlock → new block fully restored with copied connections
- [ ] 5+ integration tests added for replaceBlock undo/redo scenarios
- [ ] Manual test: replace block, undo, verify no orphans

#### Technical Notes
- Event ordering: BlockReplaced fires BEFORE removeBlock (intentional for UI selection)
- May need post-transaction event emission to preserve ordering
- removeBlock() now uses tx.removeBlockCascade - must not double-wrap

---

## Sprint 1: Runtime Execution Completion

**Goal**: Complete Phase 6 scheduled runtime execution layer

**Duration**: 16-20 hours (2-2.5 days)
**Dependencies**: Sprint 0 complete (tests passing)
**Deliverables**: 2-3

---

### P0-4: Complete Renderer-IR Pipeline

**Status**: 60% infrastructure, 0% wired
**Effort**: Medium (8-10 hours)
**Dependencies**: P0-1 (test stability)
**Spec Reference**: design-docs/12-Compiler-Final/08-Outputs, 17-Scheduler-Full • **Status Reference**: scheduled-runtime/STATUS-2025-12-26-102151.md

#### Description
Render infrastructure exists (renderSink API, buffer materialization) but NOT wired end-to-end. Blocks emit renderSink but NOT materialize steps for color/path fields. executeRenderAssemble is stub. PreviewPanel uses legacy render().

**Critical Gap**: IR rendering path is not exercised - the legacy closure path is still active.

#### Acceptance Criteria
- [ ] RenderInstances2D block lowering emits StepMaterializeColor for color field inputs
- [ ] RenderInstances2D block lowering emits StepMaterializePath for path field inputs (if path rendering)
- [ ] executeRenderAssemble reads render tree from rootNodeIndex output slot
- [ ] executeRenderAssemble validates render tree structure (sanity checks)
- [ ] executeRenderAssemble writes to stable output slot (step.outSlot)
- [ ] PreviewPanel calls Canvas2DRenderer.renderFrame() not legacy render()
- [ ] IRRuntimeAdapter uses pure IR mode (no SignalBridge fallback)
- [ ] Golden Patch renders correctly via IR path (Chrome DevTools verification)
- [ ] 8-10 tests added for executeRenderAssemble step executor
- [ ] 3-5 integration tests for end-to-end render pipeline

#### Technical Notes
- executeRenderAssemble is finalization boundary per spec (trivial implementation)
- Primary work: emit materialize steps in block lowering
- PreviewPanel currently has both IR and legacy paths - remove legacy

---

### P0-5: Implement Hot-Swap State Preservation

**Status**: NOT STARTED
**Effort**: Large (8-10 hours)
**Dependencies**: P0-4 (renderer complete for testing)
**Spec Reference**: design-docs/12-Compiler-Final/17-Scheduler-Full §9, 02-IR-Schema §22 • **Status Reference**: scheduled-runtime/STATUS-2025-12-26-102151.md

#### Description
No hot-swap logic exists. RuntimeState created fresh each compilation, discarding state/cache. This creates visual jank on edits - core UX requirement per spec. Implement state preservation via layout-hash matching.

**State Preservation Contract**: (stableKey, layoutHash) matching → preserve state cells. New slots initialized, removed slots dropped. Time continuity preserved.

#### Acceptance Criteria
- [ ] Create StateSwap.ts module with preserveState(oldRuntime, newRuntime, oldProgram, newProgram)
- [ ] Build stable key map from old state layout (blockId + port + role)
- [ ] Build stable key map from new state layout
- [ ] Copy state cells for matching (stableKey, layoutHash) pairs
- [ ] Initialize unmatched new cells with defaults from const pool
- [ ] Add RuntimeState.hotSwap(newProgram) method
- [ ] hotSwap() calls StateSwap.preserveState() for state transfer
- [ ] hotSwap() invalidates FrameCache (per-frame caches discarded)
- [ ] hotSwap() preserves tAbsMs and frameId (time continuity)
- [ ] Add ScheduleExecutor.swapProgram(newProgram) method
- [ ] State preserved correctly across hot-swap (14-22 tests)
- [ ] Manual test: edit patch, verify state persists (no jank)

#### Technical Notes
- Cache policy: per-frame caches discarded, cross-frame preserved if programId matches
- Stable key = blockId + portId + stateful role (integrate accumulator, delay ring, etc.)
- Time continuity: tAbsMs preserved, topology change handled specially

---

### P1-1: Verify executeNodeEval Necessity (Investigation)

**Status**: UNKNOWN - may be deprecated
**Effort**: Small (1-2 hours investigation + 4-6 hours implementation IF needed)
**Dependencies**: None
**Spec Reference**: design-docs/12-Compiler-Final/10-Schedule-Semantics §12.2 • **Status Reference**: scheduled-runtime/STATUS-2025-12-26-102151.md

#### Description
StepNodeEval defined in IR but compiler may not emit it. Modern IR uses higher-level steps (BusEval, Materialize). Must verify necessity BEFORE implementing.

**Decision Point**: If compiler emits NodeEval → implement. If not → mark deprecated, skip.

#### Acceptance Criteria
- [ ] Search compiled IR output for `kind: "nodeEval"` in test fixtures
- [ ] Check if Pass 6 (block lowering) emits StepNodeEval steps
- [ ] Document findings: NodeEval is ACTIVE or DEPRECATED
- [ ] IF ACTIVE: Implement opcode dispatch via SigEvaluator/FieldMaterializer (80-120 lines + 25-30 tests)
- [ ] IF DEPRECATED: Mark executeNodeEval.ts as deprecated in comments, add TODO for removal

#### Technical Notes
- If implementing: dispatch to SigEvaluator.evalSig() for signal nodes, FieldMaterializer for field nodes
- Wire inputSlots → evaluator inputs, evaluator outputs → outputSlots
- Handle stateReads/stateWrites references

---

## Sprint 2: Undo-Redo Completion

**Goal**: Complete Phase 9 Phase 3 - migrate all complex operations to transactions

**Duration**: 10-14 hours (1.5-2 days)
**Dependencies**: Sprint 0 P0-3 (replaceBlock fixed)
**Deliverables**: 2

---

### P1-2: Migrate Lens Operations to runTx

**Status**: NOT STARTED
**Effort**: Medium (4-6 hours)
**Dependencies**: P0-3 (replaceBlock pattern established)
**Spec Reference**: Phase 9 undo-redo Phase 3 • **Status Reference**: undo-redo/STATUS-2025-12-27-phase3.md

#### Description
7 lens editing methods use direct array mutations instead of runTx transactions. This breaks undo-redo for lens editing workflows (ModulationTable, ConnectionInspector).

**Methods to migrate**:
- PatchStore: updateConnection (base method), addLensToConnection, removeLensFromConnection, updateConnectionLens
- BusStore: addLensToStack, removeLensFromStack, clearLensStack

#### Acceptance Criteria
- [ ] PatchStore.updateConnection() uses runTx with tx.replace('connections', connectionId, nextConnection)
- [ ] addLensToConnection() calls updateConnection() with updated lensStack
- [ ] removeLensFromConnection() calls updateConnection() with filtered lensStack
- [ ] updateConnectionLens() calls updateConnection() with modified lens params
- [ ] BusStore.addLensToStack() uses runTx with tx.replace('listeners', listenerId, nextListener)
- [ ] removeLensFromStack() uses runTx with tx.replace for filtered stack
- [ ] clearLensStack() uses runTx with tx.replace for empty stack
- [ ] Undo addLensToConnection → lens removed from stack
- [ ] Undo removeLensFromConnection → lens restored to stack
- [ ] Undo updateConnectionLens → params restored
- [ ] 10+ integration tests for lens operation undo/redo

#### Technical Notes
- Lens methods are high-level wrappers around updateConnection/updateListener
- updateConnection is the key primitive - migrate it first
- lensStack is array - use spread/filter for immutable updates

---

### P1-3: Migrate addBlockAtIndex to runTx

**Status**: NOT STARTED
**Effort**: Small (2-3 hours)
**Dependencies**: P1-2 (transaction patterns established)
**Spec Reference**: Phase 9 undo-redo Phase 3 • **Status Reference**: undo-redo/STATUS-2025-12-27-phase3.md

#### Description
addBlockAtIndex() does direct blocks.push and lane modification, plus calls processAutoBusConnections (which creates nested transactions). Need atomic single transaction.

#### Acceptance Criteria
- [ ] addBlockAtIndex() uses single runTx transaction
- [ ] Block added via tx.add('blocks', block)
- [ ] Lane blockIds updated via tx (if lane transaction support exists)
- [ ] processAutoBusConnections integrated into same transaction (no nesting)
- [ ] Default sources created within transaction
- [ ] Undo addBlockAtIndex → block removed, lane restored
- [ ] 3+ integration tests for addBlockAtIndex undo/redo

#### Technical Notes
- Lane updates may need transaction support added to PatchStore
- processAutoBusConnections calls runTx-aware methods - need to refactor to accept tx parameter

---

## Sprint 3: UI Architecture Foundation

**Goal**: Complete semantic kernel integration and validation layer

**Duration**: 14-18 hours (2-2.5 days)
**Dependencies**: Sprint 0 complete (test stability critical)
**Deliverables**: 3

---

### P1-4: Complete Kernel Implementation

**Status**: 50% types, 0% execution
**Effort**: Large (8-10 hours)
**Dependencies**: P0-1 (test stability)
**Spec Reference**: design-docs/10-Refactor-for-UI-prep/PatchSemantics.md • **Status Reference**: ui-prep-refactor/STATUS-2025-12-27-030500.md

#### Description
Semantic kernel types defined (PatchKernel, TxBuilder, 26 Op types) but applyOp() is stub. Kernel NOT integrated with stores - PatchStore still mutates directly.

**Critical for**: Validation layer, undo-redo history tree, multi-view support

#### Acceptance Criteria
- [ ] Implement PatchKernel.applyOp() for all 26 op types (BlockAdd, BlockRemove, WireAdd, BusAdd, etc.)
- [ ] Generate inverse ops for undo (every op has inverse)
- [ ] TxBuilder.commit() applies ops and records history
- [ ] Wire PatchStore mutations to use kernel.tx() → op → apply
- [ ] Wire BusStore mutations to use kernel.tx() → op → apply
- [ ] SemanticGraph rebuilds on kernel.applyOp() (graph stays synchronized)
- [ ] Validator runs on kernel.applyOp() (preflight validation)
- [ ] All existing mutations work through kernel (no direct store mutations)
- [ ] 15-20 unit tests for applyOp() (each op type)
- [ ] 10+ integration tests for store → kernel → graph flow

#### Technical Notes
- Kernel is separate from runTx - they compose (kernel uses runTx internally)
- Inverse ops: BlockAdd → BlockRemove, WireAdd → WireRemove, etc.
- SemanticGraph must update incrementally (don't rebuild entire graph)

---

### P1-5: Implement TimeRoot Auto-Publish

**Status**: NOT STARTED
**Effort**: Small (3-4 hours)
**Dependencies**: P1-4 (kernel working)
**Spec Reference**: design-docs/10-Refactor-for-UI-prep/PhaseClock-Fix.md • **Status Reference**: ui-prep-refactor/STATUS-2025-12-27-030500.md

#### Description
CycleTimeRoot should auto-publish `phase → phaseA` and `wrap → pulse`. Currently TimeRoot blocks don't create these publishers automatically. Implicit phaseA binding for unconnected phase inputs also missing.

#### Acceptance Criteria
- [ ] CycleTimeRoot automatically creates publisher: phase → phaseA bus
- [ ] CycleTimeRoot automatically creates publisher: wrap → pulse bus
- [ ] FiniteTimeRoot automatically creates publisher: progress → progress bus (if spec confirmed)
- [ ] Implicit binding: unconnected phase inputs auto-listen to phaseA
- [ ] Auto-publishers have sortKey 0 (highest priority)
- [ ] Auto-publishers marked as system-managed (cannot be deleted by user)
- [ ] Golden Patch works without manual bus wiring
- [ ] 5-8 tests for auto-publish behavior

#### Technical Notes
- Auto-publishers created in block compiler or post-compilation pass
- Implicit binding: compiler detects unconnected phase inputs, adds listener
- May need "system" flag on Publisher to prevent user deletion

---

### P2-1: Integrate Validator with UI Mutations

**Status**: 60% validator exists, 0% integrated
**Effort**: Small (3-4 hours)
**Dependencies**: P1-4 (kernel working)
**Spec Reference**: design-docs/10-Refactor-for-UI-prep/DivergentTypes.md • **Status Reference**: ui-prep-refactor/STATUS-2025-12-27-030500.md

#### Description
SemanticGraph validator exists with cycle detection, type checking, port lookup. NOT integrated with UI mutations - invalid states still possible.

**Required**: Preflight validation before every mutation. Block/reject invalid operations.

#### Acceptance Criteria
- [ ] Validator.validate(graph) runs on every kernel.applyOp()
- [ ] Invalid operations rejected with clear error messages
- [ ] Preflight checks: canWire(from, to), canListen(bus, port), canPublish(port, bus)
- [ ] UI shows validation errors in DiagnosticHub
- [ ] Prevent: incompatible type connections, cycles without state, multiple TimeRoots
- [ ] 5-8 tests for preflight validation preventing invalid mutations

#### Technical Notes
- Validator already exists in semantic/validator.ts
- Integration point: kernel.applyOp() → SemanticGraph.update() → validator.validate()
- May need to return ValidationResult from applyOp() for UI feedback

---

## Sprint 4: UI/UX Enhancements

**Goal**: Add 3D config UI, wire lenses, primitives enforcement

**Duration**: 24-32 hours (3-4 days)
**Dependencies**: Sprint 3 complete (kernel working)
**Deliverables**: 4

---

### P1-6: Add 3D Config UI (Camera Block + Vec3 Control)

**Status**: 40% runtime, 0% UI
**Effort**: Medium (8-10 hours)
**Dependencies**: P0-1 (test stability), P1-4 (kernel for block registration)
**Spec Reference**: design-docs/7-Primitives/2-Type-System-3D-Safe.md • **Status Reference**: 3d-config-ui/STATUS-20251227-150000.md

#### Description
3D runtime (CameraStore, MeshStore, step executors) COMPLETE. UI/block layer 0%. Need Vec3 UI control, Camera block definition, compiler, and RenderInstances3D block.

#### Acceptance Criteria
- [ ] Create Vec3Editor control component (three labeled number inputs: X, Y, Z)
- [ ] Extend DefaultSourceControl to handle uiHint.kind: 'vec3'
- [ ] Add vec3, quat, mat4 types to CoreDomain (TypeDesc extension)
- [ ] Create Camera block definition with inputs: position (Signal<vec3>), lookAt (Signal<vec3>), fovY (Signal<number>), near/far (Signal<number>)
- [ ] Create Camera block compiler (lowerCamera) that generates CameraIR
- [ ] Add Camera to CameraTable during IR generation
- [ ] Create RenderInstances3D block that consumes camera ID, mesh ID, domain, position/rotation fields
- [ ] Wire RenderInstances3D to executeInstances3DProject step executor
- [ ] Manual test: Add Camera block, set position via Vec3Editor, verify 3D projection
- [ ] 8-10 tests for Camera block compilation and Vec3Editor

#### Technical Notes
- Vec3Editor similar to existing XY editor (two number inputs) but three
- Camera block follows existing domain block patterns (DomainN, GridDomain)
- Mesh block optional - can use default meshes initially
- Projection: 3D instances → 2D buffers via executeInstances3DProject

---

### P2-2: Implement Wire Lens Support

**Status**: 0% - wires have no lens support
**Effort**: Medium (10-12 hours)
**Dependencies**: P1-2 (lens operations migrated), Sprint 3 (kernel working)
**Spec Reference**: design-docs/10-Refactor-for-UI-prep/AdapterVsLens.md • **Status Reference**: wire-lenses/STATUS-2025-12-26.md

#### Description
Wire connections lack lensStack/adapterChain fields. Compiler doesn't apply lenses to wires. Creates inconsistent UX where lenses work on bus connections but not direct wires.

**Design Decision**: Treat wires as 'listener' scope (no lens definition changes needed).

#### Acceptance Criteria
- [ ] Extend Connection interface with optional lensStack and adapterChain fields
- [ ] Add patch migration for backward compatibility (fields optional, default to undefined)
- [ ] Add PatchStore.updateConnection(connectionId, updates) method
- [ ] Add PatchStore lens methods: addLensToConnection, removeLensFromConnection (reuse from P1-2 if wire-aware)
- [ ] Update compileBusAware wire resolution to apply lenses: applyAdapterChain → applyLensStack
- [ ] Pass full Connection objects through compiler (not just endpoints)
- [ ] Create shared LensChainEditor component (inline, not popover)
- [ ] Add lens section to WireConnectionView in ConnectionInspector
- [ ] Wire with scale lens multiplies value correctly
- [ ] 8-10 tests for wire lens application (unit + integration)

#### Technical Notes
- Lens scope: use existing 'listener' scope (wires consume values like listeners)
- Compiler: wire resolution similar to bus listener lens application
- UI: embed LensChainEditor inline in inspector (no "Done" button, changes immediate)

---

### P2-3: Add Primitives Enforcement

**Status**: 25% complete - NO enforcement
**Effort**: Small (6-8 hours)
**Dependencies**: Sprint 3 (kernel working for validation)
**Spec Reference**: design-docs/7-Primitives/3-Registry-Gating.md • **Status Reference**: primitives/STATUS-2025-12-27-030200.md

#### Description
Design docs specify closed primitive set with capability-based enforcement. NO enforcement exists - blocks lack capability field, validation absent, CI checks missing.

#### Acceptance Criteria
- [ ] Add capability field to BlockDefinition: 'time' | 'identity' | 'state' | 'render' | 'io' | 'pure'
- [ ] Add kernelId field to BlockDefinition (required if capability !== 'pure')
- [ ] Create src/editor/blocks/kernel-primitives.ts with KERNEL_PRIMITIVES allowlist
- [ ] Implement validateBlockDefinition() in registry-validation.ts
- [ ] Reject blocks claiming non-pure capability not in KERNEL_PRIMITIVES
- [ ] Enforce capability/form consistency (composites must be pure)
- [ ] Integrate validation into block registry loading
- [ ] Create scripts/check-kernel-primitives.ts for CI enforcement
- [ ] Add .github/workflows/check-primitives.yml GitHub Actions workflow
- [ ] All tests pass with new capability field (update 100+ block definitions)

#### Technical Notes
- capability field is BREAKING CHANGE - all BlockDefinition instances need update
- Pure blocks: operators, math, transforms (compile to AST only)
- Kernel blocks: TimeRoot, DomainN, RenderInstances (special capabilities)
- GridDomain: spec says composite, code says primitive - reconcile

---

### P2-4: Create Connection Inspector

**Status**: 0% - NOT STARTED (greenfield)
**Effort**: Large (12-16 hours)
**Dependencies**: P2-2 (wire lenses for embedded lens editor), Sprint 3 (kernel for state management)
**Spec Reference**: Feature request • **Status Reference**: connection-inspector/STATUS-2025-12-26.md

#### Description
No ConnectionInspector component exists. Need greenfield implementation for viewing/editing connection details with embedded lens editor (not popup).

**Entry points**: Port inspector connection list, ModulationTable cell click, BusInspector publisher/listener click

#### Acceptance Criteria
- [ ] Create ConnectionInspector component using InspectorContainer pattern
- [ ] Add selectedConnection to UIStore: {type: 'wire'|'publisher'|'listener', id: string}
- [ ] Handle wire connections: show endpoints, disconnect, swap (v2), lens editor
- [ ] Handle publisher connections: show block→bus, disconnect, lens editor
- [ ] Handle listener connections: show bus→block, enable/disable, lens editor
- [ ] Embed LensChainEditor inline (not popover, no "Done" button, changes immediate)
- [ ] Entry point: Port inspector connection list click → ConnectionInspector
- [ ] Entry point: ModulationTable cell click → ConnectionInspector (preserve double-click bind/unbind)
- [ ] Entry point: BusInspector publisher/listener click → ConnectionInspector
- [ ] Back navigation returns to previously viewed inspector (block/port/bus)
- [ ] 10-15 tests for ConnectionInspector component and state management

#### Technical Notes
- LensChainEditor currently designed for popover - refactor for inline use
- ModulationTable has complex click handling - add without breaking existing behavior
- selectedConnection mutually exclusive with selectedBlock/selectedPort/selectedBus

---

## Sprint 5: Polish & Optimization

**Goal**: Determinism enforcement, legacy cleanup, remaining UI prep specs

**Duration**: 16-20 hours (2-2.5 days)
**Dependencies**: Sprint 1-4 complete
**Deliverables**: 3-4

---

### P2-5: Enforce Determinism

**Status**: NOT STARTED
**Effort**: Small (4-6 hours)
**Dependencies**: Sprint 1 complete (renderer + hot-swap)
**Spec Reference**: design-docs/12-Compiler-Final/02-IR-Schema §21, 10-Schedule-Semantics §12.3 • **Status Reference**: ROADMAP.md

#### Description
IR runtime must be deterministic: same inputs → bitwise-identical outputs. Need stable topo sort, explicit tie-breaks, no Map/Set iteration, publisher ordering from IR.

#### Acceptance Criteria
- [ ] Topo sort uses stable tie-break rules (blockId lexicographic order)
- [ ] Publisher ordering from IR (sortKey + deterministic tie-break)
- [ ] No Map/Set iteration (use sorted arrays for deterministic order)
- [ ] Schedule generation is deterministic (same patch → same schedule)
- [ ] Same inputs produce bitwise-identical outputs (property test: run twice, compare)
- [ ] 5-8 tests for determinism (run compilation twice, compare IR/schedules/outputs)

#### Technical Notes
- Publisher ordering already in spec (sortKey from IR)
- Topo sort: Tarjan's SCC already deterministic if input order stable
- Map/Set iteration: replace with Array.sort() where needed

---

### P3-1: Remove Legacy Runtime

**Status**: NOT STARTED
**Effort**: Medium (6-8 hours)
**Dependencies**: Sprint 1 + Sprint 5 P2-5 (IR runtime proven)
**Spec Reference**: ROADMAP Phase 6 legacy-runtime-removal • **Status Reference**: ROADMAP.md

#### Description
Dual-emit mode still active - running both closure-based and IR evaluators. Remove closure runtime after IR validation complete.

#### Acceptance Criteria
- [ ] Remove closure exports from block compilers (all blocks use IR lowering only)
- [ ] Remove SignalBridge fallback from SigEvaluator
- [ ] Remove FieldBridge fallback from Materializer
- [ ] Remove dual-emit code paths in compileBusAware
- [ ] Remove legacy Player.render() method (use renderFrame() only)
- [ ] All tests pass with IR-only runtime (no closure fallback)
- [ ] Performance benchmark: IR runtime vs legacy (document in HANDOFF)

#### Technical Notes
- SignalBridge exists for gradual migration - no longer needed after full migration
- Closure exports in block definitions can be removed (MIGRATED_BLOCKS set)
- May reveal bugs hidden by closure fallback - thorough testing required

---

### P3-2: Complete Layout Separation

**Status**: 0% - lanes still in Patch
**Effort**: Medium (6-8 hours)
**Dependencies**: Sprint 3 P1-4 (kernel working)
**Spec Reference**: design-docs/10-Refactor-for-UI-prep/Layout-As-Projection.md • **Status Reference**: ui-prep-refactor/STATUS-2025-12-27-030500.md

#### Description
Lanes currently in Patch structure (semantic data). Should be in ViewState (projection). Enables multi-view support, deterministic auto-layout.

#### Acceptance Criteria
- [ ] Create ViewState store with blockPositions Map<BlockId, {x, y}>
- [ ] Create ViewState.lanes structure (UI projection, not semantic)
- [ ] Remove lanes from Patch type
- [ ] PatchStore no longer manages lane data
- [ ] ViewState provides layout queries: getLane(blockId), getPosition(blockId)
- [ ] Deterministic auto-layout algorithm (dagre/ELK-style left-to-right)
- [ ] Layout updates on topology change (block add/remove triggers re-layout)
- [ ] Patch serialization no longer contains lanes (UI-agnostic)
- [ ] 8-10 tests for ViewState layout management

#### Technical Notes
- Lanes are UI-specific concept (graph view projection)
- Patch must be serializable without UI data
- Auto-layout: TimeRoot left, Render right, minimize edge crossings

---

### P3-3: Lint Cleanup Pass

**Status**: 826 errors, 100 warnings
**Effort**: Small (4-6 hours)
**Dependencies**: Sprint 0 P0-1 (test failures fixed to avoid conflicts)
**Spec Reference**: Code quality • **Status Reference**: test-fixes/STATUS-2025-12-23-deep.md

#### Description
826 lint errors block clean commits and CI. Many are trivial (unused vars, any types). Need cleanup pass.

#### Acceptance Criteria
- [ ] Lint errors reduced below 50 (from 826)
- [ ] All unused imports removed
- [ ] All unused variables removed or prefixed with _
- [ ] `any` types replaced with specific types where possible
- [ ] ESLint warnings reduced below 20 (from 100)
- [ ] `just lint-fix` passes without errors
- [ ] CI lint check passes

#### Technical Notes
- Many errors are auto-fixable with `just lint-fix`
- `any` types may need gradual migration (don't break functionality)
- Unused vars often indicate incomplete refactors

---

### P3-4: Implement State Block Exposure (Optional)

**Status**: Runtime exists, NO UI blocks
**Effort**: Small (4-6 hours)
**Dependencies**: Sprint 4 P2-3 (primitives enforcement for capability)
**Spec Reference**: design-docs/7-Primitives/ • **Status Reference**: primitives/STATUS-2025-12-27-030200.md

#### Description
IntegrateBlock and HistoryBlock exist as runtime classes but NOT in block registry. Users cannot place them in patches. Need user-facing block definitions.

#### Acceptance Criteria
- [ ] Create IntegrateBlock definition in src/editor/blocks/state.ts
- [ ] Create HistoryBlock definition in src/editor/blocks/state.ts
- [ ] Add capability: 'state' to both definitions
- [ ] Connect to existing runtime implementations
- [ ] Add to block registry (appear in palette)
- [ ] Manual test: Add IntegrateBlock, wire signal input, verify accumulation
- [ ] Manual test: Add HistoryBlock, verify delay behavior
- [ ] 5-8 tests for state block compilation and execution

#### Technical Notes
- Runtime IntegrateBlock.ts already exists in compiler/unified/blocks/
- Need to create user-facing BlockDefinition wrappers
- May need UI controls for state initialization

---

## Dependency Graph

```
Sprint 0 (BLOCKERS):
  P0-1 (Test Failures) ────────┐
  P0-2 (Debug HUD) ────────────┼────> Sprint 1-5 proceed
  P0-3 (replaceBlock Undo) ────┘

Sprint 1 (Runtime):
  P0-1 ──> P0-4 (Renderer-IR) ──> P0-5 (Hot-swap) ──> Sprint 5 P3-1
                                       │
                                       └──> Sprint 5 P2-5 (Determinism)
  P1-1 (NodeEval investigation) ──> optional implementation

Sprint 2 (Undo-Redo):
  P0-3 ──> P1-2 (Lens Ops) ──> P1-3 (addBlockAtIndex)

Sprint 3 (UI Architecture):
  P0-1 ──> P1-4 (Kernel) ──> P1-5 (TimeRoot Auto-Publish)
                          │
                          └──> P2-1 (Validator Integration)

Sprint 4 (UI Enhancements):
  P0-1 + P1-4 ──> P1-6 (3D Config UI)
  P1-2 + Sprint 3 ──> P2-2 (Wire Lenses) ──> P2-4 (Connection Inspector)
  Sprint 3 ──> P2-3 (Primitives Enforcement)

Sprint 5 (Polish):
  Sprint 1 ──> P2-5 (Determinism) ──> P3-1 (Legacy Removal)
  Sprint 3 ──> P3-2 (Layout Separation)
  P0-1 ──> P3-3 (Lint Cleanup)
  P2-3 ──> P3-4 (State Blocks) [optional]
```

---

## Effort Summary by Priority

| Priority | Items | Estimated Hours | Percentage |
|----------|-------|----------------|------------|
| **P0 (Critical)** | 5 | 30-42 hours | 25-28% |
| **P1 (High)** | 6 | 44-56 hours | 37-39% |
| **P2 (Medium)** | 5 | 38-52 hours | 32-36% |
| **P3 (Low)** | 4 | 20-28 hours | 17-19% |
| **TOTAL** | 20 | 132-178 hours | 100% |

**Realistic Timeline**: 17-22 working days (3.5-4.5 weeks)

---

## Recommendations

### Sprint Execution Order

1. **Sprint 0** (IMMEDIATE) - Fixes blockers, unblocks all other work
2. **Sprint 1** - Completes runtime execution (enables 3D, export, hot-swap)
3. **Sprint 2** - Completes undo-redo (critical UX feature)
4. **Sprint 3** - Establishes UI architecture (foundation for future)
5. **Sprint 4** - Adds user-facing features (3D, lenses, inspector)
6. **Sprint 5** - Polish and optimization

### Parallelization Opportunities

**After Sprint 0 complete**, these can run in parallel:
- Sprint 1 (Runtime) + Sprint 2 (Undo-Redo) - different subsystems
- Sprint 3 (Kernel) + Sprint 1 P0-4 (Renderer) - minimal conflict

**Sprint 4 sub-items** can parallelize:
- P1-6 (3D UI) + P2-2 (Wire Lenses) - different features
- P2-3 (Primitives) independent

### Risk Mitigation

1. **Test Stability First**: P0-1 must complete before other work (prevents conflicts)
2. **Verify NodeEval**: P1-1 investigation early to avoid wasted effort
3. **Incremental Kernel**: P1-4 can be phased (applyOp per op type, integrate incrementally)
4. **Manual Testing**: Use Chrome DevTools for runtime verification (tests unreliable per spec)

---

## Deferred Work (Not in This Plan)

These items from ROADMAP marked PROPOSED but lower priority:

- **Phase 7.2+**: causal-edge-system, instrumentation-hooks, debug-drawer full implementation
- **Phase 8**: export-determinism, composite-library, replace-block-ui, technical-debt-cleanup, rust-wasm-prep
- **Phase 9.4+**: expandMacro migration, block positions + gesture buffer, IndexedDB persistence, history tree viz, variations UI
- **Phase 10 remaining specs**: 5+ UI prep specs (DiffSummary, StatePreservation, Performance, CanonicalLenses, etc.)

**Rationale**: Focus on core execution, undo-redo, and critical UI first. Polish and advanced features later.

---

## Success Metrics

**Sprint 0 Complete**:
- [ ] 100% test pass rate (1956/1956)
- [ ] Lint errors < 100
- [ ] Debug HUD shows live bus values
- [ ] replaceBlock undo leaves no orphans

**Sprint 1 Complete**:
- [ ] Golden Patch renders via IR path only
- [ ] Hot-swap preserves state across edits
- [ ] No legacy closure fallback

**Sprint 2 Complete**:
- [ ] All lens operations undoable
- [ ] replaceBlock + lens ops + addBlockAtIndex atomic

**Sprint 3 Complete**:
- [ ] All mutations go through kernel
- [ ] Validator prevents invalid operations
- [ ] TimeRoot auto-publishes to phaseA/pulse

**Sprint 4 Complete**:
- [ ] 3D Camera block placeable, configurable
- [ ] Wire lenses work like bus lenses
- [ ] Connection Inspector navigable from 3 entry points
- [ ] Primitives capability enforcement active

**Sprint 5 Complete**:
- [ ] Determinism verified (property tests pass)
- [ ] Legacy runtime removed
- [ ] Lanes out of Patch structure
- [ ] Lint errors < 50

**Overall Project Complete**:
- [ ] All 31 incomplete items delivered
- [ ] IR Compiler Migration 100% (Phases 1-7)
- [ ] Undo-Redo 100% (Phase 9 Phase 3+)
- [ ] UI/UX Architecture 80%+ (Phase 10 core complete)
