# Status Report - Canvas Renderer Implementation

**Topic**: Canvas 2D Renderer
**Topic Directory**: `.agent_planning/canvas-renderer/`
**Timestamp**: 2025-12-24 16:51:34
**Evaluation Profile**: web-app (render backend for visual editor)

---

## Cache Reuse Summary

- **Reused from eval-cache**:
  - `rendering-architecture.md` (FRESH, 2025-12-24 16:00) - RenderTree IR, Player loop, SvgRenderer, extension points
  - `test-infrastructure.md` (RECENT, 2025-12-23 05:13) - Test framework patterns
  - `architecture.md` (RECENT, 2025-12-23 05:13) - Core patterns, type system, stores
- **Fresh evaluation**: Canvas renderer spec analysis, block compiler patterns, integration points
- **Cache updates**: Will update `rendering-architecture.md` with Canvas-specific findings

---

## Executive Summary

**Overall**: 0% complete (design specs exist, no implementation started)
**Critical Issues**: 3 spec ambiguities that would cause incorrect implementation
**Infrastructure Ready**: Yes - all reusable pieces exist (RenderTree, Player, BlockCompiler pattern)
**Blockers**: Spec contradictions must be resolved before implementation

**What Exists**:
- Complete design specs: `12-CanvasBackend.md` (renderer contract), `13-CanvasRendererCode.md` (pseudocode block)
- Infrastructure: RenderTree IR, Player integration, BlockCompiler pattern, DefaultSource system
- Reference implementation: `RenderInstances2D` block (flawed but functional pattern)

**What's Missing**:
- New block: `Render2dCanvas` (does not exist)
- New renderer: `Canvas2DRenderer` class (does not exist)
- Integration: PreviewPanel renderer selection logic

**Gap**: Spec says "do it right with IR" but existing `RenderInstances2D` uses closures. This creates architectural tension.

---

## Spec Analysis: What the Design Says

### Spec 1: CanvasBackend.md (Renderer Responsibilities)

**Clear Requirements**:
- ✅ Canvas lifecycle: own `HTMLCanvasElement`, handle resize/DPR
- ✅ Execute draw commands deterministically
- ✅ Resource management: cache Path2D, images, gradients by stable keys
- ✅ Materialization boundary: renderer consumes buffers, NOT field expressions
- ✅ Command vocabulary: BeginFrame, SetTransform, DrawInstances2D, etc.

**Critical Constraints**:
- ❌ NO time logic, NO graph evaluation, NO adapter/lens chains
- ❌ NO domain semantics (doesn't know what "elements" are)
- ❌ NO sorting heuristics (order must be explicit in commands)
- ❌ Renderer sees buffers/handles, NOT FieldExpr (keep eval in VM)

**Implication**: This spec describes an **immediate-mode renderer** that executes **pre-lowered draw commands**.

---

### Spec 2: CanvasRendererCode.md (Block Pseudocode)

**Proposed Block**: `Render2dCanvas`

**Inputs** (from pseudocode):
- `domain: Domain` (required)
- `pos: Field<vec2>` (required)
- `radius: Field<number>` (required)
- `color: Field<color>` (required)
- `alpha: Field<Unit>` (optional)
- `rotation: Field<number>` (optional)
- `strokeWidth: Field<number>` (optional)
- `clearMode: Scalar<string>` (frame control - "clear" | "fade" | "none")
- `clearAlpha: Scalar<number>` (fade amount if fade mode)
- `blendMode: Scalar<string>` (Canvas blend mode)
- `zOrder: Scalar<number>` (compositor sorting)

**Output**:
- `out: RenderCmds` (special artifact type)

**Compiler Strategy** (from pseudocode):
```typescript
compileToIR(env: CompileEnv): NodeIR {
  // Returns NodeIR with OpCode: { kind: "Render2DCanvas" }
  // NOT a closure - data structure for VM to execute
}
```

**Runtime Strategy** (from pseudocode):
```typescript
exec_Render2DCanvas(vm: VM, node: NodeIR): void {
  // 1. Read scalar inputs (clearMode, blendMode, etc.)
  // 2. Read field handles (lazy FieldExpr)
  // 3. Materialize fields ONCE into ArrayBuffers
  // 4. Emit RenderCmd[] (stable structure)
  // 5. Intern commands in RenderCmdsStore
}
```

**Key Architectural Claim**: "This implementation assumes the 'do it right' architecture you're moving to: Program IR (no closures), Schedule + VM, Central ValueStore, Lazy FieldExpr until forced by a sink."

---

## Gap Analysis: Spec vs Reality

### Gap 1: Closure-Based vs IR-Based Architecture

**Spec Claims**:
- "Program IR (no closures)" (line 11)
- "Schedule + VM" (line 12)
- "Lazy FieldExpr until forced by a sink" (line 13)

**Current Reality** (`RenderInstances2D.ts`):
```typescript
compile({ params, inputs }) {
  // Returns a CLOSURE
  const renderFn = (tMs: number, ctx: RuntimeCtx): DrawNode => {
    const positions = positionField(seed, n, fieldCtx);  // Evaluates fields
    const radii = radiusField!(seed, n, fieldCtx);
    const colors = colorField(seed, n, fieldCtx);
    // Builds RenderTree
    return { kind: 'group', id: 'instances', children: circles };
  };
  return { render: { kind: 'RenderTree', value: renderFn } };
}
```

**This is NOT IR. This is a closure that:**
- Evaluates fields at render time (correct per architecture)
- Returns semantic RenderTree (correct)
- BUT: No VM, no OpCode, no NodeIR, no ValueStore

**Evidence of IR system**: `None found in codebase`
- No `src/editor/compiler/ir/` directory
- No `NodeIR` type in `compiler/types.ts`
- No `ValueSlot` or `OpCode` types
- No VM execution engine

**Conclusion**: The spec's "do it right" architecture **does not exist yet**. The pseudocode references a future system.

---

### Gap 2: RenderCmds vs RenderTree

**Spec Artifact Type**: `RenderCmds` (line 44, 77)
```typescript
type RenderCmds: { world: "special", domain: "renderCmds" }
```

**Current Reality**: No such artifact kind exists

**Artifact types in `compiler/types.ts`** (lines 319-375):
- ✅ `RenderTree` - exists (line 356: `(tMs, ctx) => DrawNode`)
- ✅ `RenderTreeProgram` - exists (line 343: `Program<RenderTree>`)
- ❌ `RenderCmds` - does NOT exist

**RenderTree is universal IR** (from cached architecture):
- Semantic scene graph (GroupNode, ShapeNode, EffectNode)
- Renderer-agnostic
- Both SVG and Canvas consume same RenderTree

**Implication**: Either:
1. Add new `RenderCmds` artifact kind (breaks universality of RenderTree)
2. Canvas renderer consumes RenderTree like SVG does (Option A from cache)
3. Spec is describing a future refactor, not current architecture

---

### Gap 3: Materialization Timing

**Spec Says** (CanvasBackend.md lines 39-46):
> "Renderer should be the main consumer that forces materialization of Fields into buffers only if the draw commands require it."
> "Renderer can accept either: already-materialized typed buffers (preferred), or a handle that can be materialized via runtime callback."
> "But: the renderer should not be evaluating FieldExpr itself if you want a Rust/WASM path cleanly. Keep eval in VM; renderer sees buffers/handles."

**Current RenderInstances2D Pattern**:
- Fields are evaluated EVERY FRAME in the closure
- No "materialization" concept - fields are functions that compute arrays
- No buffer pooling, no persistent storage

**Field Type** (`compiler/types.ts:154`):
```typescript
type Field<T> = (seed: Seed, n: number, ctx: CompileCtx) => readonly T[];
```

This is a **compute function**, not a handle to a materialized buffer.

**Question**: Does the spec's "materialization" mean:
1. Cache field results frame-to-frame (optimization)?
2. One-time evaluation at compile time (impossible - fields are time-varying)?
3. Evaluate once per frame and share buffers across sinks (not implemented)?

**Current behavior**: Fields are re-evaluated by every sink, every frame. No sharing.

---

## Ambiguities Found

| Area | Question Not Answered | How Spec Guessed | Impact |
|------|----------------------|------------------|--------|
| **Architecture** | Is the IR/VM system implemented, or is this spec describing future work? | Pseudocode assumes IR exists (NodeIR, OpCode, ValueStore, VM) | If IR doesn't exist, cannot implement as spec describes. Must use closure pattern like RenderInstances2D. |
| **Artifact Types** | Should Canvas use RenderTree (universal IR) or introduce RenderCmds (new parallel type)? | Spec uses RenderCmds, but RenderTree is current universal IR | Introducing RenderCmds breaks "one IR for all renderers" principle. Need decision on whether universality matters. |
| **Materialization** | What does "materialize fields into buffers" mean given fields are time-varying compute functions? | Spec implies fields become stable ArrayBuffers that renderer consumes | If fields are re-evaluated every frame (current reality), buffers aren't "materialized" - they're transient. Need clarity on buffering strategy. |
| **Block Design** | Should radius be an input (like spec) or a param (like current RenderInstances2D)? | Spec: input. Current impl: accepts Field OR Signal (hybrid) | User complaint: "takes radius as input when it shouldn't" suggests radius should be param. Spec says input. Which is right? |

---

## What Infrastructure Exists (Reusable)

### 1. RenderTree IR (Universal)

**Location**: `src/editor/runtime/renderTree.ts`

**Types**:
```typescript
type DrawNode = GroupNode | ShapeNode | EffectNode
type RenderTree = DrawNode

interface CircleGeom { kind: 'circle'; cx: number; cy: number; r: number }
interface Style { fill?: string; opacity?: number; ... }
```

**Status**: ✅ Complete, stable, works for both SVG and (hypothetical) Canvas

**Reusability**: 100% - Canvas renderer can consume RenderTree identically to SVG

---

### 2. Player (Runtime Loop)

**Location**: `src/editor/runtime/player.ts`

**Interface**:
```typescript
class Player {
  setFactory(factory: ProgramFactory<RenderTree>): void
  play(): void
  pause(): void
  scrubTo(tMs: number): void
  private tick(): void {
    // RAF loop: advance time, call program.signal(tMs, ctx), emit tree
    this.onFrame(tree, tMs);  // Callback to renderer
  }
}
```

**Integration Point** (PreviewPanel.tsx:118-121):
```typescript
const player = createPlayer(
  (tree: RenderTree, _tMs: number) => {
    renderer.render(tree);  // ← Renderer swap point
  },
  { width, height, onStateChange, onTimeChange, ... }
);
```

**Status**: ✅ Complete, renderer-agnostic

**Reusability**: 100% - change only the `renderer.render(tree)` callback

---

### 3. BlockCompiler Pattern

**Location**: `src/editor/compiler/types.ts:386-405`

**Interface**:
```typescript
interface BlockCompiler {
  type: string;
  inputs: readonly PortDef[];
  outputs: readonly PortDef[];
  compile(args: {
    id: BlockId;
    params: Record<string, unknown>;
    inputs: Record<string, Artifact>;
    ctx: CompileCtx;
  }): CompiledOutputs;
}
```

**Example** (`RenderInstances2D.ts`):
```typescript
export const RenderInstances2DBlock: BlockCompiler = {
  type: 'RenderInstances2D',
  inputs: [
    { name: 'domain', type: { kind: 'Domain' }, required: true },
    { name: 'positions', type: { kind: 'Field:vec2' }, required: true },
    // ...
  ],
  compile({ params, inputs }) {
    // Build closure that evaluates fields
    const renderFn = (tMs: number, ctx: RuntimeCtx): DrawNode => { ... };
    return { render: { kind: 'RenderTree', value: renderFn } };
  },
  outputs: [{ name: 'render', type: { kind: 'RenderTree' } }],
};
```

**Status**: ✅ Complete pattern, used by 40+ blocks

**Reusability**: 100% - Canvas block follows same structure

---

### 4. DefaultSource System

**Location**: `src/editor/stores/DefaultSourceStore.ts`

**Purpose**: Provides implicit values for unconnected inputs

**Interface**:
```typescript
interface DefaultSourceState {
  id: string;
  type: TypeDesc;
  value: unknown;
  uiHint?: UIControlHint;  // 'slider' | 'color' | 'text' | 'checkbox'
  rangeHint?: { min?: number; max?: number; step?: number };
}
```

**Status**: ✅ Complete, production system

**Reusability**: 100% - Canvas block inputs auto-get default sources

**Example**: If `radius` input is unconnected, DefaultSourceStore provides `{ value: 5, uiHint: 'slider', rangeHint: { min: 0, max: 100 } }`

---

### 5. SvgRenderer (Reference Implementation)

**Location**: `src/editor/runtime/svgRenderer.ts`

**Interface**:
```typescript
class SvgRenderer {
  constructor(svg: SVGSVGElement)
  render(tree: RenderTree): void {
    this.renderNode(root, tree, ctx);
  }
  private renderNode(parent: SVGGElement, node: DrawNode, ctx: RenderCtx): void {
    // Keyed reconciliation, traverse tree, update DOM
  }
}
```

**Strategy**:
- Keyed reconciliation (stable IDs → DOM mapping)
- Incremental updates
- Effect composition via `<g>` wrappers

**Status**: ✅ Production, works for current use cases

**Reusability**: Architecture pattern (traverse tree, apply effects) maps to Canvas with different implementation

---

## What Needs to be Created

### 1. Canvas2DRenderer Class

**Location**: `src/editor/runtime/canvasRenderer.ts` (new file)

**Contract** (if consuming RenderTree):
```typescript
export class Canvas2DRenderer {
  constructor(canvas: HTMLCanvasElement)

  setViewport(w: number, h: number, dpr: number): void {
    // Resize canvas, set transform
  }

  render(tree: RenderTree): void {
    // Clear canvas
    // Traverse tree, execute draw commands
  }

  private renderNode(node: DrawNode, ctx: RenderCtx): void {
    if (node.kind === 'shape') { /* draw geometry */ }
    if (node.kind === 'group') { /* recurse on children */ }
    if (node.kind === 'effect') { /* apply effect, render child */ }
  }
}
```

**Complexity**: ~200-300 lines (similar to SvgRenderer)

**Unknowns**:
- Effect parity: Can Canvas2D replicate all RenderTree effects?
  - ✅ Opacity: `ctx.globalAlpha`
  - ✅ Transform2D: `ctx.transform()`
  - ⚠️ Transform3D: No native support (would need projection or skip)
  - ⚠️ Filter: `ctx.filter` limited vs CSS filters
  - ✅ Clip: `ctx.clip()`

---

### 2. Render2dCanvas Block (if following spec)

**Location**: `src/editor/blocks/domain.ts` (BlockDefinition) + `src/editor/compiler/blocks/domain/Render2dCanvas.ts` (BlockCompiler)

**Option A: Spec-Compliant (IR/VM system)**

Requires IR infrastructure that doesn't exist:
- NodeIR, OpCode, ValueSlot types
- VM execution engine
- ValueStore, RenderCmdsStore

**Effort**: 2-4 weeks (build entire IR/VM system)

**Option B: Closure-Based (Current Pattern)**

Follow `RenderInstances2D` pattern:
- Inputs: domain, pos, radius, color (+ optional alpha, rotation, strokeWidth)
- Scalar inputs via DefaultSource: clearMode, blendMode, etc.
- Compile returns closure: `(tMs, ctx) => RenderTree`
- **Canvas-specific**: No difference from RenderInstances2D

**Wait, that's the problem**: If block returns RenderTree, and Canvas consumes RenderTree same as SVG, **there's no difference**. Canvas optimization (batched draws, reduced state changes) happens at renderer level, not block level.

**Implication**: Render2dCanvas block is UNNECESSARY if Canvas renderer consumes RenderTree.

---

### 3. PreviewPanel Renderer Selection

**Location**: `src/editor/PreviewPanel.tsx:110`

**Current** (SVG only):
```typescript
const renderer = new SvgRenderer(svg);
```

**With Canvas**:
```typescript
const canvasRef = useRef<HTMLCanvasElement>(null);
const rendererType = store.uiStore.settings.rendererType; // 'svg' | 'canvas'

const renderer = rendererType === 'canvas'
  ? new Canvas2DRenderer(canvasRef.current!)
  : new SvgRenderer(svgRef.current!);
```

**Complexity**: ~50 lines (add canvas element, conditional logic)

---

## Implementation Paths

### Path 1: Renderer-Level Swap (Minimal, Aligns with Reality)

**What**: Canvas2DRenderer consumes same RenderTree as SVG

**Steps**:
1. Create `Canvas2DRenderer` class (~200 lines)
2. Add renderer selection to PreviewPanel (~50 lines)
3. Export from `runtime/index.ts`

**No new blocks needed** - `RenderInstances2D` works for both renderers

**Effort**: 1-2 days
**Aligns with**: Cached rendering architecture (Option A)
**Breaks**: Nothing - RenderTree remains universal

**Pros**:
- Minimal change
- RenderTree universality preserved
- Works with existing blocks

**Cons**:
- Cannot optimize draw calls at block level (batching, instancing done in renderer)
- RenderTree traversal overhead every frame (no reconciliation benefit for Canvas)

---

### Path 2: Block-Level Canvas Commands (Spec-Compliant, Requires IR)

**What**: New `Render2dCanvas` block emits Canvas-specific draw commands

**Steps**:
1. Design IR system (NodeIR, OpCode, ValueStore, VM) - 1-2 weeks
2. Implement Render2dCanvas block compiler - 2-3 days
3. Implement Canvas2DRenderer command executor - 2-3 days
4. Add RenderCmds artifact type - 1 day
5. Modify Player to route RenderCmds vs RenderTree - 2 days

**Effort**: 3-4 weeks
**Aligns with**: Spec pseudocode
**Breaks**: RenderTree universality (now have two parallel render paths)

**Pros**:
- Flat command list (no tree traversal)
- Canvas-specific optimizations at block level
- Future Rust/WASM path cleaner

**Cons**:
- Massive architectural change
- Breaks "one IR for all renderers"
- IR system doesn't exist yet
- User must choose block type (RenderInstances2D vs Render2dCanvas)

---

### Path 3: Hybrid (Renderer Swap + Optimization Hints)

**What**: Canvas2DRenderer consumes RenderTree but with optimization metadata

**Steps**:
1. Add optional `meta` to RenderTree nodes (already exists: `meta?: Record<string, unknown>`)
2. RenderInstances2D emits optimization hints: `{ meta: { instanceCount: n, batched: true } }`
3. Canvas2DRenderer reads hints, applies fast paths

**Effort**: 1 week
**Aligns with**: Pragmatic optimization without breaking universality

---

## Spec Contradictions

### Contradiction 1: IR System Existence

**Spec line 11**: "This implementation assumes the 'do it right' architecture you're moving to: Program IR (no closures)"

**Reality**: No IR system exists. All blocks use closure pattern.

**Resolution needed**: Either:
1. Acknowledge spec describes future state, implement Path 1 now
2. Commit to building IR system before Canvas (3-4 week detour)

---

### Contradiction 2: Radius as Input vs Param

**User complaint**: "RenderInstances2D takes radius as input when it shouldn't"

**Spec says**: `radius: Field<number>` input (line 60)

**Current impl**: Accepts Field OR Signal (hybrid to support broadcast)

**Question**: What's the right design?
- **Input**: Flexible, can connect to any signal/field source
- **Param**: Simpler UX, single value set in inspector
- **Current hybrid**: Most flexible but confusing?

**Impact**: If radius should be param, spec is wrong. If input is right, user complaint is invalid.

---

### Contradiction 3: Materialization Strategy

**Spec implies**: Fields are materialized once per frame into stable buffers

**Reality**: Fields are functions that compute fresh arrays every call

**Spec line 163-169**:
```typescript
const posBuf = vm.fields.materializeVec2(posField, domain);
const radiusBuf = vm.fields.materializeF32(radiusField, domain);
```

But `Field<T> = (seed, n, ctx) => readonly T[]` - there's no "materialize to stable buffer" API.

**Resolution needed**: Define what "materialization" means in this architecture.

---

## Recommendations

### Recommendation 1: Clarify Spec vs Current State

**Action**: Update spec header with:
```
NOTE: This pseudocode describes a FUTURE architecture with IR/VM system.
Current implementation uses closure-based pattern (see RenderInstances2D).
Renderer-level Canvas support can be added TODAY without IR system.
```

### Recommendation 2: Implement Path 1 First (Renderer Swap)

**Why**:
- Works with current architecture
- Delivers Canvas rendering immediately
- Zero risk
- Can optimize later

**Then**: Decide if IR system is worth building (requires separate RFC/design)

### Recommendation 3: Resolve Radius Input Question

**Action**: Ask user:
> "RenderInstances2D currently accepts radius as either:
> - Field<number> input (different radius per element)
> - Signal<number> input (same animated radius for all)
>
> You mentioned radius 'shouldn't be an input'. Did you mean:
> 1. Radius should be a fixed param (single static value in inspector)?
> 2. Radius should ONLY accept Field (no Signal broadcast)?
> 3. Something else?
>
> This affects Canvas block design."

### Recommendation 4: Add Buffer Pooling (Separate Concern)

**If** performance requires reducing GC pressure from field evaluation:
- Add BufferPool to RuntimeCtx
- Fields materialize into pooled TypedArrays
- Sinks reuse buffers frame-to-frame

**But**: This is an optimization, not a blocker for Canvas renderer.

---

## What Could Not Be Verified

| Item | Why | User Can Check |
|------|-----|----------------|
| IR/VM system status | No code found, but may exist in progress elsewhere | Search codebase for `NodeIR`, `OpCode`, `ValueStore` types - do they exist in a branch or uncommitted work? |
| Intended radius design | User complaint vs spec disagree | Which is correct: radius as input (spec) or param (implied by complaint)? |
| Performance requirements | No benchmarks, no element count targets | How many elements must Canvas handle? 100? 1000? 10k? This determines if RenderTree traversal overhead matters. |
| 3D transform requirement | RenderTree supports Transform3D, Canvas2D cannot | Can Canvas renderer skip 3D transforms, or must it project to 2D? |

All other aspects verified against code and specs.

---

## Workflow Recommendation

- [x] **PAUSE** - Ambiguities need clarification before proceeding

### Clarification Needed Before Proceeding

#### Question 1: Architecture Target - IR or Closures?

**Context**: Spec pseudocode assumes IR/VM system with NodeIR, OpCode, ValueStore. No such system exists in codebase.

**How it was guessed**: Spec describes future architecture as if it's present.

**Options**:
- **Option A (Closure-based)**: Implement Canvas renderer that consumes RenderTree, works with current closure-based blocks. ~1 week effort, zero risk.
- **Option B (IR-based)**: Build IR/VM system first, then Canvas as spec describes. ~4 weeks effort, major architectural change.

**Impact of wrong choice**:
- If we build IR system but it's not actually planned, we've done 4 weeks of unnecessary work.
- If we skip IR and it IS planned, we'll have to refactor Canvas implementation later.

**Recommended**: Start with Option A (works today), defer IR decision to separate design phase.

---

#### Question 2: RenderCmds vs RenderTree Universality?

**Context**: Spec introduces `RenderCmds` artifact type separate from `RenderTree`. Current architecture has RenderTree as universal IR consumed by all renderers.

**How it was guessed**: Spec assumes parallel rendering paths are acceptable.

**Options**:
- **Option A (Universal RenderTree)**: Canvas consumes same RenderTree as SVG, preserving "one IR" principle.
- **Option B (Dual IR)**: Add RenderCmds type, Canvas-specific block emits different artifact than SVG blocks.

**Impact of wrong choice**:
- Option A: Cannot optimize draw calls at block level (all optimization in renderer). RenderTree traversal overhead.
- Option B: User must choose "SVG vs Canvas block", breaks renderer-agnostic goal.

**Recommended**: Option A unless there's strong performance reason for dual IR.

---

#### Question 3: What Does "Materialization" Mean?

**Context**: Spec says "materialize fields into buffers" but fields are time-varying functions, not static data.

**How it was guessed**: Spec implies fields become stable ArrayBuffers cached frame-to-frame.

**Options**:
- **Option A**: "Materialization" = one-time evaluation per frame, shared across sinks (optimization, not implemented)
- **Option B**: "Materialization" = just means "call the field function to get array" (current behavior)
- **Option C**: "Materialization" = compile-time conversion to static buffers (impossible for time-varying fields)

**Impact of wrong choice**:
- If Option A is intended, we need buffer sharing/pooling infrastructure.
- If Option B, term "materialization" is misleading (it's just evaluation).
- If Option C, spec is fundamentally incompatible with time-varying fields.

**Recommended**: Clarify semantics. If optimization needed, make it separate task.

---

#### Question 4: Radius Design - Input or Param?

**Context**: User says RenderInstances2D "takes radius as input when it shouldn't". Spec shows radius as input. Current impl supports both Field and Signal inputs.

**How it was guessed**: Spec assumed input flexibility is always better.

**Options**:
- **Option A**: Radius is input (current + spec) - can animate, vary per element, connect to buses
- **Option B**: Radius is param (user suggestion?) - single static value in inspector, simpler UX
- **Option C**: Radius accepts only Field, not Signal (stricter typing)

**Impact of wrong choice**:
- If user wants param but we use input, UX is cluttered.
- If user wants input flexibility but we make it param, capability is lost.

**Recommended**: Get user clarification on what "shouldn't be input" means.

---

## Deep Audit Findings

*(Not requested - would invoke `do:deep-audit` skill if comprehensive audit needed)*

---

## Runtime Assessment

**Attempted**: None - no Canvas implementation exists to run

**Result**: N/A

**Evidence**: Spec documents only, no code

---

## Test Suite Assessment

**Status**: No tests exist for Canvas renderer (implementation doesn't exist)

**When implemented, tests should cover**:
- Viewport resize / DPR handling
- Circle geometry rendering (primary use case)
- Opacity effects
- Transform2D effects
- Clear modes (clear, fade, none)
- Blend modes
- Empty domain (n=0)
- Large domain (n>1000, performance test)

---

## LLM Blind Spot Findings

*(Using web-app profile from evaluation-profiles)*

- [ ] **Empty domain**: n=0 elements - does Canvas handle gracefully? (Spec silent)
- [ ] **Second render**: Does Canvas state reset correctly between frames? (Spec doesn't mention ctx.save/restore balance)
- [ ] **Cleanup**: Are Path2D objects cached and evicted? (Spec mentions cache but no eviction policy)
- [ ] **Error messages**: What if canvas.getContext('2d') returns null? (Pseudocode throws generic error)

---

## Cache Updates

Writing to `.agent_planning/eval-cache/rendering-architecture.md`:
- Canvas renderer requirements from spec
- Ambiguity findings (IR system, RenderCmds, materialization)
- Integration points identified
