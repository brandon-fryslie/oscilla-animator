# Implementation Plan: Event System
Generated: 2025-12-20-143632
Source: STATUS-2025-12-20-143632.md
Design Doc: design-docs/4-Event-System/1-Events.md

## Executive Summary

Implement a typed, scoped event system to decouple cross-store coordination and enable the immediate use case of auto-clearing logs when macros are expanded. This is Phase A of the event system rollout, focusing on 6 core lifecycle events that provide immediate architectural value.

**Current State**: Direct coupling between stores (e.g., PatchStore would need to import logStore singleton to clear logs on macro expansion).

**Target State**: Event-driven coordination where stores emit domain events and listeners react independently.

**Immediate Value**: LogStore can listen for MacroExpanded event and auto-clear logs without PatchStore knowing about logging.

**Scope**: Phase A events only (MacroExpanded, PatchLoaded, PatchCleared, CompileSucceeded, CompileFailed, BlockAdded, BlockRemoved). Phase B events (bus lifecycle, playback, etc.) deferred per design doc.

**Total Work Items**: 7 (4 P0, 3 P1)

---

## P0 (Critical): Event System Foundation

### P0.1: Create Event Type Definitions

**Status**: Not Started
**Effort**: Small (2-3 hours)
**Dependencies**: None
**Spec Reference**: design-docs/4-Event-System/1-Events.md (lines 10-16, 107-111)
**Status Reference**: STATUS-2025-12-20-143632.md (MISSING: Event Type Definitions)

#### Description
Define the discriminated union type for all Phase A editor events. This provides compile-time type safety and exhaustiveness checking for event handlers.

#### Acceptance Criteria
- [ ] Create `src/editor/events/types.ts` file
- [ ] Define `EditorEvent` discriminated union with 7 event types:
  - MacroExpanded: `{ type: 'MacroExpanded'; macroType: string; createdBlockIds: string[] }`
  - PatchLoaded: `{ type: 'PatchLoaded'; blockCount: number; connectionCount: number }`
  - PatchCleared: `{ type: 'PatchCleared' }`
  - CompileSucceeded: `{ type: 'CompileSucceeded'; durationMs: number }`
  - CompileFailed: `{ type: 'CompileFailed'; errorCount: number }`
  - BlockAdded: `{ type: 'BlockAdded'; blockId: string; blockType: string; laneId: string }`
  - BlockRemoved: `{ type: 'BlockRemoved'; blockId: string; blockType: string }`
- [ ] Export `EventHandler<T>` type: `(event: T) => void`
- [ ] Export utility type `EventOfType<T extends EditorEvent['type']>` for extracting specific event types
- [ ] Add JSDoc comments explaining each event's purpose and when it's emitted
- [ ] TypeScript compilation succeeds with strict mode

#### Technical Notes
- Use discriminated union pattern for exhaustive type checking
- Keep event payloads minimal - only data consumers can't derive themselves
- macroType derived from expansion.blocks[0]?.type (first block in macro)
- All events are data objects (no methods, no side effects)

---

### P0.2: Implement EventDispatcher

**Status**: Not Started
**Effort**: Medium (4-6 hours)
**Dependencies**: P0.1
**Spec Reference**: design-docs/4-Event-System/1-Events.md (lines 65-87, 100-104)
**Status Reference**: STATUS-2025-12-20-143632.md (MISSING: Event System Infrastructure)

#### Description
Build the core event dispatcher that manages subscriptions and emissions. Must be synchronous, non-blocking, and isolate handler errors.

#### Acceptance Criteria
- [ ] Create `src/editor/events/EventDispatcher.ts` file
- [ ] Implement `EventDispatcher` class with three methods:
  - `emit<T extends EditorEvent>(event: T): void` - Emit event to all handlers
  - `on<T extends EditorEvent['type']>(type: T, handler: EventHandler<EventOfType<T>>): () => void` - Subscribe to specific event type
  - `subscribe(handler: EventHandler<EditorEvent>): () => void` - Subscribe to all events (for logging)
- [ ] Handler errors are isolated (try/catch around each handler invocation)
- [ ] Handler errors logged to console.error but don't break emit flow
- [ ] Unsubscribe functions work correctly (remove handler from list)
- [ ] Handlers called in registration order (deterministic)
- [ ] No async support (handlers are synchronous functions only)
- [ ] Create `src/editor/events/index.ts` to export public API
- [ ] Add JSDoc with usage examples

#### Technical Notes
- Store handlers in Map<EventType, Set<Handler>> for O(1) lookup
- Keep separate list for "all events" subscribers
- Error isolation critical - one bad handler can't break others
- No return values from handlers (non-blocking requirement)
- Consider adding debug mode that logs all emissions (development aid)

**Example Pattern**:
```typescript
export class EventDispatcher {
  private handlers = new Map<string, Set<EventHandler<any>>>();
  private globalHandlers = new Set<EventHandler<EditorEvent>>();

  emit<T extends EditorEvent>(event: T): void {
    // Emit to type-specific handlers
    const handlers = this.handlers.get(event.type);
    if (handlers) {
      for (const handler of handlers) {
        try {
          handler(event);
        } catch (error) {
          console.error(`Event handler error [${event.type}]:`, error);
        }
      }
    }

    // Emit to global handlers
    for (const handler of this.globalHandlers) {
      try {
        handler(event);
      } catch (error) {
        console.error('Global event handler error:', error);
      }
    }
  }

  on<T extends EditorEvent['type']>(
    type: T,
    handler: EventHandler<EventOfType<T>>
  ): () => void {
    if (!this.handlers.has(type)) {
      this.handlers.set(type, new Set());
    }
    const handlers = this.handlers.get(type)!;
    handlers.add(handler);

    // Return unsubscribe function
    return () => handlers.delete(handler);
  }

  subscribe(handler: EventHandler<EditorEvent>): () => void {
    this.globalHandlers.add(handler);
    return () => this.globalHandlers.delete(handler);
  }
}
```

---

### P0.3: Integrate EventDispatcher into RootStore

**Status**: Not Started
**Effort**: Small (2 hours)
**Dependencies**: P0.2
**Spec Reference**: design-docs/4-Event-System/1-Events.md (lines 95-99)
**Status Reference**: STATUS-2025-12-20-143632.md (MISSING: RootStore Event Integration)

#### Description
Add EventDispatcher as a property of RootStore, making it available to all stores via the root reference.

#### Acceptance Criteria
- [ ] Import `EventDispatcher` in `src/editor/stores/RootStore.ts`
- [ ] Add `events: EventDispatcher` property to RootStore class
- [ ] Instantiate EventDispatcher in RootStore constructor (before other stores)
- [ ] MobX observability NOT needed for events (events are not observable state)
- [ ] All child stores (PatchStore, etc.) can access via `this.root.events`
- [ ] TypeScript compilation succeeds
- [ ] No runtime errors on editor initialization

#### Technical Notes
- EventDispatcher created first so stores can set up listeners in constructors
- Events property is NOT made observable (events are ephemeral, not state)
- This makes events scoped per RootStore instance (good for testing)

**Code Change**:
```typescript
// In RootStore.ts
import { EventDispatcher } from '../events';

export class RootStore {
  events: EventDispatcher;  // NEW
  patchStore: PatchStore;
  // ... other stores

  constructor() {
    this.events = new EventDispatcher();  // First!
    this.patchStore = new PatchStore(this);
    // ... other stores
  }
}
```

---

### P0.4: Convert LogStore from Singleton to RootStore Instance

**Status**: Not Started
**Effort**: Medium (3-4 hours)
**Dependencies**: P0.3
**Spec Reference**: design-docs/4-Event-System/1-Events.md (line 13 - "Scoped")
**Status Reference**: STATUS-2025-12-20-143632.md (MISSING: LogStore Event Listener, Ambiguity 1)

#### Description
Convert LogStore from a global singleton to an instance owned by RootStore. This aligns with event system's scoping requirements and architectural consistency.

#### Acceptance Criteria
- [ ] Remove singleton export from `src/editor/logStore.ts`: Delete `export const logStore = new LogStore()`
- [ ] Add `logStore: LogStore` property to RootStore
- [ ] Instantiate LogStore in RootStore constructor: `this.logStore = new LogStore()`
- [ ] Update all imports that reference singleton `logStore`:
  - `src/editor/LogWindow.tsx` (line 10) - Pass store via props or context
  - `src/editor/compiler/integration.ts` (lines 605, 676, etc.) - Use `store.logStore`
  - Any other files importing singleton
- [ ] Create React context for RootStore if not exists (for LogWindow to access)
- [ ] TypeScript compilation succeeds
- [ ] All existing log functionality still works
- [ ] Manual test: Logs appear in UI, filters work, clear works

#### Technical Notes
- Breaking change to singleton pattern but improves testability
- May need RootStoreContext for React components to access logStore
- Check all files importing `logStore` singleton: `git grep "import.*logStore"`
- This enables LogStore to access `this.root.events` for listening

**Migration Pattern**:
```typescript
// Before (singleton):
import { logStore } from '../logStore';
logStore.info('compiler', 'Success');

// After (instance):
import type { RootStore } from '../stores/RootStore';
function compile(store: RootStore) {
  store.logStore.info('compiler', 'Success');
}
```

---

## P1 (High): Event Emissions

### P1.1: Emit Patch Lifecycle Events

**Status**: Not Started
**Effort**: Small (2 hours)
**Dependencies**: P0.3
**Spec Reference**: design-docs/4-Event-System/1-Events.md (lines 32-38)
**Status Reference**: STATUS-2025-12-20-143632.md (MISSING: Event Emissions)

#### Description
Add event emissions for patch loading, clearing, and macro expansion. These are the primary coordination points for UI and logging.

#### Acceptance Criteria
- [ ] In `RootStore.loadPatch()` (line 103), after all stores updated, emit:
  ```typescript
  this.events.emit({
    type: 'PatchLoaded',
    blockCount: this.patchStore.blocks.length,
    connectionCount: this.patchStore.connections.length,
  });
  ```
- [ ] In `RootStore.clearPatch()` (line 162), after patch cleared, emit:
  ```typescript
  this.events.emit({ type: 'PatchCleared' });
  ```
- [ ] In `PatchStore.expandMacro()` (line 229), before returning, emit:
  ```typescript
  this.root.events.emit({
    type: 'MacroExpanded',
    macroType: expansion.blocks[0]?.type ?? 'unknown',
    createdBlockIds: Array.from(refToId.values()),
  });
  ```
- [ ] All emissions happen AFTER state changes committed (not before)
- [ ] Events emitted even if no listeners registered (no conditional emission)
- [ ] TypeScript type checking passes (event payloads match type definitions)
- [ ] Manual test: Console logs events during patch operations (use global subscriber)

#### Technical Notes
- Emit after state changes to prevent reentrancy issues
- createdBlockIds extracted from refToId map built during expansion
- macroType is first block type (or 'unknown' if empty macro)
- Events are fire-and-forget (no return value checking)

---

### P1.2: Emit Compilation Events

**Status**: Not Started
**Effort**: Small (2 hours)
**Dependencies**: P0.3, P0.4
**Spec Reference**: design-docs/4-Event-System/1-Events.md (lines 46-50)
**Status Reference**: STATUS-2025-12-20-143632.md (MISSING: Event Emissions)

#### Description
Add event emissions for compilation success and failure. This decouples compile feedback from direct logging calls.

#### Acceptance Criteria
- [ ] In `CompilerService.compile()` success path (after line 676), emit:
  ```typescript
  this.events.emit({
    type: 'CompileSucceeded',
    durationMs: parseFloat(elapsed),
  });
  ```
- [ ] In `CompilerService.compile()` failure path (after line 692), emit:
  ```typescript
  this.events.emit({
    type: 'CompileFailed',
    errorCount: result.errors.length,
  });
  ```
- [ ] Keep existing logStore calls for now (migration to event listeners is Phase B)
- [ ] Events emitted for both unified and legacy compiler paths
- [ ] TypeScript type checking passes
- [ ] Manual test: Compile events logged in console (use global subscriber)

#### Technical Notes
- CompilerService needs access to RootStore to emit events
- May need to pass RootStore or events dispatcher to CompilerService
- elapsed is already calculated (line 673), convert to number
- Empty patch is NOT a failure (check line 680 logic)

**Architecture Note**: CompilerService needs refactor to receive RootStore:
```typescript
export function createCompilerService(store: RootStore): CompilerService {
  // ... existing setup
  return {
    compile(): CompileResult {
      // ... compilation
      if (result.ok) {
        store.events.emit({ type: 'CompileSucceeded', durationMs });
      } else if (!isEmptyPatch) {
        store.events.emit({ type: 'CompileFailed', errorCount });
      }
    }
  };
}
```

---

### P1.3: Emit Block Lifecycle Events

**Status**: Not Started
**Effort**: Small (1-2 hours)
**Dependencies**: P0.3
**Spec Reference**: design-docs/4-Event-System/1-Events.md (lines 38-39)
**Status Reference**: STATUS-2025-12-20-143632.md (MISSING: Event Emissions)

#### Description
Add event emissions when blocks are added or removed. Enables future features like analytics, undo tracking, etc.

#### Acceptance Criteria
- [ ] In `PatchStore.addBlock()` (line 178), before returning, emit:
  ```typescript
  this.root.events.emit({
    type: 'BlockAdded',
    blockId: id,
    blockType: type,
    laneId: laneId,
  });
  ```
- [ ] In `PatchStore.removeBlock()` (line 362), after block removed, emit:
  ```typescript
  const block = this.blocks.find(b => b.id === id);
  if (block) {
    this.root.events.emit({
      type: 'BlockRemoved',
      blockId: id,
      blockType: block.type,
    });
  }
  ```
- [ ] Events emitted AFTER state changes (block added to array, removed from array)
- [ ] BlockRemoved captures block type before removal (need to read before deleting)
- [ ] TypeScript type checking passes
- [ ] Manual test: Add/remove blocks, events logged in console

#### Technical Notes
- BlockRemoved needs block type but block is deleted - capture before deletion
- These events NOT emitted during macro expansion (macro emits MacroExpanded instead)
- addBlock already returns BlockId, emit just before return

**Pattern for BlockRemoved**:
```typescript
removeBlock(id: BlockId): void {
  const block = this.blocks.find(b => b.id === id);
  const blockType = block?.type ?? 'unknown';

  // Remove block
  this.blocks = this.blocks.filter(b => b.id !== id);
  // ... remove connections, lanes, etc.

  // Emit after state changes
  this.root.events.emit({
    type: 'BlockRemoved',
    blockId: id,
    blockType,
  });
}
```

---

## P2 (Medium): Event Listener Integration

### P2.1: Wire LogStore MacroExpanded Listener

**Status**: Not Started
**Effort**: Small (1 hour)
**Dependencies**: P0.4, P1.1
**Spec Reference**: design-docs/4-Event-System/1-Events.md (lines 120-135)
**Status Reference**: STATUS-2025-12-20-143632.md (MISSING: LogStore Event Listener)

#### Description
Set up LogStore to listen for MacroExpanded events and auto-clear logs if enabled. This is the immediate use case driving this work.

#### Acceptance Criteria
- [ ] In RootStore constructor, after creating logStore, wire listener:
  ```typescript
  this.events.on('MacroExpanded', () => {
    if (this.logStore.autoClearOnMacro) {
      this.logStore.clear();
    }
  });
  ```
- [ ] No import of logStore in PatchStore (decoupling achieved)
- [ ] Listener respects `autoClearOnMacro` setting
- [ ] Manual test: Load macro with auto-clear ON → logs cleared
- [ ] Manual test: Load macro with auto-clear OFF → logs preserved
- [ ] Manual test: Toggle setting, verify behavior changes

#### Technical Notes
- Listener set up in RootStore constructor (not in LogStore)
- This pattern keeps LogStore agnostic of event system
- autoClearOnMacro already exists (line 43 in logStore.ts)
- No need to store unsubscribe function (listener lives for app lifetime)

---

## P2 (Medium): Testing & Validation

### P2.2: Add Event System Unit Tests

**Status**: Not Started
**Effort**: Medium (4-5 hours)
**Dependencies**: P0.2
**Spec Reference**: design-docs/4-Event-System/1-Events.md (line 15 - "Testable")
**Status Reference**: STATUS-2025-12-20-143632.md (MISSING: Test Coverage)

#### Description
Comprehensive unit tests for EventDispatcher to ensure reliability and prevent regressions.

#### Acceptance Criteria
- [ ] Create `src/editor/events/__tests__/EventDispatcher.test.ts`
- [ ] Test: emit() calls registered handlers
- [ ] Test: on() returns unsubscribe function that works
- [ ] Test: subscribe() receives all event types
- [ ] Test: multiple handlers for same event type all called
- [ ] Test: handler errors are isolated (other handlers still run)
- [ ] Test: handler errors logged to console.error
- [ ] Test: handlers called in registration order
- [ ] Test: unsubscribing mid-emission doesn't break iteration
- [ ] Test: no handlers registered → emit succeeds (no-op)
- [ ] All tests pass with `just test`
- [ ] Test coverage >90% for EventDispatcher

#### Technical Notes
- Use vitest (existing test framework in project)
- Mock console.error to verify error logging
- Test edge cases: unsubscribe during emit, re-subscribe same handler, etc.

**Example Test Structure**:
```typescript
describe('EventDispatcher', () => {
  it('calls registered handlers when event emitted', () => {
    const dispatcher = new EventDispatcher();
    const handler = vi.fn();
    dispatcher.on('MacroExpanded', handler);

    dispatcher.emit({ type: 'MacroExpanded', macroType: 'test', createdBlockIds: [] });

    expect(handler).toHaveBeenCalledTimes(1);
    expect(handler).toHaveBeenCalledWith({ type: 'MacroExpanded', macroType: 'test', createdBlockIds: [] });
  });

  it('isolates handler errors', () => {
    const dispatcher = new EventDispatcher();
    const errorHandler = vi.fn(() => { throw new Error('test error'); });
    const successHandler = vi.fn();

    dispatcher.on('PatchLoaded', errorHandler);
    dispatcher.on('PatchLoaded', successHandler);

    const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
    dispatcher.emit({ type: 'PatchLoaded', blockCount: 0, connectionCount: 0 });

    expect(errorHandler).toHaveBeenCalled();
    expect(successHandler).toHaveBeenCalled(); // Still called!
    expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Event handler error'), expect.any(Error));
  });

  // ... more tests
});
```

---

### P2.3: Add Integration Tests

**Status**: Not Started
**Effort**: Medium (3-4 hours)
**Dependencies**: P1.1, P1.2, P1.3, P2.1
**Spec Reference**: design-docs/4-Event-System/1-Events.md (full integration)
**Status Reference**: STATUS-2025-12-20-143632.md (MISSING: Test Coverage)

#### Description
End-to-end tests verifying events are emitted correctly from stores and listeners respond as expected.

#### Acceptance Criteria
- [ ] Create `src/editor/__tests__/event-integration.test.ts`
- [ ] Test: Loading patch emits PatchLoaded with correct counts
- [ ] Test: Clearing patch emits PatchCleared
- [ ] Test: Expanding macro emits MacroExpanded with correct blockIds
- [ ] Test: Adding block emits BlockAdded with correct data
- [ ] Test: Removing block emits BlockRemoved with correct data
- [ ] Test: Successful compile emits CompileSucceeded
- [ ] Test: Failed compile emits CompileFailed
- [ ] Create `src/editor/__tests__/macro-log-clear.test.ts`
- [ ] Test: MacroExpanded clears logs when autoClearOnMacro = true
- [ ] Test: MacroExpanded preserves logs when autoClearOnMacro = false
- [ ] Test: Toggling autoClearOnMacro changes behavior
- [ ] All tests pass with `just test`

#### Technical Notes
- Create RootStore instance per test (isolated state)
- Use test macros from macros.ts
- Mock console.error for error isolation tests
- Test both success and failure paths

**Example Integration Test**:
```typescript
describe('Event Integration', () => {
  it('emits MacroExpanded when macro loaded', () => {
    const store = new RootStore();
    const events: EditorEvent[] = [];
    store.events.subscribe(e => events.push(e));

    const expansion: MacroExpansion = {
      blocks: [{ ref: 'test', type: 'TestBlock', laneKind: 'Program' }],
      connections: [],
    };

    store.patchStore.expandMacro(expansion);

    const macroEvent = events.find(e => e.type === 'MacroExpanded') as any;
    expect(macroEvent).toBeDefined();
    expect(macroEvent.macroType).toBe('TestBlock');
    expect(macroEvent.createdBlockIds).toHaveLength(1);
  });

  it('clears logs on macro expansion when enabled', () => {
    const store = new RootStore();
    store.logStore.info('test', 'Before macro');
    expect(store.logStore.entries).toHaveLength(2); // Initial + test log

    store.logStore.setAutoClearOnMacro(true);
    const expansion: MacroExpansion = { blocks: [], connections: [] };
    store.patchStore.expandMacro(expansion);

    expect(store.logStore.entries).toHaveLength(0); // Cleared!
  });
});
```

---

## Dependency Graph

```
P0.1 (Event Types)
  ↓
P0.2 (EventDispatcher) ←─────────────────┐
  ↓                                       │
P0.3 (Integrate into RootStore)           │
  ↓                     ↓                 │
P0.4 (LogStore Instance)  P1.1 (Patch Events)
  ↓                     ↓
P2.1 (Wire Listener)  P1.2 (Compile Events)
  ↓                     ↓
P2.3 (Integration Tests)  P1.3 (Block Events)
                          ↓
                        P2.2 (Unit Tests)
                          ↓
                        P2.3 (Integration Tests)
```

**Critical Path**: P0.1 → P0.2 → P0.3 → P1.1 → P2.1 → P2.3

---

## Recommended Sprint Planning

### Sprint 1: Foundation (P0 items)
**Goal**: Event system infrastructure in place, LogStore integrated
**Duration**: 2-3 days
**Items**: P0.1, P0.2, P0.3, P0.4
**Deliverable**: EventDispatcher working, RootStore has events, LogStore is instance
**Acceptance**: Can emit events, can subscribe, LogStore accessible via RootStore

### Sprint 2: Emissions (P1 items)
**Goal**: All lifecycle events emitted
**Duration**: 1-2 days
**Items**: P1.1, P1.2, P1.3
**Deliverable**: Patch, compile, and block events emitted at correct times
**Acceptance**: Global subscriber logs all events during normal operations

### Sprint 3: Integration & Testing (P2 items)
**Goal**: MacroExpanded listener working, full test coverage
**Duration**: 1-2 days
**Items**: P2.1, P2.2, P2.3
**Deliverable**: Log auto-clear works, comprehensive test suite
**Acceptance**: All tests pass, manual test confirms log clearing on macro load

**Total Estimated Duration**: 4-7 days

---

## Risk Assessment

### High-Risk Items
**None** - All work is additive, well-specified, and has clear rollback paths.

### Medium-Risk Items
1. **P0.4 (LogStore singleton removal)** - Touches multiple files
   - **Mitigation**: Comprehensive grep for all imports, test thoroughly
   - **Rollback**: Keep singleton pattern, pass RootStore to listeners externally

2. **P0.2 (EventDispatcher error isolation)** - Critical correctness requirement
   - **Mitigation**: Extensive unit tests for error scenarios
   - **Rollback**: N/A (core requirement, must be correct)

### Low-Risk Items
All P1 items (emissions) - Additive changes, no existing code broken.

---

## Blockers and Questions

### Question 1: macroId Format
**Question**: Should MacroExpanded.macroType be first block type or some other identifier?
**Proposed Solution**: Use `expansion.blocks[0]?.type ?? 'unknown'`
**Impact**: LOW - Just for logging/debugging, not critical

### Question 2: CompilerService Refactoring
**Question**: CompilerService is a factory function, not tied to RootStore. How to emit events?
**Proposed Solution**: Pass RootStore to `createCompilerService(store)`, access `store.events`
**Impact**: MEDIUM - Requires signature change
**Alternative**: Return events from compile() and emit externally (less clean)

### Question 3: React Context for LogStore
**Question**: How should LogWindow.tsx access logStore after singleton removal?
**Proposed Solution**: Create RootStoreContext, use `useContext` in LogWindow
**Impact**: MEDIUM - Requires React context setup
**Alternative**: Pass store as prop from parent (more verbose)

**Recommendation**: Address these during implementation, all have clear solutions.

---

## Success Metrics

### Functional Metrics
- [ ] All 7 Phase A events defined and emitted
- [ ] MacroExpanded → LogStore.clear() working
- [ ] No console errors on event emission
- [ ] Event handler errors don't crash app

### Code Quality Metrics
- [ ] `just typecheck` passes
- [ ] `just lint` passes
- [ ] `just test` passes with >80% coverage on event code
- [ ] No circular dependencies introduced

### User-Facing Metrics
- [ ] Logs auto-clear when macro loaded (if setting enabled)
- [ ] Setting toggle works correctly
- [ ] No performance degradation (event system is fast)

---

## Phase B Preview (Future Work)

Events deferred to Phase B per design doc:
- CompileStarted (before compilation begins)
- ProgramSwapped (hot reload complete)
- PlaybackStarted/Stopped (transport state)
- BindingAdded/Removed (bus listener creation)
- BusCreated/Deleted (bus lifecycle)
- TimeRootChanged (time topology change)
- CompositeEdited/Saved (composite authoring)

**Rationale**: Phase A provides immediate value (log clearing) and establishes patterns. Phase B events add more coordination points after pattern proven.

---

## Notes for Implementer

1. **Order Matters**: Do P0 items in order (types → dispatcher → integration → LogStore).
2. **Test Early**: Write EventDispatcher tests alongside implementation (TDD style).
3. **Grep is Your Friend**: Finding all logStore singleton imports is critical for P0.4.
4. **Emit After State**: Always emit events AFTER state changes committed.
5. **No Async**: If tempted to make handlers async, STOP and reconsider.
6. **Error Isolation**: Test the error isolation carefully - critical for robustness.
7. **Documentation**: Add JSDoc examples showing how to use events.
