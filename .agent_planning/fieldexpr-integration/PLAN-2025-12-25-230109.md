# Sprint Plan: FieldExpr + Materialization Integration

**Generated**: 2025-12-25-230109
**Source**: STATUS-2025-12-25-225500.md
**Topic**: fieldexpr-integration
**Git Commit**: 3dc3e2a (compiler_rewrite branch)

---

## Executive Summary

**Current State**: 60% complete - Two complete but disconnected systems exist:
- Runtime field system (src/editor/runtime/field/) - 1,542 lines, 63 tests PASSING
- 8-Pass compiler with FieldExprIR (src/editor/compiler/) - 144 tests PASSING

**Integration Gap**: These systems do NOT import each other and have incompatible type systems.

**Sprint Goal**: Create the minimum viable integration layer to connect compiler IR output to runtime field materialization, enabling end-to-end field evaluation for simple patches.

**Sprint Scope**: 2 deliverables
1. Type adapter layer (compiler TypeDesc ↔ runtime TypeDesc)
2. Integration module connecting Materializer to compiler output

**Deferred to Future Sprints**:
- Full signal evaluation (Phase 4 dependency)
- Missing node kinds (select, transform)
- Bus combine integration
- Performance optimization

**Risk Level**: MEDIUM - Architectural decisions made based on compiler authority principle

---

## Architectural Decisions

### Decision 1: Type System Authority ✓

**Context**: Two competing TypeDesc definitions exist:
- Compiler: `{ world: TypeWorld, domain: TypeDomain }` (src/editor/compiler/ir/types.ts)
- Runtime: `{ kind: 'number' | 'vec2' | ... }` (src/editor/runtime/field/types.ts)

**Decision**: **Compiler types are authoritative**

**Rationale**:
- Compiler types are part of the new 8-pass system (144 tests passing)
- They have richer semantics (world + domain + unit + semantics)
- Memory docs (02-type-system.md) specify this structure
- Runtime is an evaluator, not a type authority

**Implementation**: Create one-way adapter: compiler TypeDesc → runtime TypeDesc

---

### Decision 2: Signal Evaluation Strategy ✓

**Context**: Runtime field system's `evalSig()` function is stubbed (always returns 0), blocking broadcast functionality.

**Decision**: **Create minimal closure-based signal bridge for Phase 5**

**Rationale**:
- Phase 4 (SignalExpr Runtime) is not yet started
- Cannot defer all field integration until Phase 4 completes
- Simple closure bridge allows testing field-only paths immediately
- Can be replaced with proper signal IR evaluation later

**Implementation**: Create `SignalBridge` class that wraps signal closures and provides evalSig implementation

---

### Decision 3: Integration Module Location ✓

**Context**: Need to wire compiler output to runtime materializer without creating circular dependencies.

**Decision**: **Create `src/editor/runtime/integration/` directory**

**Structure**:
```
src/editor/runtime/integration/
├── typeAdapter.ts         # TypeDesc conversion
├── SignalBridge.ts        # Minimal signal evaluation bridge
├── CompilerRuntime.ts     # Main integration API
└── __tests__/
    └── integration.test.ts
```

**Rationale**:
- Clear separation of concerns
- Runtime imports from compiler (one-way dependency)
- Follows existing directory conventions

---

## Priority Backlog

### P0: Type Adapter Layer

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: None
**Spec Reference**: design-docs/12-Compiler-Final/02-IR-Schema.md §1 • **Status**: STATUS-2025-12-25-225500.md §Integration Gaps / Gap 1

#### Description

Create bidirectional type conversion between compiler IR TypeDesc and runtime field TypeDesc. The compiler TypeDesc is the authoritative source, so the primary flow is compiler → runtime. The reverse direction exists for error messages and debugging only.

**Key Files**:
- `src/editor/runtime/integration/typeAdapter.ts` (NEW)

**Conversion Rules**:
```typescript
// Compiler → Runtime (Primary)
{ world: 'field', domain: 'number' } → { kind: 'number' }
{ world: 'field', domain: 'vec2' }   → { kind: 'vec2' }
{ world: 'field', domain: 'vec3' }   → { kind: 'vec3' }
{ world: 'field', domain: 'vec4' }   → { kind: 'vec4' }
{ world: 'field', domain: 'color' }  → { kind: 'color' }
{ world: 'field', domain: 'boolean' } → { kind: 'boolean' }
{ world: 'signal', domain: 'number' } → { kind: 'number' } (for broadcast)

// Unsupported domains should throw clear errors
```

#### Acceptance Criteria

- [ ] `compilerToRuntimeType(compilerType: CompilerTypeDesc): RuntimeTypeDesc` function implemented
- [ ] `runtimeToCompilerType(runtimeType: RuntimeTypeDesc): CompilerTypeDesc` function implemented (for debugging)
- [ ] All common field domains (number, vec2, vec3, vec4, color, boolean) convert correctly
- [ ] Unsupported domains throw `UnsupportedTypeError` with clear message listing supported types
- [ ] Signal types with field-compatible domains convert correctly (for broadcast nodes)
- [ ] Unit tests cover all supported conversions and error cases
- [ ] Type adapter has NO dependencies on MobX stores or UI state

#### Technical Notes

- Use discriminated union exhaustiveness checking (`never` type) to ensure all cases handled
- Cache common type conversions in WeakMap for performance
- Consider creating TypeDesc utility functions (isFieldType, isDomainCompatible, etc.)
- Error messages should include both source and target type for debugging

---

### P0: Signal Bridge for Broadcast Nodes

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: Type Adapter Layer
**Spec Reference**: design-docs/12-Compiler-Final/12-SignalExpr.md • **Status**: STATUS-2025-12-25-225500.md §Integration Gaps / Gap 3

#### Description

Replace the stubbed `evalSig()` function in Materializer.ts with a minimal working implementation that evaluates signal closures. This is a TEMPORARY bridge until Phase 4 (SignalExpr Runtime) is complete. The bridge wraps legacy signal closures and provides the interface expected by field materialization.

**Key Files**:
- `src/editor/runtime/integration/SignalBridge.ts` (NEW)
- `src/editor/runtime/field/Materializer.ts` (MODIFY - replace evalSig stub)

**Architecture**:
```typescript
class SignalBridge {
  // Maps SigExprId → signal closure
  private signalClosures: Map<SigExprId, (t: number) => number>;

  evalSig(sigId: SigExprId, env: SigEnv): number {
    const closure = this.signalClosures.get(sigId);
    if (!closure) throw new Error(`Signal ${sigId} not registered`);
    return closure(env.time);
  }
}
```

#### Acceptance Criteria

- [ ] `SignalBridge` class implemented with `registerSignal()` and `evalSig()` methods
- [ ] Bridge supports registering signal closures by SigExprId
- [ ] `evalSig()` evaluates registered closures with current time from SigEnv
- [ ] Unregistered signal IDs throw clear error with signal ID in message
- [ ] Materializer.ts updated to use SignalBridge instance instead of stub
- [ ] All existing runtime/field tests continue to pass (63 tests)
- [ ] New test: broadcast field node materializes correctly with real signal values (not 0)
- [ ] Bridge is marked with TODO comment: "TEMPORARY: Replace with Phase 4 signal IR evaluator"

#### Technical Notes

- This is explicitly a Phase 5 workaround, NOT the final solution
- Keep the implementation minimal - no optimization, no caching beyond the closure map
- SigEnv will need to carry the current time value (frame time)
- Consider performance: closure call per element per broadcast field
- The bridge should be easy to replace when Phase 4 IR evaluator is ready

---

### P1: Integration Module and API

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: Type Adapter Layer, Signal Bridge
**Spec Reference**: design-docs/12-Compiler-Final/14-Compiled-IR-Program-Contract.md • **Status**: STATUS-2025-12-25-225500.md §Data Flow Verification

#### Description

Create the main integration API that connects 8-pass compiler output (LinkedGraphIR) to runtime field materialization. This module provides a clean interface for executing compiled field expressions, hiding the complexity of type conversion and environment setup.

**Key Files**:
- `src/editor/runtime/integration/CompilerRuntime.ts` (NEW)
- `src/editor/runtime/integration/__tests__/integration.test.ts` (NEW)

**Core API**:
```typescript
interface CompilerRuntime {
  // Initialize from compiler output
  loadProgram(ir: LinkedGraphIR): void;

  // Execute field materialization
  materializeField(request: MaterializationRequest): TypedArray;

  // Lifecycle
  dispose(): void;
}
```

**Data Flow**:
1. Compiler outputs LinkedGraphIR (from Pass 8)
2. CompilerRuntime extracts FieldExprTable and type information
3. Convert compiler TypeDesc → runtime TypeDesc for all field nodes
4. Build MaterializerEnv with:
   - Converted field expressions
   - Domain count resolvers
   - SignalBridge instance
   - Constant pool access
5. Delegate to runtime Materializer for execution

#### Acceptance Criteria

- [ ] `CompilerRuntime` class implemented with loadProgram, materializeField, dispose methods
- [ ] loadProgram() extracts FieldExprTable from LinkedGraphIR and converts types
- [ ] materializeField() delegates to runtime Materializer with proper environment setup
- [ ] Domain count resolution works (getDomainCount from IR domain slots)
- [ ] Constant pool access works (constants from IR const pool)
- [ ] Integration test: compile simple patch (1 const field) → materialize → verify output
- [ ] Integration test: compile broadcast field → materialize → verify signal values propagate
- [ ] Integration test: compile map operation → materialize → verify function applied
- [ ] All type conversions use typeAdapter (no inline conversion logic)
- [ ] Proper error handling with context (which field, which domain, what failed)

#### Technical Notes

- This is the main "contract boundary" between compiler and runtime
- Keep the API surface small - only expose what's needed for execution
- Consider creating a FieldEvaluationContext that packages environment state
- The integration tests are the most important part - they prove end-to-end flow
- Start with field-only tests (no buses, no complex graphs) to establish baseline
- Memory management: who owns the typed arrays? (caller or runtime?)

---

### P2: Missing FieldExpr Node Kinds

**Status**: Deferred
**Effort**: Medium (3-5 days)
**Dependencies**: Integration Module
**Spec Reference**: design-docs/12-Compiler-Final/12-SignalExpr.md • **Status**: STATUS-2025-12-25-225500.md §Integration Gaps / Gap 4

#### Description

Add support for `select` (conditional) and `transform` (transform chain) node kinds to the runtime field materializer. These exist in compiler IR but are not yet implemented in runtime evaluation.

**Deferred Because**:
- Not required for basic field materialization
- Integration tests can be written without these nodes
- Adds complexity to first sprint
- Can be added incrementally after core integration works

#### Acceptance Criteria

- [ ] `select` node kind implemented in runtime materializer (element-wise conditional)
- [ ] `transform` node kind implemented in runtime materializer (chain application)
- [ ] Unit tests for select: condition true/false branches
- [ ] Unit tests for transform: multiple transforms in chain
- [ ] Integration test: patch with select node materializes correctly
- [ ] Integration test: patch with transform chain materializes correctly

#### Technical Notes

- Select: `cond ? t : f` element-wise evaluation
- Transform: Apply chain of transforms from IR TransformChainTable
- Both require materializing child fields first, then applying operation
- Consider buffer reuse to avoid allocations

---

### P2: Bus Combine Integration

**Status**: Deferred
**Effort**: Large (1-2 weeks)
**Dependencies**: Integration Module, Pass 7 Bus Lowering verification
**Spec Reference**: design-docs/12-Compiler-Final/08-Bus-Lowering.md • **Status**: STATUS-2025-12-25-225500.md §Runtime Field System (BroadcastReduce.ts complete)

#### Description

Integrate bus combine operations from compiler IR (Pass 7 output) with runtime field materialization. This includes handling CombineSpec, pre-sorted terms, and reduce operations.

**Deferred Because**:
- Bus system is complex and involves multiple compilation passes
- Runtime BroadcastReduce.ts exists but needs wiring to compiler CombineSpec
- Requires understanding bus topology from Pass 7
- Not required for simple single-block field patches

#### Acceptance Criteria

- [ ] FieldExprBusCombine nodes evaluate correctly in runtime
- [ ] CombineSpec (sum/average/min/max/last) from IR maps to runtime operations
- [ ] Pre-sorted terms from compiler are used without re-sorting
- [ ] Integration test: multi-publisher bus materializes with correct combine mode
- [ ] Integration test: verify bus combine respects compiler ordering
- [ ] BusIndex resolution from IR works correctly

#### Technical Notes

- Compiler guarantees terms are pre-sorted by priority
- Runtime must respect this ordering (NEVER re-sort)
- CombineSpec from compiler IR may be richer than runtime CombineMode
- May need adapter for combine modes similar to type adapter

---

### P3: Performance Optimization

**Status**: Deferred
**Effort**: Medium (3-5 days)
**Dependencies**: Integration Module, working integration tests
**Spec Reference**: N/A (implementation optimization)
**Status**: STATUS-2025-12-25-225500.md (no performance metrics captured)

#### Description

Optimize the integrated field materialization pipeline for production use. Focus on reducing allocations, caching, and vectorization opportunities.

**Deferred Because**:
- Premature optimization - need working integration first
- No performance benchmarks exist yet
- Unknown where bottlenecks are without profiling

#### Acceptance Criteria

- [ ] Benchmark suite for field materialization (ops/sec, allocation count)
- [ ] Buffer pooling reduces allocations by >80% for repeated materializations
- [ ] Type conversion caching reduces type adapter overhead
- [ ] Profiling data captured for 10+ common patch patterns
- [ ] Performance regression tests prevent slowdowns
- [ ] Documentation of optimization decisions and tradeoffs

#### Technical Notes

- Likely hot paths: type conversion, buffer allocation, element-wise operations
- Consider SIMD opportunities for map/zip operations
- Cache field handles aggressively (already implemented, verify it works)
- Measure before optimizing - profile first!

---

## Recommended Sprint Planning

### Sprint 1 (This Sprint): Minimum Viable Integration

**Goal**: Connect compiler output to runtime materializer for simple field-only patches

**Deliverables**:
1. Type Adapter Layer (P0)
2. Signal Bridge (P0)
3. Integration Module with tests (P1)

**Success Criteria**:
- End-to-end test: Patch → 8 passes → IR → Materialize → Typed array output
- At least 3 integration tests passing (const, broadcast, map)
- No changes to existing 144 compiler tests or 63 runtime tests
- All tests pass: `pnpm vitest run`

**Scope Boundaries**:
- ✅ Include: const, map, zip, broadcast nodes
- ❌ Exclude: select, transform, bus combine
- ❌ Exclude: Performance optimization
- ❌ Exclude: Full signal IR evaluation (use bridge only)

---

### Sprint 2 (Future): Complete Field Operations

**Goal**: Add missing node kinds and optimize

**Deliverables**:
1. Missing Node Kinds (P2) - select, transform
2. Bus Combine Integration (P2)
3. Performance Optimization (P3)

**Dependencies**: Sprint 1 complete and stable

---

## Dependency Graph

```
Type Adapter Layer (P0)
    ↓
Signal Bridge (P0) ──→ Integration Module (P1)
    ↓                        ↓
Missing Node Kinds (P2)      Bus Combine (P2)
    ↓                        ↓
    └────────┬──────────────┘
             ↓
    Performance Optimization (P3)
```

---

## Risk Assessment

### High-Risk Areas

1. **Type System Compatibility** (MEDIUM)
   - **Risk**: Compiler types don't map cleanly to runtime types
   - **Mitigation**: Type adapter with explicit error handling for unsupported types
   - **Fallback**: Extend runtime TypeDesc to support compiler semantics

2. **Signal Bridge Performance** (MEDIUM)
   - **Risk**: Closure-based bridge is too slow for large domains
   - **Mitigation**: Mark as temporary, plan replacement with Phase 4
   - **Fallback**: Cache signal values if evaluation is deterministic

3. **Integration Test Complexity** (LOW)
   - **Risk**: Hard to create realistic test patches without UI
   - **Mitigation**: Use programmatic patch construction (already exists in pass tests)
   - **Fallback**: Start with minimal patches (single blocks)

### Uncertain Areas Requiring Investigation

1. **Domain Count Resolution**
   - How does runtime get domain count from IR domain slots?
   - Need to understand ValueStore domain slot structure
   - **Investigation**: Read Pass 6 block lowering to see how domains are emitted

2. **Constant Pool Access**
   - How does runtime access const pool from IR?
   - Need to understand BuilderProgramIR.constPool structure
   - **Investigation**: Read compiler IR const pool implementation

3. **Memory Ownership**
   - Who owns materialized typed arrays?
   - Should runtime return pooled buffers or caller-owned arrays?
   - **Investigation**: Read RenderSinkMaterializer to see current pattern

---

## Verification Plan

### Pre-Sprint Verification

- [x] All 144 compiler pass tests passing
- [x] All 63 runtime field tests passing
- [x] `pnpm typecheck` passes
- [x] `just check` passes

### During Sprint Verification

**After Type Adapter (P0)**:
- [ ] Type adapter unit tests pass
- [ ] No changes to existing tests
- [ ] `pnpm typecheck` still passes

**After Signal Bridge (P0)**:
- [ ] Signal bridge unit tests pass
- [ ] Materializer tests with bridge pass
- [ ] No existing tests break

**After Integration Module (P1)**:
- [ ] Integration tests pass (3+ tests)
- [ ] End-to-end compilation → materialization works
- [ ] All 207 existing tests still pass

### Post-Sprint Verification

- [ ] `pnpm vitest run` - all tests pass
- [ ] `pnpm typecheck` - no errors
- [ ] `just check` - full check passes
- [ ] Integration tests run in CI
- [ ] No regressions in existing functionality

---

## Success Metrics

### Quantitative

- **Test Coverage**: 210+ total tests (207 existing + 3+ new integration tests)
- **Type Coverage**: 6+ field domains converted (number, vec2, vec3, vec4, color, boolean)
- **Integration Paths**: 3+ end-to-end paths tested (const, broadcast, map)
- **Zero Regressions**: All existing tests continue passing

### Qualitative

- **Clean Abstractions**: Clear separation between compiler IR and runtime evaluation
- **One-Way Dependencies**: Runtime imports from compiler, never reverse
- **Easy to Replace**: Signal bridge can be swapped for Phase 4 IR evaluator
- **Testable**: Integration tests prove the connection works

---

## Files to Create

| Path | Purpose | Lines (est) |
|------|---------|-------------|
| `src/editor/runtime/integration/typeAdapter.ts` | Type conversion compiler ↔ runtime | ~150 |
| `src/editor/runtime/integration/SignalBridge.ts` | Temporary signal evaluation bridge | ~100 |
| `src/editor/runtime/integration/CompilerRuntime.ts` | Main integration API | ~250 |
| `src/editor/runtime/integration/__tests__/typeAdapter.test.ts` | Type adapter tests | ~200 |
| `src/editor/runtime/integration/__tests__/SignalBridge.test.ts` | Signal bridge tests | ~150 |
| `src/editor/runtime/integration/__tests__/integration.test.ts` | End-to-end integration tests | ~300 |
| **Total** | | **~1,150 lines** |

---

## Files to Modify

| Path | Change | Risk |
|------|--------|------|
| `src/editor/runtime/field/Materializer.ts` | Replace evalSig stub with SignalBridge call | LOW |
| `src/editor/runtime/field/types.ts` | Add JSDoc clarifying compiler authority | NONE |

---

## Definition of Done

Sprint complete when:

1. ✅ All P0 and P1 items complete with passing tests
2. ✅ End-to-end integration test: Patch → 8 passes → Materialize → Output
3. ✅ All 207 existing tests still pass
4. ✅ Type adapter handles 6+ field domains
5. ✅ Signal bridge allows broadcast nodes to work (not return 0)
6. ✅ Zero regressions in compiler or runtime systems
7. ✅ Code review: Clean abstractions, clear comments, no TODOs except "Phase 4 replacement"

Sprint does NOT require:

- ❌ Full signal IR evaluation (Phase 4)
- ❌ select/transform node kinds
- ❌ Bus combine integration
- ❌ Performance optimization
- ❌ UI integration or visual testing

---

## Next Steps After This Sprint

1. **Phase 4 Integration**: Replace SignalBridge with proper signal IR evaluator
2. **Complete Field Operations**: Add select, transform nodes
3. **Bus Integration**: Wire bus combine to compiler Pass 7 output
4. **Performance**: Profile and optimize hot paths
5. **End-to-End Testing**: Test with real patches in UI

---

## Questions for Stakeholder

**None** - All architectural decisions made based on:
- Compiler authority principle (STATUS recommendation)
- Minimal viable integration scope (STATUS recommendation)
- Clear separation of concerns (architecture best practice)

If these decisions need revision, please provide feedback before implementation begins.
