# Implementation Plan: HooksSystem for Console Clear on Macro

**Generated**: 2025-12-20-135520
**Source**: STATUS-20251220.md
**Topic**: console-clear-on-macro
**Complexity**: MEDIUM
**Revision**: v2 (HooksSystem approach)

---

## Executive Summary

**Current State**: LogStore has `autoClearOnMacro` setting and `clear()` method. UI checkbox exists. Previous plan used direct coupling (rejected by user).

**Gap**: Need decoupled event system for components to communicate without direct dependencies. HooksSystem provides global event registration and handling.

**Recommended Approach**: Implement HooksSystem infrastructure, register 'onExpandMacro' hook in PatchStore, add handler in logStore to clear on macro expansion.

**Key User Requirements**:
1. Global HooksSystem (NOT called "bus" to avoid confusion with existing bus system)
2. Components MUST explicitly register hooks they SUPPORT (define the hook exists)
3. Other components add handlers for registered hooks
4. Adding a handler for a non-existent hook is an IMMEDIATE ERROR
5. Hook handlers are functions with specific signatures, providing context
6. Standard callback/promise/async/await semantics

---

## Work Items

### [P0] Implement HooksSystem Core Infrastructure

**Status**: Not Started
**Effort**: Medium (2-3 hours)
**Dependencies**: None
**Spec Reference**: N/A (infrastructure) • **Status Reference**: STATUS-20251220.md (user rejection of direct coupling)

#### Description
Create a global HooksSystem that allows components to register hooks (define event types) and other components to add handlers. The system must error immediately if a handler is added for a non-existent hook.

#### Acceptance Criteria
- [ ] Create `src/editor/HooksSystem.ts` with HooksSystem class
- [ ] `registerHook(name: string, signature?: string): void` - Define a hook exists
- [ ] `addHandler(hookName: string, handler: Function): () => void` - Add handler, returns cleanup function
- [ ] `addHandler` throws error immediately if hook not registered
- [ ] `trigger(hookName: string, ...args: unknown[]): void | Promise<void>` - Execute all handlers
- [ ] Support both sync and async handlers
- [ ] Handlers execute in registration order
- [ ] Export singleton instance `hooksSystem`
- [ ] TypeScript compilation succeeds (`just typecheck`)

#### Technical Notes
**File**: `src/editor/HooksSystem.ts`

**Core Interface**:
```typescript
export class HooksSystem {
  private registeredHooks = new Map<string, HookDefinition>();
  private handlers = new Map<string, HookHandler[]>();

  /**
   * Register a hook (declare it exists).
   * Components that TRIGGER hooks must call this first.
   */
  registerHook(name: string, description?: string): void {
    if (this.registeredHooks.has(name)) {
      throw new Error(`Hook "${name}" already registered`);
    }
    this.registeredHooks.set(name, { name, description });
  }

  /**
   * Add a handler for a hook.
   * Returns cleanup function to remove the handler.
   * THROWS if hook not registered.
   */
  addHandler(hookName: string, handler: HookHandler): () => void {
    if (!this.registeredHooks.has(hookName)) {
      throw new Error(
        `Cannot add handler for unregistered hook "${hookName}". ` +
        `Available hooks: ${Array.from(this.registeredHooks.keys()).join(', ')}`
      );
    }

    const hookHandlers = this.handlers.get(hookName) ?? [];
    hookHandlers.push(handler);
    this.handlers.set(hookName, hookHandlers);

    // Return cleanup function
    return () => {
      const handlers = this.handlers.get(hookName) ?? [];
      const index = handlers.indexOf(handler);
      if (index !== -1) handlers.splice(index, 1);
    };
  }

  /**
   * Trigger a hook, executing all handlers.
   * Supports both sync and async handlers.
   */
  async trigger(hookName: string, context?: unknown): Promise<void> {
    const handlers = this.handlers.get(hookName) ?? [];

    // Execute all handlers (await async ones)
    for (const handler of handlers) {
      await handler(context);
    }
  }

  /**
   * Get list of registered hooks (for debugging/introspection)
   */
  getRegisteredHooks(): string[] {
    return Array.from(this.registeredHooks.keys());
  }
}

type HookHandler = (context?: unknown) => void | Promise<void>;

interface HookDefinition {
  name: string;
  description?: string;
}

// Export singleton
export const hooksSystem = new HooksSystem();
```

**Design Decisions**:
- **Singleton pattern**: Like logStore, use global singleton for simplicity
- **Immediate errors**: `addHandler` validates hook exists immediately (no silent failures)
- **Cleanup functions**: Handlers can be removed (important for testing and component lifecycle)
- **Async support**: `trigger` is async to support both sync and async handlers
- **Context parameter**: Handlers receive optional context object with event details

---

### [P1] Register 'onExpandMacro' Hook in PatchStore

**Status**: Not Started
**Effort**: Small (30 minutes)
**Dependencies**: P0 (HooksSystem infrastructure)
**Spec Reference**: N/A • **Status Reference**: STATUS-20251220.md lines 36-45

#### Description
PatchStore owns the macro expansion lifecycle and should register the 'onExpandMacro' hook, then trigger it at the end of `expandMacro()`.

#### Acceptance Criteria
- [ ] Import `hooksSystem` in `src/editor/stores/PatchStore.ts`
- [ ] Register 'onExpandMacro' hook in PatchStore constructor
- [ ] Trigger 'onExpandMacro' at end of `expandMacro()` method (after all blocks/connections created)
- [ ] Pass context object with expansion details: `{ macroType: string, blockCount: number }`
- [ ] TypeScript compilation succeeds (`just typecheck`)

#### Technical Notes
**Location**: `src/editor/stores/PatchStore.ts`

**Implementation**:
```typescript
import { hooksSystem } from '../HooksSystem';

export class PatchStore {
  constructor(public root: RootStore) {
    // ... existing code ...

    // Register hooks this store triggers
    hooksSystem.registerHook('onExpandMacro', 'Triggered after a macro is expanded into the patch');

    // ... rest of constructor ...
  }

  expandMacro(expansion: MacroExpansion): BlockId {
    // Clear the patch first - macros replace everything
    this.root.clearPatch();

    // ... existing expansion logic ...

    // Return the first block ID (for selection purposes)
    const firstRef = expansion.blocks[0]?.ref;
    const firstBlockId = firstRef ? refToId.get(firstRef) ?? '' : '';

    // Trigger hook at the end
    hooksSystem.trigger('onExpandMacro', {
      macroType: expansion.blocks[0]?.type ?? 'unknown',
      blockCount: expansion.blocks.length,
    });

    return firstBlockId;
  }
}
```

**Rationale**:
- PatchStore is the authoritative source for macro expansion lifecycle
- Hook triggers AFTER expansion completes (all blocks/connections created)
- Context object allows handlers to log/respond based on macro details

---

### [P2] Add LogStore Handler for 'onExpandMacro'

**Status**: Not Started
**Effort**: Small (30 minutes)
**Dependencies**: P0 (HooksSystem), P1 (hook registration)
**Spec Reference**: N/A • **Status Reference**: STATUS-20251220.md lines 12-33

#### Description
LogStore should add a handler for 'onExpandMacro' that clears logs if `autoClearOnMacro` is enabled.

#### Acceptance Criteria
- [ ] Import `hooksSystem` in `src/editor/logStore.ts`
- [ ] Add handler for 'onExpandMacro' in LogStore constructor
- [ ] Handler checks `this.autoClearOnMacro` before calling `this.clear()`
- [ ] Store cleanup function for handler removal (testing/lifecycle)
- [ ] TypeScript compilation succeeds (`just typecheck`)

#### Technical Notes
**Location**: `src/editor/logStore.ts`

**Implementation**:
```typescript
import { hooksSystem } from './HooksSystem';

export class LogStore {
  private cleanupFunctions: Array<() => void> = [];

  constructor() {
    makeObservable(this, {
      // ... existing observables ...
    });

    // Register handler for macro expansion
    const cleanup = hooksSystem.addHandler('onExpandMacro', () => {
      if (this.autoClearOnMacro) {
        this.clear();
      }
    });

    this.cleanupFunctions.push(cleanup);
  }

  /**
   * Cleanup method for testing/disposal
   */
  dispose(): void {
    for (const cleanup of this.cleanupFunctions) {
      cleanup();
    }
    this.cleanupFunctions = [];
  }
}
```

**Rationale**:
- Handler is self-contained and respects `autoClearOnMacro` setting
- Cleanup function stored for proper disposal in tests
- No direct dependency on PatchStore

---

### [P3] Add HooksSystem Tests

**Status**: Not Started
**Effort**: Medium (1-2 hours)
**Dependencies**: P0 (HooksSystem implementation)
**Spec Reference**: N/A • **Status Reference**: STATUS-20251220.md lines 149-159

#### Description
Comprehensive test suite for HooksSystem core functionality, including error cases and async handler support.

#### Acceptance Criteria
- [ ] Create test file `src/editor/__tests__/HooksSystem.test.ts`
- [ ] Test case: registerHook() creates a hook
- [ ] Test case: addHandler() throws error for unregistered hook
- [ ] Test case: trigger() executes all handlers in order
- [ ] Test case: Cleanup function removes handler
- [ ] Test case: Async handlers are awaited
- [ ] Test case: Multiple handlers for same hook all execute
- [ ] Test case: Context parameter passed to handlers
- [ ] All tests pass (`just test`)

#### Technical Notes
**Test Structure**:
```typescript
describe('HooksSystem', () => {
  let system: HooksSystem;

  beforeEach(() => {
    system = new HooksSystem();
  });

  describe('registerHook', () => {
    it('should register a hook', () => {
      system.registerHook('testHook');
      expect(system.getRegisteredHooks()).toContain('testHook');
    });

    it('should throw if hook already registered', () => {
      system.registerHook('testHook');
      expect(() => system.registerHook('testHook')).toThrow();
    });
  });

  describe('addHandler', () => {
    it('should throw for unregistered hook', () => {
      expect(() => system.addHandler('nonexistent', () => {}))
        .toThrow(/unregistered hook/);
    });

    it('should add handler for registered hook', () => {
      system.registerHook('testHook');
      expect(() => system.addHandler('testHook', () => {}))
        .not.toThrow();
    });

    it('should return cleanup function', () => {
      system.registerHook('testHook');
      const cleanup = system.addHandler('testHook', () => {});
      expect(typeof cleanup).toBe('function');
    });
  });

  describe('trigger', () => {
    it('should execute handlers in registration order', async () => {
      const order: number[] = [];
      system.registerHook('testHook');
      system.addHandler('testHook', () => order.push(1));
      system.addHandler('testHook', () => order.push(2));
      system.addHandler('testHook', () => order.push(3));

      await system.trigger('testHook');
      expect(order).toEqual([1, 2, 3]);
    });

    it('should pass context to handlers', async () => {
      let receivedContext: unknown;
      system.registerHook('testHook');
      system.addHandler('testHook', (ctx) => { receivedContext = ctx; });

      await system.trigger('testHook', { foo: 'bar' });
      expect(receivedContext).toEqual({ foo: 'bar' });
    });

    it('should await async handlers', async () => {
      let completed = false;
      system.registerHook('testHook');
      system.addHandler('testHook', async () => {
        await new Promise((resolve) => setTimeout(resolve, 10));
        completed = true;
      });

      await system.trigger('testHook');
      expect(completed).toBe(true);
    });
  });

  describe('cleanup', () => {
    it('should remove handler when cleanup called', async () => {
      let callCount = 0;
      system.registerHook('testHook');
      const cleanup = system.addHandler('testHook', () => { callCount++; });

      await system.trigger('testHook');
      expect(callCount).toBe(1);

      cleanup();
      await system.trigger('testHook');
      expect(callCount).toBe(1); // Not called again
    });
  });
});
```

---

### [P4] Add Integration Tests for Macro Log Clearing

**Status**: Not Started
**Effort**: Medium (1 hour)
**Dependencies**: P1 (hook registration), P2 (logStore handler), P3 (HooksSystem tests)
**Spec Reference**: N/A • **Status Reference**: STATUS-20251220.md lines 149-159

#### Description
Integration tests to verify the complete flow: macro expansion → hook trigger → log clearing.

#### Acceptance Criteria
- [ ] Create test file `src/editor/__tests__/macro-log-clear.test.ts`
- [ ] Test case: Logs cleared when `autoClearOnMacro = true` during macro expansion
- [ ] Test case: Logs preserved when `autoClearOnMacro = false` during macro expansion
- [ ] Test case: Setting toggle persists across multiple macro expansions
- [ ] Test verifies hook context includes macro details
- [ ] All tests pass (`just test`)

#### Technical Notes
**Test Structure**:
```typescript
import { RootStore } from '../stores/RootStore';
import { logStore } from '../logStore';
import type { MacroExpansion } from '../macros';

describe('Macro expansion log clearing', () => {
  let rootStore: RootStore;

  beforeEach(() => {
    rootStore = new RootStore();
    logStore.clear();
    logStore.setAutoClearOnMacro(true); // Reset to default
  });

  it('clears logs when autoClearOnMacro is enabled', () => {
    // Add some log entries
    logStore.info('compiler', 'Test log 1');
    logStore.info('compiler', 'Test log 2');
    expect(logStore.entries.length).toBe(2);

    // Expand macro (should clear logs)
    const expansion: MacroExpansion = {
      blocks: [{ ref: 'b1', type: 'PhaseClock', laneKind: 'Phase' }],
      connections: [],
    };
    rootStore.patchStore.expandMacro(expansion);

    // Logs should be cleared
    expect(logStore.entries.length).toBe(0);
  });

  it('preserves logs when autoClearOnMacro is disabled', () => {
    // Disable auto-clear
    logStore.setAutoClearOnMacro(false);

    // Add some log entries
    logStore.info('compiler', 'Test log 1');
    logStore.info('compiler', 'Test log 2');
    expect(logStore.entries.length).toBe(2);

    // Expand macro (should NOT clear logs)
    const expansion: MacroExpansion = {
      blocks: [{ ref: 'b1', type: 'PhaseClock', laneKind: 'Phase' }],
      connections: [],
    };
    rootStore.patchStore.expandMacro(expansion);

    // Logs should still be present
    expect(logStore.entries.length).toBe(2);
  });

  it('respects setting changes across multiple expansions', () => {
    // First expansion with auto-clear enabled
    logStore.info('compiler', 'Test log 1');
    const expansion: MacroExpansion = {
      blocks: [{ ref: 'b1', type: 'PhaseClock', laneKind: 'Phase' }],
      connections: [],
    };
    rootStore.patchStore.expandMacro(expansion);
    expect(logStore.entries.length).toBe(0);

    // Add logs and disable auto-clear
    logStore.info('compiler', 'Test log 2');
    logStore.setAutoClearOnMacro(false);
    rootStore.patchStore.expandMacro(expansion);
    expect(logStore.entries.length).toBe(1);

    // Re-enable and verify clearing works
    logStore.setAutoClearOnMacro(true);
    rootStore.patchStore.expandMacro(expansion);
    expect(logStore.entries.length).toBe(0);
  });
});
```

---

### [P5] Manual Smoke Test

**Status**: Not Started
**Effort**: Small (10 minutes)
**Dependencies**: P1 (hook registration), P2 (logStore handler)
**Spec Reference**: N/A • **Status Reference**: STATUS-20251220.md lines 211-218

#### Description
Manual verification of UX behavior to ensure feature works as expected in real usage.

#### Acceptance Criteria
- [ ] Open app, add multiple log entries manually (click "Test Log" buttons or trigger compiler errors)
- [ ] Load a macro from preset library (e.g., "Breathing Constellation")
- [ ] Verify logs are cleared when auto-clear is enabled (default)
- [ ] Disable "Auto-clear" checkbox in LogWindow
- [ ] Load macro again, verify logs are preserved
- [ ] Re-enable "Auto-clear", load macro, verify logs cleared again
- [ ] No console errors or warnings

#### Technical Notes
Use existing macros from `src/editor/macros.ts` for testing. Verify UX feels responsive and correct.

---

## Dependency Graph

```
P0: HooksSystem Core (REQUIRED)
  ↓
P1: Register 'onExpandMacro' in PatchStore
  ↓
P2: Add LogStore Handler
  ↓
P3: HooksSystem Tests
P4: Integration Tests
  ↓
P5: Manual Smoke Test
```

**Critical Path**: P0 → P1 → P2 → P5 (linear for core functionality)
**Parallel Work**: P3 and P4 can be done in parallel after P2

---

## Recommended Sprint Planning

### Sprint 1: Core Implementation (4-5 hours total)
- **Deliverables**: P0 (HooksSystem), P1 (hook registration), P2 (logStore handler), P3 (tests), P4 (integration tests), P5 (smoke test)
- **Goal**: Complete decoupled hook system with full test coverage

**Work order**:
1. P0: Implement HooksSystem core (2-3 hours)
2. P1: Register hook in PatchStore (30 min)
3. P2: Add logStore handler (30 min)
4. P3: HooksSystem unit tests (1-2 hours) - can overlap with P4
5. P4: Integration tests (1 hour) - can overlap with P3
6. P5: Manual verification (10 min)

---

## Risk Assessment

### Risk: Hook System Complexity
- **Likelihood**: Medium
- **Impact**: Medium (over-engineering for simple feature)
- **Mitigation**: Keep HooksSystem minimal and focused. Only add features as needed.
- **Status**: ACCEPTED (user requirement)

### Risk: Async Hook Timing
- **Likelihood**: Low
- **Impact**: Low (macro expansion already synchronous)
- **Mitigation**: HooksSystem supports both sync and async handlers. Current use case is sync.
- **Status**: MITIGATED

### Risk: Memory Leaks from Handlers
- **Likelihood**: Low
- **Impact**: Medium
- **Mitigation**: Provide cleanup functions from `addHandler()`. Add `dispose()` method to LogStore.
- **Status**: MITIGATED

### Risk: Hook Name Collisions
- **Likelihood**: Low
- **Impact**: Low
- **Mitigation**: Use descriptive, namespaced hook names. Document in HooksSystem.
- **Status**: MITIGATED

---

## Out of Scope

The following are explicitly NOT part of this sprint:
- [ ] Integrating LogStore into RootStore (singleton pattern is sufficient)
- [ ] Persisting auto-clear setting across sessions (not requested)
- [ ] Additional hooks beyond 'onExpandMacro' (future work)
- [ ] UI for viewing registered hooks (debugging feature, not MVP)
- [ ] Hook handler priorities or cancellation (YAGNI)

---

## Success Metrics

**Definition of Done**:
1. HooksSystem implemented with core API (register, addHandler, trigger)
2. 'onExpandMacro' hook registered in PatchStore and triggered after expansion
3. LogStore adds handler to clear logs when `autoClearOnMacro = true`
4. Comprehensive unit tests for HooksSystem (8+ test cases)
5. Integration tests verify macro expansion clears logs
6. Manual smoke test confirms UX works correctly
7. TypeScript compilation passes (`just typecheck`)
8. All tests pass (`just test`)
9. No direct coupling between PatchStore and LogStore

**Total Complexity**: MEDIUM (4-5 hours)
**Total Risk**: LOW (well-understood pattern, user-driven requirement)
**Blockers**: NONE
