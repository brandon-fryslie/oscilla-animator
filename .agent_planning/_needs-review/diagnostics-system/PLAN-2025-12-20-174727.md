# Diagnostics System Implementation Plan (REVISED)

**Generated:** 2025-12-20-174727
**Topic:** Diagnostics System Implementation
**Source STATUS:** STATUS-2025-12-20-174727.md
**Source Design Doc:** design-docs/4-Event-System/3.5-Events-and-Payloads-Schema.md

---

## Executive Summary

This plan implements a **minimal, coherent diagnostics system** based on **5 snapshot-based events** that provide clean boundaries for diagnostic state updates. The system replaces 14 fine-grained events with lifecycle events (GraphCommitted, CompileStarted, CompileFinished, ProgramSwapped, RuntimeHealthSnapshot) and implements a DiagnosticHub that consumes these events to maintain diagnostic state.

**Total Items:** 12 (P0: 8, P1: 3, P2: 1)
**Sprint Focus:** Foundation types, event refactoring, DiagnosticHub, compiler integration

---

## P0 (Critical) - Foundation Types and Core Events

### P0.1 - Define Core Diagnostic Types

**Status:** Not Started
**Effort:** Small (1-2 complexity points)
**Dependencies:** None
**Spec Reference:** 3.5-Events-and-Payloads-Schema.md (payload schemas) • STATUS-2025-12-20-174727.md §Core Diagnostic Types

#### Description
Create the foundational type definitions for the diagnostic system. These types are used in event payloads and DiagnosticHub state management.

#### Acceptance Criteria (REQUIRED)
- [ ] `Diagnostic` type defined with fields: code, severity, domain, primaryTarget, affectedTargets, message, payload, metadata
- [ ] `TargetRef` union type defined with variants: block, port, bus, binding, timeRoot, graphSpan
- [ ] `DiagnosticCode` enum defined with at least 5 codes: E_TIME_ROOT_MISSING, E_TIME_ROOT_MULTIPLE, E_TYPE_MISMATCH, W_BUS_EMPTY, W_GRAPH_UNUSED_OUTPUT
- [ ] `Severity` enum defined: hint, info, warn, error, fatal
- [ ] `Domain` enum defined: authoring, compile, runtime, perf
- [ ] All types exported from `src/editor/diagnostics/types.ts`

#### Technical Notes
- Use TypeScript discriminated unions for TargetRef (e.g., `{ kind: 'block'; blockId: string }`)
- DiagnosticCode should use string enums for readability in logs
- Payload types can start simple (Record<string, unknown>) and be refined later

---

### P0.2 - Define GraphCommitted Event Type

**Status:** Not Started
**Effort:** Small (1-2 complexity points)
**Dependencies:** P0.1
**Spec Reference:** 3.5-Events-and-Payloads-Schema.md §1 GraphCommitted • STATUS §Required Events

#### Description
Define the GraphCommitted event type that replaces 8 fine-grained events (BlockAdded, BlockRemoved, WireAdded, WireRemoved, BindingAdded, BindingRemoved, BusCreated, BusDeleted). This event provides a single mutation boundary for diagnostic recomputation.

#### Acceptance Criteria (REQUIRED)
- [ ] `GraphCommitted` event type defined with payload: patchId, patchRevision, reason, diffSummary, affectedBlockIds, affectedBusIds
- [ ] `reason` enum defined: userEdit, macroExpand, compositeSave, migration, import, undo, redo
- [ ] `diffSummary` type defined with counts: blocksAdded, blocksRemoved, busesAdded, busesRemoved, bindingsChanged, timeRootChanged
- [ ] Event type added to `EditorEvent` union in `src/editor/events/types.ts`
- [ ] 8 deprecated event types marked for removal (BlockAdded, BlockRemoved, WireAdded, WireRemoved, BindingAdded, BindingRemoved, BusCreated, BusDeleted)

#### Technical Notes
- affectedBlockIds/affectedBusIds should be optional (best effort, bounded)
- patchRevision is a monotonic integer (PatchStore responsibility to increment)

---

### P0.3 - Define Compile Lifecycle Event Types

**Status:** Not Started
**Effort:** Small (1-2 complexity points)
**Dependencies:** P0.1
**Spec Reference:** 3.5-Events-and-Payloads-Schema.md §2-3 (CompileStarted, CompileFinished) • STATUS §Required Events

#### Description
Define CompileStarted and CompileFinished event types. CompileFinished is a **single event** (not split success/fail) that includes a diagnostics snapshot in its payload.

#### Acceptance Criteria (REQUIRED)
- [ ] `CompileStarted` event type defined with payload: compileId (UUID), patchId, patchRevision, trigger (graphCommitted|manual|startup|hotReload)
- [ ] `CompileFinished` event type defined with payload: compileId, patchId, patchRevision, status (ok|failed), durationMs, diagnostics (Diagnostic[]), programMeta (optional)
- [ ] `programMeta` type defined with fields: timelineHint, timeRootKind, busUsageSummary (optional)
- [ ] Both event types added to `EditorEvent` union
- [ ] Deprecated events marked for removal: CompileSucceeded, CompileFailed

#### Technical Notes
- CompileFinished.diagnostics is the **authoritative snapshot** for compile-time diagnostics
- programMeta is only present if status === 'ok'
- compileId should be a UUID for tracking compile lifecycle

---

### P0.4 - Add patchRevision Counter to PatchStore

**Status:** Not Started
**Effort:** Small (1-2 complexity points)
**Dependencies:** P0.2
**Spec Reference:** 3.5-Events-and-Payloads-Schema.md (patchRevision in GraphCommitted) • STATUS §PatchStore Integration

#### Description
Add a monotonic patchRevision counter to PatchStore that increments on every committed graph mutation. This revision number is used for diagnostic state keying and staleness detection.

#### Acceptance Criteria (REQUIRED)
- [ ] `patchRevision` observable property added to PatchStore (initialized to 0)
- [ ] `incrementRevision()` private method added to PatchStore
- [ ] All graph mutation methods (addBlock, removeBlock, addConnection, etc.) call incrementRevision()
- [ ] patchRevision is included in GraphCommitted event payload
- [ ] Unit test: patchRevision increments on addBlock, removeBlock, addConnection, removeConnection

#### Technical Notes
- Use MobX observable for patchRevision
- Revision should increment BEFORE emitting GraphCommitted
- Consider using a getter if patchRevision needs to be readonly externally

---

### P0.5 - Implement GraphCommitted Emission in PatchStore

**Status:** Not Started
**Effort:** Medium (3-4 complexity points)
**Dependencies:** P0.2, P0.4
**Spec Reference:** 3.5-Events-and-Payloads-Schema.md §1 • STATUS §PatchStore Integration

#### Description
Update PatchStore to emit GraphCommitted event after graph mutations. Compute diffSummary and track affectedBlockIds/affectedBusIds.

#### Acceptance Criteria (REQUIRED)
- [ ] `emitGraphCommitted()` method added to PatchStore
- [ ] Method computes diffSummary (blocksAdded/Removed, busesAdded/Removed, bindingsChanged, timeRootChanged)
- [ ] Method tracks affectedBlockIds and affectedBusIds (best effort)
- [ ] All graph mutation methods call emitGraphCommitted() after successful mutation
- [ ] Unit test: GraphCommitted emitted on addBlock with correct diffSummary
- [ ] Unit test: GraphCommitted includes affectedBlockIds after removeBlock

#### Technical Notes
- Compute diff using before/after snapshots (may require storing prev state temporarily)
- affectedBlockIds should include newly added/removed blocks + blocks with changed connections
- timeRootChanged should be true if TimeRoot block added/removed/modified

---

### P0.6 - Implement DiagnosticHub with Snapshot Semantics

**Status:** Not Started
**Effort:** Large (6-8 complexity points)
**Dependencies:** P0.1, P0.2, P0.3
**Spec Reference:** 3.5-Events-and-Payloads-Schema.md §"How DiagnosticHub uses these" • STATUS §DiagnosticHub

#### Description
Create the DiagnosticHub class that subscribes to lifecycle events and maintains diagnostic state using snapshot semantics (NOT per-diagnostic add/resolve). The hub is the single source of truth for diagnostics.

#### Acceptance Criteria (REQUIRED)
- [ ] DiagnosticHub class defined in `src/editor/diagnostics/DiagnosticHub.ts`
- [ ] Subscribes to GraphCommitted: runs authoring validators, updates authoring snapshot
- [ ] Subscribes to CompileStarted: marks compile diagnostics "pending"
- [ ] Subscribes to CompileFinished: replaces compile snapshot with event payload diagnostics
- [ ] Implements stable ID generation: `hash(code + primaryTarget + signature)`
- [ ] Namespace separation: compile snapshot (keyed by patchRevision), authoring snapshot, runtime rolling window
- [ ] Query method: `getAll(filters?: { domain?, severity?, patchRevision? }): Diagnostic[]`
- [ ] Query method: `getByRevision(patchRevision: number): Diagnostic[]`
- [ ] Query method: `getActive(): Diagnostic[]` (diagnostics for current active revision)
- [ ] Unit test: CompileFinished replaces compile snapshot completely
- [ ] Unit test: Stable ID deduplication works across snapshots
- [ ] Unit test: getActive() returns diagnostics for active revision only

#### Technical Notes
- Use EventDispatcher.on() to subscribe to events in constructor
- Store diagnostics in Maps keyed by namespace (compile, authoring, runtime)
- Stable ID can use simple hash (e.g., `${code}:${primaryTarget.kind}:${primaryTarget.id}`)
- "Active revision" is set by ProgramSwapped event (Phase 1: default to latest compile)

---

### P0.7 - Create DiagnosticStore (MobX Wrapper)

**Status:** Not Started
**Effort:** Small (1-2 complexity points)
**Dependencies:** P0.6
**Spec Reference:** STATUS §DiagnosticStore

#### Description
Create a MobX observable store that wraps DiagnosticHub and provides reactive computed properties for UI consumption.

#### Acceptance Criteria (REQUIRED)
- [ ] DiagnosticStore class defined in `src/editor/stores/DiagnosticStore.ts`
- [ ] Receives DiagnosticHub instance in constructor
- [ ] Computed property: `activeDiagnostics: Diagnostic[]` (calls hub.getActive())
- [ ] Computed property: `errorCount: number` (count of severity=error diagnostics)
- [ ] Computed property: `warningCount: number` (count of severity=warn diagnostics)
- [ ] Integrated into RootStore: `this.diagnosticStore = new DiagnosticStore(hub)`
- [ ] Unit test: activeDiagnostics reacts to CompileFinished events

#### Technical Notes
- Use makeObservable() with computed properties
- DiagnosticHub state changes should trigger MobX reactivity (may need observable wrappers)
- Consider using reaction() to observe hub state if needed

---

### P0.8 - Implement Compiler Diagnostic Emission

**Status:** Not Started
**Effort:** Medium (3-4 complexity points)
**Dependencies:** P0.3, P0.6
**Spec Reference:** STATUS §Compiler Integration

#### Description
Update the compiler to build diagnostic snapshots and emit CompileStarted/CompileFinished events. Replace logStore.warn/error calls with diagnostic list building.

#### Acceptance Criteria (REQUIRED)
- [ ] Compiler emits `CompileStarted` at beginning of `compilePatch()`
- [ ] Compiler builds diagnostics array during compilation (replaces logStore calls)
- [ ] Compiler emits `CompileFinished` with diagnostics snapshot (regardless of success/failure)
- [ ] Emit at least 3 diagnostic codes: E_TIME_ROOT_MISSING, E_TIME_ROOT_MULTIPLE, E_TYPE_MISMATCH
- [ ] CompileFinished includes programMeta (timelineHint, timeRootKind) on success
- [ ] Unit test: Missing TimeRoot produces E_TIME_ROOT_MISSING diagnostic
- [ ] Unit test: Type mismatch produces E_TYPE_MISMATCH diagnostic
- [ ] Unit test: CompileFinished event includes diagnostics array

#### Technical Notes
- Use UUID library for compileId generation (e.g., randomUUID())
- Track start time for durationMs calculation
- programMeta should be extracted from compiled TimeModel

---

## P1 (High) - Additional Diagnostic Codes and Polish

### P1.1 - Add Bus-Related Diagnostic Codes

**Status:** Not Started
**Effort:** Medium (3-4 complexity points)
**Dependencies:** P0.8
**Spec Reference:** STATUS §Compiler Integration

#### Description

#### Acceptance Criteria (REQUIRED)
- [ ] Compiler emits `W_GRAPH_UNUSED_OUTPUT` for block outputs not connected and not published to bus
- [ ] Both diagnostics include affectedTargets (bus/block references)
- [ ] Unit test: Empty bus produces W_BUS_EMPTY warning
- [ ] Unit test: Unused output produces W_GRAPH_UNUSED_OUTPUT warning

#### Technical Notes

---

### P1.2 - Implement Authoring Validators (Fast)

**Status:** Not Started
**Effort:** Medium (3-4 complexity points)
**Dependencies:** P0.6
**Spec Reference:** 3.5-Events-and-Payloads-Schema.md §"On GraphCommitted: run fast authoring validators"

#### Description
Implement fast validators that run on GraphCommitted to provide immediate feedback for authoring errors (before compilation).

#### Acceptance Criteria (REQUIRED)
- [ ] Validator: Check for missing TimeRoot (authoring diagnostic)
- [ ] Validator: Check for disconnected blocks (island detection)
- [ ] Authoring diagnostics stored in separate namespace from compile diagnostics
- [ ] Authoring diagnostics cleared/recomputed on each GraphCommitted
- [ ] Unit test: Missing TimeRoot detected immediately on GraphCommitted
- [ ] Unit test: Disconnected block detected immediately on GraphCommitted

#### Technical Notes
- Authoring validators should be extremely fast (< 10ms for typical patches)
- Use graph traversal for island detection (BFS from TimeRoot)
- Authoring diagnostics supplement compile diagnostics (don't replace them)

---

### P1.3 - Add Unit Tests for Event Refactoring

**Status:** Not Started
**Effort:** Medium (3-4 complexity points)
**Dependencies:** P0.2, P0.3, P0.5
**Spec Reference:** STATUS §Quantitative Metrics

#### Description
Add comprehensive unit tests for the new event system to ensure event payloads are correct and event emission happens at the right boundaries.

#### Acceptance Criteria (REQUIRED)
- [ ] Test: GraphCommitted payload includes patchRevision, reason, diffSummary
- [ ] Test: GraphCommitted emitted after addBlock, removeBlock, addConnection, removeConnection
- [ ] Test: CompileStarted payload includes compileId, patchRevision, trigger
- [ ] Test: CompileFinished payload includes diagnostics array (success and failure cases)
- [ ] Test: CompileFinished.status is 'ok' on success, 'failed' on failure
- [ ] Test: patchRevision increments monotonically

#### Technical Notes
- Use EventDispatcher.on() in tests to capture emitted events
- Mock RootStore dependencies to isolate PatchStore tests
- Consider using a test fixture for common patch setups

---

## P2 (Medium) - Runtime Diagnostics (Phase 2 if Complex)

### P2.1 - Implement ProgramSwapped and RuntimeHealthSnapshot Events

**Status:** Not Started (Deferred Decision)
**Effort:** Large (6-8 complexity points)
**Dependencies:** P0.6, P0.7
**Spec Reference:** 3.5-Events-and-Payloads-Schema.md §3-4 (ProgramSwapped, RuntimeHealthSnapshot)

#### Description
Implement ProgramSwapped event (emitted when Player activates a new program) and RuntimeHealthSnapshot event (throttled 2-5Hz runtime stats). This enables runtime diagnostics for NaN detection, frame budget warnings, and field materialization tracking.

**DEFERRED DECISION:** Implement in Phase 1 only if straightforward; otherwise defer to Phase 2.

#### Acceptance Criteria (REQUIRED)
- [ ] `ProgramSwapped` event type defined with payload: patchRevision, compileId, swapMode, swapLatencyMs
- [ ] Player emits ProgramSwapped when activating new program
- [ ] DiagnosticHub subscribes to ProgramSwapped: sets active revision pointer
- [ ] `RuntimeHealthSnapshot` event type defined with payload: frameBudget, evalStats, nanCount, infCount, fieldMaterializations, diagnosticsDelta
- [ ] Player emits RuntimeHealthSnapshot at 2-5Hz (throttled)
- [ ] DiagnosticHub subscribes to RuntimeHealthSnapshot: updates runtime diagnostics (dedupe/expire)
- [ ] Unit test: ProgramSwapped updates active revision in DiagnosticHub
- [ ] Unit test: RuntimeHealthSnapshot updates runtime diagnostics

#### Technical Notes
- swapMode will likely be 'hard' initially (deferred/soft are future)
- RuntimeHealthSnapshot requires Player instrumentation for stats collection
- diagnosticsDelta can be full snapshot initially (optimize to delta later)
- Consider using a ring buffer for runtime diagnostic history

---

## Dependency Graph

```
P0.1 (Core Types)
  ├─> P0.2 (GraphCommitted Event)
  │     ├─> P0.4 (patchRevision Counter)
  │     │     └─> P0.5 (GraphCommitted Emission)
  │     └─> P0.6 (DiagnosticHub)
  │           └─> P0.7 (DiagnosticStore)
  │           └─> P1.2 (Authoring Validators)
  │           └─> P2.1 (Runtime Events)
  ├─> P0.3 (Compile Events)
  │     ├─> P0.6 (DiagnosticHub)
  │     └─> P0.8 (Compiler Emission)
  │           └─> P1.1 (Bus Diagnostics)
  └─> P1.3 (Event Tests)
```

---

## Recommended Sprint Planning

### Sprint 1: Foundation (P0.1-P0.5)
- Core types
- New event definitions
- PatchStore patchRevision and GraphCommitted emission
- **Deliverable:** GraphCommitted events firing correctly

### Sprint 2: DiagnosticHub and Compiler (P0.6-P0.8)
- DiagnosticHub with snapshot semantics
- DiagnosticStore MobX wrapper
- Compiler diagnostic emission
- **Deliverable:** Compile diagnostics appearing in DiagnosticStore

### Sprint 3: Polish and Runtime (P1.1-P1.3, P2.1 if feasible)
- Bus diagnostics
- Authoring validators
- Comprehensive tests
- Runtime events (if straightforward)
- **Deliverable:** Full diagnostic system operational

---

## Risk Assessment

### High-Risk Items
1. **Event refactoring** (P0.2, P0.3) - Replacing 14 events with 5 could break existing UI code
   - **Mitigation:** Audit all EventDispatcher.on() calls before removing events
2. **DiagnosticHub complexity** (P0.6) - Snapshot semantics and namespace management may be subtle
   - **Mitigation:** Start with simple snapshot replacement, add deduplication/expiry iteratively

### Medium-Risk Items
1. **Compiler integration** (P0.8) - Replacing logStore calls could miss edge cases
   - **Mitigation:** Run full test suite after migration, check for missing error messages
2. **RuntimeHealthSnapshot** (P2.1) - Player instrumentation may be complex
   - **Mitigation:** Defer to Phase 2 if blocking

### Low-Risk Items
- Core types (P0.1) - Straightforward TypeScript definitions
- DiagnosticStore (P0.7) - Simple MobX wrapper
- Unit tests (P1.3) - Standard test patterns

---

## Definition of Done (Cross-Reference)

See `DOD-2025-12-20-174727.md` for full acceptance criteria checklist.

---

## Open Questions

1. **Authoring validators scope** - Which validators are "fast enough" for GraphCommitted? (e.g., is TimeRoot check authoring or compile?)
   - **Proposed:** Missing TimeRoot is authoring (graph structure), type mismatches are compile (semantic)

2. **RuntimeHealthSnapshot complexity** - Phase 1 or Phase 2?
   - **Decision Point:** After P0.8 completion, assess Player instrumentation effort

3. **LogStore deprecation** - Remove immediately or keep for non-diagnostic logging?
   - **Proposed:** Keep LogStore for non-diagnostic logs (e.g., "Patch loaded from localStorage"), remove diagnostic uses

4. **Event removal timeline** - Can we remove 14 old events immediately or need gradual migration?
   - **Decision Point:** Audit EventDispatcher.on() calls in codebase first

---

**Plan Status:** Ready for implementation
**Risk Level:** Low-Medium (well-specified, some refactoring risk)
**Estimated Complexity:** 32-40 complexity points total (not time-based)
