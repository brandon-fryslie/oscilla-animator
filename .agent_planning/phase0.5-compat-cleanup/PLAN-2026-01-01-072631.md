# Track A Completion Plan: Unified Transform Application

**Generated:** 2026-01-01-072631
**Source STATUS:** STATUS-2026-01-01-track-a-completion.md
**Source PROGRESS:** PROGRESS-Track-A.md
**Topic:** Complete Track A - Lens/Adapter Transform Unification
**Topic Directory:** .agent_planning/phase0.5-compat-cleanup/

---

## Executive Summary

**Current State:** Track A is 80% complete (4/5 deliverables). The transforms field exists, conversion utilities work, all edges populate transforms, and compiler passes can read the field. The remaining 20% is completing unified transform application in Pass 8 and removing legacy fields.

**Sprint Goal:** Complete Track A by creating a unified `applyTransforms()` function in Pass 8 and removing legacy `lensStack`/`adapterChain` fields from Edge.

**Estimated Effort:** 2-4 days total
- A.4 completion: 1-2 days
- A.5 completion: 1-2 days

**Risk Level:** LOW - Clear path forward, stable foundation, no blockers

---

## Sprint Scope

### In Scope (This Sprint)

**P0: Complete A.4 - Unified Transform Application**
- Create single `applyTransforms()` entry point in Pass 8
- Replace 6 separate call sites using legacy functions
- Remove standalone `applyAdapterChain()` and `applyLensStack()` functions
- Handle both adapter and lens steps via kind branching

**P1: Complete A.5 - Remove Legacy Transform Fields**
- Remove `lensStack` and `adapterChain` from Edge interface
- Remove legacy fields from related types (Publisher, Listener, NormalizedBinding)
- Remove dual-write logic in edgeMigration.ts
- Final cleanup of all legacy field references

### Explicitly Out of Scope

- **Unifying LensApplyFn and AdapterApplyFn signatures** - Determined to be unnecessary. Function signature incompatibility is fundamental (RuntimeCtx vs CompileCtx) and kind branching is the appropriate solution.
- **Sprints 1-5 of main plan** - Separate work stream for bus unification
- **Track B: Registry Cleanup** - Separate parallel track
- **New compiler features** - Focus is on completing existing migration

---

## Context: Why Function Signature Incompatibility Doesn't Block Us

**Key Finding from STATUS evaluation:**

`LensApplyFn` and `AdapterApplyFn` have **fundamentally different signatures**:

```typescript
// Lenses: Runtime execution with Artifact params
export type LensApplyFn = (
  value: Artifact,
  params: Record<string, Artifact>,  // ← Artifact
  ctx: RuntimeCtx                    // ← Runtime context
) => Artifact;

// Adapters: Compile-time with unknown params
export type AdapterApplyFn = (
  artifact: Artifact,
  params: Record<string, unknown>,   // ← unknown
  ctx: CompileCtx                    // ← Compile context
) => Artifact;
```

**Why this is acceptable:**
1. **Fundamental constraint** - Different execution models (runtime vs compile-time)
2. **Already exists** - Pass 8 already has separate functions for each
3. **Explicit is better** - Branching on `step.kind` makes execution path clear
4. **Type safety preserved** - Each branch uses correct signature
5. **Still achieves goal** - Storage unified, application logic simplified from 2 functions to 1

**Implementation approach:** Accept the branch on `step.kind` and handle each case explicitly.

---

## Work Items

### P0: Complete A.4 - Unified applyTransforms() in Pass 8

**Status:** Not Started
**Effort:** Medium (1-2 days)
**Dependencies:** None (foundation already in place)
**Spec Reference:** PLAN-2026-01-01-000000.md Track A.4 • STATUS lines 107-149

#### Description

Create a single unified entry point for transform application that dispatches based on `step.kind`. This replaces the current pattern of calling `applyAdapterChain()` and `applyLensStack()` separately at each edge processing site.

**Current State (6 call sites with dual invocation):**
```typescript
// Lines 606, 617: Edge processing (wire edges)
// Lines 662, 673: Wire edges with listener
// Lines 727, 738: Bus publisher edges

// Pattern at each site:
if (edge.adapterChain) {
  ref = applyAdapterChain(ref, edge.adapterChain, ...);
}
if (edge.lensStack) {
  ref = applyLensStack(ref, edge.lensStack, ...);
}
```

**Target State (unified invocation):**
```typescript
// Single call using transforms field:
const transforms = getEdgeTransforms(edge);  // Already imported
if (transforms.length > 0) {
  ref = applyTransforms(ref, transforms, builder, errors, context);
}
```

#### Implementation Steps

1. **Extract adapter application logic** into helper function:
   - Move core logic from `applyAdapterChain()` (lines 351-413)
   - Create `applyAdapterStep(valueRef, step, builder, errors, context)`
   - Keep same error handling and registry lookup

2. **Extract lens application logic** into helper function:
   - Move core logic from `applyLensStack()` (lines 421-489)
   - Create `applyLensStep(valueRef, instance, builder, errors, context)`
   - Keep same params conversion and error handling

3. **Create unified applyTransforms() function:**
   ```typescript
   function applyTransforms(
     valueRef: ValueRefPacked,
     transforms: TransformStep[],
     builder: IRBuilder,
     errors: CompileError[],
     context: string
   ): ValueRefPacked {
     let result = valueRef;

     for (const step of transforms) {
       // Branch based on transform kind (unavoidable due to signature mismatch)
       if (step.kind === 'adapter') {
         result = applyAdapterStep(result, step, builder, errors, context);
       } else if (step.kind === 'lens') {
         result = applyLensStep(result, step, builder, errors, context);
       }
     }

     return result;
   }
   ```

4. **Update all 6 call sites:**
   - Replace dual applyAdapterChain/applyLensStack calls
   - Use `getEdgeTransforms(edge)` to get transforms
   - Call unified `applyTransforms()` once per edge

5. **Remove old functions:**
   - Delete `applyAdapterChain()` function (lines 351-413)
   - Delete `applyLensStack()` function (lines 421-489)

6. **Update tests:**
   - Add test for mixed adapter+lens transforms
   - Verify execution order preserved
   - Verify error handling unchanged

#### Acceptance Criteria (REQUIRED)

- [ ] `applyTransforms(valueRef, transforms, builder, errors, context)` function exists
- [ ] Function iterates `TransformStep[]` array once
- [ ] Branches on `step.kind` to dispatch to correct handler
- [ ] `applyAdapterStep()` helper handles adapter transforms correctly
- [ ] `applyLensStep()` helper handles lens transforms correctly
- [ ] All 6 call sites updated to use unified function:
  - [ ] Lines ~606, ~617 (edge processing)
  - [ ] Lines ~662, ~673 (wire with listener)
  - [ ] Lines ~727, ~738 (bus publishers)
- [ ] Old `applyAdapterChain()` function removed
- [ ] Old `applyLensStack()` function removed
- [ ] All 2796+ tests pass
- [ ] Golden patch compilation verified (no regression)
- [ ] Error messages still clear and actionable

#### Technical Notes

**Files to modify:**
- `src/editor/compiler/passes/pass8-link-resolution.ts` (main work)

**Helper functions pattern:**
```typescript
function applyAdapterStep(
  valueRef: ValueRefPacked,
  step: AdapterStep,
  builder: IRBuilder,
  errors: CompileError[],
  context: string
): ValueRefPacked {
  const transformDef = TRANSFORM_REGISTRY.getTransform(step.adapterId);

  if (!transformDef) {
    errors.push({ code: "UnsupportedAdapterInIRMode", message: `...` });
    return valueRef; // Continue with original value
  }

  // ... rest of adapter application logic
}

function applyLensStep(
  valueRef: ValueRefPacked,
  lensInstance: LensInstance,
  builder: IRBuilder,
  errors: CompileError[],
  context: string
): ValueRefPacked {
  const transformDef = TRANSFORM_REGISTRY.getTransform(lensInstance.lensId);

  if (!transformDef) {
    errors.push({ code: "UnsupportedLensInIRMode", message: `...` });
    return valueRef; // Continue with original value
  }

  // ... rest of lens application logic
}
```

**Why kind branching is good:**
- Explicit execution path (clear for debugging)
- Type-safe (each branch uses correct signature)
- Matches existing pattern (Pass 8 already branches on transform type)
- Preserves error handling semantics
- No loss of functionality vs dual-function approach

---

### P1: Complete A.5 - Remove Legacy Transform Fields

**Status:** Not Started (blocked by A.4)
**Effort:** Medium (1-2 days)
**Dependencies:** A.4 must be 100% complete
**Spec Reference:** PLAN-2026-01-01-000000.md Track A.5 • STATUS lines 151-191

#### Description

Remove deprecated `lensStack` and `adapterChain` fields from Edge interface and all related types after unified transforms field is fully operational. This is the final cleanup step that completes Track A.

**Blocked by:** A.4 must be complete and verified working. No code paths should access `lensStack` or `adapterChain` directly - all must use `transforms` via `getEdgeTransforms()`.

#### Implementation Steps

1. **Remove from Edge interface** (`src/editor/types.ts`):
   - Delete line 309: `readonly lensStack?: LensInstance[];`
   - Delete line 315: `readonly adapterChain?: AdapterStep[];`
   - Keep only: `readonly transforms?: TransformStep[];`

2. **Remove from related interfaces** (`src/editor/types.ts`):
   - Lines 354, 357: Publisher interface
   - Lines 386, 392: Listener interface
   - Lines 796, 799: Connection interface (deprecated type)
   - Line 232-233: Endpoint union (if applicable)

3. **Remove from NormalizedBinding** (`src/editor/bindings/types.ts`):
   - Remove any legacy transform field references
   - Ensure only transforms field used

4. **Remove dual-write logic** (`src/editor/edgeMigration.ts`):
   - Remove `convertToLegacyTransforms()` calls
   - Remove legacy field population in factory functions
   - Keep only `convertLegacyTransforms()` (for backward compat if needed)

5. **Update PatchStore** (`src/editor/stores/PatchStore.ts`):
   - Remove any legacy field handling
   - Ensure all edge mutations use transforms only

6. **Verify no references remain:**
   ```bash
   rg "lensStack|adapterChain" src/ --type ts
   ```
   - Should find ZERO references (except in comments/deprecation notes)
   - If any remain, update them to use transforms

7. **Update tests:**
   - Fix any tests that create edges with legacy fields
   - Verify all edge creation uses transforms field
   - Ensure TypeScript compilation succeeds

#### Acceptance Criteria (REQUIRED)

- [ ] Edge interface has ONLY `transforms?: TransformStep[]` field
- [ ] No `lensStack` field on Edge
- [ ] No `adapterChain` field on Edge
- [ ] NormalizedBinding uses only transforms field
- [ ] Publisher/Listener interfaces cleaned up
- [ ] Connection interface (deprecated) cleaned up
- [ ] Dual-write logic removed from edgeMigration.ts
- [ ] All edge creation uses only transforms field
- [ ] TypeScript compilation succeeds with zero errors
- [ ] All 2796+ tests pass (may require test updates)
- [ ] `rg "lensStack|adapterChain" src/ --type ts` finds zero results
- [ ] Golden patch still compiles correctly
- [ ] No runtime errors in dev server

#### Technical Notes

**Files to modify:**
- `src/editor/types.ts` (Edge, Publisher, Listener, Connection interfaces)
- `src/editor/bindings/types.ts` (NormalizedBinding)
- `src/editor/edgeMigration.ts` (remove dual-write)
- `src/editor/stores/PatchStore.ts` (remove legacy handling)
- Various test files (update edge creation)

**Migration safety:**
- This is a BREAKING change for any external code using lensStack/adapterChain
- Since this is internal compiler code, risk is low
- `getEdgeTransforms()` fallback can remain temporarily for safety
- Consider keeping conversion utilities for debugging/migration tools

**Final Edge interface:**
```typescript
export interface Edge {
  readonly id: string;
  readonly from: Endpoint;
  readonly to: Endpoint;
  readonly transforms?: TransformStep[];  // Only unified field
  readonly enabled: boolean;
  readonly weight?: number;
  readonly sortKey?: number;
}
```

---

## Dependency Graph

```
A.4 (Unified applyTransforms)
  ↓
A.5 (Remove legacy fields)
  ↓
Track A Complete ✓
```

**Sequential dependencies:**
- A.5 MUST wait for A.4 to be 100% complete
- No parallel work possible between A.4 and A.5
- Both can proceed independently of Sprints 1-5 and Track B

---

## Risk Assessment

### Technical Risks: LOW

**Strengths:**
- Foundation is solid (80% complete, all tests passing)
- Clear implementation path for both deliverables
- Signature incompatibility understood and accepted
- No ambiguous requirements
- Comprehensive test coverage (2796+ tests)

**Mitigations:**
- Run full test suite after each change
- Verify golden patch compilation after A.4 and A.5
- Keep commits focused and atomic
- Test with dev server to catch runtime issues

### Schedule Risks: NONE

- Not blocking other work streams
- Can proceed incrementally
- No external dependencies
- No coordination needed with Sprints 1-5

### Compatibility Risks: LOW

**Current state (safe migration):**
- Dual-write mode: both transforms and legacy fields populated
- Dual-read mode: compiler reads transforms with fallback to legacy
- No user-visible changes
- Backward compatible

**After A.5 (breaking change):**
- Legacy fields removed (breaking for external code)
- Internal compiler only, so low risk
- Conversion utilities remain available if needed
- Can revert if critical issues found

---

## Test Strategy

### Existing Tests (All Passing)

**Migration utilities:**
- `migrate.test.ts` - 20 tests covering conversion logic
- Roundtrip conversion verified
- Edge cases covered

**Edge creation:**
- `edgeMigration.test.ts` - 27 tests covering factory functions
- Dual-write verified

**Compiler:**
- Pass 7 tests - All passing
- Pass 8 tests - All passing
- No regressions from transforms field addition

### Tests Needed for A.4

1. **Unified execution test:**
   - Create edge with mixed transforms (adapter + lens in sequence)
   - Verify `applyTransforms()` handles both kinds correctly
   - Verify execution order preserved (lenses before adapters as per legacy)

2. **Error handling:**
   - Unknown transform ID
   - Wrong transform kind (adapter used as lens, vice versa)
   - `compileToIR()` returns null
   - Transform registry lookup failure

3. **Regression prevention:**
   - All existing transform chains still work identically
   - No change in compiled IR output (compare before/after)
   - Error messages remain clear and actionable

4. **Edge cases:**
   - Empty transforms array
   - Single adapter transform
   - Single lens transform
   - Multiple adapters + multiple lenses

**Estimated:** 5-10 new tests in Pass 8 test file

### Tests Needed for A.5

1. **Type checking:**
   - TypeScript compilation with removed fields
   - No references to lensStack/adapterChain remain

2. **Edge creation:**
   - All factories use transforms field only
   - No dual-write logic remains

3. **Runtime verification:**
   - Dev server starts without errors
   - Golden patch loads and compiles
   - Existing patches still work

**Estimated:** 3-5 test updates + verification checks

---

## Recommended Sprint Planning

### Sprint: Track A Completion (2-4 days)

**Day 1-2: A.4 Implementation**
- [ ] Extract `applyAdapterStep()` helper function
- [ ] Extract `applyLensStep()` helper function
- [ ] Create unified `applyTransforms()` function
- [ ] Update first 2 call sites (lines ~606, ~617)
- [ ] Run tests, verify no regression
- [ ] Update remaining 4 call sites
- [ ] Run full test suite
- [ ] Remove old `applyAdapterChain()` and `applyLensStack()` functions
- [ ] Add new tests for unified execution
- [ ] Verify golden patch compilation
- [ ] Commit with message: "feat(compiler): Unified transform application in Pass 8"

**Day 3-4: A.5 Implementation**
- [ ] Remove lensStack/adapterChain from Edge interface
- [ ] Remove legacy fields from Publisher/Listener/Connection
- [ ] Remove dual-write logic in edgeMigration.ts
- [ ] Update NormalizedBinding type
- [ ] Update PatchStore if needed
- [ ] Run TypeScript compilation, fix errors
- [ ] Update affected tests
- [ ] Verify no references remain (`rg` search)
- [ ] Run full test suite
- [ ] Test dev server startup
- [ ] Verify golden patch compilation
- [ ] Commit with message: "feat(compiler): Remove legacy transform fields from Edge"
- [ ] Update PROGRESS-Track-A.md to mark Track A complete

**Definition of Done:**
- All acceptance criteria met for A.4 and A.5
- All 2796+ tests passing
- Golden patch compiles without errors
- Dev server runs without runtime errors
- No TypeScript compilation errors
- No references to lensStack/adapterChain in src/ (except comments if needed)

---

## Success Metrics

**On completion of Track A:**

**Functional:**
- [x] Edge uses unified `transforms` array (A.1-A.3 complete)
- [ ] Single `applyTransforms()` function in Pass 8 (A.4)
- [ ] No lensStack/adapterChain fields remain (A.5)
- [ ] All compiler tests passing
- [ ] Transform metadata preserved
- [ ] No regressions in transform execution

**Code Quality:**
- Reduces field count on Edge interface: 3 → 1 (67% reduction)
- Reduces application functions in Pass 8: 2 → 1 (50% reduction)
- Reduces call sites in Pass 8: 12 → 6 (50% reduction)
- Increases type safety (explicit kind handling)
- Better aligns with unified transform vision
- Simpler mental model (one storage format, one application path)

**Maintenance:**
- Easier to add new transform types (just extend TransformStep union)
- Clearer execution semantics (single iteration, kind dispatch)
- Fewer places to update when changing transform behavior
- Better documentation opportunities (single function to document)

---

## Integration with Main Work Streams

### Independence from Sprints 1-5

Track A is **completely independent** of the main bus unification sprints:
- No shared code paths
- No shared data structures (beyond Edge, which is stable)
- Can complete in any order
- No coordination needed

**Recommended schedule:**
- Complete Track A this week (Days 1-4)
- Coordinate A.5 with Sprint 4 type cleanup if timing aligns (optional optimization)
- Otherwise, complete Track A fully before starting Sprint 1

### Coordination with Track B

Track B (Registry Cleanup) is also independent:
- Both tracks touch TRANSFORM_REGISTRY but in different ways
- Track A: Storage and application
- Track B: Registry implementation and compiler imports

**Recommended approach:**
- Complete Track A first (clearer priority)
- Then proceed with Track B
- Or run in parallel if different developers

---

## Verification Checklist

After completing both A.4 and A.5, verify:

**Compilation:**
- [ ] TypeScript compilation succeeds (zero errors)
- [ ] No ESLint warnings related to changes
- [ ] `just check` passes completely

**Tests:**
- [ ] `just test` passes (all 2796+ tests)
- [ ] No test skips or timeouts
- [ ] New tests added for unified execution
- [ ] Test coverage maintained or improved

**Runtime:**
- [ ] `just dev` starts without errors
- [ ] Golden patch loads in dev server
- [ ] Golden patch compiles to IR successfully
- [ ] Visual output matches expected (scrub timeline, verify animation)

**Code Quality:**
- [ ] No references to lensStack/adapterChain remain: `rg "lensStack|adapterChain" src/`
- [ ] All TODOs related to Phase 0.5 removed from Pass 8
- [ ] Function signatures clear and well-documented
- [ ] Error messages remain helpful and actionable

**Documentation:**
- [ ] PROGRESS-Track-A.md updated to mark complete
- [ ] Git commits have clear messages
- [ ] Any architectural decisions documented in comments

---

## Final Notes

**Why Track A matters:**

1. **Simplification:** Reduces transform storage from 2 fields to 1, application from 2 functions to 1
2. **Consistency:** Single unified format for all transform types
3. **Extensibility:** Easier to add new transform kinds in future
4. **Type Safety:** Explicit kind handling preserves type safety
5. **Foundation:** Sets pattern for other unification work (Sprints 1-5)

**Why signature incompatibility is acceptable:**

- It's a **fundamental constraint** of the execution models (runtime vs compile-time)
- Branching on `step.kind` is **explicit and type-safe**
- **Already exists** in current code (just outside the loop instead of inside)
- **Doesn't prevent** achieving Track A goals (storage unified, application simplified)
- **Better than alternatives** (type erasure, unsafe casting, or massive refactor)

**Track A success enables:**
- Cleaner Edge interface (single transform field)
- Simpler Pass 8 logic (one application function)
- Foundation for future transform system improvements
- Better alignment with unified compiler vision

---

**Generated by:** status-planner
**Timestamp:** 2026-01-01-072631
**Status:** Ready for implementation
**Next Step:** Begin A.4 implementation (create unified applyTransforms function)
