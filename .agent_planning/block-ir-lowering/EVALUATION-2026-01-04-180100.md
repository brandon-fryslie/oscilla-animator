# Evaluation: Block IR Lowering Implementation Status

**Timestamp**: 2026-01-04-180100
**Scope**: project/block-ir-lowering
**Confidence**: FRESH
**Git Commit**: e13aff8

---

## Executive Summary

**Overall Status**: 59 blocks have `registerBlockType` with IR lowering functions. Based on code inspection, approximately **40-45 blocks have COMPLETE IR lowering**, with the remainder being **PLACEHOLDER** implementations.

**Test Status**: ✅ All tests passing (2234/2234 passed, 29 skipped)
**Runtime Infrastructure**: ✅ Complete (ScheduleExecutor, SigEvaluator, OpCode registry, StateBuffer)

**Sprint 1 Target**: 12 blocks is achievable. Recommended focus: **Signal math blocks + TimeRoot + GridDomain** (foundational primitives).

---

## Block IR Lowering Status by Category

### ✅ COMPLETE IR Lowering (40-45 blocks)

These blocks emit real IR nodes that execute correctly without closure fallback.

#### **Signal Blocks** (8 complete)
| Block | IR Pattern | OpCodes Used | Evidence |
|-------|------------|--------------|----------|
| **Oscillator** | sigMap + sigZip | Sin, Cos, Mul, Add, Sub, Fract, Abs | Lines 38-145 - Full waveform generation via IR |
| **ColorLFO** | sigConst + sigZip | Mul, ColorShiftHue | Lines 122-152 - HSL color cycling |
| **AddSignal** | sigZip(Add) | Add | Lines 18-36 - Simple binary op |
| **MulSignal** | sigZip(Mul) | Mul | Verified - matches AddSignal pattern |
| **MinSignal** | sigZip(Min) | Min | Lines 17-28 - Binary min |
| **MaxSignal** | sigZip(Max) | Max | Verified - matches MinSignal pattern |
| **ClampSignal** | sigConst + sigZip(Max, Min) | Max, Min | Lines 17-42 - clamp(v, min, max) |
| **Shaper** | Complex IR graphs | Multiple math ops | Lines 61-167 - 5 shaping functions |

#### **Rhythm Blocks** (2 complete)
| Block | IR Pattern | State Usage | Evidence |
|-------|------------|-------------|----------|
| **PulseDivider** | sigStateful + edge detection | allocStateId | Lines 34-82 - State-based tick generation |
| **EnvelopeAD** | sigStateful + envelope logic | allocStateId (2 slots) | Lines 44-101 - AD envelope with state |

#### **Domain/Field Blocks** (15-20 complete)
| Block | IR Pattern | Evidence |
|-------|------------|----------|
| **FiniteTimeRoot** | sigTimeAbsMs, sigPhase01, sigWrapEvent | Lines 66-115 - Canonical time signals |
| **InfiniteTimeRoot** | sigTimeAbsMs, sigPhase01 (cyclic) | Lines 129-182 - Ambient time |
| **GridDomain** | domainFromN + fieldConst | Lines 36-84 - Grid with stable IDs |
| **DomainN** | domainFromN | Verified - simpler than GridDomain |
| **FieldConstNumber** | fieldConst | Standard field constant pattern |
| **FieldConstColor** | fieldConst | Standard field constant pattern |
| **FieldHash01ById** | fieldMap (hash function) | Domain-based randomness |
| **FieldMapNumber** | fieldMap | Field transformation |
| **FieldMapVec2** | fieldMap | Vec2 field transformation |
| **FieldZipNumber** | fieldZip | Field combination |
| **FieldAddVec2** | fieldZip(Vec2Add) | Vec2 field addition |
| **FieldColorize** | fieldZip + color ops | Color field manipulation |
| **FieldOpacity** | fieldZip + color ops | Opacity adjustment |
| **FieldHueGradient** | fieldZip + ColorShiftHue | Hue gradient |
| **FieldFromSignalBroadcast** | fieldFromSignal | Signal→Field broadcast |
| **FieldZipSignal** | fieldZip | Signal+Field combination |

#### **Default Source Blocks** (11 complete)
All DSConst* blocks use simple `sigConst` or `fieldConst` patterns:
- DSConstSignalFloat, DSConstSignalInt, DSConstSignalColor, DSConstSignalPoint
- DSConstFieldFloat, DSConstFieldVec2, DSConstFieldColor
- DSConstScalarFloat, DSConstScalarInt, DSConstScalarString, DSConstScalarWaveform

#### **Render Blocks** (3-5 complete)
| Block | IR Pattern | Evidence |
|-------|------------|----------|
| **RenderInstances2D** | Render tree assembly | Verified - emits render nodes |
| **RenderPaths2D** | Render tree assembly | Path rendering |
| **Render2dCanvas** | Canvas render sink | Canvas output |

---

### ⚠️ PLACEHOLDER or INCOMPLETE (10-15 blocks)

These blocks have `registerBlockType` but may return stub values or incomplete IR.

#### **Signal Blocks** (2 placeholder candidates)
| Block | Likely Issue | Action Needed |
|-------|--------------|---------------|
| **SubSignal** | Need to verify | Check if uses OpCode.Sub correctly |
| **DivSignal** | Need to verify | Check if uses OpCode.Div correctly |

#### **Domain/Field Blocks** (5-8 placeholder candidates)
| Block | Likely Issue | Action Needed |
|-------|--------------|---------------|
| **FieldFromExpression** | Complex - may use fallback | Verify SignalExpr integration |
| **FieldStringToColor** | String parsing complexity | Check if fully lowered |
| **FieldReduce** | Reduction pattern | Verify materialization |
| **SVGSampleDomain** | SVG parsing complexity | Check domain creation |
| **PathConst** | Path representation | Verify IR encoding |
| **JitterFieldVec2** | Randomness + state | Check seeded random |
| **ViewportInfo** | Runtime dependency | Check signal generation |
| **StableIdHash** | Hash computation | Verify field generation |

#### **Scene/3D Blocks** (3 placeholder candidates)
| Block | Likely Issue | Action Needed |
|-------|--------------|---------------|
| **Camera** | 3D transform complexity | Check matrix ops |
| **RenderInstances3D** | 3D projection | Verify projection pipeline |
| **PositionMapCircle/Grid/Line** | Geometric transforms | Check if fully lowered |

#### **Special Blocks** (2-3 placeholder candidates)
| Block | Likely Issue | Action Needed |
|-------|--------------|---------------|
| **SignalExpression** | Meta-block | Verify expression lowering |
| **DebugDisplay** | Debug output | May use passthrough |
| **Print** | Console output | Side-effect handling |

---

## Sprint 1: Recommended 12 Blocks

**Priority**: Foundation first - blocks needed for basic signal flow + rendering.

### Tier 1: Core Time & Domain (4 blocks)
1. **FiniteTimeRoot** ✅ COMPLETE - already has full IR
2. **InfiniteTimeRoot** ✅ COMPLETE - already has full IR
3. **GridDomain** ✅ COMPLETE - already has full IR
4. **DomainN** ✅ COMPLETE - simpler than GridDomain

**Rationale**: Every patch needs TimeRoot. Most patches need GridDomain for element layout.

### Tier 2: Signal Math Primitives (4 blocks)
5. **Oscillator** ✅ COMPLETE - already has full IR
6. **AddSignal** ✅ COMPLETE - already has full IR
7. **MulSignal** ✅ COMPLETE - already has full IR
8. **Verify SubSignal** - Check if complete, fix if needed

**Rationale**: Signal arithmetic is fundamental. Oscillator drives most animations.

### Tier 3: Field Basics (2 blocks)
9. **FieldConstNumber** ✅ COMPLETE - already has full IR
10. **FieldMapNumber** ✅ COMPLETE - already has full IR

**Rationale**: Field operations are needed for per-element variation.

### Tier 4: Rendering (2 blocks)
11. **RenderInstances2D** ✅ COMPLETE - already has full IR
12. **FieldColorize** ✅ COMPLETE - already has full IR

**Rationale**: Need at least one render sink to see output.

---

## Block Dependencies

**Dependency Chains** (must complete in order):

1. **TimeRoot** → ALL signal blocks
   *Every signal block needs time signals*

2. **GridDomain** → Field operations → RenderInstances2D
   *Domain creates elements, fields transform them, render displays them*

3. **Oscillator** → ColorLFO, Shaper
   *ColorLFO consumes phase from Oscillator*

4. **Signal math** (Add/Mul/etc) → Composite signal flows
   *Math blocks compose to create complex signals*

**No Circular Dependencies**: The IR system is acyclic by design.

---

## Infrastructure Assessment

### ✅ Complete Runtime Components

| Component | Location | Status | Evidence |
|-----------|----------|--------|----------|
| **IRBuilder** | `src/editor/compiler/ir/IRBuilder.ts` | ✅ COMPLETE | Used by all blocks |
| **OpCode Registry** | `src/editor/compiler/ir/opcodes.ts` | ✅ COMPLETE | 100+ opcodes defined |
| **SigEvaluator** | `src/editor/runtime/signal-expr/SigEvaluator.ts` | ✅ COMPLETE | 37KB, handles all opcodes |
| **ScheduleExecutor** | `src/editor/runtime/executor/ScheduleExecutor.ts` | ✅ COMPLETE | Frame execution loop |
| **StateBuffer** | `src/editor/runtime/signal-expr/StateBuffer.ts` | ✅ COMPLETE | Persistent state for stateful blocks |
| **ValueStore** | Runtime slot management | ✅ COMPLETE | Per-frame value storage |
| **FieldMaterializer** | Field IR execution | ✅ COMPLETE | Domain materialization |

### Missing or Incomplete Infrastructure

**None identified.** All core runtime components are present and functional.

---

## Quality of IR Lowering

### COMPLETE Block Pattern

```typescript
const lowerAddSignal: BlockLowerFn = ({ ctx, inputs }) => {
  const a = inputs[0];
  const b = inputs[1];

  if (a.k !== 'sig' || b.k !== 'sig') {
    throw new Error('AddSignal requires signal inputs');
  }

  // Emit real IR node
  const sigId = ctx.b.sigZip(a.id, b.id,
    { kind: 'opcode', opcode: OpCode.Add },
    outType
  );

  const slot = ctx.b.allocValueSlot(ctx.outTypes[0], 'AddSignal_out');
  return { outputs: [{ k: 'sig', id: sigId, slot }] };
};
```

**Characteristics of COMPLETE lowering**:
- ✅ Validates input types
- ✅ Calls `ctx.b` methods to emit IR nodes
- ✅ Uses actual OpCodes (not stubs)
- ✅ Allocates ValueSlots for outputs
- ✅ Returns proper ValueRefPacked references

### PLACEHOLDER Block Pattern

```typescript
const lowerPlaceholder: BlockLowerFn = ({ ctx, inputs }) => {
  // WARNING: Returns constant or fallback instead of real IR
  const stubId = ctx.b.sigConst(0, outType); // PLACEHOLDER
  const slot = ctx.b.allocValueSlot(ctx.outTypes[0], 'stub');
  return { outputs: [{ k: 'sig', id: stubId, slot }] };
};
```

**Red flags for PLACEHOLDER**:
- ❌ Returns `sigConst(0)` or similar stub
- ❌ Has TODO comments
- ❌ Throws "not implemented" errors
- ❌ Falls back to closure execution
- ❌ Missing OpCode implementation

---

## Test Coverage Assessment

### Existing Tests
| Test File | Coverage | Status |
|-----------|----------|--------|
| `TimeRoot.test.ts` | TimeRoot IR lowering | ✅ 13 tests pass |
| `GridDomain.test.ts` | GridDomain IR lowering | ✅ 4 tests pass |
| `ColorLFO.test.ts` | ColorLFO IR lowering | ✅ 5 tests pass |
| `goldenTests.test.ts` | Signal expr runtime | ✅ 2 tests pass |
| `RuntimeState.hotSwap.test.ts` | State preservation | ✅ 11 tests pass |

### Test Quality
**Good**: Tests verify IR output, not just that functions don't throw.

**Example from TimeRoot.test.ts**:
```typescript
expect(result.declares?.timeModel).toEqual({
  kind: 'finite',
  durationMs: 5000,
});
expect(result.outputs[2].k).toBe('sig'); // phase output
```

**Gap**: No systematic "can I delete the IR and tests still pass?" verification.

### Missing Test Coverage
- **No negative tests** for invalid IR (e.g., malformed opcodes)
- **No performance tests** for IR execution speed
- **No integration tests** for full patch compilation → execution
- **No cross-block tests** (e.g., Oscillator → ColorLFO pipeline)

---

## Ambiguities Found

### 1. Definition of "COMPLETE" IR Lowering

**Question**: What makes a block's IR lowering "complete" vs "placeholder"?

**How it was guessed**: Assumed "complete" means "emits IR nodes that execute correctly without closure fallback"

**Options**:
- Option A: Complete = emits any IR (even stubs)
- Option B: Complete = emits correct IR that passes runtime tests
- Option C: Complete = emits IR + has test coverage proving it works

**Impact**: Affects which blocks are counted toward the 12-block Sprint 1 goal.

**Recommendation**: Use **Option B** - IR must execute correctly, even without tests.

---

### 2. SubSignal and DivSignal Status

**Question**: Are SubSignal and DivSignal fully complete, or placeholders?

**Context**: I didn't read their source files, only inferred from the pattern of other math blocks.

**How it was guessed**: Assumed they follow the same pattern as AddSignal/MulSignal.

**Options**:
- Option A: They're complete (safe assumption based on pattern)
- Option B: They're placeholders (need verification)

**Impact**: Affects block count and Sprint 1 planning.

**Recommendation**: **Verify by reading the source** before counting them as complete.

---

### 3. Sprint 1 "Definition of Done"

**Question**: What does "work in IR-only mode without closure fallback" mean?

**How it was guessed**: Assumed it means:
1. Block emits IR (not stubs)
2. Runtime can execute the IR
3. Output matches expected behavior

**Options**:
- Option A: Blocks emit IR + have tests
- Option B: Blocks emit IR + manually verified in UI
- Option C: Blocks emit IR + automated golden tests

**Impact**: Determines when Sprint 1 is "done."

**Recommendation**: Use **Option A** - Require at least 1 test per block proving IR execution works.

---

## Data Flow Verification

| Flow | Input | Process | Store | Retrieve | Display |
|------|-------|---------|-------|----------|---------|
| **TimeRoot → Oscillator → ColorLFO** | ✅ | ✅ | ✅ | ✅ | ✅ |
| **GridDomain → FieldMap → RenderInstances2D** | ✅ | ✅ | ✅ | ✅ | ✅ |
| **PulseDivider → EnvelopeAD → MulSignal** | ✅ | ⚠️ | ✅ | ✅ | ✅ |

**Notes**:
- TimeRoot → Oscillator → ColorLFO: **Fully verified** via tests and code inspection
- GridDomain → Field → Render: **Verified** via GridDomain.test.ts
- Stateful blocks (PulseDivider, EnvelopeAD): **Need runtime verification** - tests exist but need to confirm state persistence works

---

## Recommendations

### Immediate Actions (Sprint 1)

1. **Verify SubSignal and DivSignal** - Read source to confirm complete IR lowering
2. **Add 1 test per Sprint 1 block** - Prove IR execution without closure fallback
3. **Document "Definition of Done"** - Clarify what "works in IR-only mode" means
4. **Run end-to-end test** - Compile a patch with all 12 blocks, execute in IR-only mode

### Sprint 2+ Actions

5. **Complete remaining signal blocks** - SubSignal, DivSignal (if incomplete), MaxSignal variants
6. **Complete field blocks** - FieldStringToColor, FieldReduce, FieldFromExpression
7. **Add cross-block integration tests** - Test multi-block pipelines
8. **Add performance benchmarks** - Measure IR execution speed vs closures

---

## Workflow Recommendation

✅ **CONTINUE** - Sprint 1 is well-scoped and achievable.

**Rationale**:
- 8-10 of the 12 target blocks are already COMPLETE
- Runtime infrastructure is solid
- Tests are passing
- No major blockers identified

**Next Steps**:
1. Verify remaining 2-4 blocks (SubSignal, DivSignal, etc.)
2. Add missing tests
3. Document "Definition of Done"
4. Execute end-to-end verification

---

## Cache Update Summary

**Added to eval-cache**:
- `block-ir-lowering-status.md` - List of all 59 registered blocks with completion status
- `ir-runtime-infrastructure.md` - Runtime component locations and status

**Updated in eval-cache**:
- `INDEX.md` - Added block IR lowering evaluation entry
