# Evaluation: Multi-Input Connections for Blocks

**Timestamp**: 2025-12-31-193238
**Scope**: Feature evaluation (multi-input blocks with combine modes)
**Confidence**: FRESH
**Git Commit**: cedbd90
**Topic Directory**: .agent_planning/multi-input-blocks/

---

## Executive Summary

**Verdict**: CONTINUE with STRONG ARCHITECTURAL ALIGNMENT

Multi-input connections with combine modes is:
1. **Architecturally sound** - unifies three connection types into one
2. **Already designed** - comprehensive ARCHITECTURE-PROPOSAL.md exists
3. **Partially implemented** - Edge unification Sprint 1 is in progress (Part 1 of 4 complete)
4. **Low additional effort** - requires only Phase 1 modifications (combineMode on Slot + compiler updates)
5. **High value** - eliminates buses as architectural necessity, massive simplification

**Workflow Recommendation**: CONTINUE - This is a natural extension of ongoing Edge unification work.

---

## Evaluation Reuse Summary

**Previous evaluations reviewed**:
- eval-cache/workstream-alignment.md (RECENT - 2025-12-31)
- .agent_planning/_queued/edge-unification/ARCHITECTURE-PROPOSAL.md (authoritative design)
- .agent_planning/phase0-architecture-refactoring/PLAN-2025-12-31-170000-sprint1-connections.md (current work)

**Git history analysis**: Reviewed recent commits on Edge type unification (Sprint 1 Part 1 complete as of commit cedbd90)

---

## Findings

### [FRESH] Existing Architecture Proposal

**Status**: COMPLETE DESIGN EXISTS
**Evidence**: `.agent_planning/_queued/edge-unification/ARCHITECTURE-PROPOSAL.md` (134 lines)

**Key Points**:
- Proposes EXACTLY this feature: multi-input ports with combine modes
- Comprehensive 4-phase migration plan (Phases 1-4, 6-8 weeks total effort)
- Risk assessment, test strategy, and effort estimates included
- **This is not a new idea - it's a documented architectural goal**

**Recommendation**: Strongly recommended (lines 129-132):
> Start with Phase 1 + 2 behind a feature flag. This proves the concept with low risk. If it works well, proceed to Phases 3-4.

---

### [FRESH] Current Edge Unification Progress

**Status**: SPRINT 1 PART 1 COMPLETE (2/6 work items done)
**Evidence**:
- Commit cedbd90: "feat(compiler): Add unified Edge support to compilation pipeline (Sprint 1 part 1)"
- Commit 006b3e7: "feat(types): Add unified Edge type and migration helpers"
- `src/editor/types.ts` lines 219-258: Edge type and Endpoint discriminated union defined

**Work Items Status** (from PLAN-2025-12-31-170000-sprint1-connections.md):
- ✅ **Item 1**: Edge Type Definition and Migration Helpers (COMPLETE)
- ✅ **Item 2**: PatchStore to Use Edges (COMPLETE - based on commit message)
- ⏸ **Item 3**: Pass 2 (Type Graph) updates (NOT STARTED)
- ⏸ **Item 4**: Pass 6 (Block Lowering) updates (NOT STARTED)
- ⏸ **Item 5**: Pass 7 (Bus Lowering) updates (NOT STARTED)
- ⏸ **Item 6**: Pass 8 (Link Resolution) updates (NOT STARTED)

**Current State**:
- Edge type exists and is in use
- Backward compatibility maintained (deprecated Connection/Publisher/Listener still exist)
- Compiler passes NOT YET updated to use Edge type

---

### [FRESH] Single-Input Invariant (Current Constraint)

**Status**: ENFORCED IN MULTIPLE LOCATIONS
**Evidence**:

**PatchStore.ts:905-907** (wire connections):
```typescript
// INVARIANT: An input can only have one source.
// Disconnect any existing wire or bus listener before connecting.
this.disconnectInputPort(toBlockId, toSlotId);
```

**BusStore.ts:346-348** (bus listeners):
```typescript
// INVARIANT: An input can only have one source.
// Disconnect any existing wire or bus listener before adding this listener.
this.root.patchStore.disconnectInputPort(blockId, slotId);
```

**PatchStore.ts:853-865** (`disconnectInputPort` implementation):
- Removes ALL wires to the input port
- Removes ALL bus listeners to the input port
- Enforces strict 1:1 input connection constraint

**Implication**: This invariant is INTENTIONALLY enforced. Removing it is a deliberate architectural change, not a bug fix.

---

### [FRESH] Bus Combine Modes (Existing Implementation)

**Status**: FULLY IMPLEMENTED FOR BUSES
**Evidence**:

**TypeDesc (types.ts:113)**:
```typescript
export type BusCombineMode = 'sum' | 'average' | 'max' | 'min' | 'last' | 'layer';
```

**Bus Interface (types.ts:128-149)**:
```typescript
export interface Bus {
  combineMode: BusCombineMode;
  defaultValue: unknown;
  // ... other fields
}
```

**Pass 7: Bus Lowering (pass7-bus-lowering.ts:88-150)**:
- Collects sorted publishers via `getSortedPublishers()`
- Creates explicit combine nodes (sigCombine/fieldCombine)
- Handles empty buses with default values

**Bus Semantics (busSemantics.ts:41-60)**:
- Canonical publisher sorting: `(sortKey, id)` for deterministic ordering
- Combine implementation for Signal and Field artifacts
- Single source of truth for bus logic

**Implication**: The combine logic ALREADY EXISTS and is battle-tested. Porting it to input ports is straightforward.

---

### [FRESH] Compiler Pass Integration Points

**Status**: CLEAR INTEGRATION POINTS IDENTIFIED
**Evidence**:

**Pass 6: Block Lowering** (`pass6-block-lowering.ts`):
- **Current**: Resolves single input via wire > listener > default source
- **Required**: Change to resolve MULTIPLE edges to same input, apply combine if N > 1
- **Complexity**: LOW - similar to how Pass 7 handles multiple publishers

**Pass 7: Bus Lowering** (`pass7-bus-lowering.ts`):
- **Current**: Creates combine nodes for N publishers → 1 bus
- **Required**: Reuse same combine logic for N edges → 1 input port
- **Complexity**: LOW - extract combine logic, apply to both buses and multi-input ports

**No Pass 2 Changes Needed**: Type checking doesn't care about combine - just validates source/target type compatibility per edge.

---

## Architectural Analysis

### Benefits (from ARCHITECTURE-PROPOSAL.md)

| Before | After |
|--------|-------|
| 3 connection types (Wire, Publisher, Listener) | 1 edge type |
| 2 stores (PatchStore + BusStore) | 1 store (PatchStore) |
| 3 sets of operations | 1 set of operations |
| Probe Mode needs 3 handlers | Probe Mode needs 1 handler |
| Disconnect logic in 3 places | Disconnect logic in 1 place |
| Buses architecturally required | Buses become optional UI convenience |

### What Changes

**1. Remove single-connection invariant** (PatchStore.ts, BusStore.ts):
- Delete `disconnectInputPort` call in `connect()` and `addListener()`
- Allow multiple edges to same input port

**2. Add combineMode to input slots** (Slot interface):
```typescript
interface Slot {
  // ... existing fields
  combineMode?: BusCombineMode;  // NEW: sum, max, last, etc.
  defaultCombineMode?: BusCombineMode; // Default when N > 1
}
```

**3. Compiler generates combine logic** (Pass 6):
- When input has multiple edges, emit combine step
- Reuse logic from Pass 7 bus lowering

**4. Buses become optional** (Phase 4):
- "Bus" becomes a named waypoint for discovery
- Or: add `channelName` to edges for grouping
- BusBoard becomes a view of edges grouped by channelName
- Purely organizational, not architectural

---

## Conflict Analysis: Does This Interfere with Edge Unification?

**Answer**: NO - This is a NATURAL EXTENSION of Edge unification.

**Edge Unification Sprint 1 Goal** (from PLAN-2025-12-31-170000-sprint1-connections.md):
> Replace three separate connection types (Connection, Publisher, Listener) with a single unified Edge type using discriminated union Endpoints, simplifying all compiler passes.

**Multi-Input Feature Alignment**:
1. Edge unification unifies CONNECTION TYPES (Wire, Publisher, Listener → Edge)
2. Multi-input unifies CONNECTION SEMANTICS (single-input vs multi-input with combine)
3. Both are part of the SAME architectural vision (see ARCHITECTURE-PROPOSAL.md)

**Phase Alignment**:
- **Sprint 1** (current): Edge type + compiler passes
- **Sprint 2** (proposed): Default source materialization
- **Sprint 3** (proposed): Multi-input blocks with combine modes ← **THIS FEATURE**
- **Sprint 4** (proposed): Transform unification (adapters + lenses)

**Recommendation**: Multi-input blocks should be Sprint 3, AFTER Sprint 1 (Edge unification) completes.

---

## Minimal Implementation Path

Based on ARCHITECTURE-PROPOSAL.md Phase 1 (behind feature flag):

### Step 1: Add combineMode to Slot (Small - 2-4 hours)

**File**: `src/editor/types.ts`

```typescript
export interface Slot {
  // ... existing fields

  /**
   * Combine mode for multi-input ports (when > 1 edge connected).
   * Only meaningful for input slots.
   * Defaults to 'last' if not specified.
   */
  readonly combineMode?: BusCombineMode;
}
```

### Step 2: Allow Multiple Edges to Input (Small - 2-4 hours)

**Files**: `src/editor/stores/PatchStore.ts`, `src/editor/stores/BusStore.ts`

**Behind feature flag**:
```typescript
const ENABLE_MULTI_INPUT = import.meta.env.VITE_ENABLE_MULTI_INPUT === 'true';

connect(from, to) {
  if (!ENABLE_MULTI_INPUT) {
    this.disconnectInputPort(to.blockId, to.slotId);
  }
  // ... rest of connect logic
}
```

### Step 3: Update Pass 6 for Multi-Input Resolution (Medium - 6-8 hours)

**File**: `src/editor/compiler/passes/pass6-block-lowering.ts`

**Current logic**:
```typescript
// Find single edge to input
const edge = edges.find(e => e.to === input);
```

**New logic**:
```typescript
// Find ALL edges to input
const inputEdges = edges.filter(e => e.to === input && e.enabled);

if (inputEdges.length === 0) {
  // Use default source
} else if (inputEdges.length === 1) {
  // Single input - use directly
} else {
  // Multi-input - apply combine mode
  const combineMode = inputSlot.combineMode || 'last';
  // Reuse bus combine logic from Pass 7
}
```

### Step 4: Extract Combine Logic for Reuse (Small - 4-6 hours)

**New file**: `src/editor/compiler/passes/combine-utils.ts`

Extract combine node creation from Pass 7, make it generic:
- `createCombineNode(mode: BusCombineMode, inputs: ValueRefPacked[], type: TypeDesc): ValueRefPacked`
- Use in both Pass 7 (bus lowering) and Pass 6 (multi-input lowering)

**Total Effort**: 14-22 hours (2-3 days) for Phase 1 behind feature flag

---

## Semantic/Type-System Implications

### Type Compatibility

**Question**: Do all inputs support all combine modes?

**Analysis**:
- **Signal world**: All combine modes valid (sum, average, max, min, last)
- **Field world**: All combine modes valid (same as Signal)
- **Config world**: Only 'last' makes sense (stepwise changes)
- **Scalar world**: N/A (compile-time constants, no multi-input at runtime)

**Recommendation**: Restrict `combineMode` based on `SlotWorld`:
```typescript
function getValidCombineModes(world: SlotWorld): BusCombineMode[] {
  switch (world) {
    case 'signal':
    case 'field':
      return ['sum', 'average', 'max', 'min', 'last', 'layer'];
    case 'config':
      return ['last']; // Only last makes sense for config
    case 'scalar':
      return []; // Scalar doesn't support multi-input
    default:
      return ['last'];
  }
}
```

### Domain Compatibility

**Question**: Do all domains support all combine modes?

**Analysis** (from busSemantics.ts and pass7-bus-lowering.ts):
- **Numeric domains** (float, int, vec2, vec3): All modes supported
- **Color domain**: 'last' and 'layer' (additive mixing) supported
- **String domain**: Only 'last' makes sense
- **Boolean/trigger domain**: Only 'last' or 'any' (logical OR)

**Recommendation**: Validate `combineMode` against domain:
```typescript
function isCombineModeValid(domain: CoreDomain, mode: BusCombineMode): boolean {
  if (mode === 'last') return true; // Last always valid

  switch (domain) {
    case 'float':
    case 'int':
    case 'vec2':
    case 'vec3':
      return ['sum', 'average', 'max', 'min', 'layer'].includes(mode);
    case 'color':
      return ['layer'].includes(mode);
    default:
      return false;
  }
}
```

---

## UI Implications

### Inspector UI

**Required changes**:
1. **Multi-edge visualization**: Show N edges connected to same input
2. **Combine mode selector**: Dropdown when N > 1 edges connected
3. **Edge ordering UI**: When order matters (e.g., 'layer' mode), allow reordering

**Complexity**: MEDIUM (4-6 hours)

### Canvas UI

**Required changes**:
1. **Port visual**: Indicate when port accepts multi-input (e.g., thicker border)
2. **Multiple wires**: Render N wires to same input without overlap
3. **Hover state**: Show all connected sources when hovering input

**Complexity**: SMALL (2-4 hours)

### Backward Compatibility

**Strategy**: Use feature flag during development
- `VITE_ENABLE_MULTI_INPUT=false`: Old behavior (single-input enforced)
- `VITE_ENABLE_MULTI_INPUT=true`: New behavior (multi-input allowed)

**Migration**: Existing patches work unchanged (single-input is subset of multi-input)

---

## Test Requirements

### Unit Tests

**New tests needed**:
1. ✅ Slot with combineMode defined
2. ✅ Multiple edges to same input port
3. ✅ Combine mode validation (world/domain compatibility)
4. ✅ Edge ordering and sortKey handling

**Existing tests to update**:
- PatchStore tests: Allow multiple connections to same input
- BusStore tests: Verify buses still work (backward compatibility)

### Integration Tests

**New tests needed**:
1. ✅ Compile patch with multi-input block
2. ✅ Verify combine logic (sum, average, max, min, last)
3. ✅ Verify default value when no edges
4. ✅ Verify single edge (no combine, direct passthrough)

### Golden Patch Tests

**Strategy**: Create new golden patches with multi-input blocks
- Test all combine modes
- Test mixed single/multi inputs
- Test interaction with buses (backward compat)

---

## Risk Assessment

### MEDIUM: Semantic Complexity

**Risk**: Combine modes have subtle semantics (order matters for 'last', 'layer')
**Impact**: Incorrect combine logic produces wrong output
**Mitigation**:
- Reuse battle-tested bus combine logic
- Comprehensive unit tests for all modes
- Document ordering semantics clearly

### LOW: Performance

**Risk**: N edges per input increases combine operations
**Impact**: Slower compilation/runtime
**Mitigation**:
- Bus combine already handles N publishers efficiently
- Same optimization applies (sorted array, single pass)
- Expect <5% performance impact

### LOW: UI Complexity

**Risk**: Multi-edge rendering becomes cluttered
**Impact**: Hard to see what's connected
**Mitigation**:
- Edge bundling (group edges to same port)
- Hover/select to highlight specific edge
- Inspector shows list of all sources

### LOW: Backward Compatibility

**Risk**: Existing patches break
**Impact**: User work lost
**Mitigation**:
- Feature flag during development
- Single-input is subset of multi-input (trivial migration)
- All existing patches work unchanged

---

## Comparison with Buses

### Current: Buses Handle Multi-Source

**Architecture**:
```
BlockA.out ──────> Bus ──────> BlockB.in
BlockC.out ────────┘
BlockD.out ────────┘
         (combine at bus)
```

**Pros**:
- Centralized combine logic
- Named discovery ("what's on the energy bus?")

**Cons**:
- Extra architectural layer
- 3 connection types (Wire, Publisher, Listener)
- Verbose for simple multi-input (need to create bus)

### Proposed: Blocks Handle Multi-Source

**Architecture**:
```
BlockA.out ──────┐
BlockC.out ──────┤──> BlockB.in
BlockD.out ──────┘
      (combine at input)
```

**Pros**:
- Simpler: 1 connection type (Edge)
- Direct: no intermediate bus needed
- Same semantics (combine modes identical)

**Cons**:
- Loss of named discovery (no "energy bus" to inspect)
- Repeated combine logic (if many blocks need same sources)

**Solution**: Buses become optional UI convenience
- User can still create named buses for organization
- But architecturally, they're just "blocks with multi-input and single output"
- BusBoard becomes "view of edges grouped by channelName"

---

## Recommendations

### For User

**Decision needed**: Approve multi-input blocks as Sprint 3 (after Edge unification Sprint 1 completes)?

**If YES**:
1. Let Edge unification Sprint 1 complete (4 work items remaining)
2. Start multi-input blocks Sprint 3 (2-3 days effort)
3. Defer bus removal to Phase 4 (optional, after proving concept)

**If NO**:
1. Continue with Edge unification only
2. Buses remain architecturally required
3. Multi-input blocks remain a future possibility

### For Implementer

**Next steps** (assuming YES decision):

**Immediate** (Sprint 1 completion):
- Complete Pass 2, 6, 7, 8 updates for Edge type
- Verify all tests pass with Edge type

**Sprint 3** (multi-input blocks):
1. Add `combineMode` to Slot interface
2. Add feature flag `VITE_ENABLE_MULTI_INPUT`
3. Remove single-input invariant (behind flag)
4. Extract combine logic from Pass 7 to `combine-utils.ts`
5. Update Pass 6 to handle multi-input resolution
6. Add validation for combineMode (world/domain compatibility)
7. Write tests (unit + integration)
8. Update UI (Inspector + Canvas)

**Phase 4** (optional bus removal):
- Only if multi-input blocks prove successful
- Migrate buses to "BusCombiner" blocks
- Deprecate BusStore
- Update BusBoard to query edges by channelName

---

## Ambiguities Found

| Area | Question | Impact |
|------|----------|--------|
| **Ordering semantics** | For 'layer' and 'last' modes, does order matter? If yes, how is order determined? | If undefined, output is non-deterministic. Should use `sortKey` like buses do. |
| **Default combineMode** | What's the default when N > 1 edges but no combineMode specified? | 'last' is safe default (matches single-input behavior) |
| **Scalar world** | Can scalar inputs have multi-input? | NO - scalars are compile-time constants, multi-input doesn't make sense |
| **Config world** | Can config inputs have multi-input? | Technically yes, but only 'last' makes sense (stepwise changes) |

**Clarification needed**: Document ordering semantics explicitly (use `sortKey` for determinism)

---

## Verdict

**Workflow Recommendation**: ✅ CONTINUE

**Rationale**:
1. ✅ **Good idea architecturally**: Unifies 3 connection types into 1, massive simplification
2. ✅ **Doesn't conflict**: Natural extension of Edge unification (Sprint 1)
3. ✅ **Minimal effort**: 2-3 days for Phase 1 behind feature flag
4. ✅ **Clear semantics**: Reuse battle-tested bus combine logic
5. ✅ **Backward compatible**: Single-input is subset of multi-input
6. ✅ **Already designed**: ARCHITECTURE-PROPOSAL.md is comprehensive

**No blockers identified. Proceed with Sprint 3 after Sprint 1 completes.**

---

## Files Reviewed

- `.agent_planning/_queued/edge-unification/ARCHITECTURE-PROPOSAL.md` (authoritative design)
- `.agent_planning/phase0-architecture-refactoring/PLAN-2025-12-31-170000-sprint1-connections.md` (current work)
- `.agent_planning/phase0-architecture-refactoring/DOD-2025-12-31-170000-sprint1-connections.md` (acceptance criteria)
- `src/editor/types.ts` (Edge, Endpoint, Slot, Bus types)
- `src/editor/stores/PatchStore.ts` (single-input invariant enforcement)
- `src/editor/stores/BusStore.ts` (single-input invariant enforcement)
- `src/editor/compiler/passes/pass6-block-lowering.ts` (input resolution logic)
- `src/editor/compiler/passes/pass7-bus-lowering.ts` (bus combine logic)
- `src/editor/semantic/busSemantics.ts` (canonical combine logic)
- `src/editor/blocks/signal.ts` (example block definitions)
- `src/editor/blocks/types.ts` (BlockDefinition, Slot interfaces)
- `.agent_planning/eval-cache/workstream-alignment.md` (context on current work)
- `.agent_planning/eval-cache/INDEX.md` (cache metadata)

**Total files**: 14 files, ~3000 lines reviewed

---

## Next Action

**User**: Review this evaluation and decide:
1. Approve multi-input blocks as Sprint 3? (Yes/No)
2. If Yes: Wait for Edge unification Sprint 1 to complete, then start Sprint 3
3. If No: Continue with Edge unification only, defer multi-input indefinitely

**Implementer** (if approved):
1. Complete Edge unification Sprint 1 (4 work items remaining)
2. Create Sprint 3 plan (multi-input blocks) with DOD
3. Implement behind feature flag (`VITE_ENABLE_MULTI_INPUT`)
4. Write tests and validate with golden patches
5. Update UI (Inspector + Canvas)
6. Merge to main when tests pass

---

**Evaluation complete. Workflow: CONTINUE with strong architectural alignment.**
