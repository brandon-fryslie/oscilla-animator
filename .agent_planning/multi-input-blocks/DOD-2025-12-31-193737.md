# Definition of Done: Multi-Input Blocks (Phase 1)

**Generated**: 2025-12-31-193737
**Plan**: PLAN-2025-12-31-193737.md
**Sprint**: Phase 0 - Sprint 3: Multi-Input Blocks with Combine Modes
**Feature Flag**: VITE_ENABLE_MULTI_INPUT

---

## Acceptance Criteria

### P0: Add combineMode to Slot Interface

- [ ] Slot interface extended with `readonly combineMode?: BusCombineMode` field in `src/editor/types.ts`
- [ ] JSDoc added explaining: (a) only for input slots, (b) default is 'last', (c) validated against world/domain
- [ ] No breaking changes to existing code (field is optional)
- [ ] Type exports updated if necessary
- [ ] TypeScript compilation succeeds with no errors

### P1: Feature Flag for Multi-Input Support

- [ ] Environment variable `VITE_ENABLE_MULTI_INPUT` defined (defaults to 'false')
- [ ] PatchStore.connect() conditionally calls disconnectInputPort based on flag
- [ ] BusStore.addListener() conditionally calls disconnectInputPort based on flag
- [ ] Flag documented in .env.example or equivalent config file
- [ ] All existing tests pass with flag OFF (backward compatibility verified)
- [ ] Manual test confirms multi-input allowed with flag ON

### P1: Conditionally Remove Single-Input Invariant

- [ ] PatchStore.connect() conditionally skips disconnectInputPort when flag ON
- [ ] BusStore.addListener() conditionally skips disconnectInputPort when flag ON
- [ ] disconnectInputPort logic unchanged (still used for explicit disconnects)
- [ ] Unit tests verify: (a) flag OFF = old behavior, (b) flag ON = multi-input allowed
- [ ] Integration test confirms multiple edges to same input when flag ON
- [ ] No edge cases cause errors (e.g., duplicate edges, self-loops)

### P2: Extract Combine Logic from Pass 7

- [ ] New file `src/editor/compiler/passes/combine-utils.ts` created
- [ ] Function `createCombineNode(mode, inputs, type, builder)` implemented
- [ ] Function `validateCombineMode(mode, world, domain)` implemented
- [ ] Pass 7 refactored to use combine-utils (no behavior change)
- [ ] All existing Pass 7 tests still pass (regression check)
- [ ] JSDoc added explaining combine semantics and ordering rules

### P2: Update Pass 6 for Multi-Input Resolution

- [ ] Pass 6 filters edges by `e.to === inputPort && e.enabled`
- [ ] N=0 case: Uses materializeDefaultSource (existing behavior)
- [ ] N=1 case: Direct passthrough without combine node
- [ ] N>1 case: Creates combine node with combineMode from slot
- [ ] Edge ordering uses sortKey for deterministic combine (same as buses)
- [ ] Default combineMode is 'last' if not specified on slot
- [ ] Unit tests cover all 3 cases (N=0, N=1, N>1)
- [ ] Integration test verifies compiled IR matches expected structure

### P3: Add Combine Mode Validation

- [ ] Validation function `validateCombineMode(mode, world, domain)` implemented
- [ ] Called during Pass 6 when creating combine nodes
- [ ] Invalid combinations emit CompileError with actionable message
- [ ] Unit tests cover all invalid combinations
- [ ] Unit tests verify all valid combinations pass
- [ ] Documentation updated with validation rules

---

## Unit Tests

### Slot Interface Tests
- [ ] Slot with combineMode defined compiles successfully
- [ ] combineMode optional (backward compatibility)
- [ ] combineMode ignored on output slots (no effect)

### Feature Flag Tests
- [ ] Flag OFF: single-input invariant enforced (existing behavior)
- [ ] Flag ON: multiple edges allowed to same input
- [ ] Flag toggle doesn't break existing patches

### Combine Validation Tests
- [ ] All valid world/domain combinations pass validation
- [ ] Invalid combinations emit CompileError with actionable message
- [ ] 'last' mode always valid (all worlds/domains)
- [ ] Signal/Field worlds accept all modes
- [ ] Config world only accepts 'last'
- [ ] Scalar world rejects multi-input (error if N > 1 edges)
- [ ] Numeric domains accept all modes
- [ ] Color domain only accepts 'last' and 'layer'
- [ ] String/boolean domains only accept 'last'

### Combine Logic Tests
- [ ] 'sum' mode: N floats → sum(floats)
- [ ] 'average' mode: N floats → average(floats)
- [ ] 'max' mode: N floats → max(floats)
- [ ] 'min' mode: N floats → min(floats)
- [ ] 'last' mode: N values → values[N-1] (respects sortKey)
- [ ] 'layer' mode: N values → layered composite
- [ ] Edge ordering respects sortKey (ascending)
- [ ] Ties in sortKey broken by edge ID
- [ ] N=0 inputs → default value used
- [ ] N=1 input → direct passthrough (no combine node)

---

## Integration Tests

### End-to-End Compilation Tests
- [ ] Patch with multi-input block compiles successfully (flag ON)
- [ ] IR structure contains combine node when N > 1 edges
- [ ] Different combine modes produce different IR nodes
- [ ] Single edge to input → no combine node (optimization)
- [ ] Empty input (N=0) → default source materialized

### Backward Compatibility Tests
- [ ] All existing patches compile identically with flag OFF
- [ ] Edge unification Sprint 1 patches still work
- [ ] No regression in Pass 6 behavior (single-input mode)
- [ ] No regression in Pass 7 behavior (bus combine)

---

## Golden Patch Tests

- [ ] Multi-input with 'sum' mode: 2 float signals combined correctly
- [ ] Multi-input with 'last' mode: Edge ordering verified (sortKey respected)
- [ ] Multi-input with 'layer' mode: Color domain layering correct
- [ ] Mixed single/multi inputs: Block with some inputs multi, others single
- [ ] Empty + multi-input: One slot uses default source, another has multi-input

---

## Sprint Scope

This sprint delivers:
1. **Slot interface extension**: combineMode field added
2. **Feature flag**: VITE_ENABLE_MULTI_INPUT for safe rollout
3. **Multi-input support**: Multiple edges to same input allowed (behind flag)
4. **Combine logic**: Extracted from Pass 7, reusable for Pass 6
5. **Pass 6 updates**: Handles N=0, N=1, N>1 edge cases
6. **Validation**: combineMode validated against world/domain

Deferred to future sprints:
- UI updates (Inspector multi-edge visualization + combine mode selector)
- Canvas rendering improvements (multi-wire without overlap)
- Bus removal (Phase 4 - only after multi-input proven)
- Transform unification (Sprint 4 - adapters + lenses)

---

## Validation Rules Summary

### By World
| World   | Allowed Combine Modes                        | Notes |
|---------|---------------------------------------------|-------|
| signal  | sum, average, max, min, last, layer         | All modes valid |
| field   | sum, average, max, min, last, layer         | All modes valid |
| config  | last                                        | Stepwise changes only |
| scalar  | N/A                                         | Multi-input forbidden (compile-time constants) |

### By Domain
| Domain       | Allowed Combine Modes          | Notes |
|--------------|--------------------------------|-------|
| float        | sum, average, max, min, last   | All numeric modes |
| int          | sum, average, max, min, last   | All numeric modes |
| vec2         | sum, average, max, min, last   | All numeric modes |
| vec3         | sum, average, max, min, last   | All numeric modes |
| color        | last, layer                    | Layer = additive mixing |
| string       | last                           | Only last makes sense |
| boolean      | last                           | Only last makes sense |

### Default Behavior
- **Default combineMode**: 'last' if not specified on slot
- **Edge ordering**: Ascending sortKey, ties broken by edge ID
- **Empty input (N=0)**: Use defaultSource
- **Single input (N=1)**: Direct passthrough (no combine overhead)

---

## Sprint Complete When

1. ✅ All acceptance criteria checked (above)
2. ✅ All unit tests pass (existing + new)
3. ✅ All integration tests pass
4. ✅ All golden patch tests verify actual output
5. ✅ Feature flag toggles correctly (ON = multi-input, OFF = old behavior)
6. ✅ No regressions in existing functionality
7. ✅ Documentation updated (ARCHITECTURE-PROPOSAL.md references, this DOD)
8. ✅ Code review complete (if applicable)
9. ✅ Manual smoke test confirms: (a) multi-input works, (b) single-input still works

---

## Manual Smoke Test Checklist

**With VITE_ENABLE_MULTI_INPUT=true**:
- [ ] Create patch with BlockA, BlockB, BlockC
- [ ] Connect BlockA.out → BlockB.in (wire 1)
- [ ] Connect BlockC.out → BlockB.in (wire 2)
- [ ] Verify both wires exist (not replaced)
- [ ] Set BlockB.in combineMode to 'sum'
- [ ] Compile patch → verify combine node in IR
- [ ] Run patch → verify output = A + C

**With VITE_ENABLE_MULTI_INPUT=false**:
- [ ] Create same patch as above
- [ ] Connect BlockA.out → BlockB.in (wire 1)
- [ ] Connect BlockC.out → BlockB.in (wire 2)
- [ ] Verify wire 1 replaced by wire 2 (old single-input behavior)
- [ ] Compile patch → verify no combine node
- [ ] Run patch → verify output = C only

---

**DOD complete. Ready for implementation and verification.**
