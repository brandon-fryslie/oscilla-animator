# Sprint Plan: Event System and Diagnostics Integration
**Topic**: Event System and Diagnostics Integration
**Generated**: 2025-12-27-030151
**Source**: STATUS-2025-12-27-030000.md
**Sprint Goal**: Make diagnostics VISIBLE to users through UI integration

---

## Executive Summary

**Current State**: The Event System and Diagnostics infrastructure is ~75% complete with all 130 tests passing. Core components (EventDispatcher, DiagnosticHub, DiagnosticStore, ActionExecutor, DiagnosticsConsole) are implemented and tested. The system is functionally complete but lacks the critical last mile of UI integration.

**Total Gap**: 3 work items focused on making diagnostics visible and actionable in the user interface.

**Recommended Focus**: This sprint delivers the minimum viable integration - wire the existing DiagnosticsConsole into the layout, emit compile events, and add inline badges to blocks. This makes the entire diagnostic system usable without requiring any new infrastructure.

---

## Backlog by Priority

### P0 (Critical) - Foundation for Visibility

#### [P0] Wire DiagnosticsConsole into Editor Layout

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: None
**Spec Reference**: design-docs/4-Event-System/3-Diagnostics.md (Section 4: Stores/Views) • **Status Reference**: STATUS-2025-12-27-030000.md (lines 96-103, 182-187)

##### Description
The DiagnosticsConsole component is fully implemented with 385 lines of code and complete CSS styling, but it is not imported or rendered anywhere in the main application. Users cannot see any diagnostics despite the infrastructure being complete. This work item integrates the console into the Editor layout as a collapsible bottom panel in the right sidebar.

##### Acceptance Criteria
- [ ] DiagnosticsConsole is imported in Editor.tsx
- [ ] Console is added to the right sidebar panel stack (below DebugReplPanel, above HelpPanel)
- [ ] Console has collapse/expand toggle with state persisted in useEditorLayout hook
- [ ] Console is collapsed by default to avoid overwhelming new users
- [ ] Panel header follows the same styling conventions as other panels (DebugReplPanel, HelpPanel)
- [ ] Diagnostics from DiagnosticStore are visible in the console when expanded
- [ ] Clicking on a diagnostic navigates to the target (block/bus/port) via ActionExecutor
- [ ] Severity badges (error, warn, info) render correctly with proper colors
- [ ] Mute/unmute functionality works as expected
- [ ] Layout remains responsive and does not break with console open/closed

##### Technical Notes
- Add to Editor.tsx after line 1031 (after DebugReplPanel)
- Use same panel structure as HelpPanel (collapsed state, onToggleCollapse callback)
- Add `diagnosticsCollapsed` state to useEditorLayout hook
- The DiagnosticsConsole already uses `useStore()` to access DiagnosticStore, so no additional props needed
- Verify that diagnostics update in real-time when patch changes occur
- Test with both authoring diagnostics (from SemanticValidator) and runtime diagnostics (from Player)

---

#### [P0] Add CompileFinished Event Emission from Compiler

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: None
**Spec Reference**: design-docs/4-Event-System/3-Diagnostics.md (Section 2: Compile Diagnostics) • **Status Reference**: STATUS-2025-12-27-030000.md (lines 121-124, 159-162, 191-195)

##### Description
The compiler integration exists in `src/editor/compiler/integration.ts` with diagnostic conversion logic (`compileErrorToDiagnostic`) already implemented. However, the compiler service never emits CompileStarted or CompileFinished events, so compile diagnostics never flow to DiagnosticHub. This breaks the diagnostic pipeline for compile-time errors like type mismatches, missing TimeRoot, and cycles.

The `setupAutoCompile` function in `integration.ts` orchestrates compilation but does not interact with the EventDispatcher. We need to emit CompileStarted before compilation and CompileFinished with diagnostics array after completion.

##### Acceptance Criteria
- [ ] CompileStarted event is emitted at the start of compilation in setupAutoCompile
- [ ] CompileStarted event includes patchId and patchRevision
- [ ] CompileFinished event is emitted after compilation completes (success or failure)
- [ ] CompileFinished event includes patchId, patchRevision, success flag, and diagnostics array
- [ ] Compile errors are converted to Diagnostic objects using existing compileErrorToDiagnostic function
- [ ] DiagnosticHub receives CompileFinished events and stores diagnostics in compileSnapshots
- [ ] Compile diagnostics are visible in DiagnosticsConsole after integration (P0 item above)
- [ ] Existing unit tests for compiler continue to pass
- [ ] New integration test verifies event emission and DiagnosticHub receipt
- [ ] Compile diagnostics are cleared on successful compile (no stale errors)
- [ ] Error decorations continue to work (buildDecorations uses CompileResult, not events)

##### Technical Notes
- Modify `setupAutoCompile` in `src/editor/compiler/integration.ts`
- Access EventDispatcher via `store.eventDispatcher.dispatch()`
- CompileFinished diagnostics array comes from `result.errors.map(err => compileErrorToDiagnostic(err, patchRevision))`
- Emit CompileStarted immediately before `compilePatch()` call
- Emit CompileFinished in the debounced reaction after `compilePatch()` returns
- Ensure patchRevision is captured before compilation (use `store.patchStore.revision`)
- Handle both success and failure cases (empty diagnostics array on success)
- Verify DiagnosticHub.handleCompileFinished() is called and diagnostics stored correctly
- Do NOT break existing error decoration system (it uses DecorationSet directly, not events)

---

### P1 (High) - Inline Visibility

#### [P1] Add Inline Diagnostic Badges on Blocks

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: [P0] Wire DiagnosticsConsole (for testing feedback loop)
**Spec Reference**: design-docs/4-Event-System/3-Diagnostics.md (Section 4: Inline badges on blocks/ports) • **Status Reference**: STATUS-2025-12-27-030000.md (lines 143-145, 171-172, 199-204)

##### Description
Diagnostics are currently only visible in the console (after P0 integration). Users need to see errors/warnings directly on the blocks where they occur. This work item creates a small DiagnosticBadge component and integrates it into the Block component to show severity icons and counts.

The badge should appear in the top-right corner of each block, showing the highest severity diagnostic (error > warn > info) with a count. Clicking the badge should navigate to the DiagnosticsConsole and highlight the relevant diagnostic.

##### Acceptance Criteria
- [ ] DiagnosticBadge component created in `src/editor/components/DiagnosticBadge.tsx`
- [ ] Badge displays severity icon (⛔ error, ⚠ warn, ℹ info) with count (e.g., "⛔ 2")
- [ ] Badge is positioned in top-right corner of block with consistent styling
- [ ] Badge integrates into Block component (likely BlockCard or BlockComponent)
- [ ] Badge uses `diagnosticStore.getDiagnosticsForBlock(blockId)` to fetch diagnostics
- [ ] Badge shows highest severity diagnostic when multiple exist
- [ ] Badge is hidden when no diagnostics exist for the block
- [ ] Clicking badge expands DiagnosticsConsole and scrolls to first diagnostic for that block
- [ ] Badge updates reactively when diagnostics change (MobX observer)
- [ ] Badge works for authoring, compile, and runtime diagnostics
- [ ] Visual design matches existing block styling (minimal, non-intrusive)

##### Technical Notes
- Create new file `src/editor/components/DiagnosticBadge.tsx`
- Use MobX observer to make badge reactive
- Severity priority: fatal > error > warn > info > hint
- Badge click handler: `store.uiStore.setDiagnosticsConsoleExpanded(true)` + scroll to diagnostic
- Style with CSS: absolute position, top-right, small badge with icon + count
- Integrate into Block component - find the main block rendering component (likely in `src/editor/components/`)
- Consider performance: only render badges for blocks with diagnostics (don't iterate all blocks)
- Use existing DiagnosticStore computed properties for efficiency
- Badge should not interfere with block drag/drop or selection
- Test with multiple diagnostics (show count), single diagnostic (show count "1"), no diagnostics (hide badge)

---

## Dependency Graph

```
[P0] Wire DiagnosticsConsole
     └─> [P1] Add Inline Badges (soft dependency: testing feedback loop)

[P0] Add CompileFinished Events (independent)
```

**Notes**:
- P0 items can be developed in parallel
- P1 item should wait for DiagnosticsConsole integration to enable full testing
- All items are independent of deferred features (runtime worst offenders, bus board badges, style guide)

---

## Recommended Sprint Planning

### Sprint Structure
This sprint is small and focused. All 3 items fit comfortably in a single sprint.

**Week 1 (Days 1-3)**:
- [P0] Wire DiagnosticsConsole into Editor Layout
- [P0] Add CompileFinished Event Emission (parallel work)

**Week 2 (Days 4-5)**:
- [P1] Add Inline Diagnostic Badges on Blocks
- Integration testing and polish

### Definition of Done (Sprint-Level)
- All 3 work items meet their acceptance criteria
- DiagnosticsConsole is visible and functional in the UI
- Compile diagnostics flow from compiler → DiagnosticHub → DiagnosticsConsole
- Blocks show inline badges for errors/warnings
- All existing tests pass (130 event/diagnostic tests + compiler tests)
- User can see and interact with diagnostics without opening DevTools

---

## Risk Assessment

### High-Risk Items

**Risk 1: CompileFinished Event Timing**
**Likelihood**: Medium
**Impact**: High
**Description**: The compiler integration uses debounced reactions for auto-compile. Emitting events in the wrong place could cause race conditions or missed diagnostics.
**Mitigation**: Emit CompileStarted/CompileFinished inside the debounced reaction after patchRevision is captured. Add integration tests to verify event ordering and diagnostic delivery.

**Risk 2: DiagnosticsConsole Layout Conflicts**
**Likelihood**: Low
**Impact**: Medium
**Description**: Adding DiagnosticsConsole to the right sidebar might cause layout issues or overflow in crowded layouts.
**Mitigation**: Use existing panel collapse pattern (same as DebugReplPanel, HelpPanel). Start with collapsed by default. Test with all panels open to ensure scrolling works.

### Medium-Risk Items

**Risk 3: Badge Performance on Large Patches**
**Likelihood**: Low
**Impact**: Medium
**Description**: If badges iterate all diagnostics for every block on every render, performance could degrade with many blocks.
**Mitigation**: Use DiagnosticStore computed properties which are already optimized. Only render badges for blocks with diagnostics. Use MobX observer to minimize re-renders.

### Low-Risk Items

**Risk 4: Diagnostic Conversion Edge Cases**
**Likelihood**: Low
**Impact**: Low
**Description**: Some CompileError types might not map cleanly to Diagnostic objects, causing missing or incorrect diagnostics.
**Mitigation**: The `compileErrorToDiagnostic` function is already implemented and tested. Review the mapping table and add fallback for unknown error codes.

---

## Out of Scope (Deferred to Future Sprints)

The following items from the design spec are explicitly OUT OF SCOPE for this sprint:

1. **Runtime Diagnostics for Worst Offenders** (design-docs/4-Event-System/3-Diagnostics.md, lines 46-49)
   - Track heavy field materialization with worstOffenders array in RuntimeHealthSnapshot
   - Rationale: RuntimeHealthSnapshot already emits basic stats (frameBudget, evalStats). Advanced tracking can wait.

2. **Bus Board Badges** (design-docs/4-Event-System/3-Diagnostics.md, line 148)
   - Inline diagnostic badges on bus rows in BusBoard
   - Rationale: Block badges are higher priority. Bus badges follow the same pattern.

3. **Diagnostic Style Guide** (design-docs/4-Event-System/6-DiagnosticsPolish.md, Section 5)
   - Consistent wording for diagnostic messages
   - Rationale: Current messages are functional. Polish can be a separate refinement pass.

4. **Semantic Address (pathRef)** (design-docs/4-Event-System/6-DiagnosticsPolish.md, Section 1)
   - Parallel addressing for diagnostics to survive graph rewrites
   - Rationale: Current hardRef (blockId/busId) is sufficient for now. Semantic paths are future-proofing.

5. **TypeDesc Canonical Key** (design-docs/4-Event-System/6-DiagnosticsPolish.md, Section 2)
   - Stable string representation of TypeDesc (e.g., "signal:number")
   - Rationale: TypeDesc equality and compatibility work. Canonical keys are an optimization.

6. **Diagnostic Grouping** (design-docs/4-Event-System/6-DiagnosticsPolish.md, Section 3)
   - groupKey for collapsing similar diagnostics in UI
   - Rationale: Useful for large patches with many warnings. Not needed for MVP.

7. **diagnosticsRevision Counter** (design-docs/4-Event-System/6-DiagnosticsPolish.md, Section 6)
   - Monotonic counter for efficient UI updates
   - Rationale: MobX reactivity is sufficient for now. Revision counter is an optimization.

8. **Advanced Action Execution** (design-docs/4-Event-System/3-Diagnostics.md, Section 3)
   - Multi-select goToTarget, addAdapter with full lens chain, ApplyOnPulseBoundary
   - Rationale: Basic actions (goToTarget, insertBlock, removeBlock) are implemented and tested. Advanced actions can be added incrementally.

9. **Time Console Warnings** (design-docs/4-Event-System/3-Diagnostics.md, line 149)
   - Diagnostic display in Time Console
   - Rationale: Time Console is not a priority for diagnostics in this sprint.

10. **Export Panel Warnings** (design-docs/4-Event-System/3-Diagnostics.md, line 150)
    - Diagnostic display in Export Panel
    - Rationale: Export panel diagnostics are deferred until export functionality is more mature.

11. **Patch Health Summary** (design-docs/4-Event-System/3-Diagnostics.md, line 151)
    - One-line summary in UI (Clean / Warnings / Errors)
    - Rationale: Nice-to-have for overview. DiagnosticsConsole provides detail.

---

## Testing Strategy

### Unit Tests (Already Passing)
- EventDispatcher: 14 tests ✓
- DiagnosticHub: 31 tests ✓
- DiagnosticStore: 14 tests ✓
- ActionExecutor: 22 tests ✓
- Semantic Validator (used by DiagnosticHub): existing tests ✓

### Integration Tests (New)
1. **CompileFinished Event Flow**
   - Create a patch with a type mismatch
   - Verify CompileStarted event is emitted
   - Verify CompileFinished event is emitted with diagnostics
   - Verify DiagnosticHub receives and stores diagnostics
   - Verify diagnostics appear in DiagnosticStore.activeDiagnostics

2. **DiagnosticsConsole UI Integration**
   - Render Editor with DiagnosticsConsole
   - Create authoring diagnostic (e.g., unbound port)
   - Verify diagnostic appears in console
   - Click diagnostic and verify navigation
   - Mute diagnostic and verify it disappears from active list

3. **Inline Badge Integration**
   - Render block with error diagnostic
   - Verify badge appears with error icon and count
   - Render block with multiple diagnostics (error + warn)
   - Verify badge shows error (highest severity)
   - Click badge and verify console opens to that diagnostic

### Manual Testing Checklist
- [ ] Load patch, introduce type mismatch, verify compile diagnostic appears in console
- [ ] Fix type mismatch, verify diagnostic clears
- [ ] Create unbound port, verify authoring diagnostic appears
- [ ] Play animation, verify runtime diagnostics appear (if NaN/Infinity occurs)
- [ ] Click diagnostic in console, verify navigation to block
- [ ] Mute diagnostic, verify it disappears from active list
- [ ] Click badge on block, verify console opens and scrolls to diagnostic
- [ ] Collapse/expand DiagnosticsConsole, verify state persists
- [ ] Test with many diagnostics (10+), verify UI remains usable
- [ ] Test with no diagnostics, verify console shows "No active diagnostics"

---

## Quality Standards Checklist

- [x] **Specificity**: Every work item has concrete, actionable tasks (wire component, emit events, create badge)
- [x] **Traceability**: All items link to specification sections and STATUS report sections
- [x] **Testability**: Acceptance criteria are objectively verifiable with unit and integration tests
- [x] **Completeness**: Covers all gaps identified in STATUS report for this sprint
- [x] **Realism**: Effort estimates (Small/Medium) account for complexity and unknowns
- [x] **Context**: Technical notes provide sufficient detail for developers to execute
- [x] **Acceptance Criteria**: Every work item has 2-5 specific, testable acceptance criteria (MANDATORY)

---

## Blockers and Questions

**No blockers identified.** All dependencies are in place:
- DiagnosticsConsole component exists and is tested
- DiagnosticHub and DiagnosticStore are complete
- Compiler integration has diagnostic conversion logic
- ActionExecutor is implemented

**Questions for Clarification**:
1. Should DiagnosticsConsole be collapsed or expanded by default? (Recommendation: collapsed to avoid overwhelming new users)
2. Should badges show count for single diagnostic (e.g., "⛔ 1") or just icon? (Recommendation: show count for consistency)
3. Should clicking a badge highlight the diagnostic in the console or just scroll to it? (Recommendation: scroll + highlight for better UX)

---

## Success Metrics

At the end of this sprint, users should be able to:
1. **See** diagnostics in the DiagnosticsConsole without opening DevTools
2. **Navigate** to the source of an error by clicking in the console
3. **Identify** blocks with errors/warnings via inline badges
4. **Understand** what went wrong during compilation via compile diagnostics
5. **Mute** irrelevant diagnostics to reduce noise

**Quantitative Success**:
- 0 new failing tests (all 130 existing tests + new integration tests pass)
- 3/3 work items completed with all acceptance criteria met
- DiagnosticsConsole visible in UI for 100% of users
- Compile diagnostics visible for 100% of compile errors

**Qualitative Success**:
- Diagnostics feel like an integrated part of the system, not an afterthought
- Users can fix errors without guessing where the problem is
- The UI feels more "pro" and trustworthy (per design doc goal)
