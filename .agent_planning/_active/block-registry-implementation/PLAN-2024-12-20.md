# Block Registry Implementation Plan (Vertical Slices)
**Generated:** 2024-12-20
**Topic:** Implement all block types from design-docs/3-Synthesized/09-Blocks.md

---

## Guiding Principles

1. **Every primitive MUST be used in 2+ composites** before "done"
2. **Every block MUST be bus-compatible** (can publish to or subscribe from buses)
3. **Vertical slices** - Build primitives + their consuming composites together
4. **Validate via Golden Patch** - Reference implementation must work

---

## Composite → Primitive Mapping

From the spec, here are the composites and what primitives they use:

| Composite | Primitives Used |
|-----------|-----------------|
| **BreathEnergy** | Oscillator, Shaper |
| **PulseAccentEnergy** | PulseDivider, EnvelopeAD |
| **SlowPaletteDrift** | PhaseClock (exists), ColorLFO |
| **BreathingDotsRenderer** | GridDomain, StableIdHash, JitterFieldVec2, FieldAddVec2, FieldZipSignal, RenderInstances2D (exists) |

### Primitive Usage Count

| Primitive | Used In |
|-----------|---------|
| Oscillator | BreathEnergy, (can add to SlowPaletteDrift) |
| Shaper | BreathEnergy, BreathingDotsRenderer (smoothstep for radius) |
| PulseDivider | PulseAccentEnergy, Golden Patch |
| EnvelopeAD | PulseAccentEnergy, (can use in sparkle effects) |
| ColorLFO | SlowPaletteDrift, BreathingDotsRenderer (palette) |
| StableIdHash | BreathingDotsRenderer, Golden Patch |
| FieldZipSignal | BreathingDotsRenderer, Golden Patch (phase spread) |
| JitterFieldVec2 | BreathingDotsRenderer, Golden Patch |
| FieldAddVec2 | BreathingDotsRenderer, Golden Patch |
| GridDomain | BreathingDotsRenderer, any grid-based renderer |
| AddSignal | Energy combination, (general math) |
| MulSignal | Amplitude modulation, (general math) |

---

## Vertical Slices (Implementation Order)

### Slice 1: Breathing Energy System
**Goal:** Enable smooth "breathing" intensity modulation

**Primitives:**
1. **Oscillator** - Core signal generator (sine/cosine/triangle/saw)
2. **Shaper** - Wave shaping (smoothstep for breathing curve)
3. **AddSignal** - Combine signals for energy summation
4. **MulSignal** - Scale signals (amplitude control)

**Composite:**
- **BreathEnergy** - Oscillator + Shaper publishing to energy bus

**Validation:**
- Oscillator output visible on energy bus meter
- Shaper modifies curve shape correctly
- AddSignal/MulSignal work for combination

**Bus Integration:**
- BreathEnergy publishes to `energy` bus with `sum` combine mode

---

### Slice 2: Rhythmic Accent System
**Goal:** Enable rhythmic accents synced to pulse

**Primitives:**
1. **PulseDivider** - Subdivide phase into tick events
2. **EnvelopeAD** - Attack/Decay envelope from triggers

**Composite:**
- **PulseAccentEnergy** - PulseDivider + EnvelopeAD publishing to energy bus

**Validation:**
- PulseDivider generates ticks at correct subdivisions
- EnvelopeAD triggers on pulse, decays correctly
- Combined energy shows breathing + accents

**Bus Integration:**
- PulseDivider subscribes from `phaseA`, can publish ticks to `pulse`
- EnvelopeAD subscribes from `pulse`, publishes to `energy`

---

### Slice 3: Color Palette System
**Goal:** Enable slow color drift over long phrases

**Primitives:**
1. **ColorLFO** - Generate color from phase (hue rotation)
2. **MinSignal / MaxSignal / ClampSignal** - Signal math for clamping

**Composite:**
- **SlowPaletteDrift** - PhaseClock (32s) + ColorLFO publishing to palette bus

**Validation:**
- ColorLFO produces smooth hue cycling
- Palette bus shows color swatch updating

**Bus Integration:**
- SlowPaletteDrift publishes to `palette` bus with `last` combine mode

---

### Slice 4: Per-Element Identity System
**Goal:** Enable stable per-element randomization

**Primitives:**
1. **GridDomain** - Domain with stable row/col IDs + base positions
2. **StableIdHash** - Hash stable IDs to [0,1) values

**Composite Usage:**
- Used in BreathingDotsRenderer
- Used in Golden Patch for phase offset

**Validation:**
- Same seed produces same per-element values
- Different seeds produce different but stable values
- Domain element order is deterministic

**Bus Integration:**
- Domain blocks are sources, don't use buses
- StableIdHash consumes domain, outputs field

---

### Slice 5: Field-Signal Combination System
**Goal:** Enable mixing Signal values into Field computation

**Primitives:**
1. **FieldFromSignalBroadcast** - Broadcast Signal to all elements
2. **FieldZipSignal** - Combine Field with Signal (add, mul, etc.)

**Composite Usage:**
- Used in Golden Patch for phase spread: `phasePer = frac(phaseA + idRand * 0.35)`

**Validation:**
- Signal value broadcasts correctly to all elements
- FieldZipSignal applies operator correctly

**Bus Integration:**
- FieldZipSignal subscribes signal from bus, combines with field

---

### Slice 6: Position Animation System
**Goal:** Enable per-element position drift/jitter

**Primitives:**
1. **JitterFieldVec2** - Animated per-element drift from phase + random
2. **FieldAddVec2** - Add vec2 fields element-wise

**Composite Usage:**
- Used in BreathingDotsRenderer for position drift
- Used in Golden Patch: pos = pos0 + drift

**Validation:**
- Jitter produces smooth, deterministic motion
- FieldAddVec2 combines positions correctly

**Bus Integration:**
- JitterFieldVec2 subscribes phase from bus

---

### Slice 7: Visual Styling System
**Goal:** Enable per-element color and opacity

**Primitives:**
1. **FieldColorize** - Apply color to field elements
2. **FieldOpacity** - Set opacity per element

**Composite Usage:**
- Used in BreathingDotsRenderer for fill/opacity

**Validation:**
- Colors apply correctly per element
- Opacity varies per element as expected

---

### Slice 8: Viewport Information
**Goal:** Enable responsive layouts based on canvas size

**Primitives:**
1. **ViewportInfo** - Outputs viewport size and center

**Composite Usage:**
- Used by GridDomain to center the grid
- Used by any responsive layout

**Validation:**
- ViewportInfo provides correct canvas dimensions
- Updates on resize

**Bus Integration:**
- ViewportInfo is a source block with scalar outputs

---

### Slice 9: Full Rendering Composite
**Goal:** Complete BreathingDotsRenderer

**Composite:**
- **BreathingDotsRenderer** - Full assembly of all field primitives

**Validation:**
- Golden Patch renders correctly
- All 400+ dots animate smoothly
- Breathing + accents + color drift all visible

---

## Implementation Details per Block

### Oscillator
```typescript
// src/editor/blocks/signal.ts
{
  type: 'Oscillator',
  inputs: [{ name: 'phase', type: { kind: 'Signal:phase' }, required: true }],
  params: [
    { name: 'shape', type: 'enum', options: ['sine', 'cosine', 'triangle', 'saw'], default: 'sine' },
    { name: 'amplitude', type: 'number', default: 1, min: 0, max: 10 },
    { name: 'bias', type: 'number', default: 0, min: -10, max: 10 }
  ],
  outputs: [{ name: 'out', type: { kind: 'Signal:number' } }]
}

// Compiler: src/editor/compiler/blocks/signal/Oscillator.ts
compile({ inputs, params }) {
  const phaseSignal = inputs.phase.value;
  const shape = params.shape;
  const amplitude = params.amplitude;
  const bias = params.bias;

  const shapeFns = {
    sine: (p) => Math.sin(p * 2 * Math.PI),
    cosine: (p) => Math.cos(p * 2 * Math.PI),
    triangle: (p) => 1 - 4 * Math.abs((p % 1) - 0.5),
    saw: (p) => 2 * (p % 1) - 1
  };

  return {
    out: {
      kind: 'Signal:number',
      value: (t, ctx) => {
        const phase = phaseSignal(t, ctx);
        return shapeFns[shape](phase) * amplitude + bias;
      }
    }
  };
}
```

### Shaper
```typescript
// Shaping functions
const shapers = {
  tanh: (x, k) => Math.tanh(x * k),
  softclip: (x, k) => x / (1 + Math.abs(x * k)),
  sigmoid: (x, k) => 1 / (1 + Math.exp(-x * k)),
  smoothstep: (x) => x * x * (3 - 2 * x),  // assumes x in [0,1]
  pow: (x, k) => Math.sign(x) * Math.pow(Math.abs(x), k)
};
```

### PulseDivider
```typescript
// Detects when (phase * divisions) crosses integer boundaries
compile({ inputs, params }) {
  const phaseSignal = inputs.phase.value;
  const divisions = params.divisions;
  let lastSubPhase = -1;

  return {
    tick: {
      kind: 'Signal:number',  // 1 on tick frame, 0 otherwise
      value: (t, ctx) => {
        const phase = phaseSignal(t, ctx);
        const subPhase = Math.floor(phase * divisions);
        if (subPhase !== lastSubPhase) {
          lastSubPhase = subPhase;
          return 1;
        }
        return 0;
      }
    }
  };
}
```

### EnvelopeAD
```typescript
// Stateful envelope - needs trigger detection
compile({ inputs, params, id }) {
  const triggerSignal = inputs.trigger.value;
  const attack = params.attack * 1000;  // to ms
  const decay = params.decay * 1000;
  const peak = params.peak;

  // State keys for hot swap
  let triggerTime = -Infinity;
  let wasTriggered = false;

  return {
    env: {
      kind: 'Signal:number',
      value: (t, ctx) => {
        const trig = triggerSignal(t, ctx);

        // Detect rising edge
        if (trig > 0.5 && !wasTriggered) {
          triggerTime = t;
          wasTriggered = true;
        } else if (trig <= 0.5) {
          wasTriggered = false;
        }

        const elapsed = t - triggerTime;
        if (elapsed < 0) return 0;
        if (elapsed < attack) return (elapsed / attack) * peak;
        if (elapsed < attack + decay) return peak * (1 - (elapsed - attack) / decay);
        return 0;
      }
    }
  };
}
```

### StableIdHash
```typescript
// Uses element's stable ID (not index) for hashing
compile({ inputs, params }) {
  const domain = inputs.domain.value;
  const salt = String(params.salt);

  return {
    u01: {
      kind: 'Field:number',
      value: (seed, n, ctx) => {
        const elements = domain.elements;
        return elements.map(el => {
          // Hash stable ID + salt -> [0,1)
          const hash = stableHash(el.id + salt);
          return hash / 0xFFFFFFFF;
        });
      }
    }
  };
}
```

### FieldZipSignal
```typescript
compile({ inputs, params }) {
  const fieldIn = inputs.field.value;
  const signalIn = inputs.signal.value;
  const op = params.fn;

  const ops = {
    add: (a, b) => a + b,
    sub: (a, b) => a - b,
    mul: (a, b) => a * b,
    min: (a, b) => Math.min(a, b),
    max: (a, b) => Math.max(a, b)
  };

  return {
    out: {
      kind: 'Field:number',
      value: (seed, n, ctx) => {
        const fieldValues = fieldIn(seed, n, ctx);
        const signalValue = signalIn(ctx.t, ctx);
        return fieldValues.map(v => ops[op](v, signalValue));
      }
    }
  };
}
```

### JitterFieldVec2
```typescript
compile({ inputs, params }) {
  const idRand = inputs.idRand.value;
  const phaseSignal = inputs.phase.value;
  const amount = params.amount;
  const frequency = params.frequency;

  return {
    drift: {
      kind: 'Field:vec2',
      value: (seed, n, ctx) => {
        const randoms = idRand(seed, n, ctx);
        const phase = phaseSignal(ctx.t, ctx);

        return randoms.map(r => {
          const angle = r * Math.PI * 2;
          const mag = Math.sin((phase * frequency + r) * Math.PI * 2) * amount;
          return { x: Math.cos(angle) * mag, y: Math.sin(angle) * mag };
        });
      }
    }
  };
}
```

---

## File Organization

```
src/editor/blocks/
├── signal.ts              # Oscillator, Shaper, ColorLFO
├── signal-math.ts         # AddSignal, MulSignal, MinSignal, MaxSignal, ClampSignal
├── rhythm.ts              # PulseDivider, EnvelopeAD
├── field-ops.ts           # StableIdHash, FieldFromSignalBroadcast, FieldZipSignal
├── field-vec.ts           # JitterFieldVec2, FieldAddVec2
├── field-style.ts         # FieldColorize, FieldOpacity
├── viewport.ts            # ViewportInfo
├── composites/
│   ├── AmbientLoopRoot.ts
│   ├── BreathEnergy.ts
│   ├── PulseAccentEnergy.ts
│   ├── SlowPaletteDrift.ts
│   └── BreathingDotsRenderer.ts
└── registry.ts            # Updated to include all

src/editor/compiler/blocks/
├── signal/
│   ├── Oscillator.ts
│   ├── Shaper.ts
│   ├── ColorLFO.ts
│   ├── AddSignal.ts
│   ├── MulSignal.ts
│   ├── MinSignal.ts
│   ├── MaxSignal.ts
│   └── ClampSignal.ts
├── rhythm/
│   ├── PulseDivider.ts
│   └── EnvelopeAD.ts
├── domain/                # Existing + new
│   ├── StableIdHash.ts
│   ├── FieldFromSignalBroadcast.ts
│   ├── FieldZipSignal.ts
│   ├── JitterFieldVec2.ts
│   ├── FieldAddVec2.ts
│   ├── FieldColorize.ts
│   ├── FieldOpacity.ts
│   └── GridDomain.ts      # Enhanced version
└── render/
    └── ViewportInfo.ts
```

---

## Acceptance Criteria (Updated)

### Per Slice

**Slice 1: Breathing Energy**
- [ ] Oscillator produces all 4 waveforms correctly
- [ ] Shaper applies all 5 shaping functions
- [ ] AddSignal/MulSignal work for signal math
- [ ] BreathEnergy composite publishes to energy bus

**Slice 2: Rhythmic Accent**
- [ ] PulseDivider generates correct subdivisions
- [ ] EnvelopeAD triggers and decays correctly
- [ ] PulseAccentEnergy composite works with energy bus

**Slice 3: Color Palette**
- [ ] ColorLFO produces smooth hue cycling
- [ ] MinSignal/MaxSignal/ClampSignal work
- [ ] SlowPaletteDrift composite publishes to palette bus

**Slice 4: Per-Element Identity**
- [ ] GridDomain outputs stable element IDs + positions
- [ ] StableIdHash produces deterministic per-element values

**Slice 5: Field-Signal Combination**
- [ ] FieldFromSignalBroadcast broadcasts correctly
- [ ] FieldZipSignal combines field + signal

**Slice 6: Position Animation**
- [ ] JitterFieldVec2 produces smooth drift
- [ ] FieldAddVec2 combines positions correctly

**Slice 7: Visual Styling**
- [ ] FieldColorize applies colors per element
- [ ] FieldOpacity sets opacity per element

**Slice 8: Viewport**
- [ ] ViewportInfo provides correct dimensions

**Slice 9: Full Composite**
- [ ] BreathingDotsRenderer works end-to-end
- [ ] Golden Patch can be constructed and runs

### Quality Gates
- [ ] `just typecheck` passes
- [ ] `just lint` passes
- [ ] `just test` passes
- [ ] All blocks appear in palette
- [ ] All blocks connect without type errors

---

## Bus Compatibility Checklist

Every block must support bus integration:

| Block | Can Subscribe From | Can Publish To |
|-------|-------------------|----------------|
| Oscillator | phaseA (phase input) | energy |
| Shaper | any Signal<number> | energy |
| PulseDivider | phaseA | pulse |
| EnvelopeAD | pulse | energy |
| ColorLFO | phaseA, phaseB | palette |
| StableIdHash | - (domain input) | - (field output) |
| FieldZipSignal | any Signal | - (field output) |
| JitterFieldVec2 | phaseA, phaseB | - (field output) |
| AddSignal | any Signal<number> x2 | any number bus |
| MulSignal | any Signal<number> x2 | any number bus |
| ViewportInfo | - | - (scalar source) |

---

## Dependencies

- Existing block factory (`createBlock()`)
- Existing compiler infrastructure
- Existing Field evaluation pattern
- Bus system for pub/sub
- Runtime context for viewport/time
