# Sprint Plan: Undo/Redo Implementation
**Generated**: 2025-12-27-000000
**Source**: STATUS-2025-12-27-000000.md
**Spec**: design-docs/6-Transactions/

## Executive Summary

This sprint delivers a **working undo/redo system** for Oscilla Animator, transforming the current direct-mutation architecture into a command-based transaction system with full history tracking.

**Current State**: Direct MobX store mutations, no history, no undo capability
**Sprint Goal**: Command-based transactions + revision history + working undo/redo UI
**Scope**: Core transaction system → History tracking → Basic UI (defer: gesture buffer advanced features)

**Risk Level**: Medium (architectural change, but well-specified)
**Dependencies**: None (all infrastructure exists)

---

## Phase 1: Transaction Foundation (P0)

### P0-1: Define Op Types and Inverses

**Status**: Not Started
**Complexity**: Medium
**Dependencies**: None
**Spec Reference**: 2-Ops.md → STATUS-2025-12-27-000000.md (Missing Components)

#### Description
Create the complete Op union type and inverse computation logic. This is the foundation of the entire transaction system - every mutation must be expressible as an Op with a computable inverse.

#### Implementation
1. Create `src/editor/transactions/ops.ts`:
   - Define Op union: `Add | Remove | Update | SetBlockPosition | SetTimeRoot | SetTimelineHint | Many`
   - Each op has `type` discriminator + entity-specific fields
   - `Remove` ops capture `removed` entity for inverse
   - `Update` ops capture both `prev` and `next` state
   - `Many` op wraps an array of ops (for batch operations)

2. Implement `computeInverse(op: Op): Op`:
   - Add → Remove (with captured entity)
   - Remove → Add (restore removed entity)
   - Update → Update (swap prev/next)
   - SetBlockPosition → SetBlockPosition (swap prev/next)
   - Many → Many (reverse array, invert each op)

3. Add serialization helpers for IndexedDB persistence

#### Acceptance Criteria
- [ ] All 8 op types defined with TypeScript discriminated union
- [ ] `computeInverse()` correctly inverts each op type (unit tested)
- [ ] `Many` op correctly handles nested ops and order reversal
- [ ] Remove ops capture full entity state in `removed` field
- [ ] Update ops capture both prev and next states
- [ ] Ops are JSON-serializable (no functions, classes, or observables)

#### Technical Notes
- Ops store plain data only - no MobX observables
- Entity IDs (blockId, busId) are sufficient for lookups
- Prev/next states for params use `Record<string, unknown>`
- SetBlockPosition stores `{ x: number, y: number }` coords

---

### P0-2: Implement TxBuilder Core

**Status**: Not Started
**Complexity**: Large
**Dependencies**: P0-1
**Spec Reference**: 3-TxBuilderSpec.md → STATUS-2025-12-27-000000.md (No runTx() function)

#### Description
Create the `TxBuilder` API and `runTx()` function that becomes the **only** way to mutate patch state. This enforces transaction boundaries and enables inverse capture.

#### Implementation
1. Create `src/editor/transactions/TxBuilder.ts`:
   - `class TxBuilder` with methods: `add()`, `remove()`, `replace()`, `setTimeRoot()`, `many()`
   - Internal `ops: Op[]` accumulator
   - `commit()` method that applies ops to stores and computes inverses

2. Create `runTx()` wrapper:
   ```typescript
   function runTx(
     store: RootStore,
     spec: { label?: string },
     build: (tx: TxBuilder) => void
   ): { ops: Op[], inverseOps: Op[] }
   ```
   - Creates TxBuilder, calls build function, commits transaction
   - Returns both forward ops and inverse ops
   - Emits GraphCommitted event after commit

3. Implement store mutation logic in `commit()`:
   - Add: push to store arrays
   - Remove: filter store arrays
   - Update: mutate entity in place (preserves MobX reactivity)
   - SetBlockPosition: update ViewStateStore
   - Many: apply each op in sequence

#### Acceptance Criteria
- [ ] `runTx()` is the only way to mutate patch state (enforced by architecture)
- [ ] TxBuilder captures all ops in order during build phase
- [ ] `commit()` applies ops to stores atomically
- [ ] Inverse ops are computed correctly at commit time
- [ ] MobX reactivity is preserved (mutations update observables in place)
- [ ] GraphCommitted event fires after successful commit
- [ ] Transaction label is captured for history display
- [ ] Failed transactions don't partially mutate state (rollback on error)

#### Technical Notes
- TxBuilder receives RootStore reference for store access
- Update ops mutate entity objects in place (for MobX)
- Add/Remove ops modify observable arrays (triggers reactivity)
- All current PatchStore/BusStore actions will be refactored to use runTx()

---

### P0-3: Add Cascade Helpers

**Status**: Not Started
**Complexity**: Medium
**Dependencies**: P0-2
**Spec Reference**: 3-TxBuilderSpec.md (Cascade Helpers) → STATUS-2025-12-27-000000.md (No cascade helpers)

#### Description
Implement `removeBlockCascade()` and `removeBusCascade()` helpers that generate the correct sequence of ops when removing entities with dependencies.

#### Implementation
1. Add to TxBuilder class:
   - `removeBlockCascade(blockId)`:
     - Remove all connections to/from block
     - Remove default sources for block inputs
     - Remove block from lanes
     - Remove block itself

   - `removeBusCascade(busId)`:
     - Remove bus itself

2. Query helpers for dependency discovery:
   - `getConnectionsForBlock(blockId)`: find all wires

#### Acceptance Criteria
- [ ] `removeBlockCascade()` removes block and all dependent entities in correct order
- [ ] `removeBusCascade()` removes bus and all routing in correct order
- [ ] Cascade operations generate multiple ops (connections first, then entity)
- [ ] Inverse ops correctly recreate entire cascade (reverse order)
- [ ] No orphaned connections or bindings remain after cascade
- [ ] Cascades work when invoked during `runTx()` build phase

#### Technical Notes
- Removal order matters: connections/bindings before blocks/buses
- Inverse order is reversed for undo
- Cascade helpers emit Many op containing all sub-ops
- Current `removeBlock()` logic provides reference implementation

---

## Phase 2: History System (P0)

### P0-4: Implement HistoryStore

**Status**: Not Started
**Complexity**: Large
**Dependencies**: P0-2
**Spec Reference**: 6-HistoryStore.md → STATUS-2025-12-27-000000.md (No revision tree)

#### Description
Create the HistoryStore that maintains a persistent revision tree with snapshots and op replay capability.

#### Implementation
1. Create `src/editor/stores/HistoryStore.ts`:
   - `RevisionNode` type: `{ id, parentId, ops, inverseOps, label, timestamp, snapshotData? }`
   - Observable `revisions: Map<number, RevisionNode>`
   - Observable `currentRevisionId: number`
   - `addRevision(ops, inverseOps, label)`: create new node
   - `getRevision(id)`: lookup by ID
   - `getChildren(id)`: find all child nodes

2. Snapshot policy:
   - Create snapshot every 25 revisions
   - Store full patch state (using `RootStore.toJSON()`)
   - Load = find nearest snapshot + replay ops forward

3. Integration with runTx():
   - Hook into commit phase to auto-create revision nodes
   - Pass ops and inverseOps to HistoryStore after successful commit

#### Acceptance Criteria
- [ ] HistoryStore maintains revision tree with parent/child links
- [ ] New revisions are added automatically after each runTx() commit
- [ ] Snapshots are created every 25 revisions
- [ ] Each revision stores ops, inverseOps, label, timestamp
- [ ] Revision tree supports multiple children per parent (variations)
- [ ] currentRevisionId tracks active revision
- [ ] Tree structure is queryable (getChildren, getRevision)

#### Technical Notes
- Revision IDs match patchRevision counter
- Parent ID is previous currentRevisionId
- Snapshot data uses Patch type from toJSON()
- Tree is never truncated (history is forever)

---

### P0-5: Implement Undo/Redo Logic

**Status**: Not Started
**Complexity**: Medium
**Dependencies**: P0-4
**Spec Reference**: 7-UndoRedo.md → STATUS-2025-12-27-000000.md (No undo capability)

#### Description
Implement `undo()` and `redo()` operations that navigate the revision tree by applying inverse ops.

#### Implementation
1. Add to HistoryStore:
   - `undo()`:
     - Get current revision's inverseOps
     - Apply ops to stores (using applyOps helper)
     - Set currentRevisionId to parent
     - Update patchRevision

   - `redo()`:
     - Get child revision (use preferred child or prompt for variation)
     - Apply child's forward ops
     - Set currentRevisionId to child
     - Update patchRevision

2. Helper: `applyOps(ops: Op[])`:
   - Execute ops directly against stores
   - Do NOT create new revision (we're navigating history, not creating new nodes)
   - Use same mutation logic as TxBuilder.commit()

3. Variation handling:
   - If multiple children exist, choose first child (simple strategy)
   - Mark chosen child as "preferred" for future redo

#### Acceptance Criteria
- [ ] `undo()` applies inverse ops and moves to parent revision
- [ ] `redo()` applies forward ops and moves to child revision
- [ ] Undo/redo correctly updates patchRevision counter
- [ ] Multiple undo calls navigate up the tree correctly
- [ ] Redo after undo restores exact state
- [ ] Works with branching history (variations)
- [ ] Undo at root (no parent) does nothing gracefully
- [ ] Redo at leaf (no children) does nothing gracefully

#### Technical Notes
- Undo/redo use same mutation primitives as transactions
- No new GraphCommitted events during undo/redo (navigation, not mutation)
- Current state is always reflected by currentRevisionId
- Snapshot replay may be needed if navigating far back

---

## Phase 3: Store Migration (P0)

### P0-6: Refactor PatchStore to Use runTx()

**Status**: Not Started
**Complexity**: Large
**Dependencies**: P0-3
**Spec Reference**: 3-TxBuilderSpec.md → STATUS-2025-12-27-000000.md (Current mutation patterns)

#### Description
Migrate all PatchStore action methods to use `runTx()` instead of direct mutations. This is the critical migration that enforces transaction boundaries.

#### Implementation
1. Refactor each action method:
   ```typescript
   // Before:
   addBlock(type, params) {
     const block = { id, type, ... };
     this.blocks.push(block);
     this.emitGraphCommitted(...);
   }

   // After:
   addBlock(type, params) {
     runTx(this.root, { label: 'Add Block' }, tx => {
       tx.add('blocks', { id, type, ... });
       // Auto-cascade handled by TxBuilder
     });
   }
   ```

2. Migrate methods in order:
   - `addBlock()`, `removeBlock()`, `updateBlock()`
   - `connect()`, `disconnect()`, `updateConnection()`
   - `replaceBlock()` (uses removeBlockCascade + add)
   - `expandMacro()` (uses many ops)

3. Remove manual GraphCommitted emissions (now handled by runTx)

#### Acceptance Criteria
- [ ] All PatchStore action methods use runTx() exclusively
- [ ] No direct array mutations (push/filter) remain in PatchStore
- [ ] Block add/remove operations generate correct ops
- [ ] Connection add/remove operations generate correct ops
- [ ] replaceBlock preserves connections using cascade helpers
- [ ] expandMacro creates single Many op for entire expansion
- [ ] All existing tests pass with new transaction system
- [ ] GraphCommitted events still fire correctly

#### Technical Notes
- This is a large refactor touching ~15 methods
- Maintain backward compatibility for existing UI code
- Event emission moves from individual methods to runTx()
- May need intermediate commits for partial migration

---

### P0-7: Refactor BusStore to Use runTx()

**Status**: Not Started
**Complexity**: Medium
**Dependencies**: P0-6
**Spec Reference**: 3-TxBuilderSpec.md → STATUS-2025-12-27-000000.md (Current mutation patterns)

#### Description
Migrate all BusStore action methods to use `runTx()` for bus and routing mutations.

#### Implementation
1. Refactor bus management:
   - `createBus()`, `deleteBus()`, `updateBus()`
   - Use removeBusCascade for deleteBus

2. Refactor routing management:

3. Lens stack operations:
   - `addLensToStack()`, `removeLensFromStack()`, `clearLensStack()`

#### Acceptance Criteria
- [ ] All BusStore action methods use runTx() exclusively
- [ ] Bus creation/deletion generates correct ops
- [ ] deleteBus uses removeBusCascade helper
- [ ] All existing bus tests pass
- [ ] Bus-related events still fire correctly

#### Technical Notes

---

## Phase 4: Basic Undo/Redo UI (P1)

### P1-1: Add Undo/Redo Keyboard Shortcuts

**Status**: Not Started
**Complexity**: Small
**Dependencies**: P0-5
**Spec Reference**: 7-UndoRedo.md → STATUS-2025-12-27-000000.md (No undo/redo UI)

#### Description
Add keyboard shortcuts (Cmd+Z / Cmd+Shift+Z) for undo/redo operations.

#### Implementation
2. Call HistoryStore.undo() / redo() on keypress
3. Prevent default browser behavior
4. Show toast/notification on undo/redo

#### Acceptance Criteria
- [ ] Cmd+Z (Ctrl+Z on Windows) triggers undo
- [ ] Cmd+Shift+Z (Ctrl+Shift+Z on Windows) triggers redo
- [ ] Shortcuts work when editor has focus
- [ ] Visual feedback shows undo/redo occurred (toast or status message)
- [ ] Shortcuts disabled when no undo/redo available
- [ ] Works with current selection system

#### Technical Notes
- Use same keyboard handler pattern as existing shortcuts
- Toast duration: 1-2 seconds

---

### P1-2: Create History Panel Component

**Status**: Not Started
**Complexity**: Medium
**Dependencies**: P0-5
**Spec Reference**: 8-HistoryPanelUI.md → STATUS-2025-12-27-000000.md (No history panel)

#### Description
Create a basic History Panel that shows the revision list and allows clicking to navigate history.

#### Implementation
1. Create `src/editor/components/HistoryPanel.tsx`:
   - List view showing revisions (newest at top)
   - Each item shows: label, timestamp, revision ID
   - Current revision highlighted
   - Click to navigate to revision

2. Navigation logic:
   - Click → load snapshot (if available) or replay ops
   - Update currentRevisionId
   - Trigger recompile

3. Add panel toggle button in main UI

#### Acceptance Criteria
- [ ] History panel displays all revisions in chronological order
- [ ] Current revision is visually highlighted
- [ ] Clicking a revision navigates to that state
- [ ] Panel shows revision label, timestamp, and ID
- [ ] Panel can be toggled open/closed
- [ ] Panel updates reactively when new revisions added
- [ ] Scrollable when revision list is long

#### Technical Notes
- Use MobX observer for reactive updates
- Panel placement: sidebar or modal (design decision)
- Virtualize list if performance issues with long history
- Defer map view (tree visualization) to future sprint

---

## Phase 5: Testing & Integration (P0)

### P0-8: Write Transaction System Tests

**Status**: Not Started
**Complexity**: Medium
**Dependencies**: P0-7
**Spec Reference**: 3-TxBuilderSpec.md → STATUS-2025-12-27-000000.md

#### Description
Create comprehensive test suite for transaction system, covering op inversion, cascades, and undo/redo.

#### Implementation
1. Test op inversion:
   - Each op type correctly inverts
   - Many op handles nested ops
   - Round-trip: apply op + apply inverse = original state

2. Test TxBuilder:
   - runTx creates correct ops
   - Cascade helpers generate correct sequences
   - Failed transactions rollback cleanly

3. Test HistoryStore:
   - Revision tree builds correctly
   - Undo/redo navigation works
   - Snapshots created at correct intervals
   - Multiple children (variations) handled

4. Integration tests:
   - Add block → undo → redo = correct state
   - Complex operations (replace block, expand macro) undo correctly
   - Bus routing undo/redo preserves bindings

#### Acceptance Criteria
- [ ] All op types have inversion tests (8+ tests)
- [ ] TxBuilder commit logic has unit tests (5+ tests)
- [ ] Cascade helpers tested with real dependencies (4+ tests)
- [ ] HistoryStore tree navigation tested (6+ tests)
- [ ] Undo/redo integration tests cover all entity types (10+ tests)
- [ ] Snapshot creation and replay tested
- [ ] Edge cases tested (undo at root, redo at leaf, variations)
- [ ] All tests pass before merging

#### Technical Notes
- Use existing test infrastructure (Jest + @testing-library)
- Mock RootStore for isolated TxBuilder tests
- Use real stores for integration tests
- Test files: `__tests__/transactions/`

---

### P0-9: Manual Testing & Edge Cases

**Status**: Not Started
**Complexity**: Small
**Dependencies**: P1-2
**Spec Reference**: All specs → STATUS-2025-12-27-000000.md

#### Description
Manually verify undo/redo works correctly in real usage scenarios and identify edge cases.

#### Test Scenarios
1. Basic operations:
   - Add block → undo → redo
   - Connect blocks → undo → redo
   - Delete block with connections → undo → redo

2. Complex operations:
   - Replace block → undo (preserves old connections)
   - Expand macro → undo (removes all created blocks)
   - Bus routing changes → undo → redo

3. Edge cases:
   - Undo at patch start (nothing to undo)
   - Multiple undo then redo
   - Create variation (edit after undo)

4. Performance:
   - Undo/redo with large patch (100+ blocks)
   - History panel with 100+ revisions

#### Acceptance Criteria
- [ ] All basic operations undo/redo correctly
- [ ] Complex operations (replace, macro) undo correctly
- [ ] Bus routing preserved through undo/redo
- [ ] Edge cases handled gracefully (no crashes)
- [ ] Performance acceptable with large patches
- [ ] History panel usable with long history
- [ ] No memory leaks during extended undo/redo session

#### Technical Notes
- Use Chrome DevTools MCP for verification
- Test with "Breathing Constellation" golden patch
- Monitor memory usage during long sessions
- Document any discovered issues as P2 items

---

## Deferred to Future Sprints

### Gesture Buffer (4-GestureBufferSpec.md)
**Deferred**: Full gesture buffer with working state overlay
**Reason**: Core undo/redo is higher priority; gesture buffer enhances UX but isn't required for basic functionality
**Future Work**:
- beginGesture/updateGesture/commitGesture lifecycle
- Working state overlay with O(1) lookups
- Consolidation rules for param drags and block moves
- Preview policies (compile-live, compile-debounced)

### Advanced History Features
**Deferred**:
- Map view (tree visualization)
- Variation chooser UI (when multiple children)
- Revision search/filter
- History export/import
**Reason**: List view + keyboard shortcuts are sufficient for MVP

### IndexedDB Persistence
**Deferred**: Persistent history storage across sessions
**Reason**: In-memory history is sufficient for single session; persistence is nice-to-have
**Future Work**:
- IndexedDB schema for revision nodes
- Auto-save history on window close
- Load history on patch open

---

## Sprint Delivery Summary

### Delivered Features
1. ✅ Command-based transaction system (Op types + TxBuilder)
2. ✅ All mutations through runTx() (no direct store mutations)
3. ✅ Revision history tree with snapshots
4. ✅ Working undo/redo (keyboard shortcuts)
5. ✅ Basic History Panel UI (list view)
6. ✅ Comprehensive test coverage

### Sprint Success Criteria
- [ ] User can undo any edit operation with Cmd+Z
- [ ] User can redo any undone operation with Cmd+Shift+Z
- [ ] History panel shows all revisions chronologically
- [ ] Complex operations (replace block, expand macro) undo correctly
- [ ] No direct store mutations remain (all via runTx)
- [ ] All existing tests pass
- [ ] New transaction tests pass (30+ tests)

### Post-Sprint State
- **Architecture**: Command-based transactions enforced
- **Safety**: All edits are reversible
- **UX**: Basic undo/redo keyboard shortcuts working
- **Foundation**: Ready for gesture buffer and advanced features

---

## Risk Assessment

### Medium Risks
1. **MobX Integration**: Transaction system must preserve reactivity
   - *Mitigation*: Mutate observables in place (Update ops)
   - *Validation*: Test with complex MobX-dependent UI

2. **Performance**: Undo/redo with large patches (100+ blocks)
   - *Mitigation*: Use snapshots for fast replay
   - *Validation*: Load test with Breathing Constellation patch

3. **Migration Completeness**: Missing a mutation path breaks undo
   - *Mitigation*: Systematic refactor of all store actions
   - *Validation*: Code review + grep for direct mutations

### Low Risks
   - *Mitigation*: runTx emits GraphCommitted as before

2. **Test Coverage**: Need comprehensive tests for confidence
   - *Mitigation*: Dedicated P0-8 task for test suite

---

## Dependencies & Prerequisites

**External Dependencies**: None
**Internal Prerequisites**:
- MobX store architecture ✓
- Event system ✓
- Serialization (toJSON/loadPatch) ✓
- Patch revision tracking ✓

**All prerequisites met** - ready to begin implementation.

---

## Recommended Implementation Order

1. **Week 1**: Foundation (P0-1, P0-2, P0-3)
   - Define ops → Implement TxBuilder → Add cascades
   - Goal: runTx() working with basic ops

2. **Week 2**: History + Migration (P0-4, P0-5, P0-6)
   - HistoryStore → Undo/Redo → Migrate PatchStore
   - Goal: Undo/redo working for blocks/connections

3. **Week 3**: Complete Migration + UI (P0-7, P1-1, P1-2)
   - Migrate BusStore → Add keyboard shortcuts → Build panel
   - Goal: Full undo/redo with UI

4. **Week 4**: Testing & Polish (P0-8, P0-9)
   - Write tests → Manual testing → Fix issues
   - Goal: Production-ready undo/redo

**Total Complexity**: ~12 person-weeks if done sequentially
**Recommended**: 2-3 developers working in parallel for 2-3 week sprint
