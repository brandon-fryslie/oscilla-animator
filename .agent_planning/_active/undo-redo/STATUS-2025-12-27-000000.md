# Status Report: Undo/Redo Feature
**Generated**: 2025-12-27-000000
**Agent**: status-planner (initial evaluation)
**Spec Reference**: design-docs/6-Transactions/

## Executive Summary

The Oscilla Animator codebase currently uses **direct MobX store mutations** with no transaction system or undo/redo capability. All patch state changes happen immediately on stores (PatchStore, BusStore, etc.) with no history tracking or rollback mechanism.

**Current State**: Foundation-level only (events + revision tracking)
**Target State**: Full command-based undo/redo with gesture buffer and persistent history

## Current Implementation Status

### ✅ Existing Infrastructure

1. **Event System** (EventDispatcher)
   - All mutation actions emit events (GraphCommitted, BlockAdded, WireAdded, etc.)
   - Event-based cross-store coordination in place
   - Provides audit trail of what changed (but not captured for undo)

2. **Patch Revision Tracking**
   - `patchRevision` counter increments on every mutation
   - `emitGraphCommitted()` with diff summaries (blocksAdded, blocksRemoved, etc.)
   - Used for diagnostic state keying and event correlation

3. **MobX Store Architecture**
   - PatchStore: blocks, connections, lanes
   - BusStore: buses, publishers, listeners
   - DefaultSourceStore: default source bindings
   - ViewStateStore: layout and view state
   - UIStateStore: selection and settings

4. **Serialization**
   - `RootStore.toJSON()` and `loadPatch()` provide full patch snapshots
   - Can capture complete state at any point
   - Already handles all entity types (blocks, buses, connections, etc.)

### ❌ Missing Components (Per Spec)

#### Core Transaction System

1. **Op Types** (2-Ops.md)
   - No Op union defined
   - No primitive operations (Add, Remove, Update, SetBlockPosition, etc.)
   - No inverse computation
   - No operation serialization

2. **TxBuilder** (3-TxBuilderSpec.md)
   - No `runTx()` function - all mutations are direct store calls
   - No transaction builder API
   - No cascade helpers (removeBlockCascade, removeBusCascade)
   - No explicit inverse tracking
   - No commit boundary
   - All current mutations in PatchStore/BusStore are **imperative and immediate**

3. **Gesture Buffer** (4-GestureBufferSpec.md)
   - No gesture lifecycle (beginGesture, updateGesture, commitGesture)
   - No working state overlay
   - No consolidation rules for continuous edits
   - No preview policies
   - Param drags and block moves mutate state immediately

4. **Working View Lookup** (5-WorkingViewLookupSpec.md)
   - No overlay structure (added/updated/removed tables)
   - No O(1) lookup strategy during gestures
   - No index strategy for cascade queries
   - Store arrays are mutated in place

#### History System

5. **HistoryStore** (6-HistoryStore.md)
   - No revision tree
   - No snapshots
   - No IndexedDB persistence
   - No parent/child navigation
   - Revision number exists but no history is preserved

6. **Undo/Redo Operations** (7-UndoRedo.md)
   - No undo capability
   - No redo capability
   - No variation tree navigation
   - No "go to parent/child" logic

7. **History Panel UI** (8-HistoryPanelUI.md)
   - No history panel component
   - No list view or map view
   - No revision labels or timestamps
   - No "fork chooser" for multiple children

### Current Mutation Patterns

**Example from PatchStore.ts** (direct mutations):
```typescript
addBlock(type, params) {
  const block = { id, type, ... };
  this.blocks.push(block);  // Direct mutation
  this.emitGraphCommitted(...);  // Event emitted, but no inverse captured
}

removeBlock(id) {
  this.blocks = this.blocks.filter(b => b.id !== id);  // Direct mutation
  // Connections removed in cascade, but no inverse recorded
}

connect(from, to) {
  this.connections.push(connection);  // Direct mutation
  // No way to undo
}
```

**No transaction boundaries** - each action is atomic and irreversible.

## Quantitative Metrics

| Category | Current | Target | Gap |
|----------|---------|--------|-----|
| Transaction System | 0% | 100% | Core Op types, TxBuilder, runTx() |
| Gesture Buffer | 0% | 100% | Working state overlay, consolidation |
| History Tracking | 0% | 100% | Revision tree, snapshots, persistence |
| Undo/Redo UI | 0% | 100% | History panel, navigation |
| Mutation Safety | 0% | 100% | All mutations through runTx() |

## Current Code Locations

- **Stores**: `src/editor/stores/` (PatchStore, BusStore, RootStore, etc.)
- **Events**: `src/editor/events/` (EventDispatcher, event types)
- **Types**: `src/editor/types/` (Block, Bus, Connection, etc.)
- **Serialization**: `RootStore.toJSON()`, `RootStore.loadPatch()`

## Known Constraints

1. **MobX Reactivity** - Transaction system must preserve MobX observability
2. **Event System** - Existing event listeners must continue to work
3. **Compiler Integration** - Gesture buffer must integrate with compile triggers
4. **UI Responsiveness** - Working state overlay must be fast (O(1) lookups)

## Dependencies & Blockers

**No blockers** - All required infrastructure exists:
- Event system for change tracking ✓
- Serialization for snapshots ✓
- Store architecture for state management ✓
- Type system for entities ✓

Ready to implement transaction system from scratch.

## Next Steps (Planning Phase)

1. Define Op union types and inverse computation
2. Implement TxBuilder API with cascade helpers
3. Route all mutations through runTx()
4. Add gesture buffer for continuous edits
5. Implement HistoryStore with revision tree
6. Build undo/redo navigation
7. Create History Panel UI

## Notes

- Current `patchRevision` can be repurposed as revision node ID
- Existing events provide natural audit trail for ops
- `toJSON()` can be used for snapshot creation
- No conflicting undo/redo implementations to remove
