# Sprint Plan: Undo/Redo Phase 2 - Complete Store Migration
**Generated**: 2025-12-27-103000
**Source**: STATUS-2025-12-27-phase2.md
**Spec**: design-docs/6-Transactions/

## Executive Summary

Sprint 2 completes the undo/redo system by migrating all remaining store methods to use `runTx()`, making undo/redo functional for real user operations.

**Sprint 1 Delivered**: Op types, TxBuilder, HistoryStore, cascade helpers, basic UI (66 tests passing)
**Sprint 2 Goal**: Complete store migration so ALL user-facing operations support undo/redo
**Current Gap**: ~85% of PatchStore and ~50% of BusStore still bypass runTx()

**Risk Level**: Medium (refactoring existing methods, potential UI breakage)
**Complexity**: Large (systematic migration across 20+ methods)

---

## Sprint 2 Deliverables

### In Scope (2-3 deliverables)
1. **PatchStore Full Migration** (P0) - addBlock, removeBlock, updateBlock, updateBlockParams, setTimeRoot
3. **Integration Testing** (P0) - End-to-end tests + manual verification

### Explicitly Deferred to Phase 3
- `replaceBlock()` - Complex, creates temporary state, needs careful transaction design
- `expandMacro()` - Very complex, creates many entities at once, needs multi-step transaction
- `addBlockAtIndex()` - Edge case, low priority
- Lens stack operations on connections - Complex, needs lens snapshot design
- Block position undo (drag operations) - Needs ViewStateStore integration
- Gesture buffer - UX enhancement, not required for basic undo
- IndexedDB persistence - Nice-to-have
- Advanced history UI (map view, variations chooser)

---

## P0-1: Migrate addBlock() to runTx()

**Status**: Not Started
**Complexity**: Small
**Dependencies**: None (TxBuilder exists)
**Spec Reference**: 3-TxBuilderSpec.md → STATUS-2025-12-27-phase2.md (Line 132: addBlock bypasses runTx)

### Description
Convert `PatchStore.addBlock()` from direct array mutation to transaction-based approach. This is the highest-impact migration as addBlock is the most common user operation.

### Current Implementation Analysis
```typescript
// src/editor/stores/PatchStore.ts (lines 600-644)
addBlock(type: BlockType, params?: Record<string, unknown>): BlockId {
  const block = { id, type, params, ... };
  this.blocks.push(block);  // ❌ Direct mutation
  this.emitGraphCommitted(...);  // ❌ Manual event
  return block.id;
}
```

### Implementation Steps
1. Replace direct mutation with `runTx()`:
   ```typescript
   addBlock(type: BlockType, params?: Record<string, unknown>): BlockId {
     const block = { id: this.root.generateId('block'), type, params, ... };

     runTx(this.root, { label: `Add ${type}` }, tx => {
       tx.add('blocks', block);
     });

     return block.id;
   }
   ```

2. Remove manual `emitGraphCommitted()` call (runTx handles this)
3. Update diff summary calculation (runTx computes this automatically)
4. Verify BlockAdded event still fires (should be emitted separately, not from transaction)

### Acceptance Criteria
- [ ] `addBlock()` uses `runTx()` for all block creation
- [ ] No direct push to `this.blocks` array
- [ ] User can add block → undo → redo successfully
- [ ] GraphCommitted event fires with correct diff summary
- [ ] MobX reactivity preserved (UI updates when block added)
- [ ] All existing tests pass after migration
- [ ] New test: "undoes addBlock operation" passes

### Technical Notes
- Block ID generation happens BEFORE runTx (needed to return ID synchronously)
- Initial params are captured in Add op (enables perfect undo)
- TimeRoot blocks need special handling (check `isTimeRootBlock()` logic)
- GraphCommitted diff includes: `blocksAdded: 1, timeRootChanged: <bool>`

---

## P0-2: Migrate removeBlock() to use removeBlockCascade()

**Status**: Not Started
**Complexity**: Medium
**Dependencies**: P0-1
**Spec Reference**: 3-TxBuilderSpec.md (Cascade Helpers) → STATUS-2025-12-27-phase2.md (Lines 127, 285-296)

### Description
Replace `PatchStore.removeBlock()` with a call to `TxBuilder.removeBlockCascade()`, eliminating the dual-path mutation pattern and duplicate cascade logic.

### Current Implementation Analysis
```typescript
// src/editor/stores/PatchStore.ts (lines 659-714)
removeBlock(id: BlockId, options?: { suppressGraphCommitted?: boolean }): void {
  this.blocks = this.blocks.filter(b => b.id !== id);  // ❌ Direct mutation
  this.root.defaultSourceStore.removeDefaultSourcesForBlock(id);  // ❌ Direct
  for (const conn of connectionsToRemove) {
    this.disconnect(conn.id, { suppressGraphCommitted: true });  // ❌ Dual path
  }
  // ... more direct mutations
}
```

**Problem**: This duplicates TxBuilder.removeBlockCascade() logic but doesn't use it.

### Implementation Steps
1. Replace entire method body with single runTx call:
   ```typescript
   removeBlock(id: BlockId): void {
     runTx(this.root, { label: 'Remove Block' }, tx => {
       tx.removeBlockCascade(id);
     });
   }
   ```

2. Remove `suppressGraphCommitted` option entirely (no longer needed)
3. Update callers that used `suppressGraphCommitted: true` (replaceBlock, removeBlock)
4. Move BlockRemoved event emission to AFTER runTx (or into commit hook)

### Acceptance Criteria
- [ ] `removeBlock()` uses `tx.removeBlockCascade()` exclusively
- [ ] No direct array filtering on `this.blocks`
- [ ] `suppressGraphCommitted` option removed from signature
- [ ] User can remove block → undo → redo successfully
- [ ] Lane membership restored on undo
- [ ] GraphCommitted event fires with correct diff (blocks, connections, bindings)
- [ ] All existing tests pass after migration

### Technical Notes
- Cascade generates Many op containing all sub-ops (correct order for inverse)
- GraphCommitted diff computed automatically from op count
- Removing `suppressGraphCommitted` simplifies API and eliminates dual-path bugs

### Breaking Changes
- Callers using `suppressGraphCommitted: true` must be updated:
  - `replaceBlock()` - Will be refactored in Phase 3
  - Internal cascade calls - No longer needed (TxBuilder handles cascades)

---

## P0-3: Migrate updateBlock() and updateBlockParams()

**Status**: Not Started
**Complexity**: Small
**Dependencies**: P0-1
**Spec Reference**: 3-TxBuilderSpec.md → STATUS-2025-12-27-phase2.md (Lines 127-129)

### Description
Migrate block property updates to use transaction-based Update ops, enabling undo for param changes (the most frequent user edit).

### Current Implementation Analysis
```typescript
// src/editor/stores/PatchStore.ts (line 647-651)
updateBlock(id: BlockId, updates: Partial<Block>): void {
  const block = this.blocks.find(b => b.id === id);
  Object.assign(block, updates);  // ❌ Direct mutation, no event, no undo
}

updateBlockParams(id: BlockId, params: Record<string, unknown>): void {
  const block = this.blocks.find(b => b.id === id);
  Object.assign(block.params, params);  // ❌ Direct mutation
}
```

**Problem**: These are called on EVERY param slider drag, but generate no undo history.

### Implementation Steps
1. Migrate `updateBlock()`:
   ```typescript
   updateBlock(id: BlockId, updates: Partial<Block>): void {
     runTx(this.root, { label: 'Update Block' }, tx => {
       const block = this.root.patchStore.blocks.find(b => b.id === id);
       if (!block) throw new Error(`Block ${id} not found`);

       const next = { ...block, ...updates };
       tx.replace('blocks', id, next);
     });
   }
   ```

2. Migrate `updateBlockParams()`:
   ```typescript
   updateBlockParams(id: BlockId, params: Record<string, unknown>): void {
     runTx(this.root, { label: 'Update Params' }, tx => {
       const block = this.root.patchStore.blocks.find(b => b.id === id);
       if (!block) throw new Error(`Block ${id} not found`);

       const next = { ...block, params: { ...block.params, ...params } };
       tx.replace('blocks', id, next);
     });
   }
   ```

3. Consider consolidation: `updateBlockParams` could call `updateBlock` internally

### Acceptance Criteria
- [ ] `updateBlock()` uses `tx.replace()` for all updates
- [ ] `updateBlockParams()` uses `tx.replace()` for param updates
- [ ] No direct Object.assign mutations on blocks
- [ ] User can drag param slider → undo → redo successfully
- [ ] Undo restores previous param value exactly
- [ ] MobX reactivity preserved (UI updates immediately on param change)
- [ ] GraphCommitted event fires after param update
- [ ] All existing tests pass after migration

### Technical Notes
- `tx.replace()` creates Update op with prev/next states
- Update op captures full entity state (ensures perfect undo)
- MobX reactivity preserved via Object.assign in applyOps (mutates in place)
- Param updates are high-frequency operations (may need gesture buffer in Phase 3)
- Consider debouncing for continuous edits (deferred to gesture buffer feature)

---

## P0-4: Migrate setTimeRoot()

**Status**: Not Started
**Complexity**: Small
**Dependencies**: None
**Spec Reference**: 3-TxBuilderSpec.md → STATUS-2025-12-27-phase2.md (Not explicitly mentioned, but critical)

### Description
Migrate `PatchStore.setTimeRoot()` to use `tx.setTimeRoot()` op, enabling undo for time root changes.

### Current Implementation Analysis
```typescript
// src/editor/stores/PatchStore.ts (check current implementation)
setTimeRoot(blockId: BlockId | null): void {
  this.timeRootBlockId = blockId;  // ❌ Direct mutation
  // Likely emits event but no undo support
}
```

### Implementation Steps
1. Replace with runTx:
   ```typescript
   setTimeRoot(blockId: BlockId | null): void {
     runTx(this.root, { label: 'Set Time Root' }, tx => {
       tx.setTimeRoot(blockId);
     });
   }
   ```

2. Verify TxBuilder.setTimeRoot() implementation exists (check lines 170-180)
3. Verify applyOps handles SetTimeRoot op correctly

### Acceptance Criteria
- [ ] `setTimeRoot()` uses `tx.setTimeRoot()` exclusively
- [ ] No direct assignment to `this.timeRootBlockId`
- [ ] User can set time root → undo → redo successfully
- [ ] Undo restores previous time root (or null)
- [ ] GraphCommitted event fires with `timeRootChanged: true`
- [ ] Player reacts correctly to time root changes
- [ ] All existing tests pass after migration

### Technical Notes
- SetTimeRoot op stores prev and next block IDs (or null)
- Critical for undo: time root change affects entire playback system
- May affect compiler (time signals propagate from root)

---

## P0-5: Remove suppressGraphCommitted Pattern

**Status**: Not Started
**Complexity**: Medium
**Dependencies**: P0-2 (removeBlock migration)
**Spec Reference**: STATUS-2025-12-27-phase2.md (Lines 259-283)

### Description
Eliminate the `suppressGraphCommitted` dual-path mutation pattern from connect() and disconnect() methods. All mutations should flow through runTx() with consistent event emission.

### Current Implementation Analysis
```typescript
// src/editor/stores/PatchStore.ts (lines 970-998)
connect(..., options?: { suppressGraphCommitted?: boolean }): void {
  if (options?.suppressGraphCommitted === true) {
    this.connections.push(connection);  // ❌ Bypass transaction system
  } else {
    runTx(this.root, { label: 'Connect' }, tx => {
      tx.add('connections', connection);
    });
  }
}
```

**Problem**: Internal callers (replaceBlock, removeBlock) use suppress=true to bypass transactions, breaking undo for complex operations.

### Implementation Steps
1. Remove `suppressGraphCommitted` parameter from:
   - `connect()` signature
   - `disconnect()` signature

2. Update all callers to remove the option:
   - `removeBlock()` - Already migrated in P0-2, no longer calls disconnect directly
   - `replaceBlock()` - Defer to Phase 3 (complex operation)
   - `expandMacro()` - Defer to Phase 3 (complex operation)

3. Ensure connect/disconnect ALWAYS use runTx:
   ```typescript
   connect(...): string {
     // Always use runTx, no conditional paths
     runTx(this.root, { label: 'Connect' }, tx => {
       tx.add('connections', connection);
     });
     return connection.id;
   }
   ```

### Acceptance Criteria
- [ ] `suppressGraphCommitted` option removed from connect() signature
- [ ] `suppressGraphCommitted` option removed from disconnect() signature
- [ ] All mutations flow through runTx() (no dual paths)
- [ ] GraphCommitted always fires after connect/disconnect
- [ ] All callers updated (or deferred to Phase 3)
- [ ] All existing tests pass after migration
- [ ] No regression in replaceBlock behavior (if called)

### Technical Notes
- This simplifies the API and eliminates a major source of bugs
- Complex operations (replaceBlock, expandMacro) will need proper transaction design in Phase 3
- Breaking change: Internal code using suppress flag must be updated
- May expose issues in replaceBlock/expandMacro (acceptable - they're deferred anyway)

---

## P1-1: Migrate BusStore.deleteBus() to removeBusCascade()

**Status**: Not Started
**Complexity**: Small
**Dependencies**: P0-5
**Spec Reference**: 3-TxBuilderSpec.md → STATUS-2025-12-27-phase2.md (Lines 148-153, 187-191)

### Description
Replace `BusStore.deleteBus()` with a call to `TxBuilder.removeBusCascade()`, enabling undo for bus deletion.

### Current Implementation Analysis
```typescript
// src/editor/stores/BusStore.ts (lines 187-191)
deleteBus(busId: string): void {
  this.buses = this.buses.filter(b => b.id !== busId);  // ❌ Direct mutation
}
```

**Problem**: Duplicates cascade logic instead of using TxBuilder helper.

### Implementation Steps
1. Replace with runTx call:
   ```typescript
   deleteBus(busId: string): void {
     runTx(this.root, { label: 'Delete Bus' }, tx => {
       tx.removeBusCascade(busId);
     });
   }
   ```

2. Move BusDeleted event emission to after runTx (or into commit hook)

### Acceptance Criteria
- [ ] `deleteBus()` uses `tx.removeBusCascade()` exclusively
- [ ] User can delete bus → undo → redo successfully
- [ ] GraphCommitted event fires with correct diff
- [ ] All existing tests pass after migration

### Technical Notes
- `removeBusCascade()` already implemented in TxBuilder (lines 398-421)

---

## P1-2: Migrate BusStore.updateBus()

**Status**: Not Started
**Complexity**: Small
**Dependencies**: None
**Spec Reference**: 3-TxBuilderSpec.md → STATUS-2025-12-27-phase2.md (Lines 156-157, 206-208)

### Description
Migrate bus property updates to use transaction-based Update ops.

### Current Implementation Analysis
```typescript
// src/editor/stores/BusStore.ts (lines 200-209)
updateBus(busId: string, updates: Partial<Bus>): void {
  const bus = this.buses.find(b => b.id === busId);
  if (updates.name !== undefined) bus.name = updates.name;  // ❌ Direct mutation
  if (updates.combineMode !== undefined) bus.combineMode = updates.combineMode;  // ❌ Direct
  if (updates.defaultValue !== undefined) bus.defaultValue = updates.defaultValue;  // ❌ Direct
}
```

### Implementation Steps
1. Replace with runTx:
   ```typescript
   updateBus(busId: string, updates: Partial<Pick<Bus, 'name' | 'combineMode' | 'defaultValue'>>): void {
     runTx(this.root, { label: 'Update Bus' }, tx => {
       const bus = this.root.busStore.buses.find(b => b.id === busId);
       if (!bus) throw new Error(`Bus ${busId} not found`);

       const next = { ...bus, ...updates };
       tx.replace('buses', busId, next);
     });
   }
   ```

### Acceptance Criteria
- [ ] `updateBus()` uses `tx.replace()` for all updates
- [ ] No direct property assignments on bus objects
- [ ] User can update bus name → undo → redo successfully
- [ ] User can update combine mode → undo → redo successfully
- [ ] MobX reactivity preserved (UI updates immediately)
- [ ] GraphCommitted event fires after update
- [ ] All existing tests pass after migration

### Technical Notes
- Bus updates are less frequent than param updates (no gesture buffer needed)
- Combine mode changes affect bus evaluation logic
- Name changes affect UI display only

---


**Status**: Not Started
**Complexity**: Medium
**Dependencies**: P1-2
**Spec Reference**: 3-TxBuilderSpec.md → STATUS-2025-12-27-phase2.md (Lines 156-161, 267-282)

### Description

### Current Implementation Analysis
```typescript
// src/editor/stores/BusStore.ts (lines 267-282)
  const updated = { ...existing, ...updates };
}

```

**Problem**: Array index replacement doesn't go through transaction system.

### Implementation Steps
   ```typescript

       const next = { ...pub, ...updates };
     });
   }
   ```



### Acceptance Criteria
- [ ] No direct array index assignments
- [ ] Lens stack updates (adapterChain, lensStack) undoable
- [ ] MobX reactivity preserved
- [ ] GraphCommitted event fires after update
- [ ] All existing tests pass after migration

### Technical Notes
- sortKey changes affect evaluation order (critical for correctness)
- Lens stack changes affect signal transformation pipeline
- enabled flag affects runtime evaluation (disabled = skipped)

---

## P1-4: Migrate Lens Stack Operations (Deferred - Complex)

**Status**: DEFERRED to Phase 3
**Complexity**: Large
**Dependencies**: P1-3

### Deferred Methods
- `addLensToStack()`
- `removeLensFromStack()`
- `clearLensStack()`
- Connection lens operations (lenses array on connections)

### Why Deferred
1. Lens stacks are nested arrays within entities (requires Update op for entire entity)
2. Lens instances have complex state (source bindings, params)
3. Lens operations are less frequent than basic CRUD
4. Proper design requires snapshot/restore strategy for nested structures

### Future Work (Phase 3)
- Design lens stack snapshot format (for prev/next in Update op)
- Implement lens instance deep copy helper
- Migrate all lens operations to runTx
- Test lens stack undo/redo thoroughly

---

## P0-6: Write Integration Tests

**Status**: Not Started
**Complexity**: Medium
**Dependencies**: P0-4, P1-3
**Spec Reference**: STATUS-2025-12-27-phase2.md (Lines 245-254, 409-422)

### Description
Create end-to-end tests that verify undo/redo works for real user operations, not just isolated transaction logic.

### Test Coverage Required

#### Block Operations
```typescript
describe('Undo/Redo Integration - Blocks', () => {
  it('undoes addBlock operation', () => {
    const initialCount = rootStore.patchStore.blocks.length;

    // Add block
    const blockId = rootStore.patchStore.addBlock('Constant');
    expect(rootStore.patchStore.blocks.length).toBe(initialCount + 1);

    // Undo
    rootStore.historyStore.undo();
    expect(rootStore.patchStore.blocks.length).toBe(initialCount);
    expect(rootStore.patchStore.blocks.find(b => b.id === blockId)).toBeUndefined();

    // Redo
    rootStore.historyStore.redo();
    expect(rootStore.patchStore.blocks.length).toBe(initialCount + 1);
    expect(rootStore.patchStore.blocks.find(b => b.id === blockId)).toBeDefined();
  });

  it('undoes removeBlock with cascade', () => {
    const blockId = rootStore.patchStore.addBlock('Multiply');
    const connId = rootStore.patchStore.connect(...);

    rootStore.patchStore.removeBlock(blockId);
    expect(rootStore.patchStore.blocks.find(b => b.id === blockId)).toBeUndefined();
    expect(rootStore.patchStore.connections.find(c => c.id === connId)).toBeUndefined();

    // Undo (recreates everything)
    rootStore.historyStore.undo();
    expect(rootStore.patchStore.blocks.find(b => b.id === blockId)).toBeDefined();
    expect(rootStore.patchStore.connections.find(c => c.id === connId)).toBeDefined();
  });

  it('undoes updateBlockParams', () => {
    const blockId = rootStore.patchStore.addBlock('Constant');
    const block = rootStore.patchStore.blocks.find(b => b.id === blockId)!;

    // Update param
    rootStore.patchStore.updateBlockParams(blockId, { value: 42 });
    expect(block.params.value).toBe(42);

    // Undo
    rootStore.historyStore.undo();
    expect(block.params.value).not.toBe(42); // Restored to original
  });
});
```

#### Bus Operations
```typescript
describe('Undo/Redo Integration - Buses', () => {
  it('undoes deleteBus with cascade', () => {
    const busId = rootStore.busStore.createBus('TestBus');

    // Delete bus (cascade removes routing)
    rootStore.busStore.deleteBus(busId);
    expect(rootStore.busStore.buses.find(b => b.id === busId)).toBeUndefined();

    // Undo (recreates bus + routing)
    rootStore.historyStore.undo();
    const restoredBus = rootStore.busStore.buses.find(b => b.id === busId);
    expect(restoredBus).toBeDefined();
    expect(restoredBus.name).toBe('TestBus');
  });

  it('undoes updateBus', () => {
    const busId = rootStore.busStore.createBus('Original');

    // Update bus name
    rootStore.busStore.updateBus(busId, { name: 'Updated' });
    expect(rootStore.busStore.buses.find(b => b.id === busId)!.name).toBe('Updated');

    // Undo
    rootStore.historyStore.undo();
    expect(rootStore.busStore.buses.find(b => b.id === busId)!.name).toBe('Original');
  });

    const busId = rootStore.busStore.createBus('TestBus');


    // Undo
    rootStore.historyStore.undo();
  });
});
```

#### MobX Reactivity
```typescript
describe('Undo/Redo Integration - MobX', () => {
  it('triggers MobX reactions on undo/redo', () => {
    const reactions: string[] = [];

    // Setup observer
    autorun(() => {
      const count = rootStore.patchStore.blocks.length;
      reactions.push(`blocks:${count}`);
    });

    // Add block
    rootStore.patchStore.addBlock('Constant');
    expect(reactions).toContain('blocks:1');

    // Undo
    rootStore.historyStore.undo();
    expect(reactions).toContain('blocks:0');

    // Redo
    rootStore.historyStore.redo();
    expect(reactions).toContain('blocks:1');
  });
});
```

### Acceptance Criteria
- [ ] All block operations (add, remove, update) have undo/redo integration tests
- [ ] All bus operations (create, delete, update) have undo/redo integration tests
- [ ] Cascade operations (removeBlock, deleteBus) verified to restore all dependencies
- [ ] MobX reactivity verified (autorun triggers on undo/redo)
- [ ] Multi-step undo (undo → undo → redo → redo) works correctly
- [ ] Undo at root / redo at leaf handled gracefully
- [ ] All integration tests pass
- [ ] Test coverage: 20+ integration tests

### Technical Notes
- Integration tests use real RootStore (not mocked)
- Tests verify both state correctness and MobX reactivity
- Tests should exercise common user workflows
- Use existing test infrastructure (Vitest)
- Place in `src/editor/transactions/__tests__/integration/`

---

## P0-7: Manual Testing with Chrome DevTools MCP

**Status**: Not Started
**Complexity**: Small
**Dependencies**: P0-6
**Spec Reference**: CLAUDE.md (Verification section) → STATUS-2025-12-27-phase2.md

### Description
Manually verify undo/redo works correctly in the real UI using Chrome DevTools MCP. Tests alone are not reliable indicators - visual verification is required.

### Test Scenarios

#### Basic Operations
1. **Add Block → Undo → Redo**
   - Open editor
   - Add Constant block
   - Verify block appears in canvas
   - Press Cmd+Z
   - Verify block disappears
   - Press Cmd+Shift+Z
   - Verify block reappears in same position

2. **Connect Blocks → Undo → Redo**
   - Add two blocks
   - Connect output to input
   - Verify wire appears
   - Press Cmd+Z
   - Verify wire disappears
   - Press Cmd+Shift+Z
   - Verify wire reappears

3. **Remove Block with Connections → Undo**
   - Create block with connections
   - Delete block
   - Verify connections removed
   - Press Cmd+Z
   - Verify block AND connections restored

#### Parameter Updates
4. **Drag Param Slider → Undo**
   - Add Constant block
   - Drag value slider
   - Verify value updates in real-time
   - Press Cmd+Z
   - Verify value restored to previous state

#### Bus Operations
   - Create bus
   - Press Cmd+Z (undo create bus)
   - Verify bus removed

6. **Delete Bus → Undo**
   - Delete bus
   - Press Cmd+Z
   - Verify bus + routing restored

#### Complex Workflows
7. **Multi-step Undo**
   - Add block 1
   - Add block 2
   - Connect 1 → 2
   - Press Cmd+Z (undo connect)
   - Press Cmd+Z (undo add block 2)
   - Press Cmd+Z (undo add block 1)
   - Verify canvas empty
   - Press Cmd+Shift+Z (redo all)
   - Verify full state restored

8. **History Panel Navigation**
   - Open History Panel
   - Verify all revisions listed
   - Click on older revision
   - Verify canvas state matches that revision
   - Click on newer revision
   - Verify canvas updates

### Verification Checklist
- [ ] All basic operations undo/redo correctly in UI
- [ ] Parameter changes undo correctly (slider returns to previous value)
- [ ] Bus operations undo correctly (routing preserved)
- [ ] Multi-step undo navigates history correctly
- [ ] History Panel displays all revisions
- [ ] History Panel navigation updates canvas
- [ ] Keyboard shortcuts work (Cmd+Z, Cmd+Shift+Z)
- [ ] No visual glitches or partial states
- [ ] MobX reactivity works (UI updates immediately)
- [ ] No console errors during undo/redo

### Acceptance Criteria
- [ ] All 8 test scenarios pass visual verification
- [ ] No regressions in existing UI behavior
- [ ] Undo/redo feels smooth and predictable to user
- [ ] History Panel is usable and informative
- [ ] No memory leaks during extended undo/redo session (DevTools Memory tab)

### Technical Notes
- Use Chrome DevTools MCP to automate some verification steps
- Take screenshots before/after undo for comparison
- Monitor console for errors during testing
- Test with both mouse and keyboard interactions
- Verify compiler recompiles after undo (check compiled output)

---

## Deferred to Phase 3

### Complex Operations (High Risk, Needs Careful Design)

#### replaceBlock()
**Complexity**: Large
**Why Deferred**:
- Creates temporary intermediate state (old block removed, new block added)
- Needs to preserve connections (complex matching logic)
- Currently uses `suppressGraphCommitted` dual-path (being eliminated)
- Requires multi-step transaction design (remove cascade + add + reconnect)

**Future Work**:
- Design single transaction that captures: old block, new block, connection mapping
- Implement connection preservation logic in transaction
- Test edge cases: incompatible ports, missing inputs

#### expandMacro()
**Complexity**: XL
**Why Deferred**:
- Creates many entities at once (blocks, connections, routing)
- Clears entire patch first (destructive)
- Complex state transformation (macro definition → concrete blocks)
- Needs macro snapshot for inverse

**Future Work**:
- Design macro expansion transaction (captures entire before/after state)
- Implement macro snapshot format
- Test with complex macros (nested composites, bus routing)

### Advanced Features (Low Priority, UX Enhancement)

#### Block Position Undo (Drag Operations)
**Why Deferred**:
- Needs ViewStateStore integration (blockPositions Map)
- Needs gesture buffer for drag consolidation (avoid 100 revisions for single drag)
- applySetBlockPosition currently no-op (line 303-306 in applyOps.ts)

#### Gesture Buffer
**Why Deferred**:
- UX enhancement, not required for basic undo
- Needs working state overlay design
- Needs consolidation policy (when to commit)

#### IndexedDB Persistence
**Why Deferred**:
- Nice-to-have, in-memory history sufficient for single session
- Needs schema design for revision storage
- Needs migration strategy

---

## Sprint Success Criteria

### Functional Requirements
- [ ] User can undo: addBlock, removeBlock, updateBlockParams, connect, disconnect
- [ ] All operations restore exact previous state (no data loss)
- [ ] Undo after cascade operations (removeBlock, deleteBus) restores all dependencies
- [ ] Multi-step undo/redo works correctly (undo → undo → redo → redo)

### Code Quality
- [ ] All PatchStore mutations use runTx() (no direct mutations remain)
- [ ] All BusStore mutations use runTx() (no direct mutations remain)
- [ ] `suppressGraphCommitted` pattern eliminated from connect/disconnect
- [ ] All store methods have consistent transaction-based API
- [ ] No dual-path mutations (one code path for all operations)

### Testing
- [ ] All existing tests pass (66 transaction tests + store tests)
- [ ] 20+ new integration tests pass (undo/redo for all operations)
- [ ] Manual testing with Chrome DevTools MCP verifies UI behavior
- [ ] No regressions in existing functionality

### Events & Reactivity
- [ ] GraphCommitted events fire correctly for all operations
- [ ] Fine-grained events (BlockAdded, WireAdded) still fire for UI
- [ ] MobX reactivity preserved (UI updates immediately)
- [ ] Compiler recompiles after undo/redo

---

## Risk Assessment

### High Risks
1. **Breaking Existing UI Code**
   - *Risk*: Changing store method signatures could break UI components
   - *Mitigation*: Keep public API the same, only change implementation
   - *Validation*: Run full test suite + manual UI testing

2. **MobX Reactivity Broken**
   - *Risk*: Transaction system could break MobX reactivity
   - *Mitigation*: Use Object.assign in applyOps (mutate in place)
   - *Validation*: Integration tests with autorun, manual UI testing

### Medium Risks
1. **Performance Degradation**
   - *Risk*: Transaction overhead on every operation
   - *Mitigation*: Current tests show negligible overhead (66 tests in 63ms)
   - *Validation*: Monitor performance with large patches

2. **Event Ordering Changes**
   - *Risk*: Events fire in different order with transactions
   - *Mitigation*: GraphCommitted fires after commit (same as before)

### Low Risks
1. **Test Coverage Gaps**
   - *Risk*: Missing edge cases in tests
   - *Mitigation*: Dedicated integration testing task (P0-6)
   - *Validation*: Code review + manual testing

---

## Recommended Implementation Order

### Week 1: Core PatchStore Migration
1. **Day 1-2**: P0-1 (addBlock) + P0-3 (updateBlock/updateBlockParams)
   - Highest impact methods
   - Test immediately with undo/redo
   - Goal: User can add blocks and change params with undo

2. **Day 3-4**: P0-2 (removeBlock cascade) + P0-4 (setTimeRoot)
   - More complex (cascade logic)
   - Test with connections
   - Goal: User can remove blocks with undo

3. **Day 5**: P0-5 (remove suppressGraphCommitted)
   - Cleanup dual-path mutations
   - Update callers
   - Goal: Consistent API, single code path

### Week 2: BusStore Migration + Testing
   - Complete bus operation migration
   - Test with undo/redo
   - Goal: All bus operations undoable

2. **Day 3-4**: P0-6 (Integration Tests)
   - Write 20+ integration tests
   - Cover all entity types
   - Goal: Comprehensive test coverage

3. **Day 5**: P0-7 (Manual Testing)
   - Visual verification with Chrome DevTools MCP
   - Test all user workflows
   - Goal: Production-ready undo/redo

---

## Post-Sprint State

### Architecture
- **Transaction System**: All mutations flow through runTx() (enforced)
- **Store API**: Clean, consistent, transaction-based
- **Event System**: GraphCommitted + fine-grained events coexist
- **Undo/Redo**: Functional for all basic operations

### User Experience
- **Keyboard Shortcuts**: Cmd+Z / Cmd+Shift+Z work for all operations
- **History Panel**: Shows all revisions, clickable navigation
- **Predictability**: Every user action is undoable (except deferred operations)

### Foundation for Phase 3
- **Ready for**: replaceBlock, expandMacro, gesture buffer, block positions
- **Technical Debt Eliminated**: suppressGraphCommitted pattern removed
- **Test Coverage**: Comprehensive integration tests

---

## Dependencies & Prerequisites

**External Dependencies**: None

**Internal Prerequisites**:
- ✓ TxBuilder implemented (Sprint 1)
- ✓ HistoryStore implemented (Sprint 1)
- ✓ Cascade helpers implemented (Sprint 1)
- ✓ Undo/redo logic implemented (Sprint 1)
- ✓ 66 transaction tests passing

**All prerequisites met** - ready to begin Sprint 2 implementation.

---

## Total Complexity Estimate

| Task | Complexity |
|------|------------|
| P0-1: addBlock | Small |
| P0-2: removeBlock cascade | Medium |
| P0-3: updateBlock/Params | Small |
| P0-4: setTimeRoot | Small |
| P0-5: Remove suppress flag | Medium |
| P1-1: deleteBus cascade | Small |
| P1-2: updateBus | Small |
| P0-6: Integration tests | Medium |
| P0-7: Manual testing | Small |

**Total**: 2 Large + 4 Medium + 4 Small = Approximately 2-3 weeks for single developer

**Recommended**: 1 developer, 2-3 weeks OR 2 developers, 1-2 weeks
