# Field Runtime Red Flags - Status Report

**Timestamp:** 2025-12-28-160500
**Scope:** Field Runtime (FieldExpr, FieldHandle, Materializer)
**Source:** `design-docs/implementation/compiler/Compiler-Audit-RedFlags-Field-Runtime.md`

---

## Executive Summary

**Overall Status:** 8 documented issues + 1 critical undocumented bug discovered during evaluation.

| Severity | Count | Status |
|----------|-------|--------|
| Critical | 3 (+1 discovered) | NOT STARTED |
| High | 3 | NOT STARTED |
| Medium | 2 | NOT STARTED |

**Key Finding:** The exploration discovered an additional critical bug not in the audit document - params are not propagated from IR field nodes to FieldHandle, breaking all parameterized field operations (rotate, scale, jitter, etc.).

---

## Issue Analysis

### CRITICAL #1: Field Transform Chains Not Implemented (DOCUMENTED)

**Location:** `src/editor/runtime/field/Materializer.ts:1145-1175`

**Current State:**
```typescript
// Line 1167: THROWS
throw new Error('fillBufferTransform: transform chain evaluation not implemented');
```

**Impact:** Any field-level adapter/lens/transform crashes at runtime.

**Fix Required:**
- Iterate through transform chain steps
- Apply each step type (cast, map, scaleBias, etc.) to source buffer
- Output to destination buffer

**Complexity:** Medium-High - requires implementing each transform step type

---

### CRITICAL #2: Field Expression Input Slots Not Implemented (DOCUMENTED)

**Location:** `src/editor/runtime/field/FieldHandle.ts:180-183`

**Current State:**
```typescript
case 'inputSlot':
  handle = env.slotHandles.read(node.slot);
  break;
```

**Analysis:** ACTUALLY IMPLEMENTED! The audit document is outdated.

**Evidence:** FieldHandle.ts line 180-183 handles `inputSlot` nodes by reading from `env.slotHandles`.

**Status:** FALSE POSITIVE - already implemented

---

### CRITICAL #3: Field Broadcast Signal Fallback (DOCUMENTED)

**Location:** `src/editor/runtime/field/Materializer.ts:167-184`

**Current State:**
```typescript
// evalSig() function
if (env.irEnv && env.irNodes) {
  return evalSigIR(sigId, env.irEnv, env.irNodes);
}
if (env.signalBridge) {
  return env.signalBridge.evalSig(sigId);
}
return 0;  // Silent fallback!
```

**Impact:** Field broadcast silently produces 0s when signal evaluation is missing.

**Fix Required:**
- Add warning or error when falling back to 0
- Consider making fallback an explicit error in strict mode
- At minimum, log a diagnostic trace

**Complexity:** Low - add warning/error handling

---

### CRITICAL #4: Params Not Propagated to FieldHandle (UNDOCUMENTED)

**Location:** `src/editor/runtime/field/FieldHandle.ts:118-136`

**Current State:**
```typescript
case 'map':
  handle = {
    kind: 'Op',
    op: fnRefToFieldOp(node.fn),
    args: [node.src],
    type: node.type,
    // MISSING: params: node.params
  };
  break;

case 'zip':
  handle = {
    kind: 'Zip',
    op: fnRefToFieldZipOp(node.fn),
    a: node.a,
    b: node.b,
    type: node.type,
    // MISSING: params: node.params
  };
  break;
```

**Impact:** ALL parameterized field operations fail:
- Vec2: rotate, scale, translate, reflect, jitter
- Any op using `readParamNumber()` in Materializer

**Fix Required:**
- Add `params: node.params` to both map and zip handle creation
- Verify Materializer's `readParamNumber()` works correctly

**Complexity:** Low - simple property addition

---

### HIGH #1: Field Combine Numeric-Only (DOCUMENTED)

**Location:** `src/editor/runtime/field/Materializer.ts:1208-1247`

**Analysis:** PARTIALLY INCORRECT - code review shows `fillBufferCombine` works correctly.

**Current State:**
```typescript
// combineElement() handles the actual combination
// fillBufferCombine() iterates and calls combineElement()
```

**Evidence:** The combine implementation handles all modes (sum, average, min, max, last, product). However, the issue may be about TYPE checking, not the combine logic itself.

**Verification Needed:** Check if there's a type guard that restricts to numbers.

**Status:** NEEDS VERIFICATION

---

### HIGH #2: Field Reduce Placeholder (DOCUMENTED)

**Location:** `src/editor/compiler/ir/IRBuilderImpl.ts:537-557`

**Current State:**
```typescript
reduceFieldToSig(_field: FieldExprId, fn: ReduceFn): SigExprId {
  // Placeholder - field input ignored!
  const id = this.allocSigExprId();
  this.sigExprs.push({
    kind: "map",
    type: fn.outputType,
    src: 0 as SigExprId,  // INVALID - should use field
    fn: {
      kind: "kernel",
      kernelId: `reduce_${fn.reducerId}`,
    },
  });
  return id;
}
```

**Impact:** Field-to-signal reduction completely non-functional.

**Fix Required:**
- Use the `_field` parameter (currently ignored)
- Create proper reduction IR node
- Wire field input to reduction kernel

**Complexity:** High - requires understanding IR schema for reductions

---

### HIGH #3: Path Field Evaluation Const-Only (DOCUMENTED)

**Location:** `src/editor/runtime/executor/steps/executeMaterializePath.ts:122-146`

**Current State:**
```typescript
// Only supports const field nodes
if (fieldNode.kind !== 'const') {
  throw new Error(`Path field must be const, got: ${fieldNode.kind}`);
}
```

**Impact:** Dynamic path fields cannot be materialized.

**Fix Required:**
- Support non-const field nodes (map, zip, busCombine)
- Integrate with Materializer for dynamic path evaluation

**Complexity:** High - requires path materialization design

---

### MEDIUM #1: FieldHandle Cache Lacks Eviction (DOCUMENTED)

**Location:** `src/editor/runtime/field/FieldHandle.ts:95-103`

**Current State:**
```typescript
// Cache check
if (env.cache.stamp[fieldId] === env.cache.frameId) {
  return env.cache.handles[fieldId];
}
```

**Impact:** Stale handles possible after hot-swap if field IDs reorder.

**Analysis:** This is a hot-swap edge case, not a core runtime issue.

**Fix Required:**
- Add field table version check
- Clear cache on field table change

**Complexity:** Low - add version stamp

---

### MEDIUM #2: Domain Element IDs Inconsistent (DOCUMENTED)

**Location:** `src/editor/runtime/field/Materializer.ts:283`

**Current State:**
```typescript
const elementId = env.domainElements?.[index] ?? String(index);
```

**Impact:** `hash01ById` always uses index fallback because `domainElements` is never populated.

**Fix Required:**
- Populate `domainElements` in executor setup
- Pass element IDs from domain creation

**Complexity:** Medium - requires tracing domain creation paths

---

## Priority Matrix

| Issue | Severity | Complexity | Sprint Scope |
|-------|----------|------------|--------------|
| Params not propagated | CRITICAL | Low | Sprint 1 |
| Signal fallback warning | CRITICAL | Low | Sprint 1 |
| Transform chains | CRITICAL | Medium-High | Sprint 2 |
| Field reduce placeholder | HIGH | High | Sprint 2+ |
| Path field const-only | HIGH | High | Sprint 2+ |
| Cache eviction | MEDIUM | Low | Sprint 1 |
| Domain element IDs | MEDIUM | Medium | Sprint 2 |

---

## What's Actually Working

Based on code review:

1. **Input slot handling** - Implemented correctly
2. **Bus combine operations** - All modes working (sum, average, min, max, last, product)
3. **Cache mechanism** - Works for normal frame-to-frame operation
4. **Basic field ops** - Work when params not needed
5. **Signal broadcast** - Works when irEnv is present

---

## Dependencies

1. **Block registry fix** (from Sprint 0) must be done first - tests currently fail
2. **IR compilation must work** - several of these issues only manifest in IR mode
3. **Signal evaluation infrastructure** - needed for field broadcast

---

## Recommendations

### Sprint 1 Scope (Low Complexity, High Impact)

1. **Fix params propagation** - Unblocks all parameterized ops
2. **Add signal fallback warning** - Makes silent failures visible
3. **Add cache eviction on hot-swap** - Prevents stale handle bugs

### Sprint 2 Scope (Higher Complexity)

4. **Implement transform chains** - Required for adapters/lenses
5. **Domain element ID propagation** - For stable hash01ById

### Future Sprints

6. **Field reduce implementation** - Complex IR work
7. **Dynamic path fields** - Requires design work

---

## Verdict

**Status:** CONTINUE - issues are well-understood and can be planned

**Next Action:** Generate sprint plan focusing on low-complexity, high-impact fixes first.
