# Sprint Plan: Field Runtime Workstream 3 - Implementation Sprint

**Generated:** 2025-12-31-110500
**Source STATUS:** STATUS-2025-12-31-013739.md
**Topic:** Field Runtime Implementation + Closeout

---

## Executive Summary

This sprint completes 2 critical field runtime primitives from the original 03-field-runtime-primitives plan, plus closeout documentation for the massive hidden providers work.

**Sprint Goal:** Implement stable domain element IDs and FieldExprMapIndexed/FieldExprZipSig IR nodes, then close out the workstream.

**Current State:**
- Hidden providers work: COMPLETE (Sprints 1-18)
- Red-flag plan: P0/P0.5/P1 COMPLETE, P2 MOOT, P3 needs final update
- Tests: 2646 passing (all green)
- Typecheck: PASSING

---

## Work Item Breakdown

### P0: Stable Domain Element IDs

**Status:** Not Started
**Effort:** Small-Medium (2-4 hours)
**Dependencies:** None
**Spec Reference:** `plans/ir-compiler-backlog-streams/03-field-runtime-primitives.md` Section 5
**Key File:** `src/editor/runtime/field/Materializer.ts:283-289`

#### Description

Currently, `hash01ById` and related ops fall back to using the element index when stable IDs aren't available:

```typescript
const elementId = env.domainElements?.[index] ?? String(index);
```

This breaks determinism for hash-based operations when domain elements change order. We need to:
1. Ensure domain builders emit stable element IDs
2. Thread element IDs through domain handles into runtime
3. Remove the index fallback (or make it a hard error)

#### Implementation Steps

1. **Audit domain builders** for element ID emission:
   - `GridDomain` - should emit IDs like `grid:r{row}:c{col}`
   - `DomainN` - should emit IDs based on seed+index (stable per instance)
   - `PositionMapGrid`, `PositionMapCircle` - check for ID emission

2. **Thread element IDs through runtime:**
   - Check `DomainHandle` in `src/editor/runtime/field/types.ts`
   - Verify `MaterializerEnv.domainElements` is populated correctly
   - Trace from domain builder → compiler → runtime

3. **Update Materializer:**
   - Remove fallback to `String(index)`
   - Either require element IDs or emit clear error if missing

#### Acceptance Criteria

- [ ] GridDomain emits stable element IDs (not index-based)
- [ ] DomainN emits stable element IDs (seed+index based)
- [ ] `hash01ById` uses actual element IDs, not index fallback
- [ ] Runtime throws clear error if domain elements are missing (no silent fallback to index)
- [ ] Hash-based operations produce deterministic results when domain order changes

---

### P0: Add FieldExprMapIndexed + FieldExprZipSig IR Nodes

**Status:** Not Started
**Effort:** Medium (4-6 hours)
**Dependencies:** None
**Spec Reference:** `plans/ir-compiler-backlog-streams/03-field-runtime-primitives.md` Section 1
**Key Files:**
- `src/editor/compiler/ir/fieldExpr.ts:46-127`
- `src/editor/compiler/ir/IRBuilderImpl.ts`
- `src/editor/runtime/field/FieldHandle.ts`
- `src/editor/runtime/field/Materializer.ts`

#### Description

Currently field ops can only use `FieldExprMap` (single field input) and `FieldExprZip` (two field inputs). We need:

1. **FieldExprMapIndexed** - field op that has access to:
   - Element index (`i`)
   - Element count (`N`)
   - Optionally: signal values for parameterization

2. **FieldExprZipSig** - combine field elements with multiple signals:
   - Primary field input
   - Multiple signal inputs
   - Enables ops like "scale each element by signal A, then offset by signal B"

These are needed for more sophisticated field operations.

#### Implementation Steps

1. **Add IR node types** in `src/editor/compiler/ir/fieldExpr.ts`:
   ```typescript
   /** Map with element index access */
   export interface FieldExprMapIndexed {
     kind: "mapIndexed";
     type: TypeDesc;
     src: FieldExprId;
     fn: PureFnRef;
     params?: Record<string, unknown>;
   }

   /** Zip field with multiple signals */
   export interface FieldExprZipSig {
     kind: "zipSig";
     type: TypeDesc;
     src: FieldExprId;
     signals: SigExprId[];
     fn: PureFnRef;
     params?: Record<string, unknown>;
   }
   ```

2. **Add union members** to `FieldExprIR` type

3. **Add IRBuilder helpers** in `src/editor/compiler/ir/IRBuilderImpl.ts`:
   - `fieldMapIndexed(src, fn, params?, outputType): FieldExprId`
   - `fieldZipSig(src, signals, fn, params?, outputType): FieldExprId`

4. **Add FieldHandle variants** in `src/editor/runtime/field/FieldHandle.ts`:
   - `OpIndexed` - single field with index access
   - `ZipSig` - field + multiple signals

5. **Implement materialization** in `src/editor/runtime/field/Materializer.ts`:
   - `fillBufferOpIndexed` - pass index to op function
   - `fillBufferZipSig` - evaluate signals, apply to field elements

6. **Update lowerers** that need these ops (if any exist):
   - Check `src/editor/compiler/blocks/field/` for candidates

#### Acceptance Criteria

- [ ] `FieldExprMapIndexed` node type exists in fieldExpr.ts
- [ ] `FieldExprZipSig` node type exists in fieldExpr.ts
- [ ] IRBuilder has `fieldMapIndexed()` helper
- [ ] IRBuilder has `fieldZipSig()` helper
- [ ] FieldHandle.ts has corresponding handle types
- [ ] Materializer can fill buffers for indexed and zipSig operations
- [ ] Typecheck passes
- [ ] All existing tests pass

---

### P1: Closeout Documentation (Brief)

**Status:** Not Started
**Effort:** Small (1 hour)
**Dependencies:** P0 tasks complete
**Spec Reference:** Previous sprint plan

#### Description

After implementing the P0 items, briefly update documentation to:
1. Mark stable domain IDs as COMPLETE
2. Mark FieldExprMapIndexed/ZipSig as COMPLETE
3. Update audit document to note P2 is MOOT
4. Mark hidden providers as COMPLETE

#### Acceptance Criteria

- [ ] `.agent_planning/audit/field-runtime-redflags-resolved.md` updated
- [ ] Original plan items marked as COMPLETE vs DEFERRED
- [ ] Brief summary of what was delivered in this sprint

---

## Sprint Scope Summary

**This sprint delivers:**
1. Stable domain element IDs (no more index fallback)
2. FieldExprMapIndexed IR node + runtime support
3. FieldExprZipSig IR node + runtime support
4. Brief closeout documentation

**Still deferred:**
- Transform chain evaluation
- Field reduce support (reduceFieldToSig)
- Non-numeric field combine (vec2/vec3/color)

---

## Validation Strategy

Per CLAUDE.md: Use `just dev` and Chrome DevTools MCP for runtime verification.

1. **Stable IDs validation:**
   - Create patch with GridDomain + hash01ById
   - Change domain order/size
   - Verify hash values are stable per element

2. **MapIndexed validation:**
   - Create patch using a field op that needs index access
   - Verify index is correctly passed to op

3. **ZipSig validation:**
   - Create patch with field + multiple signal modulation
   - Verify signals are correctly applied per-element

---

## Success Criteria

**Sprint is successful when:**
1. `env.domainElements` is populated with stable IDs (not fallback indices)
2. FieldExprMapIndexed and FieldExprZipSig nodes work end-to-end
3. All 2646+ tests still pass
4. Typecheck passes
5. Brief documentation updated
