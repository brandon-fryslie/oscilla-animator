# Definition of Done: Phase 7 Debug Infrastructure Integration

**Generated**: 2025-12-25-232750
**Plan**: PLAN-2025-12-25-232750.md
**Topic**: debug-integration

---

## Acceptance Criteria

### P0-1: Export Debug Modules from index.ts

- [ ] index.ts exports DebugIndex, SpanRing, ValueRing, TypeKeyEncoding, TraceController, SpanTypes, ValueRecord, instrumentClosure
- [ ] TypeScript compilation passes (`just typecheck`)
- [ ] No import errors in any file that imports from `editor/debug`

### P0-2: Add debugIndex Field to CompileResult

- [ ] CompileResult interface includes `debugIndex?: DebugIndex` field
- [ ] CompileResult interface includes `typeKeyTable?: TypeKeyTable` field
- [ ] Import statements for DebugIndex and TypeKeyTable added to types.ts
- [ ] TypeScript compilation passes (`just typecheck`)
- [ ] Existing compiler tests still pass (fields are optional)

### P0-3: Create DebugIndex in Pass 1 (Normalize)

- [ ] Pass 1 creates new DebugIndex with generated compileId (UUID)
- [ ] Pass 1 passes debugIndex to Pass 2 via Pass1Output
- [ ] CompileResult.debugIndex is populated with the DebugIndex instance
- [ ] DebugIndex.compileId is unique per compilation
- [ ] TypeScript compilation passes (`just typecheck`)
- [ ] Integration test: compile a patch, verify debugIndex exists and has compileId

### P0-4: Populate DebugIndex in Pass 6 (Block Lowering)

- [ ] Pass 6 calls `debugIndex.internBlock(blockId)` for every block lowered
- [ ] Interning happens before block compilation (so blockId is available for error reporting)
- [ ] DebugIndex.blocks map contains all block IDs from the patch
- [ ] TypeScript compilation passes (`just typecheck`)
- [ ] Integration test: compile patch with 3 blocks, verify debugIndex.blocks.size === 3

### P0-5: Populate DebugIndex in Pass 7 (Bus Lowering)

- [ ] Pass 7 calls `debugIndex.internBus(busId)` for every bus processed
- [ ] Interning happens before bus combine closure creation
- [ ] DebugIndex.buses map contains all bus IDs from the patch
- [ ] TypeScript compilation passes (`just typecheck`)
- [ ] Integration test: compile patch with 2 buses, verify debugIndex.buses.size === 2

### P0-6: Populate DebugIndex in Pass 8 (Link Resolution)

- [ ] Pass 8 calls `debugIndex.internPort(portKey)` for every port reference resolved
- [ ] Interning happens during link resolution (when port keys are constructed)
- [ ] DebugIndex.ports map contains all port keys from the patch
- [ ] TypeScript compilation passes (`just typecheck`)
- [ ] Integration test: compile patch with 5 ports, verify debugIndex.ports.size === 5

### P1-1: Extend RuntimeCtx with frameId and tMs

- [ ] RuntimeCtx interface includes `frameId?: number` field
- [ ] RuntimeCtx interface includes `tMs?: number` field (separate from signal parameter)
- [ ] TypeScript compilation passes (`just typecheck`)
- [ ] Existing runtime code compiles without errors (fields are optional)
- [ ] instrumentClosure wrappers correctly default frameId to 0 when missing

### P1-2: Populate RuntimeCtx Fields in Player

- [ ] Player maintains a frameId counter (starts at 0, increments per render)
- [ ] Player.renderOnce() sets runtimeCtx.frameId before calling program.signal()
- [ ] Player.renderOnce() sets runtimeCtx.tMs to current animation time
- [ ] frameId increments monotonically (even during scrubbing/hot reload)
- [ ] TypeScript compilation passes (`just typecheck`)
- [ ] Integration test: render 3 frames, verify frameId increments 0 → 1 → 2

### P1-3: Create TypeKeyTable in Pass 2 (Types)

- [ ] Pass 2 creates new TypeKeyTable instance
- [ ] Pass 2 calls typeKeyTable.intern(typeKey) for all TypeKeys encountered
- [ ] CompileResult.typeKeyTable is populated with the TypeKeyTable instance
- [ ] TypeKeyTable contains all unique TypeKeys from the patch
- [ ] TypeScript compilation passes (`just typecheck`)
- [ ] Integration test: compile patch, verify typeKeyTable.size > 0

---

## Sprint Scope

**This sprint delivers**:
1. Full debug infrastructure exported and accessible
2. DebugIndex creation and population during compilation (blocks, buses, ports)
3. TypeKeyTable creation and population during type resolution
4. RuntimeCtx extended with frameId/tMs for span attribution

**Deferred to future sprints**:
- Closure wrapping in compileBusAware (too invasive)
- SpanRing/ValueRing instantiation (no instrumentation yet)
- Debug UI consumption (Phase 8)
- EdgeRing for causal links (design doc feature, not yet implemented)
- Performance testing and optimization
- Trace export/persistence

---

## Integration Test Requirements

After all work items are complete, the following end-to-end test must pass:

```typescript
describe('debug infrastructure integration', () => {
  it('populates DebugIndex during compilation', () => {
    const patch = createTestPatch({ blocks: 2, buses: 1, connections: 3 });
    const result = compile(patch);

    expect(result.debugIndex).toBeDefined();
    expect(result.debugIndex.compileId).toMatch(/^[0-9a-f-]{36}$/);
    expect(result.debugIndex.blocks.size).toBe(2);
    expect(result.debugIndex.buses.size).toBe(1);
    expect(result.debugIndex.ports.size).toBeGreaterThan(0);
  });

  it('populates TypeKeyTable during type resolution', () => {
    const patch = createTestPatch({ blocks: 2 });
    const result = compile(patch);

    expect(result.typeKeyTable).toBeDefined();
    expect(result.typeKeyTable.size).toBeGreaterThan(0);
  });

  it('populates RuntimeCtx.frameId during render', () => {
    const player = createTestPlayer();
    player.setFactory(compiledProgramFactory);

    player.renderOnce();
    expect(player.getRuntimeCtx().frameId).toBe(0);

    player.renderOnce();
    expect(player.getRuntimeCtx().frameId).toBe(1);

    player.renderOnce();
    expect(player.getRuntimeCtx().frameId).toBe(2);
  });
});
```

---

## Verification Checklist

- [ ] TypeScript compilation passes (`just typecheck`)
- [ ] All existing tests pass (`just test`)
- [ ] Integration test suite passes
- [ ] No performance regressions (compilation time unchanged)
- [ ] No breaking changes to existing APIs
- [ ] Manual verification: Compile "Breathing Constellation" golden patch
- [ ] Manual verification: Inspect CompileResult.debugIndex in Chrome DevTools
- [ ] Manual verification: Verify debugIndex.blocks/buses/ports are populated

---

## Success Definition

This sprint is successful when:

1. A compiled patch has a populated DebugIndex with interned blocks, buses, and ports
2. A compiled patch has a populated TypeKeyTable with all unique type encodings
3. RuntimeCtx supports frameId (monotonic counter) and tMs (animation time)
4. All debug infrastructure modules are exported and accessible
5. Zero regressions in existing compiler/runtime behavior
6. All acceptance criteria above are met

The system is then ready for future closure instrumentation work (Phase 8).
