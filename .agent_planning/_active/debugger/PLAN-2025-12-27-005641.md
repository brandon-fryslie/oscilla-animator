# Phase 7 Debug Infrastructure - Sprint Plan

**Generated**: 2025-12-27-005641
**Source**: STATUS-20251226.md
**Scope**: Phase 7 Debug Infrastructure (IR Runtime Instrumentation)

---

## Executive Summary

**Current State**: Phase 7 infrastructure is ~60% complete. Ring buffers (SpanRing, ValueRing), TypeKeyEncoding, and TraceController exist and are tested. The IR compiler schema includes DebugIndex and StepDebugProbe types.

**Critical Gaps**:
1. Compiler emits empty DebugIndex (not populated during build)
2. executeDebugProbe is a stub (no value recording)
3. No debug probe steps inserted into schedule

**Sprint Focus**: Wire the existing infrastructure into the IR compilation and runtime execution paths to enable basic value tracing at step boundaries.

**Sprint Deliverables**: 2 core deliverables
- Deliverable 1: Compiler emits populated DebugIndex
- Deliverable 2: executeDebugProbe records values to trace buffers

**Deferred**: Causal edge recording (requires dependency tracking analysis - save for follow-up sprint)

---

## Backlog by Priority

### P0: Populate DebugIndex During Compilation

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: None
**Spec Reference**: design-docs/3-Synthesized/06-Runtime.md §Runtime Model • **Status Reference**: STATUS-20251226.md §What's Missing

#### Description

The IR compiler currently emits a DebugIndex structure with empty maps (`sigExprSource`, `fieldExprSource`, `slotSource`). This deliverable populates these maps during IRBuilder.build() by tracking source block IDs as signal/field expressions and value slots are allocated.

**Current behavior** (IRBuilderImpl.ts:463-467):
```typescript
debugIndex: {
  sigExprSource: new Map(),
  fieldExprSource: new Map(),
  slotSource: new Map(),
}
```

**Target behavior**:
- When allocating signal expressions: `sigExprSource.set(sigExprId, blockId)`
- When allocating field expressions: `fieldExprSource.set(fieldExprId, blockId)`
- When allocating value slots: `slotSource.set(slot, { blockId, slotId })`

This enables runtime-to-editor mapping for debugging UI (e.g., "which block produced this NaN?").

#### Acceptance Criteria

- [ ] IRBuilderImpl tracks blockId when allocating signal expressions (addSignalNode or equivalent)
- [ ] IRBuilderImpl tracks blockId when allocating field expressions (addFieldNode or equivalent)
- [ ] IRBuilderImpl tracks blockId + slotId when allocating value slots (allocateSlot or equivalent)
- [ ] ProgramIR.debugIndex maps contain entries for all allocated nodes/slots after build()
- [ ] Unit test: given a simple patch with 3 blocks, verify debugIndex contains 3+ sigExpr mappings
- [ ] Unit test: given a field-using block, verify debugIndex.fieldExprSource is populated
- [ ] Integration test: compile Golden Patch, verify debugIndex.slotSource has entries for TimeRoot slots

#### Technical Notes

**Implementation hints**:
1. Add optional `sourceBlockId` parameter to signal/field allocation methods
2. Store blockId at allocation time in internal tracking maps
3. Copy tracking maps to final ProgramIR.debugIndex in build()
4. Ensure composite instances use derived blockIds (compositeInstance.id + internalKey)

**Files to modify**:
- `src/editor/compiler/ir/IRBuilderImpl.ts` - add tracking to allocation methods
- `src/editor/compiler/ir/builderTypes.ts` - already defines BuilderDebugIndex correctly
- `src/editor/compiler/ir/__tests__/builder.test.ts` - add debug index population tests

**Gotchas**:
- Block compilation happens in multiple phases (signal graph, field graph, schedule). Track blockId at allocation, not at final assembly.
- Composite instances: internal nodes must map to composite instance ID, not the composite definition's internal IDs.

---

### P0: Implement executeDebugProbe Step

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: P0 Populate DebugIndex (for slot-to-block mapping)
**Spec Reference**: design-docs/3-Synthesized/06-Runtime.md §Evaluation Loop • **Status Reference**: STATUS-20251226.md §executeDebugProbe Step [STUB ONLY]

#### Description

The executeDebugProbe step currently does nothing. This deliverable implements basic value recording to TraceController ring buffers at specified debug probe points in the schedule.

**Current behavior** (executeDebugProbe.ts:34-36):
```typescript
export function executeDebugProbe(_step: StepDebugProbe, _runtime: RuntimeState): void {
  // Stub: No-op - debug probes disabled in Sprint 1
}
```

**Target behavior**:
1. Check TraceController mode (if 'off', return immediately)
2. For each slot in step.probe.slots:
   - Read value from runtime.values.read(slot)
   - Convert to ValueSummary using existing summarize() function
   - Record to appropriate ring buffer (ValueRing for 'value' mode, SpanRing for 'trace' mode)
3. Emit debug event to DebugStore for UI updates (throttled to ~10Hz)

#### Acceptance Criteria

- [ ] executeDebugProbe reads TraceController.mode and no-ops if mode === 'off'
- [ ] executeDebugProbe reads values for all slots in step.probe.slots using runtime.values.read()
- [ ] Values are converted to ValueSummary using debug/types.summarize()
- [ ] For mode='value': values written to ValueRing with current timestamp
- [ ] For mode='trace': span begin/end recorded to SpanRing
- [ ] Unit test: executeDebugProbe with mode='off' performs no operations
- [ ] Unit test: executeDebugProbe with mode='basic' records to ValueRing
- [ ] Integration test: run simple IR program with debug probe, verify ring buffer contains sampled values

#### Technical Notes

**Implementation approach**:
1. Add TraceController instance to RuntimeState (singleton, shared across frames)
2. In executeDebugProbe:
   ```typescript
   if (runtime.traceController.mode === 'off') return;

   for (const slot of step.probe.slots) {
     const rawValue = runtime.values.read(slot);
     const summary = summarize(rawValue, slotType);
     runtime.traceController.valueRing.write(slot, summary, runtime.tMs);
   }
   ```
3. Throttle event emission (don't emit to DebugStore every probe - batch at 10Hz)

**Files to modify**:
- `src/editor/runtime/executor/steps/executeDebugProbe.ts` - full implementation
- `src/editor/runtime/RuntimeState.ts` - add traceController field
- `src/editor/runtime/executor/__tests__/stepDispatch.test.ts` - add debug probe tests

**Integration points**:
- Use existing `summarize()` from `debug/types.ts`
- Use existing `ValueRing` and `SpanRing` from `debug/`
- Use existing `TraceController` from `debug/TraceController.ts`

**Gotchas**:
- Don't allocate objects in hot path (ValueSummary should be reused or pooled)
- TypedArray ring buffers are zero-alloc by design - use them correctly
- Throttle UI events (emit at 10Hz, not per-frame which could be 60Hz)

---

### P1: Add Debug Probe Steps to Schedule

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: P0 Implement executeDebugProbe
**Spec Reference**: design-docs/3-Synthesized/11-Roadmap.md WP6 • **Status Reference**: STATUS-20251226.md §What's Missing

#### Description

The schedule builder (buildSchedule) currently does not emit any StepDebugProbe steps. This deliverable adds instrumentation points at key boundaries:
- After each bus evaluation
- After each block signal evaluation
- After each field materialization
- After render assembly

This enables "why is this value what it is?" queries by capturing intermediate values.

**Current behavior**: Schedule contains only evaluation steps (evalSignal, materializeColor, renderAssemble, etc.)

**Target behavior**: Schedule contains debugProbe steps interspersed with evaluation steps when TraceController mode !== 'off'

**Example schedule fragment**:
```
Step 0: evalSignal (TimeRoot phaseA)
Step 1: debugProbe (slots: [phaseA.output])
Step 2: evalSignal (Oscillator breath)
Step 3: debugProbe (slots: [breath.output])
Step 4: materializeColor (palette field)
Step 5: debugProbe (slots: [palette.buffer])
```

#### Acceptance Criteria

- [ ] buildSchedule accepts optional DebugConfig parameter (probeMode: 'off' | 'basic' | 'full')
- [ ] When probeMode='basic': insert debugProbe steps after bus evaluation steps
- [ ] When probeMode='full': insert debugProbe steps after every significant step
- [ ] debugProbe steps reference correct slots based on preceding step's outputs
- [ ] debugProbe steps have unique probe IDs (e.g., "probe:bus:phaseA", "probe:block:breath")
- [ ] Unit test: buildSchedule with probeMode='off' emits no debugProbe steps
- [ ] Unit test: buildSchedule with probeMode='basic' emits debugProbe after bus steps
- [ ] Integration test: execute schedule with probes, verify TraceController buffers populated

#### Technical Notes

**Implementation strategy**:
1. Add DebugConfig to buildSchedule options:
   ```typescript
   export interface ScheduleOptions {
     debugConfig?: { probeMode: 'off' | 'basic' | 'full' };
   }
   ```

2. During schedule building, after emitting a key step:
   ```typescript
   if (options.debugConfig?.probeMode !== 'off') {
     const probeSlots = determineProbeSlots(step);
     schedule.steps.push({
       kind: 'debugProbe',
       probe: { id: `probe:${step.id}`, slots: probeSlots, mode: 'value' }
     });
   }
   ```

3. For 'basic' mode: probe only after bus/block evaluation
4. For 'full' mode: probe after every step that writes to value slots

**Files to modify**:
- `src/editor/compiler/ir/buildSchedule.ts` - add debug probe insertion logic
- `src/editor/compiler/ir/__tests__/buildSchedule.test.ts` - test probe insertion
- `src/editor/runtime/executor/IRRuntimeAdapter.ts` - pass debug config from player

**Complexity considerations**:
- Schedule size increases significantly in 'full' mode (2x step count)
- Performance impact is negligible when TraceController.mode='off' (early return in executeDebugProbe)
- 'basic' mode is the default for production debugging

**Gotchas**:
- Don't insert probes inside tight loops (field evaluation over domain elements)
- Probe insertion must respect schedule ordering (don't violate dependencies)
- Use StepId for probe IDs to ensure uniqueness

---

## Deferred Items

### P2: Causal Edge Recording

**Deferred to**: Follow-up sprint (Phase 7.2)
**Rationale**: Requires dependency analysis infrastructure that doesn't exist yet. The current DependencyIndexIR schema exists but is not populated during compilation.

**What's needed**:
- Populate DependencyIndexIR.slotProducerStep during schedule building
- Populate DependencyIndexIR.slotConsumerSteps during schedule building
- Use dependency index to record "slot X was produced by step Y" edges in trace buffers
- Add causal query API: "Why did slot X have value V at time T?"

**Why defer**: Current sprint deliverables enable basic value observation. Causal queries are a power-user feature that can wait.

---

## Dependency Graph

```
┌─────────────────────────────────┐
│ P0: Populate DebugIndex         │
│ (Compiler tracks blockId)       │
└─────────────┬───────────────────┘
              │
              v
┌─────────────────────────────────┐
│ P0: Implement executeDebugProbe │
│ (Runtime records values)        │
└─────────────┬───────────────────┘
              │
              v
┌─────────────────────────────────┐
│ P1: Add Probes to Schedule      │
│ (Instrumentation points)        │
└─────────────────────────────────┘

              Enables ↓
    ┌──────────────────────────┐
    │ Future: Causal Edges     │
    │ (Why queries)            │
    └──────────────────────────┘
```

---

## Recommended Sprint Execution

### Week 1: DebugIndex Population
**Focus**: P0 Populate DebugIndex During Compilation

**Tasks**:
1. Day 1-2: Add blockId tracking to IRBuilderImpl allocation methods
2. Day 3: Write unit tests for debug index population
3. Day 4: Test with Golden Patch compilation, verify all blocks mapped
4. Day 5: Code review + documentation

**Success metric**: `ProgramIR.debugIndex.sigExprSource.size > 0` after compiling any non-trivial patch

---

### Week 2: Runtime Instrumentation
**Focus**: P0 Implement executeDebugProbe + P1 Add Probes to Schedule

**Tasks**:
1. Day 1-2: Implement executeDebugProbe with ValueRing recording
2. Day 3: Add TraceController to RuntimeState, wire initialization
3. Day 4: Modify buildSchedule to insert debug probe steps
4. Day 5: Integration test - run Golden Patch, verify ring buffers populated

**Success metric**: Run patch with TraceController.mode='basic', observe values in ValueRing at 10Hz

---

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| **Performance overhead from debug probes** | Could slow frame rate | Execute only when TraceController.mode !== 'off'; use zero-alloc ring buffers |
| **Schedule size explosion in 'full' mode** | Memory + compilation time | Default to 'basic' mode; document 'full' as expert-only |
| **Missing slot type metadata** | Cannot call summarize() correctly | Verify SlotMetaEntry exists for all allocated slots |
| **DebugIndex maps too large** | Memory overhead | Maps are compile-time artifacts, not runtime; bounded by node/slot count |
| **Composite instance blockId conflicts** | Wrong source attribution | Use composite instance ID + internal key for derived IDs |

---

## Test Strategy

### Unit Tests (Required)
- DebugIndex population during IR build
- executeDebugProbe value recording to ValueRing
- buildSchedule probe insertion logic
- TraceController mode switching

### Integration Tests (Required)
- Compile + execute simple patch with debug probes enabled
- Verify ring buffers contain expected samples
- Verify DebugIndex slot-to-block mapping accuracy

### Manual Verification (Recommended)
- Use Chrome DevTools MCP to inspect TraceController state during playback
- Compare probe timestamps against frame timeline
- Verify no frame rate impact when mode='off'

---

## Blockers and Questions

None identified. All prerequisites exist:
- Ring buffer infrastructure: ✓ Complete
- Type encoding: ✓ Complete
- TraceController: ✓ Complete
- IR schema: ✓ Complete

This is a pure wiring sprint - connect existing pieces.

---

## Success Criteria

Sprint succeeds if:
1. IRBuilder emits non-empty DebugIndex after compiling Golden Patch
2. executeDebugProbe writes values to ring buffers when mode='basic'
3. Schedule contains debugProbe steps at bus evaluation boundaries
4. Integration test: compile + run patch, query ValueRing, find recorded samples
5. Performance: no measurable impact when TraceController.mode='off'

---

## References

- **STATUS Report**: `.agent_planning/debugger/STATUS-20251226.md`
- **Design Docs**: `design-docs/3-Synthesized/06-Runtime.md`, `11-Roadmap.md`
- **Existing Code**:
  - Ring buffers: `src/editor/debug/ValueRing.ts`, `SpanRing.ts`
  - TraceController: `src/editor/debug/TraceController.ts`
  - IR types: `src/editor/compiler/ir/schedule.ts` (StepDebugProbe)
  - Stub: `src/editor/runtime/executor/steps/executeDebugProbe.ts`
