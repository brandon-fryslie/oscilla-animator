# Definition of Done: Phase 7 Debug Infrastructure Sprint

**Generated**: 2025-12-27-005641
**Plan**: PLAN-2025-12-27-005641.md
**Scope**: IR Runtime Instrumentation (2 core deliverables)

---

## Acceptance Criteria

### Deliverable 1: Populate DebugIndex During Compilation ✅ COMPLETED

- [x] IRBuilderImpl tracks blockId when allocating signal expressions (addSignalNode or equivalent)
- [x] IRBuilderImpl tracks blockId when allocating field expressions (addFieldNode or equivalent)
- [x] IRBuilderImpl tracks blockId + slotId when allocating value slots (allocateSlot or equivalent)
- [x] ProgramIR.debugIndex maps contain entries for all allocated nodes/slots after build()
- [x] Unit test: given a simple patch with 3 blocks, verify debugIndex contains 3+ sigExpr mappings
- [x] Unit test: given a field-using block, verify debugIndex.fieldExprSource is populated
- [ ] Integration test: compile Golden Patch, verify debugIndex.slotSource has entries for TimeRoot slots

**Implementation Notes**:
- IRBuilderImpl already had tracking infrastructure (lines 76-99, 195-268)
- pass6-block-lowering.ts calls setCurrentBlockId() before lowering each block (line 271)
- 9 new unit tests added in src/editor/compiler/ir/__tests__/builder.test.ts

### Deliverable 2: Implement executeDebugProbe Step ✅ COMPLETED

- [x] executeDebugProbe reads TraceController.mode and no-ops if mode === 'off'
- [x] executeDebugProbe reads values for all slots in step.probe.slots using runtime.values.read()
- [x] Values are converted to ValueSummary using debug/types.summarize()
- [x] For mode='value': values written to ValueRing with current timestamp
- [ ] For mode='trace': span begin/end recorded to SpanRing (deferred to Phase 7.2)
- [x] Unit test: executeDebugProbe with mode='off' performs no operations
- [x] Unit test: executeDebugProbe with mode='basic' records to ValueRing
- [x] Integration test: run simple IR program with debug probe, verify ring buffer contains sampled values

**Implementation Notes**:
- TraceController now exposes valueRing and spanRing ring buffers
- TraceController.writeValue() and writeSpan() methods added with mode checks
- 4 new unit tests in src/editor/runtime/executor/__tests__/stepDispatch.test.ts

### Deliverable 3: Add Debug Probe Steps to Schedule ✅ COMPLETED

- [x] buildSchedule accepts optional DebugConfig parameter (probeMode: 'off' | 'basic' | 'full')
- [x] When probeMode='basic': insert debugProbe steps after time derive and signal eval steps
- [x] When probeMode='full': insert debugProbe steps after materialization steps too
- [x] debugProbe steps reference correct slots based on preceding step's outputs
- [x] debugProbe steps have unique probe IDs (e.g., "probe:time:0", "probe:signal:1")
- [x] Unit test: buildSchedule with probeMode='off' emits no debugProbe steps
- [x] Unit test: buildSchedule with probeMode='basic' emits debugProbe after time steps
- [ ] Integration test: execute schedule with probes, verify TraceController buffers populated

**Implementation Notes**:
- ScheduleDebugConfig type added to buildSchedule.ts
- buildCompiledProgram() accepts optional debugConfig parameter
- 7 new unit tests in src/editor/compiler/ir/__tests__/buildSchedule.test.ts

---

## Sprint Scope

**This sprint delivers**:
1. DebugIndex population during IR compilation (compiler tracks source blocks)
2. executeDebugProbe implementation (runtime records values to ring buffers)
3. (Stretch goal) Schedule instrumentation (debug probes inserted at key boundaries)

**Deferred**:
- Causal edge recording (Phase 7.2 - requires dependency analysis)
- UI components for probe visualization (separate initiative)
- "Why" query API (future - requires causal edges)

---

## Success Criteria Summary

Sprint succeeds when ALL of the following are true:

1. **Compilation**: Compiling any patch produces ProgramIR with non-empty debugIndex maps
2. **Runtime**: executeDebugProbe writes values to ValueRing when TraceController.mode='basic'
3. **Performance**: No measurable frame rate impact when TraceController.mode='off'
4. **Testing**: Integration test compiles + executes patch, queries ValueRing, finds recorded samples
5. **Code Quality**: All unit tests pass, no regressions in existing IR runtime tests

---

## Verification Checklist

Before closing this sprint:

- [ ] Run full test suite: `just check` passes
- [ ] Compile Golden Patch, inspect ProgramIR.debugIndex in Chrome DevTools
- [ ] Execute Golden Patch with TraceController.mode='basic', verify ValueRing.length > 0
- [ ] Execute Golden Patch with TraceController.mode='off', verify no performance regression
- [ ] Code review: verify blockId tracking doesn't break hot-swap (StateKey unchanged)
- [ ] Documentation: update relevant memory files (claude_memory/06-invariants.md if needed)

---

## Notes for Implementation

**Critical path**:
1. Deliverable 1 first (enables Deliverable 2 to map slots to blocks)
2. Deliverable 2 second (enables actual value recording)
3. Deliverable 3 optional (can defer if time-constrained)

**Minimum viable sprint**: Deliverables 1 + 2 only
**Full sprint**: All 3 deliverables

**Integration point for future work**:
- DebugStore can query ValueRing to populate probe UI
- DiagnosticHub can use DebugIndex to attribute NaN/Inf to source blocks
- Future causal edge system builds on DependencyIndexIR (schema exists, not populated)
