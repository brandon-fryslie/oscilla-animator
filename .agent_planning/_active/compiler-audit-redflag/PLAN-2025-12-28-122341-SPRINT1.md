# Sprint 1 Implementation Plan: Core IR Execution

**Generated:** 2025-12-28-122341
**Source:** STATUS-2025-12-28.md
**Sprint Goal:** Make IR mode functional for simple patches
**Duration:** 1 week
**Prerequisites:** Sprint 0 complete (block registry fixed, IR compilation mandatory)

---

## Executive Summary

Sprint 0 successfully unblocked test infrastructure and made IR compilation mandatory. Sprint 1 builds on this foundation by implementing the core time system threading that makes IR execution actually work. Currently, IR mode compiles patches but executes them with incorrect time semantics (always infinite) and incomplete time data propagation.

**Current State (Sprint 0 Complete):**
- Test baseline: 118/126 test files pass, 2362/2411 tests pass
- Block registry capability propagation: FIXED (commit 72874c3)
- IR compilation mandatory when enabled: FIXED (commit a4ea0c1)
- IR compiler runs but produces incorrect schedules

**Sprint 1 Scope:**
Three tightly-focused items that fix time system integration:
1. TimeModel threading from Pass 3 to schedule builder
2. timeDerive step writes tAbsMs slot correctly
3. Feature flag parsing bug (prevents disabling unified compiler)

**Success Criteria:**
- IR-only mode can execute patches with correct time topology
- Finite/cyclic/infinite TimeRoots behave distinctly
- Absolute time available to downstream signal nodes
- Unified compiler can be explicitly disabled via env var

**Known Limitations After Sprint 1:**
- Pass 6 still uses placeholder block lowering (Sprint 2)
- Bus evaluation not implemented (Sprint 3)
- Default sources not lowered (Sprint 2)
- Type conversions unimplemented (Sprint 4)

---

## P0-1: TimeModel Threading

**Priority:** P0 (Critical)
**Status:** Not Started
**Effort:** Medium (2 days)
**Dependencies:** None
**Spec Reference:** STATUS-2025-12-28.md lines 155-162
**Status Reference:** STATUS-2025-12-28.md section "Tier 1: Critical IR-Only Blockers" item 2

### Description

Pass 3 (time extraction) successfully extracts the TimeModel from the patch's TimeRoot block, but this information never reaches the schedule builder. The IRBuilder's `build()` method doesn't return the timeModel, and `buildSchedule()` hardcodes an infinite time model with 30s window.

**Current Behavior:**
```typescript
// Pass 3 extracts TimeModel correctly (pass3-time.ts:170)
const timeModelInfo = extractTimeModelFromRoot(patch, rootId);

// But IRBuilder.build() doesn't return it (IRBuilderImpl.ts:605)
public build(): ProgramIR {
  // timeModel is computed but not returned
  return { schedule, signalExprs, ... };  // missing timeModel!
}

// So buildSchedule hardcodes infinite (buildSchedule.ts)
const timeModel: TimeModel = {
  kind: 'infinite',
  windowMs: 30000
};
```

**Impact:**
- All time topologies broken - finite/cyclic patches behave as infinite
- `progress` signal in finite patches never completes (always 0)
- `phase` signal in cyclic patches never wraps (always increases)
- `wrap` event in cyclic patches never fires
- Player UI shows incorrect time bounds

### Acceptance Criteria

**AC1: IRBuilder returns TimeModel**
- [ ] `IRBuilderImpl.build()` returns `{ schedule, signalExprs, ..., timeModel }`
- [ ] `ProgramIR` interface includes `timeModel: TimeModel` field
- [ ] TimeModel is extracted from Pass 3 results and stored in IRBuilder state

**AC2: Schedule builder uses provided TimeModel**
- [ ] `buildSchedule()` accepts `timeModel: TimeModel` parameter
- [ ] Remove hardcoded infinite time model
- [ ] Schedule generation respects time topology (finite/cyclic/infinite)

**AC3: Compiled program exposes TimeModel**
- [ ] `CompiledProgramIR` interface includes `timeModel: TimeModel`
- [ ] `compileBusAware()` passes timeModel from IRBuilder to program wrapper
- [ ] Player can read timeModel from compiled program

**AC4: Tests verify topology preservation**
- [ ] Add test: finite TimeRoot produces `{ kind: 'finite', durationMs: N }`
- [ ] Add test: cyclic TimeRoot produces `{ kind: 'cyclic', periodMs: N }`
- [ ] Add test: infinite TimeRoot produces `{ kind: 'infinite', windowMs: N }`
- [ ] Verify schedule step semantics differ per topology

### Technical Notes

**Files to Modify:**

1. **src/editor/compiler/ir/IRBuilderImpl.ts** (line 605)
   - Add `timeModel` field to builder state
   - Populate from Pass 3 results in constructor/init
   - Return in `build()` method

2. **src/editor/compiler/ir/builderTypes.ts**
   - Add `timeModel: TimeModel` to `ProgramIR` interface

3. **src/editor/compiler/ir/buildSchedule.ts** (line 337)
   - Add `timeModel: TimeModel` parameter
   - Remove hardcoded value
   - Use timeModel in schedule logic

4. **src/editor/compiler/ir/program.ts**
   - Add `timeModel` to `CompiledProgramIR` interface
   - Thread through from `buildSchedule()` result

5. **src/editor/compiler/compileBusAware.ts** (line 777-796)
   - Pass `programIR.timeModel` to program wrapper
   - Expose on final CompiledProgram

**Implementation Sequence:**

1. Update ProgramIR interface to include timeModel
2. Extract timeModel from Pass 3 results in IRBuilderImpl constructor
3. Store timeModel in builder state
4. Return timeModel in build() method
5. Update buildSchedule() signature to accept timeModel parameter
6. Remove hardcoded infinite timeModel
7. Thread timeModel through to CompiledProgramIR
8. Write tests for each time topology
9. Verify with browser DevTools that finite/cyclic patches behave correctly

**Potential Gotchas:**

- Pass 3 results may not be available in all code paths - verify initialization
- TimeModel may need default value if no TimeRoot found (should be compile error)
- Schedule step generation may need topology-specific logic (defer to Sprint 2 if complex)
- Player UI may cache old timeModel - verify reactivity

---

## P0-2: timeDerive Writes tAbsMs Slot

**Priority:** P0 (Critical)
**Status:** Not Started
**Effort:** Small (1 day)
**Dependencies:** None
**Spec Reference:** STATUS-2025-12-28.md lines 191-197
**Status Reference:** STATUS-2025-12-28.md section "Tier 1: Critical IR-Only Blockers" item 6

### Description

The `executeTimeDerive` step declares a `tAbsMsSlot` in the schedule but never writes to it. The executor only writes derived time outputs (`tModelMs`, `phase01`, `wrapEvent`, `progress01`) but not the input absolute time. Downstream signal nodes that read `tAbsMs` get stale or uninitialized data.

**Current Behavior:**
```typescript
// Schedule declares tAbsMsSlot (schedule.ts)
export interface TimeDerive {
  type: 'timeDerive';
  tAbsMsSlot: number;  // Declared but never written!
  outputs: { tModelMs?: number; phase01?: number; ... };
}

// Executor only writes outputs (executeTimeDerive.ts:36-56)
function executeTimeDerive(step: TimeDerive, state: RuntimeState) {
  const tAbs = /* input from somewhere? */

  // Writes these:
  state.slots[step.outputs.tModelMs] = derived;
  state.slots[step.outputs.phase01] = phase;

  // But NEVER writes:
  // state.slots[step.tAbsMsSlot] = tAbs;  // MISSING!
}
```

**Impact:**
- Signal nodes reading `tAbsMs` get undefined or stale values
- Any block using absolute time (timestamps, playback position) fails
- Debug displays show incorrect time values
- Scrubbing behavior unreliable

### Acceptance Criteria

**AC1: Executor writes tAbsMs slot**
- [ ] `executeTimeDerive()` writes `state.slots[step.tAbsMsSlot] = tAbsMs`
- [ ] Write occurs BEFORE derived outputs (tAbsMs is input to derivation)
- [ ] Value written is the input absolute time from executor context

**AC2: tAbsMs source is correct**
- [ ] Verify tAbsMs comes from `EffectiveTime` interface
- [ ] Confirm EffectiveTime includes tAbsMs field
- [ ] Value matches player's current time position

**AC3: Tests verify slot write**
- [ ] Add test: executeTimeDerive writes tAbsMsSlot
- [ ] Verify written value equals input tAbsMs
- [ ] Test that downstream signal reads get correct value

**AC4: Integration test with signal consumer**
- [ ] Create patch with block that reads tAbsMs
- [ ] Verify value updates each frame
- [ ] Confirm scrubbing updates tAbsMs

### Technical Notes

**Files to Modify:**

1. **src/editor/runtime/executor/steps/executeTimeDerive.ts** (lines 36-56)
   - Add slot write for tAbsMs BEFORE computing derived values
   - Source tAbsMs from executor context (likely passed as parameter)

2. **src/editor/runtime/executor/ScheduleExecutor.ts**
   - Verify EffectiveTime is passed to executeTimeDerive
   - Confirm tAbsMs is available in context

3. **src/core/types.ts** (or wherever EffectiveTime is defined)
   - Verify EffectiveTime includes tAbsMs field
   - Document that tAbsMs is absolute player time in milliseconds

**Implementation Sequence:**

1. Verify EffectiveTime interface includes tAbsMs
2. Trace how tAbsMs flows from Player to ScheduleExecutor
3. Add parameter to executeTimeDerive if needed (or read from RuntimeState)
4. Write tAbsMs to slot FIRST (before derivation)
5. Write unit test for executeTimeDerive step
6. Write integration test with consumer block
7. Verify in browser that time values are correct

**Potential Gotchas:**

- tAbsMs source may not be obvious - check ScheduleExecutor.step() signature
- Slot write order matters - tAbsMs must be available before derived computations
- EffectiveTime might be named differently - search for interface definition
- Some time topologies might not use tAbsMs - verify all paths

---

## P0-3: Feature Flag Parsing Fixed

**Priority:** P0 (Critical)
**Status:** Not Started
**Effort:** Trivial (1 hour)
**Dependencies:** None
**Spec Reference:** STATUS-2025-12-28.md lines 258-269
**Status Reference:** STATUS-2025-12-28.md section "Tier 3: Medium Priority" item 14

### Description

The feature flag parser for `VITE_USE_UNIFIED_COMPILER` incorrectly checks `!== undefined` instead of parsing the string value. This forces the flag to `true` whenever the environment variable exists, regardless of value. Cannot explicitly disable unified compiler by setting `VITE_USE_UNIFIED_COMPILER=false`.

**Current Behavior:**
```typescript
// featureFlags.ts:121
if (env.VITE_USE_UNIFIED_COMPILER !== undefined) {
  currentFlags.useUnifiedCompiler = true;  // ALWAYS true if var exists!
}

// .env
VITE_USE_UNIFIED_COMPILER=false  // Ignored! Still enables compiler
```

**Impact:**
- Cannot disable unified compiler for A/B testing
- Cannot quickly revert to legacy compiler if IR bugs found
- Developer workflow hampered (no escape hatch)
- Misleading behavior - false looks like it should work

### Acceptance Criteria

**AC1: Parse string value correctly**
- [ ] Check `env.VITE_USE_UNIFIED_COMPILER === 'true'` (not `!== undefined`)
- [ ] Setting `VITE_USE_UNIFIED_COMPILER=false` disables compiler
- [ ] Setting `VITE_USE_UNIFIED_COMPILER=true` enables compiler
- [ ] Omitting variable uses default value (check current default)

**AC2: Tests verify flag behavior**
- [ ] Add test: `VITE_USE_UNIFIED_COMPILER=true` sets flag true
- [ ] Add test: `VITE_USE_UNIFIED_COMPILER=false` sets flag false
- [ ] Add test: undefined variable uses default
- [ ] Add test: invalid value (not 'true'/'false') uses default or errors

**AC3: Documentation updated**
- [ ] Update .env.example with correct usage
- [ ] Add comment explaining string comparison
- [ ] Document default value clearly

### Technical Notes

**Files to Modify:**

1. **src/editor/compiler/featureFlags.ts** (line 121)
   - Change condition to: `env.VITE_USE_UNIFIED_COMPILER === 'true'`
   - Consider adding warning for invalid values
   - Document expected values in comment

2. **.env.example** (if exists)
   - Add example: `VITE_USE_UNIFIED_COMPILER=true`
   - Explain effect of true/false values

**Implementation Sequence:**

1. Change condition from `!== undefined` to `=== 'true'`
2. Add comment explaining string comparison
3. Write unit tests for flag parsing
4. Test manually: set false, verify compiler disabled
5. Test manually: set true, verify compiler enabled
6. Update .env.example

**Potential Gotchas:**

- Check if other feature flags have same bug - fix all if so
- Verify default value is sensible (should be true for current branch)
- Consider case-insensitive comparison ('True', 'TRUE')
- Consider validation/warning for invalid values ('1', 'yes', etc.)

---

## Dependency Graph

```
Sprint 0 (COMPLETE)
  ├─ Block registry fix ✓
  └─ IR compilation mandatory ✓
      ↓
Sprint 1 (THIS SPRINT)
  ├─ P0-3: Feature flag fix (1 hour) ─────┐
  ├─ P0-2: timeDerive tAbsMs (1 day) ─────┤ → Can be done in parallel
  └─ P0-1: TimeModel threading (2 days) ──┘
      ↓
  Tests confirm:
    ✓ Finite patches complete
    ✓ Cyclic patches wrap
    ✓ Infinite patches run continuously
    ✓ Absolute time flows correctly
    ✓ Compiler can be disabled
      ↓
Sprint 2 (NEXT)
  └─ Block lowering, default sources, ColorLFO
```

**Critical Path:** P0-1 (TimeModel threading) is longest (2 days)
**Parallelizable:** All three items are independent and can be worked simultaneously

---

## Risk Assessment

### High Risk Items

**NONE** - All Sprint 1 items are low-risk mechanical fixes

### Medium Risk Items

**P0-1: TimeModel Threading**
- **Risk:** Pass 3 timeModel extraction may not work in all scenarios
- **Mitigation:** Validate with unit tests for each time topology
- **Fallback:** Can hardcode infinite for Sprint 1, fix properly in Sprint 2

### Low Risk Items

**P0-2: timeDerive tAbsMs**
- **Risk:** tAbsMs source unclear, may need executor refactor
- **Mitigation:** Trace through ScheduleExecutor carefully before coding

**P0-3: Feature Flag Parsing**
- **Risk:** None - trivial string comparison fix
- **Mitigation:** N/A

---

## Validation Strategy

### Unit Tests (Required)

**TimeModel Threading:**
- `IRBuilder.build()` returns timeModel
- `buildSchedule()` uses provided timeModel
- Finite/cyclic/infinite schedules differ

**timeDerive tAbsMs:**
- `executeTimeDerive()` writes tAbsMsSlot
- Written value equals input tAbsMs

**Feature Flags:**
- Flag parsing handles true/false/undefined correctly

### Integration Tests (Required)

**End-to-End Time Topology:**
- Compile finite patch → verify progress reaches 1.0
- Compile cyclic patch → verify wrap event fires
- Compile infinite patch → verify continuous execution

**Absolute Time Flow:**
- Signal reads tAbsMs → value updates per frame
- Scrubbing updates tAbsMs correctly

### Manual Testing (Required)

**Browser DevTools Verification:**
1. Open Chrome DevTools MCP
2. Load patch with finite TimeRoot
3. Verify compiled program has `timeModel: { kind: 'finite', ... }`
4. Play animation → verify stops at completion
5. Repeat for cyclic and infinite

**Feature Flag Toggle:**
1. Set `VITE_USE_UNIFIED_COMPILER=false` in .env
2. Restart dev server
3. Verify legacy compiler used (check console logs)
4. Set `VITE_USE_UNIFIED_COMPILER=true`
5. Verify unified compiler used

---

## Success Metrics

**Quantitative:**
- Test suite remains stable: 118/126 files, 2362/2411 tests (or better)
- New tests added: 8 unit tests, 3 integration tests
- Code changes: ~100 lines modified/added total
- Time spent: 3-4 days (2 days TimeModel + 1 day tAbsMs + 1 hour flags + testing)

**Qualitative:**
- IR-only patches execute with correct time semantics
- Developer can toggle compiler for debugging
- Foundation ready for Sprint 2 block lowering

---

## Out of Scope (Deferred)

**Sprint 2 Items:**
- Pass 6 block lowering (still uses placeholders)
- Default source lowering
- ColorLFO HSL→RGB kernel
- SVGSampleDomain initialization

**Sprint 3 Items:**
- Bus evaluation steps
- Event bus lowering

**Sprint 4+ Items:**
- Type conversion paths
- Transform chains
- Type system unification

---

## Recommended Sprint Planning

### Day 1: Setup and Feature Flags
- **Morning:** Review Sprint 0 commits, understand current state
- **Afternoon:** Fix P0-3 (feature flags) - 1 hour + tests
- **Evening:** Write unit test stubs for P0-1 and P0-2

### Day 2-3: TimeModel Threading
- **Focus:** P0-1 (TimeModel threading)
- **Day 2:** Interface changes, builder modifications, schedule update
- **Day 3:** Integration, testing, browser verification

### Day 4: timeDerive Slot Write
- **Focus:** P0-2 (timeDerive tAbsMs)
- **Morning:** Trace EffectiveTime flow, understand executor context
- **Afternoon:** Implement slot write, unit tests
- **Evening:** Integration test, browser verification

### Day 5: Integration and Validation
- **Morning:** Run full test suite, fix any regressions
- **Afternoon:** Manual testing with Chrome DevTools
- **Evening:** Documentation, commit messages, Sprint 1 review

---

## Blockers and Questions

**NONE** - Sprint 0 resolved the critical blocker (registry validation). Sprint 1 has clear scope and no known blockers.

**Ambiguities Resolved:**
- TimeModel source: Pass 3 extraction (confirmed in STATUS)
- tAbsMs location: EffectiveTime interface (assumed, to verify)
- Feature flag default: true for current branch (assumed)

**If Blockers Arise:**
- Check STATUS-2025-12-28.md for context
- Review Pass 3 implementation (pass3-time.ts)
- Consult Player and ScheduleExecutor code

---

## References

**Status File:** `.agent_planning/compiler-audit-redflag/STATUS-2025-12-28.md`

**Key Sections:**
- Lines 155-162: TimeModel threading issue
- Lines 191-197: timeDerive tAbsMs issue
- Lines 258-269: Feature flag parsing bug
- Lines 336-361: Sprint 1 scope (this plan)

**Related Files:**
- `/src/editor/compiler/passes/pass3-time.ts` - TimeModel extraction
- `/src/editor/compiler/ir/IRBuilderImpl.ts` - IR builder
- `/src/editor/compiler/ir/buildSchedule.ts` - Schedule generation
- `/src/editor/runtime/executor/steps/executeTimeDerive.ts` - Time derivation step
- `/src/editor/compiler/featureFlags.ts` - Feature flag parsing
- `/src/core/types.ts` - Core type definitions (EffectiveTime)

**Tests to Review:**
- `tests/compiler/` - Compiler integration tests
- `tests/runtime/executor/` - Executor step tests
- `tests/time/` - Time system tests (if exists)

---

## Definition of Done

Sprint 1 is complete when:

1. **All acceptance criteria met** (see DOD-2025-12-28-122341-SPRINT1.md)
2. **Test suite stable or improved** (118+ files, 2362+ tests passing)
3. **New tests written and passing** (8 unit, 3 integration)
4. **Manual browser verification complete** (finite/cyclic/infinite patches work)
5. **Feature flag toggle verified** (can disable compiler)
6. **Code reviewed and committed** (clean commits, no debug code)
7. **Sprint 2 ready** (foundation for block lowering in place)

---

**Next Steps:** Proceed to implementation via `/lp:impl` or direct coding. Consult DOD file for detailed acceptance criteria checklist.
