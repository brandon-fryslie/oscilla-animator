# Sprint 1 Plan: Core IR Execution

**Generated:** 2025-12-28-122552
**Source Status:** STATUS-2025-12-28-sprint1.md
**Previous Status:** STATUS-2025-12-28.md
**Sprint Goal:** Make IR mode functional for simple patches with correct time topology

---

## Executive Summary

**Sprint 0 Completed:** ✅ Both deliverables shipped (block registry + IR mandatory)
**Sprint 1 Scope:** 2 critical items remaining from original 4-item list
**Test Status:** 126/128 files pass (2422/2426 tests) - infrastructure functional
**Sprint Duration:** 2 days (estimated)
**Blockers:** None - all dependencies resolved

### What Changed from Original Sprint 1

**Original Sprint 1 (4 items):**
1. IR compilation mandatory → ✅ Moved to Sprint 0, COMPLETE
2. TimeModel threading → ❌ Remains in Sprint 1 (P0)
3. timeDerive tAbsMs write → ✅ Already fixed, no work needed
4. Feature flag parsing → ❌ Remains in Sprint 1 (P1)

**Revised Sprint 1 (2 items):**
1. TimeModel threading (P0 - CRITICAL)
2. Feature flag parsing fix (P1 - quick win)

---

## Scope Definition

### In Scope

**Must Ship:**
- [ ] TimeModel threaded from Pass 3 through IRBuilder to schedule
- [ ] Feature flag parsing correctly handles explicit `=false` values

**Must Verify:**
- [ ] Finite patches compile with `timeModel.kind === 'finite'`
- [ ] Cyclic patches compile with `timeModel.kind === 'cyclic'`
- [ ] Infinite patches compile with `timeModel.kind === 'infinite'`
- [ ] Feature flag `VITE_USE_UNIFIED_COMPILER=false` disables IR mode

### Out of Scope (Deferred to Future Sprints)

**Sprint 2 (Next):**
- Default source lowering
- Block lowering for core signal blocks
- Pass 6 placeholder replacement

**Sprint 3 (Later):**
- Bus evaluation steps
- Event bus lowering
- Bus type support (vec2, color)

**Sprint 4+ (Future):**
- Type conversion paths
- Transform chain implementation
- Field reduce implementation

### Known Gaps After Sprint 1

These will remain broken but are explicitly out of scope:
- ❌ Default sources not lowered → blocks required inputs without connections
- ❌ Block lowering uses placeholders → outputs wrong values
- ❌ Bus evaluation absent → bus-driven graphs broken
- ❌ Event buses not lowered → event listeners fail

---

## Work Items

### P0 (Critical) - Must Complete

## [P0] TimeModel Threading from Pass 3 to Schedule

**Status:** Not Started
**Effort:** Medium (2 days)
**Dependencies:** None
**Spec Reference:** Time-Architecture.md (Red Flag: "TimeModel hardcoded to infinite") • **Status Reference:** STATUS-2025-12-28-sprint1.md lines 129-181

### Description

Currently, Pass 3 correctly extracts the TimeModel from the TimeRoot block and stores it in `TimeResolvedPatch.timeModel`. However, the IRBuilder ignores this value and hardcodes `{ kind: "infinite", windowMs: 30000 }` in its `build()` method. This causes ALL patches to behave as infinite time, breaking finite (one-shot) and cyclic (looping) animations.

**Current Data Flow:**
```
pass3TimeTopology()
  ↓ timeResolved.timeModel ← extracted from TimeRoot
pass4DepGraph(timeResolved)
  ↓ (passes through timeModel)
pass5CycleValidation(depGraph)
  ↓
pass6BlockLowering(validated, ...) ← creates IRBuilder
  ↓ builder.build() ← HARDCODES infinite model ❌
buildCompiledProgram(builderIR)
  ↓ uses builderIR.timeModel (always infinite)
CompiledProgramIR ← wrong time topology
```

**Required Changes:**
1. Thread `timeModel` from Pass 3 input to Pass 6 IRBuilder
2. Add `IRBuilder.setTimeModel(timeModel: TimeModel)` method (parallel to existing `setTimeSlots`)
3. Call `setTimeModel()` during TimeRoot block lowering
4. Remove hardcoded fallback in `IRBuilderImpl.build()` line 640-643

**Files to Modify:**
- `src/editor/compiler/ir/IRBuilder.ts` - add `setTimeModel()` interface method
- `src/editor/compiler/ir/IRBuilderImpl.ts` - implement method, remove hardcoded value
- `src/editor/compiler/passes/pass6-block-lowering.ts` - call `setTimeModel()` during lowering
- `src/editor/compiler/blocks/time/FiniteTimeRoot.ts` - ensure lowering calls setTimeModel
- (removed - legacy time component)
- `src/editor/compiler/blocks/time/InfiniteTimeRoot.ts` - ensure lowering calls setTimeModel

### Acceptance Criteria (REQUIRED)

- [ ] `IRBuilder` interface has `setTimeModel(timeModel: TimeModel): void` method
- [ ] `IRBuilderImpl` implements `setTimeModel()` and stores timeModel in instance field
- [ ] `IRBuilderImpl.build()` uses stored timeModel instead of hardcoded infinite value
- [ ] `pass6BlockLowering()` threads `input.timeModel` to IRBuilder
- [ ] Each TimeRoot block compiler calls `builder.setTimeModel()` during lowering
- [ ] TypeScript compilation passes with no errors
- [ ] Test: Finite patch compiles with `compiledProgram.ir.timeModel.kind === 'finite'`
- [ ] Test: Cyclic patch compiles with `compiledProgram.ir.timeModel.kind === 'cyclic'`
- [ ] Test: Infinite patch compiles with `compiledProgram.ir.timeModel.kind === 'infinite'`

### Technical Notes

**Implementation Strategy:**
1. Follow the existing pattern for `timeSlots` (see `IRBuilder.setTimeSlots()` lines 21-22)
2. Store timeModel in IRBuilderImpl as private field
3. Validate timeModel is set before `build()` is called (defensive check)
4. Ensure all three TimeRoot compilers set it during lowering

**Defensive Checks:**
```typescript
// In IRBuilderImpl.build()
if (!this.timeModel) {
  throw new Error('IRBuilder.build() called before setTimeModel() - internal compiler error');
}
```

**Testing Approach:**
- Create minimal finite patch: `FiniteTimeRoot(5000ms)` → verify timeModel.kind
- Create minimal infinite patch: `InfiniteTimeRoot()` → verify timeModel.kind
- Use Chrome DevTools MCP to verify runtime behavior matches timeModel

---

### P1 (High) - Should Complete

## [P1] Feature Flag Parsing Fix

**Status:** Not Started
**Effort:** Small (1 hour)
**Dependencies:** None
**Spec Reference:** Core.md (Red Flag: "Feature flag parsing ignores explicit false") • **Status Reference:** STATUS-2025-12-28-sprint1.md lines 214-241

### Description

The feature flag parsing logic in `featureFlags.ts` line 121-122 checks if `VITE_USE_UNIFIED_COMPILER !== undefined` and unconditionally sets the flag to `true`. This means setting `VITE_USE_UNIFIED_COMPILER=false` is treated the same as `=true`, making it impossible to explicitly disable the unified compiler via environment variable.

**Current Broken Logic:**
```typescript
if (env.VITE_USE_UNIFIED_COMPILER !== undefined) {
  currentFlags.useUnifiedCompiler = true;  // ❌ Always true if var exists
}
```

**Correct Logic (used by other flags on lines 125, 128):**
```typescript
if (env.VITE_USE_UNIFIED_COMPILER !== undefined) {
  currentFlags.useUnifiedCompiler = env.VITE_USE_UNIFIED_COMPILER === 'true';
}
```

**Files to Modify:**
- `src/editor/compiler/featureFlags.ts` - line 121-123

### Acceptance Criteria (REQUIRED)

- [ ] `VITE_USE_UNIFIED_COMPILER=false` sets `useUnifiedCompiler` to `false`
- [ ] `VITE_USE_UNIFIED_COMPILER=true` sets `useUnifiedCompiler` to `true`
- [ ] `VITE_USE_UNIFIED_COMPILER` undefined uses default behavior (no change)
- [ ] TypeScript compilation passes
- [ ] Test: Set env var to `false`, verify flag is false
- [ ] Test: Set env var to `true`, verify flag is true
- [ ] Dev workflow: `VITE_USE_UNIFIED_COMPILER=false just dev` runs legacy compiler

### Technical Notes

**Risk:** None - this is a trivial one-line fix

**Testing Strategy:**
- Unit test the `updateFeatureFlags()` function with mocked env
- Integration test: launch dev server with env var set, verify compiler mode

**Why This Matters:**
- Enables A/B testing between legacy and IR compilers
- Allows debugging by toggling modes without code changes
- Improves developer workflow and QA process

---

## Dependencies Graph

```
Sprint 0 (COMPLETE):
  ✅ Block Registry Fix
  ✅ IR Compilation Mandatory
    ↓
Sprint 1 (THIS SPRINT):
  ❌ TimeModel Threading (P0) ──┐
  ❌ Feature Flag Parsing (P1) ──┼─→ Basic IR execution works
                                 │   with correct time topology
    ↓                            │
  Validation Tests ──────────────┘
    - Finite patch test
    - Cyclic patch test
    - Feature flag test
    ↓
Sprint 2 (NEXT):
  Default Sources
  Block Lowering
```

**No blocking dependencies between Sprint 1 items** - both can be implemented in parallel.

---

## Validation Plan

### Pre-Implementation Checks

**Before starting work:**
- [ ] Verify Sprint 0 deliverables are committed (commits 72874c3, 857d3a4)
- [ ] Run `just test` - confirm 126/128 files pass
- [ ] Run `just typecheck` - confirm no errors

### During Implementation

**After TimeModel Threading:**
1. TypeScript compiles without errors
2. Create test patch with FiniteTimeRoot
3. Compile in IR mode
4. Inspect `compiledProgram.ir.timeModel.kind`
5. Expected: `'finite'` (not `'infinite'`)

**After Feature Flag Fix:**
1. Set `VITE_USE_UNIFIED_COMPILER=false` in .env.local
2. Run `just dev`
3. Open browser console
4. Expected: See legacy compiler logs (not IR logs)

### Post-Implementation Tests

**Add these test files:**

1. `tests/compiler/timemodel.test.ts`
   ```typescript
   describe('TimeModel Threading', () => {
     it('compiles finite patch with finite timeModel', () => {
       // Create patch with FiniteTimeRoot(5000)
       // Compile with IR
       // Assert compiledProgram.ir.timeModel.kind === 'finite'
       // Assert compiledProgram.ir.timeModel.durationMs === 5000
     });

     it('compiles infinite patch with infinite timeModel', () => {
       // Create patch with InfiniteTimeRoot()
       // Compile with IR
       // Assert compiledProgram.ir.timeModel.kind === 'infinite'
     });
   });
   ```

2. `tests/compiler/feature-flags.test.ts`
   ```typescript
   describe('Feature Flag Parsing', () => {
     it('respects VITE_USE_UNIFIED_COMPILER=false', () => {
       // Mock env with VITE_USE_UNIFIED_COMPILER='false'
       // Call updateFeatureFlags()
       // Assert getFeatureFlags().useUnifiedCompiler === false
     });

     it('respects VITE_USE_UNIFIED_COMPILER=true', () => {
       // Mock env with VITE_USE_UNIFIED_COMPILER='true'
       // Call updateFeatureFlags()
       // Assert getFeatureFlags().useUnifiedCompiler === true
     });
   });
   ```

### Runtime Validation (Chrome DevTools MCP)

**Use Chrome DevTools to verify behavior:**

1. Create patch with `FiniteTimeRoot(durationMs: 5000)`
2. Add simple render block (e.g., `Render2dCanvas`)
3. Compile and run
4. Observe player behavior:
   - Progress should go 0→1 over 5 seconds
   - Playback should stop at 5 seconds (not loop)
   - Scrubbing should respect duration boundary

5. Observe looping behavior works through InfiniteTimeRoot

**Acceptance:** Player behavior matches TimeRoot type, not always infinite

---

## Risk Assessment

### Low Risk (Both Items)

**TimeModel Threading:**
- **Complexity:** Low - mechanical data threading
- **Blast Radius:** Isolated to compiler passes
- **Rollback:** Easy - revert commits
- **Validation:** Clear pass/fail criteria

**Feature Flag Fix:**
- **Complexity:** Trivial - one-line change
- **Blast Radius:** Minimal - only affects flag parsing
- **Rollback:** Instant - revert commit
- **Validation:** Boolean test

### Mitigation Strategy

**If TimeModel Threading breaks tests:**
1. Check if TimeRoot compilers are calling `setTimeModel()`
2. Verify Pass 6 is threading timeModel from input
3. Inspect IRBuilderImpl instance state before `build()`
4. Add debug logging to trace timeModel value

**If Feature Flag Fix causes issues:**
1. Verify Vite env variable parsing is consistent
2. Check if other flags (VITE_STRICT_STATE_VALIDATION) still work
3. Test in both dev and production builds

---

## Sprint Success Criteria

**Definition of Done for Sprint 1:**

### Must Have (P0)
- [x] TimeModel threading implemented
- [x] All TimeRoot types compile with correct timeModel
- [x] Tests verify finite/cyclic/infinite behavior
- [x] TypeScript compilation passes
- [x] Test suite remains stable (≥126/128 files pass)

### Should Have (P1)
- [x] Feature flag parsing fixed
- [x] Tests verify `=false` and `=true` handling
- [x] Dev workflow supports toggling compiler modes

### Quality Gates
- [x] No new TypeScript errors
- [x] No new test failures (beyond existing 4)
- [x] Code review by maintainer (if applicable)
- [x] Documentation updated (if needed)

**Sprint is INCOMPLETE if:**
- Any P0 item is not shipped
- Test suite regresses (pass rate drops below 98%)
- TypeScript compilation fails
- TimeModel still hardcoded to infinite

---

## Deferred Items (Explicitly Out of Scope)

**These were in original STATUS red flags but are NOT Sprint 1:**

### Sprint 2 (Default Sources & Block Lowering)
- Default source lowering (Pass 8 enhancement)
- Block lowering for signal math blocks
- Block lowering for field operations
- ColorLFO HSL→RGB kernel
- SVGSampleDomain initialization

### Sprint 3 (Bus System)
- Bus evaluation step implementation
- Event bus lowering design
- Bus type support (vec2, color)
- Publisher transform chains

### Sprint 4+ (Type System)
- Type conversion path computation
- Field transform chains
- Field reduce implementation
- Type system unification

---

## Blockers and Questions

**None Identified.**

All Sprint 1 items have:
- Clear implementation paths
- No external dependencies
- Unambiguous acceptance criteria
- Low technical risk

**Safe to proceed without user clarification.**

---

## References

**Source Files:**
- `/Users/bmf/code/oscilla-animator_codex/src/editor/compiler/ir/IRBuilderImpl.ts:640` - hardcoded timeModel
- `/Users/bmf/code/oscilla-animator_codex/src/editor/compiler/passes/pass3-time.ts:220` - timeModel extraction
- `/Users/bmf/code/oscilla-animator_codex/src/editor/compiler/featureFlags.ts:121` - feature flag bug

**Status Files:**
- `.agent_planning/compiler-audit-redflag/STATUS-2025-12-28-sprint1.md`
- `.agent_planning/compiler-audit-redflag/STATUS-2025-12-28.md`

**Design Docs:**
- `design-docs/12-Compiler-Final/Compiler-Audit-RedFlags-Time-Architecture.md`
- `design-docs/12-Compiler-Final/Compiler-Audit-RedFlags-Core.md`
- `design-docs/12-Compiler-Final/Compiler-Audit-RedFlags-Schedule-and-Runtime.md`

---

## Estimated Timeline

**Day 1:**
- Morning: Implement TimeModel threading (4 hours)
- Afternoon: Fix feature flag parsing + write tests (2 hours)
- End of day: Run test suite, verify no regressions

**Day 2:**
- Morning: Add TimeModel validation tests (2 hours)
- Afternoon: Runtime validation with Chrome DevTools (2 hours)
- End of day: Sprint retrospective, prepare Sprint 2 planning

**Total Sprint Duration:** 2 days

---

**Plan Complete - Ready for Implementation**
