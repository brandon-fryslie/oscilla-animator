# Sprint 2 Implementation Plan: Block Lowering Foundation

**Generated:** 2025-12-28-152613
**Source STATUS:** STATUS-2025-12-28-sprint1.md
**Sprint Goal:** Real block semantics in IR
**Estimated Duration:** 2 weeks

---

## Executive Summary

Sprint 2 moves the IR compiler from placeholder skeleton nodes to real block semantics. After Sprint 0 (test infrastructure) and Sprint 1 (time model threading + feature flags), the IR compiler can now execute simple patches correctly. Sprint 2 focuses on making **core signal blocks** produce correct outputs through proper IR lowering, implementing **default source resolution**, adding the **ColorLFO HSL→RGB kernel**, and fixing **SVGSampleDomain runtime initialization**.

**Current State (Post-Sprint 1):**
- ✅ Test infrastructure functional (126/128 files pass)
- ✅ IR compilation mandatory (no fallback)
- ✅ TimeModel correctly threaded from Pass 3
- ✅ Feature flags parse correctly
- ❌ Block lowering uses placeholders (sigTimeAbsMs, fieldConst(0))
- ❌ Default sources not lowered
- ❌ ColorLFO throws error (missing HSL→RGB)
- ❌ SVGSampleDomain missing runtime initialization

**Post-Sprint 2 State:**
- ✅ Core signal math blocks (Add, Sub, Mul, Div, Min, Max, Clamp) produce correct IR
- ✅ Oscillator/LFO blocks produce correct signal expressions
- ✅ Default inputs wire correctly when not connected
- ✅ ColorLFO emits proper color signals
- ✅ SVGSampleDomain domains initialize at runtime
- ❌ Buses still not evaluated (Sprint 3)
- ❌ Events still placeholders (Sprint 3)
- ❌ Complex field operations still partial (Sprint 4)

---

## Dependencies and Prerequisites

### ✅ Completed (Unblocks Sprint 2)
- Sprint 0: Block registry capability propagation fixed
- Sprint 1: TimeModel threading, IR mandatory, feature flags

### External Dependencies
None - Sprint 2 work is self-contained within the compiler.

### Assumptions
1. **Incremental Migration Strategy:** Continue placeholder approach for unlowered blocks, migrate block-by-block (per STATUS-2025-12-28.md Ambiguity #1, Option A)
2. **DebugDisplay Deferred:** Keep DebugDisplay legacy-only, block in IR mode (decision deferred to future sprint)
3. **Type System Unification Deferred:** Continue with dual TypeDesc systems, unify incrementally (STATUS-2025-12-28.md Ambiguity #4, Option C)

---

## Work Items by Priority

---

## P0 (Critical) - Core Block Lowering

### P0-1: Implement IR Lowering for Core Signal Math Blocks

**Status:** Not Started
**Effort:** Medium (3-5 days)
**Dependencies:** None
**Spec Reference:** Compiler-Audit-RedFlags-Blocks.md • Compiler-Audit-RedFlags-Passes.md "Pass 6 emits placeholder IR"
**Status Reference:** STATUS-2025-12-28.md lines 163-177, STATUS-2025-12-28-sprint1.md lines 366-378

#### Description

Pass 6 currently emits placeholder IR nodes (`sigTimeAbsMs` for signals, `fieldConst(0)` for fields). Core signal math blocks have `lower` functions defined but many still produce generic placeholders rather than actual operation semantics.

**Blocks to Lower (8 total):**
1. **AddSignal** - ALREADY DONE (lines 18-34 of AddSignal.ts show proper lowering)
2. **SubSignal** - Need to verify/implement
3. **MulSignal** - Need to verify/implement
4. **DivSignal** - Need to verify/implement
5. **MinSignal** - Need to verify/implement
6. **MaxSignal** - Need to verify/implement
7. **ClampSignal** - Need to verify/implement
8. **Oscillator** - Need to verify/implement (sine/tri/saw/square)

**Pattern (from AddSignal.ts):**
```typescript
const lowerAddSignal: BlockLowerFn = ({ ctx, inputs }) => {
  const [a, b] = inputs;
  if (a.k !== 'sig' || b.k !== 'sig') {
    throw new Error('AddSignal requires signal inputs');
  }
  const outType = { world: 'signal', domain: 'number' };
  const sigId = ctx.b.sigZip(a.id, b.id, {
    fnId: 'add',
    opcode: OpCode.Add,
    outputType: outType,
  });
  const slot = ctx.b.allocValueSlot();
  return { outputs: [{ k: 'sig', id: sigId, slot }] };
};
```

**Implementation Steps:**
1. Read each block file in `src/editor/compiler/blocks/signal/`
2. Check if `lower` function exists and is implemented
3. If placeholder/TODO, implement proper lowering using OpCode
4. Verify OpCode exists in `src/editor/compiler/ir/opcodes.ts`
5. Add unit test for each block's IR lowering
6. Run `just test` to verify no regressions

#### Acceptance Criteria
- [ ] All 8 core signal math blocks have `lower` functions that emit proper IR nodes (not placeholders)
- [ ] Each block's `lower` function uses correct OpCode (Add, Sub, Mul, Div, Min, Max, Clamp, Sin/Tri/Saw/Square)
- [ ] Unit tests exist for each block's IR lowering path
- [ ] Test suite passes (`just test`)
- [ ] TypeScript compiles without errors (`just typecheck`)
- [ ] Simple patch using these blocks compiles to IR and produces correct output values

#### Technical Notes

**OpCodes Needed:**
- OpCode.Add, Sub, Mul, Div (arithmetic)
- OpCode.Min, Max (comparison)
- OpCode.Clamp (needs min/max bounds)
- OpCode.Sin, Tri, Saw, Square (waveforms for Oscillator)

**Oscillator Special Case:**
The Oscillator block produces different waveforms based on config. The `lower` function should read `config.waveform` and emit the appropriate OpCode.

**Error Handling:**
Each `lower` function should validate input types and throw clear errors:
```typescript
if (input.k !== 'sig') {
  throw new Error(`${BlockType}: expected sig input, got ${input.k}`);
}
```

**Slot Allocation:**
Always allocate a value slot for the output signal:
```typescript
const slot = ctx.b.allocValueSlot();
return { outputs: [{ k: 'sig', id: sigId, slot }] };
```

---

### P0-2: Implement Default Source Lowering in Pass 8

**Status:** Not Started
**Effort:** Medium (3-4 days)
**Dependencies:** None
**Spec Reference:** Compiler-Audit-RedFlags-Passes.md "Default sources are not lowered"
**Status Reference:** STATUS-2025-12-28.md lines 175-181

#### Description

Pass 8 (link resolution) currently only records errors for missing inputs but doesn't wire default sources. When a block input has no wire connection and no bus listener, it should fall back to the `defaultSource` specified in the block definition.

**Current Code (pass8-link-resolution.ts:258-299):**
```typescript
// Resolution priority:
// 1. Wire connection (direct block-to-block)
// 2. Bus listener (bus → input)
// 3. Default source (fallback - for Sprint 2, we'll use placeholder)
```

The TODO comment indicates default sources are not implemented.

**Default Source Mechanism:**
Block definitions can specify default input values:
```typescript
// Example from ColorLFO.ts:
inputs: [
  { name: 'phase', type: { kind: 'Signal:phase' }, required: true },
  { name: 'base', type: { kind: 'Scalar:color' }, required: false }, // Has default
  { name: 'hueSpan', type: { kind: 'Scalar:number' }, required: false }, // Has default
]
```

When `required: false`, the block definition should provide a default value.

**Implementation Strategy:**

1. **Extend BlockDefinition Interface:**
   Add `defaultSource` field to input port definitions in `src/editor/compiler/ir/lowerTypes.ts`:
   ```typescript
   interface InputPort {
     portId: string;
     label: string;
     dir: 'in';
     type: TypeDesc;
     defaultSource?: Artifact; // Default value if not connected
   }
   ```

2. **Update Block Registrations:**
   For blocks with optional inputs, specify default sources:
   ```typescript
   registerBlockType({
     type: 'ColorLFO',
     inputs: [
       { portId: 'phase', type: {...}, required: true },
       {
         portId: 'base',
         type: { world: 'signal', domain: 'color' },
         defaultSource: { kind: 'Scalar:color', value: '#3B82F6' }
       },
     ],
     // ...
   });
   ```

3. **Implement Default Source Lowering in Pass 8:**
   In `buildBlockInputRoots()`, after checking wires and bus listeners:
   ```typescript
   // 3. Default source (fallback)
   if (!inputRef) {
     const blockDef = BLOCK_DEFS_BY_TYPE.get(block.type);
     const inputPort = blockDef?.inputs.find(i => i.portId === input.id);
     if (inputPort?.defaultSource) {
       // Lower the default artifact to IR
       const defaultRef = artifactToValueRef(
         inputPort.defaultSource,
         builder,
         block.id,
         input.id
       );
       if (defaultRef) {
         inputRef = defaultRef;
       }
     }
   }
   ```

4. **Handle Missing Required Inputs:**
   If no wire, no bus listener, and no default source, record compile error:
   ```typescript
   if (!inputRef && inputPort?.required) {
     errors.push({
       code: 'MissingRequiredInput',
       message: `Block ${block.id} input ${input.id} is required but not connected`,
       where: { blockId: block.id, inputId: input.id },
     });
   }
   ```

#### Acceptance Criteria
- [ ] `BlockDefinition` interface includes `defaultSource?: Artifact` field on input ports
- [ ] All blocks with optional inputs register default sources in `registerBlockType()` calls
- [ ] Pass 8 `buildBlockInputRoots()` function checks for default sources after wires/buses
- [ ] Default sources are lowered to IR using `artifactToValueRef()`
- [ ] Patches with unconnected optional inputs compile without errors
- [ ] Runtime executor receives correct default values for unconnected inputs
- [ ] Unit test verifies default source lowering (create patch with unconnected ColorLFO inputs)
- [ ] Test suite passes (`just test`)

#### Technical Notes

**Artifact-to-IR Translation:**
Reuse the `artifactToValueRef()` helper from Pass 6:
- Scalar → `sigConst(value, type)`
- Signal → Lower to proper signal expression
- Field → Lower to proper field expression

**Common Default Values:**
- Colors: `'#3B82F6'` (blue), `'#FFFFFF'` (white)
- Numbers: `0`, `1.0`, `360` (hue span)
- Vec2: `{ x: 0, y: 0 }`
- Booleans: `false`

**Edge Cases:**
- Default source has wrong type → Compile error
- Default source is complex (requires dependencies) → For Sprint 2, only support scalar defaults
- Block definition missing default for optional input → Use zero/null fallback

---

## P1 (High) - Color and Domain Support

### P1-1: Implement ColorLFO HSL→RGB Kernel

**Status:** Not Started
**Effort:** Small (1-2 days)
**Dependencies:** P0-1 (Core Block Lowering infrastructure)
**Spec Reference:** Compiler-Audit-RedFlags-Blocks.md "ColorLFO is not IR-ready (missing HSL→RGB)"
**Status Reference:** STATUS-2025-12-28.md lines 282-288

#### Description

ColorLFO block currently throws an error in IR lowering because the HSL→RGB color conversion requires a kernel function that doesn't exist yet. The block has all the HSL→RGB math implemented in the legacy closure compiler (lines 18-90 of ColorLFO.ts), but the IR path needs a kernel opcode.

**Current Error (ColorLFO.ts:160):**
```typescript
throw new Error('ColorLFO IR lowering requires ColorHSLToRGB opcode which is not yet implemented in the evaluator...');
```

**Implementation Options:**

**Option A: Add OpCode.ColorHSLToRGB Kernel**
1. Define new opcode in `src/editor/compiler/ir/opcodes.ts`:
   ```typescript
   ColorHSLToRGB = 'ColorHSLToRGB',
   ```
2. Implement kernel in executor/evaluator
3. Use in ColorLFO lowering:
   ```typescript
   const rgb = ctx.b.sigMap(hslColor, {
     fnId: 'colorHSLToRGB',
     opcode: OpCode.ColorHSLToRGB,
     outputType: colorType,
   });
   ```

**Option B: Build HSL→RGB as IR Node Composition**
Decompose the piecewise HSL→RGB function into existing opcodes (Add, Mul, Clamp, conditionals). More complex but doesn't require new kernel.

**Recommendation:** Option A (new kernel) - cleaner, more maintainable, matches the ColorLFO use case.

**HSL→RGB Algorithm (from ColorLFO.ts:51-90):**
```typescript
function hslToHex(h: number, s: number, l: number): string {
  h = h % 360;
  const c = (1 - Math.abs(2 * l - 1)) * s;
  const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
  const m = l - c / 2;
  // Piecewise based on hue sector (0-60, 60-120, 120-180, etc.)
  // Returns RGB components
}
```

**Implementation Steps:**
1. Add `ColorHSLToRGB` to OpCode enum
2. Implement kernel function in executor (`src/editor/runtime/executor/kernels/color.ts` or similar)
3. Update ColorLFO lowering to use kernel:
   ```typescript
   const satSig = ctx.b.sigConst(sat, numberType);
   const lightSig = ctx.b.sigConst(light, numberType);
   const hslColor = /* construct HSL triple */;
   const rgb = ctx.b.sigMap(hslColor, {
     fnId: 'colorHSLToRGB',
     opcode: OpCode.ColorHSLToRGB,
     outputType: { world: 'signal', domain: 'color' },
   });
   return { outputs: [{ k: 'sig', id: rgb, slot }] };
   ```
4. Remove the `throw new Error()` line
5. Add unit test for ColorLFO IR lowering

#### Acceptance Criteria
- [ ] `OpCode.ColorHSLToRGB` exists in opcodes enum
- [ ] Kernel function implemented in executor/runtime (converts H,S,L inputs to RGB hex string)
- [ ] ColorLFO `lower` function uses ColorHSLToRGB kernel instead of throwing error
- [ ] Unit test verifies ColorLFO compiles to IR without errors
- [ ] Integration test verifies ColorLFO produces correct color output at runtime
- [ ] Test patch: phase=0.5 → hue shift produces expected color
- [ ] TypeScript compiles (`just typecheck`)
- [ ] Test suite passes (`just test`)

#### Technical Notes

**Color Representation in IR:**
Currently, colors are represented as hex strings (`'#RRGGBB'`). The kernel should:
- Accept three number inputs: H (0-360), S (0-1), L (0-1)
- Return color hex string
- Handle hue wrapping (h % 360)

**Kernel Signature:**
```typescript
function colorHSLToRGB(h: number, s: number, l: number): string {
  // Implementation from ColorLFO.ts lines 51-90
}
```

**Testing Strategy:**
1. Unit test: `colorHSLToRGB(240, 0.8, 0.5)` → `'#1966e6'` (blue)
2. Integration test: Patch with ColorLFO connected to phase signal
3. Runtime verification: Scrub time slider, verify color changes

---

### P1-2: Fix SVGSampleDomain Runtime Initialization

**Status:** Not Started
**Effort:** Small (1 day)
**Dependencies:** None
**Spec Reference:** Compiler-Audit-RedFlags-Blocks.md "SVG domains may be missing runtime initialization"
**Status Reference:** STATUS-2025-12-28.md lines 295-298

#### Description

SVGSampleDomain's IR lowering calls `domainFromSVG()` but the IRBuilder doesn't register the domain for runtime initialization. This means the domain slot never gets initialized, leading to invalid domain counts and empty materializations.

**Current Code (IRBuilderImpl.ts:587-591):**
```typescript
domainFromSVG(_svgRef: string, _sampleCount: number): ValueSlot {
  // Allocate a value slot for the domain
  // The actual SVG sampling will be handled by the runtime
  const slot = this.allocValueSlot();
  // NOTE: Missing registration in this.domains array
  return slot;
}
```

**Compare with domainFromN (IRBuilderImpl.ts:577-585):**
```typescript
domainFromN(n: number): ValueSlot {
  const slot = this.allocValueSlot();
  // Track the domain definition for runtime initialization
  this.domains.push({ slot, count: n });
  return slot;
}
```

**Fix Required:**
Register the domain in `this.domains` array so the runtime can initialize it:

```typescript
domainFromSVG(svgRef: string, sampleCount: number): ValueSlot {
  const slot = this.allocValueSlot();

  // Register domain for runtime initialization
  this.domains.push({
    slot,
    count: sampleCount,
    svgPath: svgRef, // Store SVG path for runtime sampling
  });

  return slot;
}
```

**Runtime Side:**
Ensure the executor/runtime reads `svgPath` from domain definition and performs SVG sampling during initialization. May need to update `DomainDefinition` type to include optional `svgPath` field.

#### Acceptance Criteria
- [ ] `domainFromSVG()` registers domain in `this.domains` array
- [ ] `DomainDefinition` type includes optional `svgPath?: string` field
- [ ] Runtime executor initializes SVG domains with correct element count
- [ ] Unit test verifies SVGSampleDomain produces valid domain slot
- [ ] Integration test: Patch with SVGSampleDomain → render instances
- [ ] Domain count matches sampleCount parameter
- [ ] Test suite passes (`just test`)

#### Technical Notes

**DomainDefinition Interface:**
```typescript
interface DomainDefinition {
  slot: ValueSlot;
  count: number;
  svgPath?: string; // Optional: for SVG domains
}
```

**Runtime Initialization:**
In `src/editor/runtime/executor/` (domain initialization step):
```typescript
for (const domain of domains) {
  if (domain.svgPath) {
    // Sample SVG to get element count
    const elements = sampleSVGPath(domain.svgPath, domain.count, 'even');
    runtime.values.write(domain.slot, { count: elements.length });
  } else {
    // Regular domain from N
    runtime.values.write(domain.slot, { count: domain.count });
  }
}
```

**Edge Cases:**
- Invalid SVG path → Fall back to count-based domain
- sampleCount = 0 → Use 1 as minimum
- Missing svgPath → Treat as regular domain

---

## P2 (Medium) - Testing and Validation

### P2-1: Add Block Lowering Coverage Tests

**Status:** Not Started
**Effort:** Small (1-2 days)
**Dependencies:** P0-1, P1-1, P1-2
**Spec Reference:** STATUS-2025-12-28.md "Missing Checks" section
**Status Reference:** STATUS-2025-12-28.md lines 516-535

#### Description

Create comprehensive tests that verify block lowering coverage and correctness. These tests serve as regression prevention and documentation of what's IR-ready.

**Test Files to Create:**

1. **`tests/compiler/block-lowering.test.ts`** - Coverage tracking
2. **`tests/compiler/signal-math.test.ts`** - Signal math block integration
3. **`tests/compiler/color-blocks.test.ts`** - Color block integration
4. **`tests/compiler/domain-blocks.test.ts`** - Domain block integration

**Coverage Test Structure:**
```typescript
describe('Block Lowering Coverage', () => {
  it('tracks which blocks are IR-ready', () => {
    const irReadyBlocks = [
      'AddSignal', 'SubSignal', 'MulSignal', 'DivSignal',
      'MinSignal', 'MaxSignal', 'ClampSignal',
      'Oscillator', 'ColorLFO',
      'SVGSampleDomain', 'DomainN', 'GridDomain',
    ];

    for (const blockType of irReadyBlocks) {
      const blockDef = BLOCK_DEFS_BY_TYPE.get(blockType);
      expect(blockDef).toBeDefined();
      expect(blockDef.lower).toBeDefined();
      // Verify lowering doesn't throw
      // ...
    }
  });

  it('documents blocks that are legacy-only', () => {
    const legacyOnlyBlocks = [
      'DebugDisplay', // Cannot be lowered (side-effect node)
      // ... others ...
    ];

    for (const blockType of legacyOnlyBlocks) {
      // Verify these blocks throw or are not registered
    }
  });
});
```

**Integration Test Structure:**
```typescript
describe('Signal Math Block IR Integration', () => {
  it('AddSignal produces correct sum', () => {
    // Create patch: Const(2) + Const(3) → should equal 5
    const patch = createTestPatch([
      { type: 'ConstSignal', config: { value: 2 } },
      { type: 'ConstSignal', config: { value: 3 } },
      { type: 'AddSignal' },
    ]);

    const compiled = compilePatch(patch);
    expect(compiled.ok).toBe(true);

    const result = executeAtTime(compiled.program, 0);
    expect(result.signals.get('add-out')).toBe(5);
  });

  // Similar tests for Sub, Mul, Div, Min, Max, Clamp
});
```

#### Acceptance Criteria
- [ ] Coverage test lists all IR-ready blocks and verifies their `lower` functions exist
- [ ] Coverage test documents legacy-only blocks and verifies they're excluded from IR
- [ ] Integration tests verify arithmetic correctness for all signal math blocks
- [ ] Integration test verifies ColorLFO produces correct color at various phase values
- [ ] Integration test verifies SVGSampleDomain produces valid domain with expected count
- [ ] All tests pass (`just test`)
- [ ] Coverage metric: >80% of commonly-used blocks are IR-ready

#### Technical Notes

**Test Utilities:**
Create helpers in `tests/helpers/compiler-test-utils.ts`:
```typescript
export function createTestPatch(blocks: BlockConfig[]): Patch { ... }
export function compilePatch(patch: Patch): CompileResult { ... }
export function executeAtTime(program: CompiledProgram, t: number): RuntimeState { ... }
```

**Golden Values:**
For ColorLFO, document expected outputs:
```typescript
const colorTests = [
  { phase: 0.0, hueSpan: 180, expected: '#3B82F6' }, // base color
  { phase: 0.5, hueSpan: 180, expected: '#...' },    // +90 deg hue
  { phase: 1.0, hueSpan: 180, expected: '#...' },    // +180 deg hue
];
```

---

## Sprint 2 Scope Summary

### Must Have (Blockers for Sprint 3)
1. ✅ Core signal math blocks lowered (P0-1)
2. ✅ Default source lowering (P0-2)
3. ✅ ColorLFO HSL→RGB (P1-1)
4. ✅ SVGSampleDomain initialization (P1-2)

### Should Have (Quality)
5. ✅ Block lowering coverage tests (P2-1)

### Out of Scope (Deferred)
- ❌ Bus evaluation (Sprint 3)
- ❌ Event bus lowering (Sprint 3)
- ❌ Field transform chains (Sprint 4)
- ❌ Type conversion paths (Sprint 4)
- ❌ Complex field operations (Sprint 4)

---

## Validation Criteria

**At Sprint 2 completion, the following MUST work:**

### Test 1: Simple Signal Math Patch
```
Patch: Const(10) → Mul(2) → Add(5) → out
Expected: out = 25 at all times
```

### Test 2: Oscillator Animation
```
Patch: FiniteTimeRoot(5000ms) → phase → Oscillator(sine) → out
Expected: out = sin(phase * 2π), smooth oscillation over 5 seconds
```

### Test 3: Color Animation with Defaults
```
Patch: CycleTimeRoot(2000ms) → phase → ColorLFO(base=#FF0000) → out
Expected: out cycles red through color wheel, using default hueSpan=180
```

### Test 4: SVG Domain Rendering
```
Patch: SVGSampleDomain(path="M 0 0 L 100 100", count=50) → domain → RenderInstances → canvas
Expected: 50 instances rendered along diagonal line
```

### Test 5: Combined Patch
```
Patch: TimeRoot → phase → [Oscillator, ColorLFO] → [position, color] → RenderInstances
Expected: Animated instances with oscillating positions and cycling colors
```

---

## Risk Assessment

### Low Risk
- **Core signal math lowering** - Pattern is well-established (AddSignal.ts), mechanical replication
- **SVGSampleDomain fix** - One-line registration, clear pattern from domainFromN

### Medium Risk
- **Default source lowering** - Touches multiple systems (BlockDefinition, Pass 8, artifact lowering), potential edge cases
- **ColorLFO kernel** - Requires new opcode + executor implementation, color math complexity

### High Risk
None identified for Sprint 2 scope.

### Mitigation Strategies
1. **Incremental Development:** Implement one block at a time, run tests after each
2. **Early Integration Testing:** Test default sources with simple scalar values first, expand to complex cases
3. **Color Verification:** Use visual inspection in browser + Chrome DevTools MCP to verify ColorLFO output
4. **Rollback Plan:** If ColorLFO kernel proves complex, defer to Sprint 3 and keep legacy-only

---

## Success Metrics

**Quantitative:**
- [ ] 8/8 core signal math blocks have proper IR lowering
- [ ] 100% of blocks with optional inputs support default sources
- [ ] 1/1 color blocks (ColorLFO) IR-ready
- [ ] 1/1 SVG domain blocks (SVGSampleDomain) IR-ready
- [ ] Test suite: 128/128 files pass (up from 126/128)
- [ ] >20 new integration tests added

**Qualitative:**
- [ ] Patches using signal math compile to IR and produce correct outputs
- [ ] Unconnected optional inputs work (default sources resolve)
- [ ] Color animations play smoothly in IR-only mode
- [ ] SVG-based domains render correctly

---

## Post-Sprint 2 Capabilities

**What Works:**
- Time topology (finite/cyclic/infinite) ✅
- Core signal math (add, sub, mul, div, min, max, clamp) ✅
- Oscillators (sine, tri, saw, square) ✅
- Color generation (ColorLFO) ✅
- Default input resolution ✅
- SVG domain initialization ✅

**What Doesn't Work (Known Gaps):**
- Bus-driven graphs (no busEval steps) ❌
- Event buses (pulse, wrap) ❌
- Field transform chains (adapters, lenses) ❌
- Type conversions (signal→field broadcast) ❌
- Complex field operations (reduce, zip) ❌

**Readiness for Sprint 3:**
After Sprint 2, the foundation is solid for bus system implementation. Simple signal-driven patches work end-to-end, providing a stable base for adding bus evaluation and event handling.

---

## Implementation Sequence

**Week 1:**
- Day 1-2: P0-1 (Core signal math blocks)
- Day 3: P1-2 (SVGSampleDomain fix) - Quick win
- Day 4-5: P0-2 (Default source lowering)

**Week 2:**
- Day 1-2: P1-1 (ColorLFO kernel)
- Day 3-4: P2-1 (Testing and validation)
- Day 5: Integration testing, bug fixes, documentation updates

**Daily Workflow:**
1. Implement feature/fix
2. Run `just typecheck` (ensure no TS errors)
3. Run `just test` (ensure no regressions)
4. Run `just dev` + manual testing in browser
5. Commit with clear message
6. Update STATUS-SPRINT2.md with progress

---

## Files to Modify

**New Files:**
- `src/editor/runtime/executor/kernels/color.ts` (ColorHSLToRGB kernel)
- `tests/compiler/block-lowering.test.ts`
- `tests/compiler/signal-math.test.ts`
- `tests/compiler/color-blocks.test.ts`
- `tests/compiler/domain-blocks.test.ts`
- `tests/helpers/compiler-test-utils.ts`

**Modified Files:**
- `src/editor/compiler/blocks/signal/SubSignal.ts` (verify lowering)
- `src/editor/compiler/blocks/signal/MulSignal.ts` (verify lowering)
- `src/editor/compiler/blocks/signal/DivSignal.ts` (verify lowering)
- `src/editor/compiler/blocks/signal/MinSignal.ts` (verify lowering)
- `src/editor/compiler/blocks/signal/MaxSignal.ts` (verify lowering)
- `src/editor/compiler/blocks/signal/ClampSignal.ts` (verify lowering)
- `src/editor/compiler/blocks/signal/Oscillator.ts` (verify lowering)
- `src/editor/compiler/blocks/signal/ColorLFO.ts` (add kernel, remove throw)
- `src/editor/compiler/blocks/domain/SVGSampleDomain.ts` (already done, verify)
- `src/editor/compiler/ir/IRBuilderImpl.ts` (fix domainFromSVG)
- `src/editor/compiler/ir/opcodes.ts` (add ColorHSLToRGB)
- `src/editor/compiler/ir/lowerTypes.ts` (add defaultSource to InputPort)
- `src/editor/compiler/passes/pass8-link-resolution.ts` (implement default source lowering)
- `src/editor/runtime/executor/kernels/` (add color kernel)

---

## Questions for User (If Any)

None at this time. All Sprint 2 scope is well-defined from red flags documentation and STATUS reports. If ColorLFO kernel implementation proves unexpectedly complex, will raise flag and propose deferral to Sprint 3.

---

**End of Sprint 2 Plan**
