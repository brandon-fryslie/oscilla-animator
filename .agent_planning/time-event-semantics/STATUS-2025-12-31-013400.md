# Status Report - Time + Event Semantics Workstream
**Timestamp:** 2025-12-31-013400
**Scope:** project/time-event-semantics
**Confidence:** FRESH (just evaluated)
**Branch:** ir-backlog-02-time-event
**Git Commit:** 455d9be

---

## Executive Summary

**Overall Completion:** ~60% complete | **Critical Gaps:** 3 | **Test Quality:** 3/5
**Workflow Recommendation:** **CONTINUE** - Gaps are clear, implementation can proceed

### Deliverables Status
| Deliverable | Status | Evidence |
|------------|--------|----------|
| 1. TimeRoot is authoritative | ‚úÖ COMPLETE | pass3-time.ts:158-213 |
| 2. wrapEvent is discrete trigger | ‚ùå INCOMPLETE | No EventStore, using numeric signals |
| 3. Scrubbing without phantom events | ‚ö†Ô∏è PARTIAL | Detection works, no suppression mechanism |

---

## Evaluation Reuse Summary
- **Carried forward:** 0 RECENT findings (no previous evaluations)
- **Spot-checked:** 0 RISKY findings
- **Re-evaluated:** 0 STALE findings
- **Fresh evaluation:** All findings are new

---

## Runtime Check Results

| Check | Status | Output |
|-------|--------|--------|
| `just test` | ‚ùå FAIL | TypeScript compilation errors in state-offset-resolution.test.ts |
| `just build` | Not run | Blocked by test failures |
| `just check` | Not run | Blocked by test failures |

### Test Failures (BLOCKER)

**Location:** `src/editor/compiler/ir/__tests__/state-offset-resolution.test.ts`

6 test files have TypeScript errors:
- Lines 84, 143, 206, 249, 307, 371
- Error: Missing `debugProbes` property in test mock objects
- Type: `BuilderProgramIR` requires `debugProbes: DebugProbeIR[]`

**Impact:** Cannot verify runtime behavior until tests pass.

**Fix Required:** Add `debugProbes: []` to all mock BuilderProgramIR objects in test files.

---

## Plan Deliverable Assessment

### ‚úÖ Deliverable 1: TimeRoot is Authoritative (COMPLETE)

**Status:** COMPLETE
**Confidence:** FRESH
**Evidence:** `src/editor/compiler/passes/pass3-time.ts:158-213`

#### What Exists
1. **TimeRoot extraction is mandatory** (lines 164-189)
   - Throws `MissingTimeRoot` if no TimeRoot exists
   - Throws `MultipleTimeRoots` if >1 exists
   - Exactly one TimeRoot enforced at compile time ‚úÖ

2. **TimeModel correctly extracted** (lines 74-100)
   - `FiniteTimeRoot` ‚Üí `{ kind: "finite", durationMs }`
   - `InfiniteTimeRoot` ‚Üí `{ kind: "cyclic", periodMs, mode }` ‚ö†Ô∏è
   - Note: InfiniteTimeRoot currently emits **cyclic**, not infinite (line 85 comment)

3. **TimeModel threaded through compiler** (line 209)
   - Pass3 output includes `timeModel: TimeModelIR`
   - Carried into Pass4/Pass5/Pass6 via `TimeResolvedPatch`

4. **Canonical time signals generated** (lines 123-148)
   - `tAbsMs`, `tModelMs` always generated
   - Cyclic models add `phase01`, `wrapEvent`
   - Signals created via IRBuilder methods

#### ‚ö†Ô∏è Red Flag: InfiniteTimeRoot Naming Confusion

**Location:** `src/editor/compiler/passes/pass3-time.ts:85-96`

```typescript
if (timeRoot.type === "InfiniteTimeRoot") {
  // NEEDS REVIEW - DEPRECATED: InfiniteTimeRoot currently emits cyclic TimeModel.
  const periodMs = extractParamValue(timeRoot, "periodMs", 3000) as number;
  const mode = extractParamValue(timeRoot, "mode", "loop") as "loop" | "pingpong";
  return {
    kind: "cyclic",
    periodMs,
    mode,
    phaseDomain: "0..1",
  };
}
```

**Issue:** Block named "InfiniteTimeRoot" produces **cyclic** time, not infinite.

**Question for User:** Is this intentional or a naming bug? Should there be a true "infinite" time model, or should InfiniteTimeRoot be renamed to CyclicTimeRoot?

---

### ‚ùå Deliverable 2: wrapEvent is Discrete Trigger (INCOMPLETE)

**Status:** INCOMPLETE - 40% complete
**Confidence:** FRESH
**Evidence:** No EventStore implementation found

#### What Exists

1. **Wrap detection uses real frame deltas** ‚úÖ
   **Location:** `src/editor/runtime/executor/timeResolution.ts:92-181`

   - TimeState tracks `prevTModelMs` (line 54-56)
   - Wrap detection compares actual previous tModelMs (lines 121-127)
   - Works correctly for variable frame rates ‚úÖ
   - Loop mode: wrap when `tModelMs < prevTModelMs` (line 124)
   - Ping-pong mode: wrap when cycle count changes (lines 143-148)

2. **TimeState persisted across frames** ‚úÖ
   **Location:** `src/editor/runtime/executor/RuntimeState.ts:63-64`

   - `timeState: TimeState` stored in RuntimeState
   - Created via `createTimeState()` (line 613)
   - Preserved during hot-swap (line 655)
   - Passed to `resolveTime()` in ScheduleExecutor (line 108)

3. **wrapEvent written to ValueStore** ‚ö†Ô∏è
   **Location:** `src/editor/runtime/executor/steps/executeTimeDerive.ts:65-69`

   - wrapEvent written as **numeric value** (0.0 or 1.0)
   - Written to `step.out.wrapEvent` slot
   - No distinction from continuous signals

#### What's Missing (CRITICAL)

1. **No EventStore implementation**
   **Expected Location:** `src/editor/runtime/executor/EventStore.ts` (does not exist)

   - Searched for "EventStore" class/interface: **0 results**
   - Events stored in ValueStore (numeric values), not discrete store
   - Per plan: need separate EventStore with trigger/check/reset semantics

2. **No event-specific semantics**
   - wrapEvent is indistinguishable from continuous signals
   - Edge detection happens at wrong level (consumers must detect 0‚Üí1 transition)
   - Plan specifies: `{ triggered: boolean, payload?: {...} }`

3. **No event reset per frame**
   - Events should clear at frame start
   - Currently persists in ValueStore until overwritten

#### Implementation Gap Summary

| Plan Item | Status | Evidence |
|-----------|--------|----------|
| EventStore class | ‚ùå MISSING | No implementation found |
| Event payload support | ‚ùå MISSING | Only numeric values |
| Per-frame reset | ‚ùå MISSING | No reset mechanism |
| Discrete trigger semantics | ‚ùå MISSING | Using continuous storage |

**Recommendation:** Implement EventStore as specified in `plans/SPEC-05-time-architecture.md:278-312`.

---

### ‚ö†Ô∏è Deliverable 3: Scrubbing Without Phantom Events (PARTIAL)

**Status:** PARTIAL - 30% complete
**Confidence:** FRESH
**Evidence:** Detection logic exists, no suppression mechanism

#### What Exists

1. **Wrap detection is scrub-aware** ‚úÖ
   **Location:** `src/editor/runtime/executor/timeResolution.ts:121-127`

   - Comment explicitly mentions "scrubbing backwards" (line 123)
   - Detection handles non-monotonic time correctly
   - Uses previous tModelMs comparison (works for forward and backward jumps)

2. **Scrubbing infrastructure exists** ‚úÖ
   **Evidence:** grep results show extensive scrub support in unified compiler

   - `TimeCtx.mode: 'scrub' | 'performance'` (unified/TimeCtx.ts:13)
   - State blocks have `scrubPolicy` (unified/StateBlock.ts:29)
   - Policies: 'hold', 'reset', 'interpolate', 'recompute'
   - IntegrateBlock freezes accumulator during scrub ‚úÖ
   - HistoryBlock freezes buffer during scrub ‚úÖ

3. **Player has scrubTo() method** ‚úÖ
   **Location:** `src/editor/runtime/player.ts:328`

   - Public API for scrubbing
   - Used extensively in tests (grep shows 30+ usages)

#### What's Missing (HIGH PRIORITY)

1. **No scrub mode in ScheduleExecutor**
   **Location:** `src/editor/runtime/executor/ScheduleExecutor.ts:97-101`

   ```typescript
   public executeFrame(
     program: CompiledProgramIR,
     runtime: RuntimeState,
     tMs: number,  // ‚Üê No mode parameter
   ): RenderFrameIR
   ```

   - No way to signal "this is a scrub, not playback"
   - Cannot suppress wrap events during scrubbing
   - Cannot trigger stateful block scrub policies

2. **No wrap event suppression**
   **Location:** `src/editor/runtime/executor/timeResolution.ts:114-127`

   - Always emits wrapEvent when detected
   - No mode check to suppress during scrub
   - Plan specifies: "If scrub, suppress wrapEvent" (SPEC-05:358)

3. **Scrub detection not implemented**
   **Expected:** Detect large jumps or backward time

   Plan suggests (SPEC-05:352-356):
   ```typescript
   const isScrub = input.mode === "scrub" ||
                   Math.abs(deltaMs) > 1000 ||  // >1s jump
                   deltaMs < 0;                  // Backwards
   ```

   Currently: No automatic detection, no mode parameter.

#### IR vs Unified Compiler Gap

**CRITICAL FINDING:** Unified compiler has full scrub support, but IR runtime does not use it.

- Unified: TimeCtx carries mode ('scrub' | 'performance')
- IR: ScheduleExecutor has no mode concept
- Unified state blocks respect scrub policies
- IR executor has no equivalent mechanism

**Question for User:** Should IR executor adopt unified compiler's scrub semantics, or implement independently?

---

## Data Flow Verification

Traced wrapEvent from time derivation to consumer:

| Stage | File:Line | Status | Notes |
|-------|-----------|--------|-------|
| **1. Time Resolution** | timeResolution.ts:114-127 | ‚úÖ Works | Detects wrap correctly |
| **2. Write to Store** | executeTimeDerive.ts:65-69 | ‚ö†Ô∏è Wrong store | Writes to ValueStore (numeric) |
| **3. Consumer Read** | N/A | ‚ùå Untested | No test coverage for wrap consumers |
| **4. Edge Detection** | N/A | ‚ùå Missing | Consumer must implement 0‚Üí1 detection |

**Gap:** No end-to-end test verifying wrap event consumption.

---

## Test Suite Assessment

**Overall Quality:** 3/5

### Existing Tests

1. **timeResolution.test.ts** (lines 1-149)
   - ‚úÖ Tests finite, cyclic, infinite models
   - ‚úÖ Tests phase and progress computation
   - ‚ö†Ô∏è Wrap detection test is weak (line 87-93)
   - ‚ùå No multi-frame wrap detection tests
   - ‚ùå No scrubbing tests
   - ‚ùå No backward time tests

2. **IRRuntimeIntegration.test.ts** (grep results)
   - Uses `scrubTo()` extensively (30+ calls)
   - Tests scrubbing mechanics
   - ‚ùå Does not verify wrap event suppression during scrub

3. **Unified compiler scrub tests** (grep results)
   - HistoryBlock.test.ts: scrub mode behavior ‚úÖ
   - IntegrateBlock.test.ts: accumulator freeze during scrub ‚úÖ
   - EndToEnd.test.ts: deterministic scrubbing ‚úÖ
   - **IR executor has no equivalent tests**

### Test Quality Rubric

| Question | Answer | Status |
|----------|--------|--------|
| If I delete implementation and leave stubs, do tests fail? | Partially | ‚ö†Ô∏è |
| If I introduce obvious bug (always emit wrap), do tests catch it? | **NO** | ‚ùå BLIND SPOT |
| Do tests exercise real user flows end-to-end? | **NO** | ‚ùå COVERAGE GAP |
| Do tests use real systems or mock everything? | Real | ‚úÖ |
| Do tests cover error conditions users will hit? | Partially | ‚ö†Ô∏è |

### Missing Test Coverage

**Critical gaps in timeResolution.test.ts:**

1. **Multi-frame wrap detection**
   ```typescript
   // Test wrap with actual frame sequence
   it('detects wrap across multiple frames', () => {
     const state = createTimeState();
     resolveTime(900, cyclicModel, state);   // frame 1
     resolveTime(1100, cyclicModel, state);  // frame 2 - should wrap
     // Verify wrapEvent = 1.0
   });
   ```

2. **Scrubbing backward across wrap**
   ```typescript
   it('detects wrap when scrubbing backward', () => {
     const state = createTimeState();
     resolveTime(1100, cyclicModel, state);  // after wrap
     resolveTime(900, cyclicModel, state);   // scrub back before wrap
     // Verify wrapEvent behavior
   });
   ```

3. **Wrap suppression during scrub**
   ```typescript
   it('suppresses wrap event during scrub mode', () => {
     // When mode='scrub', wrapEvent should be false
   });
   ```

4. **End-to-end wrap consumption**
   - No test showing a block consuming wrapEvent
   - No test verifying edge detection works
   - No test for wrap event payload (count, deltaMs)

---

## LLM Blind Spot Findings

Checked common failure patterns:

- [x] **Pagination & Lists:** N/A (not applicable to time system)
- [x] **State & Persistence:** ‚úÖ TimeState persists correctly (verified in RuntimeState.ts:655)
- [x] **Cleanup & Resources:** ‚úÖ FrameCache.newFrame() clears buffers (RuntimeState.ts:238)
- [x] **Error Messages:** ‚ö†Ô∏è Pass3 errors are good, but no runtime wrap errors
- [x] **Edge Cases:**
  - ‚úÖ Zero duration handled (timeResolution.test.ts:130)
  - ‚úÖ Zero period handled (timeResolution.test.ts:137)
  - ‚ùå Negative time not tested
  - ‚ùå Very large time jumps (>Number.MAX_SAFE_INTEGER) not tested

---

## Ambiguities Found

| Area | Question | How LLM Guessed | Impact |
|------|----------|-----------------|--------|
| **InfiniteTimeRoot semantics** | Should InfiniteTimeRoot emit infinite or cyclic time? | Assumed cyclic (line 85 comment says "DEPRECATED") | User creates InfiniteTimeRoot expecting unbounded time, gets looping instead |
| **EventStore integration** | Where should EventStore live? Runtime or compiler IR? | Not implemented | Cannot implement discrete events without architectural decision |
| **Scrub mode plumbing** | Should IR executor use unified compiler's TimeCtx.mode? | No implementation | Unified and IR have different scrub semantics, inconsistent behavior |
| **Wrap payload** | What data should wrap event carry? (phase, count, deltaMs?) | Spec says yes (SPEC-05:283), not implemented | If consumers need payload, current numeric storage insufficient |

---

## Implementation Red Flags

### üö© Red Flag 1: Fake Completeness - wrapEvent

**Location:** `src/editor/runtime/executor/steps/executeTimeDerive.ts:65-69`

```typescript
if (step.out.wrapEvent !== undefined && time.wrapEvent !== undefined) {
  if (!written.has(step.out.wrapEvent)) {
    runtime.values.write(step.out.wrapEvent, time.wrapEvent);  // ‚Üê Numeric value
    written.add(step.out.wrapEvent);
  }
}
```

**Issue:** wrapEvent is written to ValueStore as numeric (0.0 or 1.0), not to EventStore as discrete trigger.

**Why this is fake completeness:**
- Looks like events are implemented (wrapEvent exists)
- Actually just a continuous signal pretending to be an event
- Plan explicitly requires EventStore (SPEC-05:278-312)

**Correct fix:** Implement EventStore, write to `runtime.events.trigger(slot, payload)`.

### üö© Red Flag 2: Test That Doesn't Test

**Location:** `src/editor/runtime/executor/__tests__/timeResolution.test.ts:87-93`

```typescript
it("detects wrap event (simplified test)", () => {
  // Note: Wrap detection is approximate (uses 16.67ms frame delta)
  // This is a basic sanity check - full wrap detection would need
  // multiple frames with actual deltas
  const time = resolveTime(1000, cyclicModel);
  expect(time.wrapEvent).toBeDefined();  // ‚Üê Only checks defined, not correctness
});
```

**Issue:** Comment admits test doesn't actually test wrap detection.

**Why this is worthless:**
- Only checks wrapEvent is not undefined
- Doesn't verify wrapEvent = 1.0 (triggered)
- Single-frame test can't verify multi-frame detection logic
- Comment admits "would need multiple frames with actual deltas"

**Correct fix:** Write multi-frame test with TimeState, verify wrap detection logic.

### üö© Red Flag 3: TypeScript Errors Blocking Validation

**Location:** `src/editor/compiler/ir/__tests__/state-offset-resolution.test.ts`

**Impact:** Cannot run test suite to verify time behavior.

**Why this matters:**
- Tests are currently broken (6 failures)
- Cannot verify runtime correctness
- Cannot detect regressions
- Violates CLAUDE.md rule: "Tests lie. Verify behavior with Chrome DevTools MCP"

**Resolution:** Must fix test compilation errors before claiming deliverables complete.

---

## Recommendations (Prioritized)

### Priority 1: Fix Test Compilation (BLOCKER)

**Why:** Cannot verify any behavior until tests run.

**Action:** Add `debugProbes: []` to test mocks in `state-offset-resolution.test.ts`.

**Estimated effort:** 5 minutes

### Priority 2: Clarify InfiniteTimeRoot Semantics

**Why:** User-facing confusion - block name doesn't match behavior.

**Action:** Ask user:
1. Should InfiniteTimeRoot emit infinite time (tModelMs = tAbsMs)?
2. Or is current cyclic behavior correct and block should be renamed?

**Blocking:** Cannot finalize Pass3 implementation without decision.

### Priority 3: Implement EventStore

**Why:** Core deliverable, enables discrete event semantics.

**Action:** Follow SPEC-05:278-312 implementation plan:
1. Create EventStore class (trigger/check/reset)
2. Add to RuntimeState
3. Update executeTimeDerive to write events to EventStore
4. Add consumer reading logic

**Estimated effort:** 2-4 hours

### Priority 4: Add Scrub Mode to ScheduleExecutor

**Why:** Required for deliverable 3 (suppress wrap during scrub).

**Action:**
1. Add `mode?: 'scrub' | 'playback'` parameter to executeFrame()
2. Pass mode to resolveTime()
3. Suppress wrapEvent when mode='scrub'
4. Add scrub detection heuristic (large jumps, backward time)

**Question for user:** Should IR executor adopt unified compiler's TimeCtx pattern?

**Estimated effort:** 1-2 hours

### Priority 5: Add Multi-Frame Wrap Tests

**Why:** Current test coverage is inadequate.

**Action:** Write tests covering:
1. Wrap detection across frame sequence
2. Backward scrubbing across wrap boundary
3. Wrap suppression during scrub mode
4. End-to-end wrap event consumption

**Estimated effort:** 1 hour

---

## Missing Checks (Implementer Should Create)

These persistent checks should be added to the test suite:

### Check 1: Multi-Frame Wrap Detection
```typescript
describe('multi-frame wrap detection', () => {
  it('detects wrap when crossing period boundary', () => {
    const state = createTimeState();
    const model: TimeModelIR = { kind: 'cyclic', periodMs: 1000, mode: 'loop' };

    const t1 = resolveTime(900, model, state);
    expect(t1.wrapEvent).toBe(0.0);

    const t2 = resolveTime(1100, model, state);
    expect(t2.wrapEvent).toBe(1.0);  // ‚Üê Should trigger

    const t3 = resolveTime(1200, model, state);
    expect(t3.wrapEvent).toBe(0.0);  // ‚Üê Should reset
  });
});
```

### Check 2: Scrub Mode Wrap Suppression
```typescript
it('suppresses wrap during scrub mode', () => {
  const state = createTimeState();
  const model: TimeModelIR = { kind: 'cyclic', periodMs: 1000, mode: 'loop' };

  resolveTime(900, model, state);
  const scrubbed = resolveTime(100, model, state, { mode: 'scrub' });

  expect(scrubbed.wrapEvent).toBe(0.0);  // ‚Üê No wrap during scrub
});
```

### Check 3: End-to-End Integration
```typescript
it('wrap event triggers downstream blocks', () => {
  // Create patch with TimeRoot + TriggerOnWrap + counter
  // Verify counter increments once per wrap
  // Verify scrubbing doesn't trigger counter
});
```

---

## Verdict

- [x] **CONTINUE** - Issues are clear, implementer can fix
- [ ] PAUSE - Ambiguities need clarification

**Rationale:**
- Core architecture (TimeRoot authoritative) is complete ‚úÖ
- Gaps are well-defined (EventStore, scrub mode)
- Implementation path is clear (follow SPEC-05)
- Ambiguities exist but don't block progress (can ask during implementation)

**Next Actions:**
1. Fix test compilation errors (5 min)
2. Clarify InfiniteTimeRoot semantics with user
3. Implement EventStore (2-4 hours)
4. Add scrub mode to ScheduleExecutor (1-2 hours)
5. Write multi-frame wrap tests (1 hour)

**Estimated completion time:** 4-7 hours of focused work.

---

## Files Examined

**Compiler passes:**
- `src/editor/compiler/passes/pass3-time.ts:1-214` (TimeRoot extraction, TimeModel generation)

**Runtime:**
- `src/editor/runtime/executor/timeResolution.ts:1-182` (resolveTime logic)
- `src/editor/runtime/executor/steps/executeTimeDerive.ts:1-79` (writing time slots)
- `src/editor/runtime/executor/RuntimeState.ts:1-668` (timeState storage)
- `src/editor/runtime/executor/ScheduleExecutor.ts:1-200` (frame execution)

**Tests:**
- `src/editor/runtime/executor/__tests__/timeResolution.test.ts:1-149` (basic time tests)
- `src/editor/runtime/__tests__/IRRuntimeIntegration.test.ts` (scrubTo tests)
- `src/editor/compiler/unified/__tests__/*.test.ts` (scrub mode tests)

**Planning docs:**
- `plans/ir-compiler-backlog-streams/02-time-event-semantics.md`
- `plans/SPEC-05-time-architecture.md`

---

## Cache Updated

No eval-cache entries written (this is the first evaluation of this workstream).

**Recommendation:** After fixes are implemented, cache:
- Time architecture overview ‚Üí `eval-cache/time-architecture.md`
- Test infrastructure for time ‚Üí `eval-cache/time-testing.md`
- Scrub semantics ‚Üí `eval-cache/scrub-behavior.md`
