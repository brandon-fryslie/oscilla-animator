# Sprint Plan: Block & Edge Roles Type System
Generated: 2026-01-03-124630
Source: EVALUATION-2026-01-03.md
Spec: design-docs/final-System-Invariants/15-Block-Edge-Roles.md

---

## Executive Summary

**Current State**: BlockRole exists as a simple string union (`'defaultSourceProvider' | 'internal'`). EdgeRole does not exist at all. Both role fields are optional when the spec requires them to be required. The `hidden?: boolean` field is separate and redundant with role semantics.

**Target State**: Both BlockRole and EdgeRole are discriminated unions with metadata attached. Both are required fields. The system can distinguish user entities from structural entities by role, and structural entities carry metadata about what they target.

**Sprint Scope**: This sprint focuses ONLY on the foundational type system changes from §15. It does NOT include graph normalization (§16), which is a separate topic. We are building the type foundation that normalization will later use.

**Total Gap**: 6 core deliverables identified, scoped to 3 for this sprint.

---

## Sprint Deliverables

This sprint delivers the core type system changes that enable role-based entity management. We're limiting scope to 3 deliverables that can be completed in one sprint.

### Deliverable 1: Discriminated Union Type System

**Priority**: P0 (Critical - foundation for all other work)
**Effort**: Medium (2-3 days)
**Dependencies**: None
**Spec Reference**: §15 lines 48-87 (Invariant 2)
**Status Reference**: EVALUATION-2026-01-03.md lines 84-108, 109-127

Replace string-based roles with discriminated unions that carry metadata.

#### Changes Required

**Types to add** (src/editor/types.ts):
```typescript
// BlockRole discriminated union
export type BlockRole =
  | { kind: "user" }
  | { kind: "structural"; meta: StructuralMeta };

export type StructuralMeta =
  | { kind: "defaultSource"; target: { kind: "port"; port: PortRef } }
  | { kind: "wireState";     target: { kind: "wire"; wire: WireId } }
  | { kind: "globalBus";     target: { kind: "bus"; busId: BusId } }
  | { kind: "lens";          target: { kind: "node"; node: NodeRef; port?: string } };

// EdgeRole discriminated union
export type EdgeRole =
  | { kind: "user" }
  | { kind: "default"; meta: { defaultSourceBlockId: BlockId } }
  | { kind: "busTap";  meta: { busId: BusId } }
  | { kind: "auto";    meta: { reason: "portMoved" | "rehydrate" | "migrate" } };
```

**Migration strategy**:
- Keep old `BlockRole` as `LegacyBlockRole` temporarily
- Add migration helper: `migrateLegacyRole(old: LegacyBlockRole | undefined): BlockRole`
- Default blocks without role to `{ kind: "user" }`
- Map `'defaultSourceProvider'` → `{ kind: "structural", meta: { kind: "defaultSource", ... } }`
- Map `'internal'` → `{ kind: "structural", meta: { kind: "wireState", ... } }` (or appropriate variant)

#### Acceptance Criteria

- [ ] BlockRole is a discriminated union with `kind` discriminator
- [ ] BlockRole has `user` and `structural` variants
- [ ] StructuralMeta has all 4 variants: defaultSource, wireState, globalBus, lens
- [ ] Each StructuralMeta variant includes target metadata
- [ ] EdgeRole is a discriminated union with `kind` discriminator
- [ ] EdgeRole has all 4 variants: user, default, busTap, auto
- [ ] Migration function converts old string roles to new discriminated unions
- [ ] TypeScript compilation succeeds with new types
- [ ] Unit tests verify role shape at compile time (type-level tests)
- [ ] Migration tests verify old roles map to correct new roles

#### Technical Notes

- Use closed unions (no `Record<string, unknown>` for meta)
- Consistent discriminator name: always `kind`
- Include JSDoc comments explaining each role variant
- PortRef, WireId, BusId, NodeRef must already exist (verify)
- Migration function should be pure (no side effects)

---

### Deliverable 2: Required Role Fields with Migration

**Priority**: P0 (Critical - enforces invariant)
**Effort**: Medium (2-3 days)
**Dependencies**: Deliverable 1
**Spec Reference**: §15 lines 20-46 (Invariant 1)
**Status Reference**: EVALUATION-2026-01-03.md lines 20-46, 100-106, 191-195

Make `role` a required field on both Block and Edge interfaces, with safe migration path.

#### Changes Required

**Block interface** (src/editor/types.ts ~line 695):
```typescript
// Change from:
role?: BlockRole;

// To:
role: BlockRole;  // REQUIRED
```

**Edge interface** (src/editor/types.ts ~line 293-323):
```typescript
// Add new required field:
export interface Edge {
  readonly id: string;
  readonly from: Endpoint;
  readonly to: Endpoint;
  readonly transforms?: TransformStep[];
  readonly enabled: boolean;
  readonly weight?: number;
  readonly sortKey?: number;
  readonly role: EdgeRole;  // NEW REQUIRED FIELD
}
```

**Migration in PatchStore**:
- Update `addBlock()` to default `role: { kind: "user" }`
- Update `connect()` to default `role: { kind: "user" }`
- Add `migrateBlockRole()` helper for patch deserialization
- Add `migrateEdgeRole()` helper for patch deserialization

#### Acceptance Criteria

- [ ] Block.role is required (no `?` modifier)
- [ ] Edge.role is required (no `?` modifier)
- [ ] PatchStore.addBlock() sets `role: { kind: "user" }` by default
- [ ] PatchStore.connect() sets `role: { kind: "user" }` by default
- [ ] Patch deserialization migrates blocks without role to user role
- [ ] Patch deserialization migrates edges without role to user role
- [ ] All existing blocks in test fixtures have valid roles
- [ ] All existing edges in test fixtures have valid roles
- [ ] TypeScript compilation enforces role presence at all creation sites
- [ ] Integration test verifies old patches load correctly with migration

#### Technical Notes

- Migration happens at deserialization boundary (PatchStore.fromJSON or equivalent)
- Runtime checks for legacy patches: `if (!block.role) block.role = { kind: "user" }`
- Consider warning log when migrating (for debugging)
- Ensure structural blocks created by pass0-materialize.ts get correct role

---

### Deliverable 3: Structural Block Creation Updates

**Priority**: P1 (High - completes type system usage)
**Effort**: Small (1-2 days)
**Dependencies**: Deliverable 1, Deliverable 2
**Spec Reference**: §15 lines 48-67 (StructuralMeta types)
**Status Reference**: EVALUATION-2026-01-03.md lines 130-148, 203-205

Update all sites that create structural blocks to use new discriminated role with metadata.

#### Changes Required

**pass0-materialize.ts** (~line 92-100):
```typescript
// Change from:
const providerBlock: Block = {
  id: providerId,
  type: providerType,
  label: `Default ${slot.label}`,
  // ...
  hidden: true,
  role: 'defaultSourceProvider',  // OLD
};

// To:
const providerBlock: Block = {
  id: providerId,
  type: providerType,
  label: `Default ${slot.label}`,
  // ...
  role: {
    kind: 'structural',
    meta: {
      kind: 'defaultSource',
      target: {
        kind: 'port',
        port: { blockId, slotId: slot.id, direction: 'in' }  // Actual target
      }
    }
  },
  // hidden field removed (derived from role.kind === 'structural')
};

// Edge creation:
const defaultEdge: Edge = {
  // ...
  role: {
    kind: 'default',
    meta: { defaultSourceBlockId: providerId }
  }
};
```

**Any other structural block creation sites**:
- Search for `role: 'defaultSourceProvider'`
- Search for `role: 'internal'`
- Update to use discriminated unions with metadata
- Remove redundant `hidden: true` assignments

#### Acceptance Criteria

- [ ] pass0-materialize.ts creates blocks with discriminated role
- [ ] Structural block role includes target metadata (which port it targets)
- [ ] Default source edges include metadata (which block provides the default)
- [ ] No creation sites use old string roles
- [ ] No creation sites set `hidden: true` (redundant with role)
- [ ] Compiler tests pass with new role shapes
- [ ] Default source blocks still compile correctly
- [ ] Integration test verifies default source metadata is correct
- [ ] grep 'defaultSourceProvider' returns only migration code or comments
- [ ] grep 'internal' (for role) returns only migration code or comments

#### Technical Notes

- Keep `hidden?: boolean` field for now (Deliverable 4 removes it)
- Ensure PortRef includes all required fields (blockId, slotId, direction)
- Default edge metadata must reference the structural block's ID
- Verify that compiler passes ignore role (they should already)

---

## Deferred Deliverables

The following are out of scope for this sprint but tracked for future work:

### Deliverable 4: Remove Hidden Field (Deferred)

**Priority**: P2 (Medium - cleanup)
**Reason for deferral**: Requires updating UI code that filters by `hidden` flag. Better to do after role-based filtering is proven in Deliverable 3.

**What it would do**:
- Remove `Block.hidden?: boolean` field entirely
- Update PatchStore.userBlocks to filter by `role.kind === 'user'`
- Add helper: `isStructuralBlock(block: Block): boolean`
- Update all UI filtering logic

### Deliverable 5: Role Invariant Validation (Deferred)

**Priority**: P1 (High - correctness)
**Reason for deferral**: Requires graph normalization architecture (§16) to be in place. Validation should run after normalization.

**What it would do**:
- Implement `validateRoleInvariants(patch: Patch): Diagnostic[]`
- Check default edges reference structural blocks
- Check structural metadata targets exist
- Integrate into compile pipeline

### Deliverable 6: Terminology Consistency (Deferred)

**Priority**: P3 (Low - documentation)
**Reason for deferral**: Cosmetic change, can be done independently later.

**What it would do**:
- Replace "hidden block" → "structural block" in comments
- Update variable names: `hiddenBlocks` → `structuralBlocks`
- Update JSDoc comments for consistency

---

## Dependency Graph

```
Deliverable 1 (Type System)
    ↓
Deliverable 2 (Required Fields) ← depends on Deliverable 1
    ↓
Deliverable 3 (Creation Sites) ← depends on Deliverable 1, 2
    ↓
[DEFERRED] Deliverable 4 (Remove Hidden) ← depends on Deliverable 3
    ↓
[DEFERRED] Deliverable 5 (Validation) ← depends on Deliverable 3 + §16
[DEFERRED] Deliverable 6 (Terminology) ← independent
```

---

## Risk Assessment

### High-Risk Items

**Breaking Changes**:
- Making `role` required on Block and Edge is a breaking change
- Existing patches in the wild will fail to load without migration
- TypeScript compilation will fail at all creation sites until updated

**Mitigation**:
- Migration functions handle legacy patches gracefully
- Default to `{ kind: "user" }` for any entity without role
- Add integration tests for patch migration
- Consider feature flag for gradual rollout

### Medium-Risk Items

**Type System Complexity**:
- Discriminated unions are more complex than string unions
- Developers must understand metadata requirements
- More verbose code at creation sites

**Mitigation**:
- Comprehensive JSDoc comments on each type
- Helper functions for common role creation patterns
- Examples in comments showing correct usage

### Low-Risk Items

**Compiler Compatibility**:
- Compiler should ignore roles (already does)
- IR generation should not be affected

**Verification**:
- Run full test suite after each deliverable
- Verify compiler output unchanged for same input patch

---

## Testing Strategy

### Unit Tests

**Type-level tests** (Deliverable 1):
```typescript
// Verify discriminated union shape
const userRole: BlockRole = { kind: "user" };
const structRole: BlockRole = {
  kind: "structural",
  meta: { kind: "defaultSource", target: { kind: "port", port: mockPortRef } }
};

// Should NOT compile:
// const wrongRole: BlockRole = "defaultSourceProvider";
```

**Migration tests** (Deliverable 2):
```typescript
test("migrates legacy string role to discriminated union", () => {
  const legacy: any = { role: "defaultSourceProvider" };
  const migrated = migrateBlockRole(legacy);
  expect(migrated.role.kind).toBe("structural");
  expect(migrated.role.meta.kind).toBe("defaultSource");
});
```

**Creation site tests** (Deliverable 3):
```typescript
test("default source block has correct role metadata", () => {
  const patch = createPatchWithUnconnectedInput();
  const compiler = new Compiler(patch);
  const normalized = compiler.materializeDefaults();

  const defaultSourceBlocks = normalized.blocks.filter(
    b => b.role.kind === "structural" && b.role.meta.kind === "defaultSource"
  );

  expect(defaultSourceBlocks.length).toBeGreaterThan(0);
  const block = defaultSourceBlocks[0];
  expect(block.role.meta.target.kind).toBe("port");
  expect(block.role.meta.target.port).toBeDefined();
});
```

### Integration Tests

**Patch migration** (Deliverable 2):
- Load legacy patch with old role format
- Verify migration produces valid discriminated unions
- Verify compilation succeeds with migrated patch
- Verify output IR is correct

**End-to-end compilation** (Deliverable 3):
- Create patch with unconnected input
- Compile with default source materialization
- Verify default source has correct role metadata
- Verify generated edge has correct role metadata
- Verify IR output is unchanged (roles don't affect compilation)

### Manual Testing

**DevTools inspection** (all deliverables):
- Inspect block objects in Chrome DevTools
- Verify role shape matches discriminated union
- Verify metadata is populated correctly
- Check for any `role: undefined` cases

---

## Definition of Done

Each deliverable is complete when:

1. TypeScript compilation succeeds with no errors
2. All unit tests pass (existing + new)
3. All integration tests pass
4. Manual DevTools inspection confirms correct runtime shapes
5. No grep results for deprecated patterns (e.g., string roles)
6. Code review confirms spec compliance
7. JSDoc comments explain new types/patterns

Sprint is complete when:
- All 3 deliverables meet their individual acceptance criteria
- Full test suite passes (`just check`)
- Compiler output unchanged for same inputs (verified)
- Legacy patches load and migrate correctly (integration test)

---

## Blockers and Questions

**None identified**. The spec is clear, the gap analysis is thorough, and the implementation path is straightforward. This is mechanical work: update types, migrate data, update creation sites.

If issues arise during implementation:
- Check §15 spec for authoritative type shapes
- Refer to EVALUATION-2026-01-03.md for gap details
- Consult §16 (Graph Normalization) for context on how roles will be used

---

## Files to Modify

### Core Type Definitions
- **src/editor/types.ts** (BlockRole, EdgeRole, StructuralMeta types)
- **src/editor/types.ts** (Block and Edge interfaces)

### Creation Sites
- **src/editor/compiler/passes/pass0-materialize.ts** (default source block/edge creation)
- **src/editor/stores/PatchStore.ts** (addBlock, connect methods)

### Migration
- **src/editor/stores/PatchStore.ts** (patch deserialization, migration helpers)

### Tests (new files)
- **src/editor/types.test.ts** (role type tests)
- **src/editor/stores/PatchStore.test.ts** (migration tests)
- **src/editor/compiler/passes/pass0-materialize.test.ts** (structural block creation tests)

---

## Success Metrics

- Zero TypeScript errors related to role types
- 100% of blocks have required `role` field
- 100% of edges have required `role` field
- Zero usage of legacy string roles (except in migration code)
- Full test suite passes (`just check`)
- Legacy patches migrate successfully (verified by integration test)

---

## Summary

This sprint delivers the foundational type system for Block & Edge Roles. We're building discriminated unions with metadata, making roles required, and updating creation sites to use the new types. This is the foundation for graph normalization (§16) and role-based validation, but we're keeping scope tight by deferring those to future sprints.

The work is mechanical but high-leverage: once the type system is correct, the compiler and editor can rely on role metadata for their respective responsibilities.
