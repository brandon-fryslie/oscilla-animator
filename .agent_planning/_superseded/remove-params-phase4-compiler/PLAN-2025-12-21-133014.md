# Phase 4: Compiler Default Source Resolution

**Generated:** 2025-12-21-133014
**Source Design Doc:** `design-docs/10-Refactor-for-UI-prep/14-RemoveParams.md`
**Phase Context:** Refactor to eliminate `block.params` in favor of Default Sources per input
**Scope:** Compiler input resolution logic only (no block definition changes, no UI changes)

---

## Executive Summary

This plan details the compiler changes needed to resolve inputs from Default Sources when no explicit wire or bus connection exists. After Phase 4, the compiler will:

1. Never access `block.params` during compilation
2. Generate constant artifacts from `slot.defaultValue` for unconnected inputs
3. Support four world types: Signal, Field, Scalar, Config
4. Integrate Config inputs with hot-swap topology change behavior

**Key Invariant:** Every input always has exactly one effective source:
- Explicit wire connection, OR
- Bus listener (with optional lens stack), OR
- Default Source (constant artifact from slot.defaultValue)

---

## Current State Analysis

### How Compilers Currently Access Parameters

**Wire-Only Compiler** (`src/editor/compiler/compile.ts:293`):
```typescript
const outs = compiler.compile({ id: blockId, params: block.params, inputs, ctx });
```

**Bus-Aware Compiler** (`src/editor/compiler/compileBusAware.ts:434`):
```typescript
const outs = compiler.compile({ id: blockId, params: block.params, inputs, ctx });
```

**Example Block Compiler** (`src/editor/compiler/blocks/rhythm/EnvelopeAD.ts:35-37`):
```typescript
const attack = Number(params.attack ?? 0.05) * 1000;
const decay = Number(params.decay ?? 0.5) * 1000;
const peak = Number(params.peak ?? 1.0);
```

**Current Input Resolution** (`src/editor/compiler/compileBusAware.ts:364-415`):
1. Check for wire connection → use upstream artifact
2. Check for bus listener → combine bus publishers with lens
3. If required → Error artifact
4. If optional → Error artifact with "Unwired optional input" message

### Slot Interface Limitations

**Current Slot Definition** (`src/editor/types.ts:402-414`):
```typescript
export interface Slot {
  readonly id: string;
  readonly label: string;
  readonly type: SlotType;
  readonly direction: 'input' | 'output';
}
```

**Missing:** `defaultValue` field - **PREREQUISITE: Phase 1-3 must add this field**

---

## Gap Analysis

### What's Missing for Phase 4

1. **Slot.defaultValue field** - Must be added in earlier phase
2. **Default artifact generation logic** - Convert defaultValue to typed Artifact
3. **World-specific artifact constructors** - Signal/Field/Scalar/Config
4. **Compiler interface changes** - Remove params from compile() signature
5. **Block compiler updates** - All 28 block compilers must migrate from params
6. **Config input detection** - Identify Config inputs for hot-swap integration
7. **TimeRoot param inference** - TimeModel currently reads block.params directly

### Dependencies on Earlier Phases

**BLOCKING:** This phase assumes Phases 1-3 have completed:
- Phase 1: Slot definitions updated with `defaultValue?: unknown`
- Phase 2: Block definitions migrated (params → inputs with defaults)
- Phase 3: UI updated to edit slot.defaultValue instead of block.params

---

## Technical Design

### 1. Input Resolution Algorithm (New Logic)

**Location:** `src/editor/compiler/compileBusAware.ts:362-416` (replace existing loop)

```typescript
// For each compiler input port definition
for (const inputPort of compiler.inputs) {
  // Step 1: Check for explicit wire connection
  const wireConn = incoming.get(keyOf(blockId, inputPort.name))?.[0];

  if (wireConn) {
    // Wire takes precedence - use upstream artifact
    const srcKey = keyOf(wireConn.from.blockId, wireConn.from.port);
    inputs[inputPort.name] = compiledPortMap.get(srcKey) ?? makeError(...);
    continue;
  }

  // Step 2: Check for bus listener
  const busListener = listeners.find(
    l => l.enabled && l.to.blockId === blockId && l.to.slotId === inputPort.name
  );

  if (busListener) {
    // Get combined bus value and apply lens stack
    let busArtifact = getBusValue(busListener.busId, buses, publishers, compiledPortMap, errors);
    inputs[inputPort.name] = applyLensStack(busArtifact, busListener.lensStack);
    continue;
  }

  // Step 3: Default Source - get slot defaultValue from block definition
  const blockDef = getBlockDefinition(block.type);
  const inputSlot = blockDef.inputs.find(s => s.id === inputPort.name);

  if (!inputSlot) {
    inputs[inputPort.name] = makeError(`Input slot ${inputPort.name} not found in block definition`);
    continue;
  }

  // Generate constant artifact from slot.defaultValue
  inputs[inputPort.name] = createDefaultSourceArtifact(
    inputSlot.type,      // SlotType (e.g., 'Signal<number>', 'Field<vec2>')
    inputSlot.defaultValue ?? getTypeNeutralValue(inputSlot.type),
    { blockId, port: inputPort.name }
  );
}
```

**Key Changes:**
- No fallback to `block.params`
- Default Source is the third-priority source (after wire and bus)
- Uses `blockDef.inputs[].defaultValue` as source of truth
- Falls back to type-neutral value if defaultValue undefined

---

### 2. Default Source Artifact Generation

**New Function:** `src/editor/compiler/defaultSources.ts` (new file)

```typescript
import type { Artifact, SlotType, RuntimeCtx, Vec2 } from './types';

/**
 * Create a constant artifact from a Default Source value.
 *
 * World mapping:
 * - Signal<T> → constant signal function (t, ctx) => value
 * - Field<T> → constant field expression (seed, n) => [value, value, ...]
 * - Scalar:T → direct value (used at compile time)
 * - Config:T → direct value (triggers topology change on edit)
 */
export function createDefaultSourceArtifact(
  slotType: SlotType,
  defaultValue: unknown,
  where: { blockId: string; port: string }
): Artifact {
  // Parse slot type to extract world and domain
  const parsed = parseSlotType(slotType);

  switch (parsed.world) {
    case 'signal':
      return createSignalConstant(parsed.domain, defaultValue, where);

    case 'field':
      return createFieldConstant(parsed.domain, defaultValue, where);

    case 'scalar':
      return createScalarConstant(parsed.domain, defaultValue, where);

    case 'config':
      return createConfigConstant(parsed.domain, defaultValue, where);

    default:
      return {
        kind: 'Error',
        message: `Unknown world type in slot type: ${slotType}`,
        where,
      };
  }
}

/**
 * Parse SlotType string into world + domain.
 * Examples:
 *   'Signal<number>' → { world: 'signal', domain: 'number' }
 *   'Field<vec2>' → { world: 'field', domain: 'vec2' }
 *   'Scalar:number' → { world: 'scalar', domain: 'number' }
 */
function parseSlotType(slotType: SlotType): { world: string; domain: string } {
  // Signal/Field: 'Signal<domain>' or 'Field<domain>'
  const genericMatch = slotType.match(/^(Signal|Field|Event)<(.+)>$/);
  if (genericMatch) {
    return {
      world: genericMatch[1]!.toLowerCase(),
      domain: genericMatch[2]!,
    };
  }

  // Scalar: 'Scalar:domain'
  const scalarMatch = slotType.match(/^Scalar:(.+)$/);
  if (scalarMatch) {
    return {
      world: 'scalar',
      domain: scalarMatch[1]!,
    };
  }

  // Config (new): 'Config:domain' or 'Config<domain>'
  const configMatch = slotType.match(/^Config[:<](.+)>?$/);
  if (configMatch) {
    return {
      world: 'config',
      domain: configMatch[1]!,
    };
  }

  // Special cases (Domain, RenderTree, etc.)
  return {
    world: 'special',
    domain: slotType,
  };
}

/**
 * Create a constant Signal artifact.
 * Signal<T> is a time-indexed function: (t: number, ctx: RuntimeCtx) => T
 *
 * Default Source signals are time-invariant - always return the same value.
 */
function createSignalConstant(
  domain: string,
  value: unknown,
  where: { blockId: string; port: string }
): Artifact {
  // Type-check and coerce value
  const typedValue = coerceToDomain(domain, value);

  // Create constant signal function
  const constantSignal = (_t: number, _ctx: RuntimeCtx) => typedValue;

  // Determine Artifact kind from domain
  const artifactKind = `Signal:${domain}` as Artifact['kind'];

  return {
    kind: artifactKind,
    value: constantSignal,
  };
}

/**
 * Create a constant Field artifact.
 * Field<T> is a bulk function: (seed: number, n: number) => readonly T[]
 *
 * Default Source fields produce uniform arrays - all elements have same value.
 */
function createFieldConstant(
  domain: string,
  value: unknown,
  where: { blockId: string; port: string }
): Artifact {
  const typedValue = coerceToDomain(domain, value);

  // Create uniform field function
  const uniformField = (_seed: number, n: number): readonly unknown[] => {
    return new Array(n).fill(typedValue);
  };

  const artifactKind = `Field:${domain}` as Artifact['kind'];

  return {
    kind: artifactKind,
    value: uniformField,
  };
}

/**
 * Create a Scalar artifact (compile-time constant).
 * Scalar values are used directly during compilation - no runtime function.
 */
function createScalarConstant(
  domain: string,
  value: unknown,
  where: { blockId: string; port: string }
): Artifact {
  const typedValue = coerceToDomain(domain, value);

  const artifactKind = `Scalar:${domain}` as Artifact['kind'];

  return {
    kind: artifactKind,
    value: typedValue,
  };
}

/**
 * Create a Config artifact (compile-time constant with hot-swap semantics).
 * Config values trigger topology change on edit (crossfade/freeze behavior).
 *
 * Semantically identical to Scalar but tagged for hot-swap detection.
 */
function createConfigConstant(
  domain: string,
  value: unknown,
  where: { blockId: string; port: string }
): Artifact {
  const typedValue = coerceToDomain(domain, value);

  // For now, Config artifacts are the same as Scalar
  // Future: add metadata for hot-swap detection
  const artifactKind = `Config:${domain}` as Artifact['kind'];

  return {
    kind: artifactKind,
    value: typedValue,
  };
}

/**
 * Type-coerce a raw value to match the expected domain.
 * Ensures type safety and provides sensible defaults.
 */
function coerceToDomain(domain: string, value: unknown): unknown {
  switch (domain) {
    case 'number':
    case 'time':
    case 'phase':
    case 'rate':
      return typeof value === 'number' ? value : Number(value ?? 0);

    case 'vec2':
    case 'Point':
      if (isVec2(value)) return value;
      return { x: 0, y: 0 };

    case 'color':
      if (typeof value === 'string') return value;
      return '#000000';

    case 'boolean':
      return Boolean(value);

    case 'string':
      return String(value ?? '');

    default:
      // Pass through for unknown domains
      return value;
  }
}

function isVec2(value: unknown): value is Vec2 {
  return (
    typeof value === 'object' &&
    value !== null &&
    'x' in value &&
    'y' in value &&
    typeof (value as any).x === 'number' &&
    typeof (value as any).y === 'number'
  );
}

/**
 * Get the neutral/identity value for a type when no default is specified.
 *
 * Neutral values:
 * - number: 0
 * - vec2: { x: 0, y: 0 }
 * - color: '#000000' (black/transparent)
 * - boolean: false
 * - time/phase/rate: 0
 */
export function getTypeNeutralValue(slotType: SlotType): unknown {
  const parsed = parseSlotType(slotType);

  switch (parsed.domain) {
    case 'number':
    case 'time':
    case 'phase':
    case 'rate':
      return 0;

    case 'vec2':
    case 'Point':
      return { x: 0, y: 0 };

    case 'color':
      return '#000000';

    case 'boolean':
      return false;

    case 'string':
      return '';

    default:
      return undefined;
  }
}
```

---

### 3. Compiler Interface Changes

**Current BlockCompiler Interface** (`src/editor/compiler/types.ts`):
```typescript
interface BlockCompiler {
  compile(args: {
    id: BlockId;
    params: BlockParams;  // ← REMOVE THIS
    inputs: Record<string, Artifact>;
    ctx: CompileCtx;
  }): Record<string, Artifact>;
}
```

**New Interface:**
```typescript
interface BlockCompiler {
  compile(args: {
    id: BlockId;
    // params removed - use inputs instead
    inputs: Record<string, Artifact>;
    ctx: CompileCtx;
  }): Record<string, Artifact>;
}
```

**Migration Strategy:**
1. Add new optional signature alongside old one (temporary)
2. Update compiler call sites to stop passing params
3. Update all 28 block compilers to use inputs instead of params
4. Remove old signature once all blocks migrated

---

### 4. TimeRoot Special Case

**Problem:** TimeModel inference currently reads `block.params` directly:

```typescript
// src/editor/compiler/compileBusAware.ts:527-536
if (block.type === 'FiniteTimeRoot') {
  const durationMs = Number(block.params.durationMs ?? 5000);  // ← params access
  return { kind: 'finite', durationMs, ... };
}
```

**Solution:** Read from compiled artifacts instead of params

```typescript
function inferTimeModelFromTimeRoot(
  block: BlockInstance,
  compiledPortMap: Map<string, Artifact>
): TimeModel {
  switch (block.type) {
    case 'FiniteTimeRoot': {
      // Option A: Read from block definition's input defaults
      const blockDef = getBlockDefinition(block.type);
      const durationInput = blockDef.inputs.find(s => s.id === 'duration');
      const durationMs = Number(durationInput?.defaultValue ?? 5000);

      // Option B: If duration is an input port with artifact, read it
      // (requires compiling TimeRoot before inferring TimeModel)

      return {
        kind: 'finite',
        durationMs,
        cuePoints: [
          { tMs: 0, label: 'Start', kind: 'marker' },
          { tMs: durationMs, label: 'End', kind: 'marker' },
        ],
      };
    }

    // Similar for CycleTimeRoot, InfiniteTimeRoot
  }
}
```

**Decision Point:** Should TimeRoot parameters be inputs or configs?
- **Inputs:** Allow modulation (dynamic duration changes)
- **Configs:** Static topology (duration set at compile time)

**Recommendation:** Treat as **Config** inputs initially:
- Changing period/duration is a topology change (requires recompile)
- Hot-swap handles crossfade on change
- Future: could allow Signal<duration> for dynamic speed changes

---

### 5. Hot-Swap Integration for Config Inputs

**Current Hot-Swap Detection** (`src/editor/runtime/player.ts`):
- Detects topology changes (blocks added/removed, connections changed)
- Applies crossfade for topology changes
- Preserves state for parameter-only changes

**New Requirement:** Detect Config input edits as topology changes

```typescript
// In hot-swap change classification
function classifyChange(oldPatch: Patch, newPatch: Patch): ChangeClass {
  // ... existing topology checks ...

  // NEW: Check for Config input value changes
  for (const [blockId, newBlock] of newPatch.blocks) {
    const oldBlock = oldPatch.blocks.get(blockId);
    if (!oldBlock) continue; // New block - already detected as topology change

    const blockDef = getBlockDefinition(newBlock.type);

    for (const inputSlot of blockDef.inputs) {
      // Detect Config inputs (new world type)
      if (isConfigInput(inputSlot.type)) {
        const oldValue = oldBlock.inputs.get(inputSlot.id)?.defaultValue;
        const newValue = newBlock.inputs.get(inputSlot.id)?.defaultValue;

        if (!deepEqual(oldValue, newValue)) {
          return { class: 'topology', reason: `Config input ${inputSlot.id} changed` };
        }
      }
    }
  }

  return { class: 'parameter' }; // Safe hot-swap
}

function isConfigInput(slotType: SlotType): boolean {
  return slotType.startsWith('Config:') || slotType.startsWith('Config<');
}
```

---

### 6. Block Compiler Migration Pattern

**Example: EnvelopeAD** (before):
```typescript
compile({ params, inputs }) {
  const attack = Number(params.attack ?? 0.05) * 1000;
  const decay = Number(params.decay ?? 0.5) * 1000;
  const peak = Number(params.peak ?? 1.0);
  // ...
}
```

**After:**
```typescript
compile({ inputs }) {
  // Attack is now an input with Default Source
  const attackArtifact = inputs.attack;
  if (attackArtifact?.kind !== 'Scalar:number') {
    return { env: makeError('attack must be Scalar:number') };
  }
  const attack = Number(attackArtifact.value) * 1000;

  // Similar for decay, peak
  // ...
}
```

**Or, if using helper:**
```typescript
compile({ inputs }) {
  const attack = extractScalar(inputs.attack, 'number', 0.05) * 1000;
  const decay = extractScalar(inputs.decay, 'number', 0.5) * 1000;
  const peak = extractScalar(inputs.peak, 'number', 1.0);
  // ...
}

// Helper function
function extractScalar(artifact: Artifact | undefined, domain: string, fallback: number): number {
  if (artifact?.kind === `Scalar:${domain}`) {
    return Number(artifact.value);
  }
  return fallback;
}
```

---

## Implementation Roadmap

### Prerequisites (Must Complete First)
- [ ] **Phase 1:** Add `defaultValue?: unknown` to Slot interface
- [ ] **Phase 2:** Migrate all block definitions (params → input slots with defaults)
- [ ] **Phase 3:** Update UI to edit slot.defaultValue instead of params

### Phase 4 Work Items (This Plan)

#### P0: Core Infrastructure
- [ ] **Create `src/editor/compiler/defaultSources.ts`**
  - `createDefaultSourceArtifact()` - main entry point
  - `parseSlotType()` - SlotType string parsing
  - `createSignalConstant()` - Signal<T> artifact generator
  - `createFieldConstant()` - Field<T> artifact generator
  - `createScalarConstant()` - Scalar:T artifact generator
  - `createConfigConstant()` - Config:T artifact generator
  - `coerceToDomain()` - type coercion logic
  - `getTypeNeutralValue()` - fallback values per domain

- [ ] **Update BlockCompiler interface**
  - Add new signature without `params` argument
  - Keep old signature temporarily for migration
  - Add deprecation comment on old signature

#### P1: Compiler Integration
- [ ] **Update wire-only compiler** (`src/editor/compiler/compile.ts`)
  - Modify input resolution loop (lines 248-276)
  - Add Default Source fallback after wire check
  - Remove params from compile() call (line 293)
  - Update error messages (no more "params" references)

- [ ] **Update bus-aware compiler** (`src/editor/compiler/compileBusAware.ts`)
  - Modify input resolution loop (lines 364-416)
  - Add Default Source fallback after wire and bus checks
  - Remove params from compile() call (line 434)
  - Import and use `createDefaultSourceArtifact()`

- [ ] **Update TimeModel inference**
  - Modify `inferTimeModelFromTimeRoot()` in both compilers
  - Read from block definition defaults instead of params
  - Handle missing defaults gracefully
  - Add test for TimeModel with Default Sources

#### P2: Block Compiler Migration (28 files)
- [ ] **Domain blocks** (10 files)
  - `GridDomain.ts`, `DomainN.ts`, `SVGSampleDomain.ts`
  - `FieldReduce.ts`, `FieldZipSignal.ts`, `FieldZipNumber.ts`
  - `JitterFieldVec2.ts`, `StableIdHash.ts`
  - `TimeRoot.ts`, `PhaseClock.ts`

- [ ] **Signal blocks** (3 files)
  - `Oscillator.ts`, `ColorLFO.ts`, `ClampSignal.ts`, `Shaper.ts`

- [ ] **Field blocks** (7 files)
  - `FieldOpacity.ts`, `FieldColorize.ts`, `FieldConstColor.ts`
  - `FieldConstNumber.ts`, `FieldMapVec2.ts`, `FieldMapNumber.ts`
  - `FieldHash01ById.ts`

- [ ] **Position blocks** (3 files)
  - `PositionMapLine.ts`, `PositionMapCircle.ts`, `PositionMapGrid.ts`

- [ ] **Render blocks** (1 file)
  - `RenderInstances2D.ts`

- [ ] **Rhythm blocks** (2 files)
  - `EnvelopeAD.ts`, `PulseDivider.ts`

- [ ] **Legacy blocks** (2 files)
  - `PhaseClockLegacy.ts`

#### P3: Hot-Swap Integration
- [ ] **Add Config input detection**
  - Implement `isConfigInput()` helper
  - Update change classifier in Player
  - Add test for Config edit triggering topology change

- [ ] **Update hot-swap logic**
  - Detect Config input value changes
  - Classify as topology change
  - Apply crossfade behavior

#### P4: Testing & Validation
- [ ] **Unit tests for Default Sources**
  - Test `createDefaultSourceArtifact()` for all worlds
  - Test type coercion edge cases
  - Test neutral value fallbacks

- [ ] **Compiler integration tests**
  - Test patch with no connections (all Default Sources)
  - Test mixed: wire + bus + Default Source
  - Test TimeModel inference without params

- [ ] **Hot-swap tests**
  - Test Config input edit triggers topology change
  - Test Signal/Field/Scalar edits do not trigger topology change

- [ ] **Golden Patch verification**
  - Breathing Constellation still works
  - No params references in compiled output
  - Scrubbing still deterministic

#### P5: Cleanup
- [ ] **Remove deprecated code**
  - Remove old BlockCompiler signature (with params)
  - Remove params access from all compilers
  - Remove params from test fixtures

- [ ] **Update documentation**
  - Update compiler architecture docs
  - Document Default Source behavior
  - Add migration guide for custom blocks

---

## Testing Strategy

### Test Coverage Requirements

1. **Default Source Artifact Generation**
   ```typescript
   describe('createDefaultSourceArtifact', () => {
     it('creates Signal<number> constant from number defaultValue', () => {
       const artifact = createDefaultSourceArtifact(
         'Signal<number>',
         42,
         { blockId: 'test', port: 'input' }
       );
       expect(artifact.kind).toBe('Signal:number');
       const signal = artifact.value as (t: number, ctx: any) => number;
       expect(signal(0, {})).toBe(42);
       expect(signal(1000, {})).toBe(42); // Time-invariant
     });

     it('creates Field<vec2> uniform from vec2 defaultValue', () => {
       const artifact = createDefaultSourceArtifact(
         'Field<vec2>',
         { x: 10, y: 20 },
         { blockId: 'test', port: 'pos' }
       );
       expect(artifact.kind).toBe('Field:vec2');
       const field = artifact.value as (seed: number, n: number) => Vec2[];
       const result = field(0, 5);
       expect(result).toHaveLength(5);
       expect(result[0]).toEqual({ x: 10, y: 20 });
       expect(result[4]).toEqual({ x: 10, y: 20 });
     });

     it('creates Scalar:number from number defaultValue', () => {
       const artifact = createDefaultSourceArtifact(
         'Scalar:number',
         100,
         { blockId: 'test', port: 'count' }
       );
       expect(artifact.kind).toBe('Scalar:number');
       expect(artifact.value).toBe(100);
     });

     it('falls back to neutral value if defaultValue undefined', () => {
       const artifact = createDefaultSourceArtifact(
         'Signal<number>',
         undefined,
         { blockId: 'test', port: 'input' }
       );
       const signal = artifact.value as (t: number, ctx: any) => number;
       expect(signal(0, {})).toBe(0); // Neutral value for number
     });
   });
   ```

2. **Compiler Input Resolution**
   ```typescript
   describe('Compiler Default Source Resolution', () => {
     it('uses wire connection over Default Source', () => {
       const patch = {
         blocks: new Map([
           ['const', { id: 'const', type: 'ConstNumber', params: { value: 5 } }],
           ['user', { id: 'user', type: 'BlockWithInput', params: {} }],
         ]),
         connections: [
           { from: { blockId: 'const', port: 'out' }, to: { blockId: 'user', port: 'input' } }
         ],
       };
       const result = compilePatch(patch, registry, seed, ctx);
       expect(result.ok).toBe(true);
       // Verify 'user' input comes from 'const', not Default Source
     });

     it('uses Default Source when no connection', () => {
       const patch = {
         blocks: new Map([
           ['user', { id: 'user', type: 'BlockWithInput', params: {} }],
         ]),
         connections: [],
       };
       const result = compilePatch(patch, registry, seed, ctx);
       expect(result.ok).toBe(true);
       // Verify 'user' input uses Default Source value
     });

     it('uses bus listener over Default Source', () => {
       const patch = {
         blocks: new Map([
           ['pub', { id: 'pub', type: 'Publisher', params: {} }],
           ['sub', { id: 'sub', type: 'Subscriber', params: {} }],
         ]),
         connections: [],
         buses: [{ id: 'testBus', type: { world: 'signal', domain: 'number' }, combineMode: 'last' }],
         publishers: [{ from: { blockId: 'pub', slotId: 'out' }, busId: 'testBus' }],
         listeners: [{ to: { blockId: 'sub', slotId: 'input' }, busId: 'testBus' }],
       };
       const result = compilePatch(patch, registry, seed, ctx);
       expect(result.ok).toBe(true);
       // Verify 'sub' input comes from bus, not Default Source
     });
   });
   ```

3. **TimeModel Inference Without Params**
   ```typescript
   describe('TimeModel Inference', () => {
     it('infers finite time from FiniteTimeRoot default duration', () => {
       const patch = {
         blocks: new Map([
           ['time', { id: 'time', type: 'FiniteTimeRoot', params: {} }],
         ]),
         connections: [],
       };
       const result = compilePatch(patch, registry, seed, ctx);
       expect(result.ok).toBe(true);
       expect(result.timeModel.kind).toBe('finite');
       expect(result.timeModel.durationMs).toBe(5000); // Default from block def
     });
   });
   ```

4. **Config Input Hot-Swap**
   ```typescript
   describe('Config Input Hot-Swap', () => {
     it('classifies Config input change as topology change', () => {
       const oldPatch = createPatchWithConfigValue('mode', 'circles');
       const newPatch = createPatchWithConfigValue('mode', 'squares');

       const changeClass = classifyChange(oldPatch, newPatch);
       expect(changeClass.class).toBe('topology');
       expect(changeClass.reason).toContain('Config input');
     });

     it('does NOT classify Signal input change as topology change', () => {
       const oldPatch = createPatchWithSignalDefault('radius', 10);
       const newPatch = createPatchWithSignalDefault('radius', 20);

       const changeClass = classifyChange(oldPatch, newPatch);
       expect(changeClass.class).toBe('parameter');
     });
   });
   ```

### Integration Test: Full Pipeline

```typescript
describe('Default Sources E2E', () => {
  it('compiles and runs patch with no explicit connections', () => {
    // Patch: GridDomain → RenderInstances2D (no wires, all Default Sources)
    const patch = {
      blocks: new Map([
        ['grid', { id: 'grid', type: 'GridDomain', params: {} }],
        ['render', { id: 'render', type: 'RenderInstances2D', params: {} }],
      ]),
      connections: [
        // Only connect domain and positions - everything else is Default Source
        { from: { blockId: 'grid', port: 'domain' }, to: { blockId: 'render', port: 'domain' } },
        { from: { blockId: 'grid', port: 'pos0' }, to: { blockId: 'render', port: 'positions' } },
      ],
    };

    const result = compilePatch(patch, registry, seed, ctx);
    expect(result.ok).toBe(true);

    // Run the program
    const frame = result.program.signal(0, runtimeCtx);
    expect(frame).toBeDefined();
    expect(frame.children.length).toBeGreaterThan(0);

    // Verify default values were applied:
    // - radius: default (e.g., 5)
    // - opacity: default (1.0)
    // - color: default (#000000)
  });
});
```

---

## Definition of Done

### Functional Acceptance Criteria

- [ ] **No `params` access in any compiler code**
  - `grep -r "params\." src/editor/compiler/` returns zero results
  - All block compilers read from `inputs` only

- [ ] **All inputs resolve to artifacts**
  - Wire → upstream artifact
  - Bus listener → combined bus value with lens
  - Neither → Default Source artifact from slot.defaultValue

- [ ] **World types implemented**
  - Signal<T> → constant signal function
  - Field<T> → uniform field function
  - Scalar:T → direct value
  - Config:T → direct value + hot-swap detection

- [ ] **TimeModel inference works without params**
  - Reads from block definition defaults
  - All three TimeRoot types supported
  - Graceful fallback if defaults missing

- [ ] **Config inputs trigger topology changes**
  - Hot-swap detector identifies Config edits
  - Crossfade behavior applied
  - Signal/Field edits still allow fast hot-swap

### Test Coverage Criteria

- [ ] **Unit tests pass (100% coverage for new code)**
  - `defaultSources.ts` fully tested
  - All artifact generators covered
  - Type coercion edge cases handled

- [ ] **Integration tests pass**
  - Wire-only compiler with Default Sources
  - Bus-aware compiler with Default Sources
  - Mixed wires + buses + Default Sources

- [ ] **Golden Patch verification**
  - Breathing Constellation compiles
  - No runtime errors
  - Deterministic output (same seed = same result)

- [ ] **Regression tests pass**
  - All existing compiler tests still pass
  - No breaking changes to stable APIs

### Performance Criteria

- [ ] **Compilation time unchanged**
  - Default Source generation is O(1) per input
  - No new loops or expensive operations

- [ ] **Runtime performance unchanged**
  - Constant signal/field functions are cheap
  - No observable performance regression

### Documentation Criteria

- [ ] **Inline documentation complete**
  - All new functions have TSDoc comments
  - Complex logic has explanatory comments
  - Examples in doc comments

- [ ] **Architecture docs updated**
  - Compiler docs mention Default Sources
  - Input resolution algorithm documented
  - Config input behavior explained

---

## Risk Assessment

### High Risk Items

1. **BLOCKER: Slot.defaultValue field missing**
   - **Risk:** Cannot implement without this field
   - **Mitigation:** Verify Phase 1-3 completion before starting Phase 4
   - **Fallback:** Implement as separate metadata structure if Slot can't change

2. **Type coercion bugs**
   - **Risk:** Wrong default values cause silent failures
   - **Mitigation:** Extensive unit tests for coerceToDomain()
   - **Fallback:** Add runtime validation in artifact generators

3. **Breaking block compilers**
   - **Risk:** Migrating 28 compilers introduces bugs
   - **Mitigation:** Migrate incrementally, test each one
   - **Fallback:** Keep old signature temporarily, gradual migration

### Medium Risk Items

4. **TimeModel inference edge cases**
   - **Risk:** Missing defaults break time system
   - **Mitigation:** Require defaults for all TimeRoot config inputs
   - **Fallback:** Hard-coded fallbacks in inferTimeModel()

5. **Config vs. Scalar confusion**
   - **Risk:** Wrong world type breaks hot-swap behavior
   - **Mitigation:** Clear documentation, lint rule for Config usage
   - **Fallback:** Treat all as Scalar initially, migrate to Config later

### Low Risk Items

6. **Performance regression**
   - **Risk:** Default Source generation adds overhead
   - **Mitigation:** Benchmark before/after, optimize if needed
   - **Fallback:** Cache Default Source artifacts per block type

---

## Open Questions

1. **Should TimeRoot params be Config or Signal inputs?**
   - Config: Static topology, easier to reason about
   - Signal: Allows dynamic speed changes (advanced use case)
   - **Recommendation:** Config for Phase 4, upgrade path to Signal later

2. **How to handle optional vs. required inputs with Default Sources?**
   - Current: required inputs error if unwired
   - New: required inputs use Default Source if unwired
   - **Recommendation:** All inputs are effectively "required" (always have a source)

3. **Should Default Source artifacts be cached?**
   - Pro: Avoid recreating constant functions every compile
   - Con: Adds complexity, minor perf gain
   - **Recommendation:** Start without caching, optimize if profiling shows need

4. **Error handling for malformed defaultValue?**
   - Option A: Fail compilation with clear error
   - Option B: Fall back to type neutral value, warn
   - **Recommendation:** Option B (graceful degradation) for Phase 4

5. **Lens stack with Default Sources?**
   - Can lenses be applied to Default Source artifacts?
   - Should they? (Probably not - Default Sources are local, lenses are for buses)
   - **Recommendation:** Lenses only apply to bus listeners, not Default Sources

---

## Next Steps After Phase 4

Once compiler integration is complete:

1. **Phase 5: Remove params from stores**
   - Update PatchStore, UIStateStore
   - Remove params serialization
   - Migrate test fixtures

2. **Phase 6: UI finalization**
   - Verify Inspector edits slot.defaultValue correctly
   - Add Default Source indicators on ports
   - Polish UX for switching wire/bus/Default Source

3. **Phase 7: Documentation**
   - User guide: "Every input has a default value"
   - Developer guide: "How to add new block types"
   - Migration guide: "Upgrading custom blocks"

---

## Summary

Phase 4 eliminates `block.params` from the compiler by implementing Default Source resolution. After this phase:

- **Every input always has a value** (wire, bus, or Default Source)
- **Compilers never access params** - only inputs
- **Four world types supported** (Signal, Field, Scalar, Config)
- **Config inputs integrate with hot-swap** (topology changes)
- **TimeModel infers from defaults** (no params dependency)

**Key Deliverable:** `src/editor/compiler/defaultSources.ts` with complete artifact generation logic integrated into both compilers.

**Estimated Complexity:** HIGH (28 block compilers to migrate, new artifact types, hot-swap integration)

**Blockers:** Phase 1-3 must add `Slot.defaultValue` field before this phase can begin.
