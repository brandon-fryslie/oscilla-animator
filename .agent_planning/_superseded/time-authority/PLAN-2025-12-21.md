# Implementation Plan: Time Authority Unification

## Problem Statement

The Player currently wraps time internally for cyclic time models, but the TimeRoot compilers ALSO derive phase using modulo arithmetic. This creates "two truths" about time:

1. Player wraps tMs at period boundary


The result is "accidentally correct" behavior where animations work but the architecture is unsound.

### Current Player.tick() Behavior (WRONG)
```typescript
case 'cyclic':
  // Cyclic time models wrap continuously
  if (this.tMs >= this.maxTime) {
    this.tMs = this.tMs % this.maxTime;  // <-- This should NOT happen
  }
```

### Desired Behavior
```typescript
case 'cyclic':
  // Cyclic: time advances unbounded
  // TimeRoot handles phase derivation via modulo arithmetic
  // Player just ensures non-negative
  if (this.tMs < 0) {
    this.tMs = 0;
  }
  break;
```

## Implementation Steps

### Step 1: Modify Player.tick() Time Handling

In `src/editor/runtime/player.ts`, change the TimeModel handling in tick():

**Before:**
```typescript
switch (this.timeModel.kind) {
  case 'cyclic':
    if (this.tMs >= this.maxTime) {
      this.tMs = this.tMs % this.maxTime;
    } else if (this.tMs < 0) {
      this.tMs = this.maxTime + (this.tMs % this.maxTime);
    }
    break;
  // ...
}
```

**After:**
```typescript
switch (this.timeModel.kind) {
  case 'cyclic':
    // Cyclic: TimeRoot handles phase derivation
    // Player provides monotonic time (just clamp to non-negative)
    if (this.tMs < 0) {
      this.tMs = 0;
    }
    break;

  case 'infinite':
    // Infinite: same - unbounded time
    if (this.tMs < 0) {
      this.tMs = 0;
    }
    break;

  case 'finite':
    // Finite: allow time to go past duration
    // Program handles clamping progress to 1.0
    // Only pause when past duration if finiteLoopMode=false
    if (this.tMs >= this.maxTime && !this.finiteLoopMode) {
      this.tMs = this.maxTime;
      this.pause();
    } else if (this.tMs >= this.maxTime && this.finiteLoopMode) {
      // Loop back to start for finite loop mode
      this.tMs = this.tMs % this.maxTime;
    }
    if (this.tMs < 0) {
      this.tMs = 0;
    }
    break;
}
```

### Step 2: Verify TimeRoot Compilers

Check that TimeRoot compilers correctly derive phase from monotonic time:


```typescript
const phaseA: SignalNumber = (tMs) => {
  const cycles = tMs / periodMs;
  const phase = cycles - Math.floor(cycles); // 0..1
  // ...
};
```

**FiniteTimeRootBlock** (already correct):
```typescript
const progress: SignalNumber = (tMs) => {
  if (tMs <= 0) return 0;
  if (tMs >= durationMs) return 1;
  return tMs / durationMs;
};
```

### Step 3: Update maxTime Semantics

The Player's `maxTime` changes meaning:
- For **finite**: Still the duration - used for pause behavior
- For **cyclic**: The period - used only for UI timeline framing, NOT for wrapping
- For **infinite**: The preview window - UI framing only

### Step 4: Test Behavior

After changes:
1. Run `just test` to ensure no regressions
2. Run `just dev` and test:

   - FiniteTimeRoot: Should pause at end (finiteLoopMode=false) or loop (finiteLoopMode=true)
   - InfiniteTimeRoot: Should advance unbounded

## Files to Modify

1. **`src/editor/runtime/player.ts`**
   - Modify tick() time wrapping logic
   - Remove cyclic tMs wrapping
   - Simplify to monotonic advancement

## Risks and Mitigations

### Risk: UI scrubber becomes unbounded for cyclic
**Mitigation**: Scrubber should show time within current period (tMs % maxTime for display), but internally tMs is monotonic.

### Risk: Existing animations break
**Mitigation**: TimeRoot compilers already use modulo arithmetic, so they'll work correctly with monotonic time.

## Verification

1. `just test` - All tests pass
2. Manual testing:

   - Watch phase ring animate
   - Verify tMs continues past period (check via console)
   - Verify phase wraps correctly (visual)
