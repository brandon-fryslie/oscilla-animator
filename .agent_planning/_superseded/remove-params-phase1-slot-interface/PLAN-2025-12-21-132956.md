# Remove Parameters Phase 1: Slot Interface Extension

**Generated**: 2025-12-21-132956
**Source STATUS**: STATUS-2025-12-21.md (UI Refactor Prep consolidated status)
**Spec Reference**: design-docs/10-Refactor-for-UI-prep/14-RemoveParams.md
**Design Principle**: "Keep exactly one concept: inputs. Replace parameters with Default Sources plus metadata."

---

## Executive Summary

**Goal**: Extend the `Slot` interface to support Default Sources, eliminating the need for separate `params`/`paramSchema` concepts while preserving UI convenience and compilation semantics.

**Current State**:
- Slot interface is minimal (4 fields: id, label, type, direction)
- Parameters live separately in `BlockDefinition.paramSchema[]` and `BlockDefinition.defaultParams`
- No connection between inputs and their default values
- UI controls are generated from ParamSchema, disconnected from port semantics

**Target State**:
- Every input slot carries its own default source metadata
- Parameters are eliminated (merged into input slots)
- UI controls are generated from slot metadata, not separate schema
- Default sources are implicit (per-port constant), not real patch blocks

**Scope**: Type definitions and migration strategy only. **NO IMPLEMENTATION** in this phase.

---

## 1. Extended Slot Interface

### 1.1 Core Type Definition

```typescript
/**
 * World classification for slots.
 * Determines evaluation timing and hot-swap behavior.
 */
export type SlotWorld =
  | 'signal'    // Time-indexed, continuous, per-frame evaluation
  | 'field'     // Per-element, lazy, bulk evaluation
  | 'scalar'    // Compile-time constant (for domain size, seed, etc.)
  | 'config';   // Compile-time selection (enum/bool), stepwise changes only

/**
 * UI presentation tier for inputs.
 * Controls visibility and layout in Inspector.
 */
export type SlotTier =
  | 'primary'    // Always visible on block face
  | 'secondary'; // Tucked under "More" / "Advanced"

/**
 * UI control hint for rendering inline input controls.
 * Determines widget type when slot is in Default Source mode.
 */
export type UIControlHint =
  | { kind: 'slider'; min: number; max: number; step: number }
  | { kind: 'number'; min?: number; max?: number; step?: number }
  | { kind: 'select'; options: readonly { value: string; label: string }[] }
  | { kind: 'color' }
  | { kind: 'boolean' }
  | { kind: 'text' };

/**
 * Default Source definition for an input slot.
 * Represents the implicit constant value when nothing is connected.
 */
export interface DefaultSource {
  /** The constant value (typed per SlotType) */
  readonly value: unknown;

  /** UI control metadata for inline editing */
  readonly uiHint: UIControlHint;

  /**
   * World classification - determines:
   * - Evaluation timing (compile vs runtime)
   * - Hot-swap behavior (topology change vs parameter change)
   */
  readonly world: SlotWorld;
}

/**
 * Extended Slot interface with Default Source support.
 *
 * BREAKING CHANGE: Adds optional fields for Phase 1.
 * Future phases will make these required for all input slots.
 */
export interface Slot {
  /** Unique identifier for this slot (unique within block) */
  readonly id: string;

  /** Human-readable label */
  readonly label: string;

  /** Type of value this slot accepts/produces */
  readonly type: SlotType;

  /** Input or output? */
  readonly direction: 'input' | 'output';

  // === NEW FIELDS (Phase 1: optional, Phase 3+: required for inputs) ===

  /**
   * Default Source for input slots.
   * Provides the constant value when nothing is connected.
   *
   * MUST be undefined for output slots.
   * SHOULD be defined for input slots (required in future phases).
   */
  readonly defaultSource?: DefaultSource;

  /**
   * UI presentation tier (primary vs secondary).
   * Controls visibility in Inspector UI.
   *
   * Only meaningful for input slots.
   * Defaults to 'primary' if not specified.
   */
  readonly tier?: SlotTier;
}
```

### 1.2 Backward Compatibility Strategy

**Phase 1 Approach**: Make new fields **optional** to avoid breaking existing code.

- `defaultSource?: DefaultSource` - Optional in Phase 1, required in Phase 3
- `tier?: SlotTier` - Optional always (defaults to 'primary')

**Migration Path**:
1. **Phase 1**: Add optional fields, update type definitions
2. **Phase 2**: Create migration helpers to derive DefaultSource from existing ParamSchema
3. **Phase 3**: Make `defaultSource` required for all input slots
4. **Phase 4**: Remove `paramSchema` and `defaultParams` from BlockDefinition

---

## 2. Relationship to Existing ParamSchema

### 2.1 Mapping ParamSchema → DefaultSource

| ParamSchema Field | Maps To | Notes |
|-------------------|---------|-------|
| `key` | Slot `id` | Must match for migration |
| `label` | Slot `label` | Redundant, slot label is authoritative |
| `type` | UIControlHint `kind` | Direct mapping (see table below) |
| `min`, `max`, `step` | UIControlHint fields | For slider/number controls |
| `options` | UIControlHint `options` | For select controls |
| `defaultValue` | DefaultSource `value` | The actual constant |

### 2.2 ParamType → UIControlHint Mapping

| ParamType | UIControlHint | World | Notes |
|-----------|---------------|-------|-------|
| `'number'` | `{ kind: 'slider', min, max, step }` | `'signal'` or `'scalar'` | If has min/max → slider, else number input |
| `'select'` | `{ kind: 'select', options }` | `'config'` | Enum selection → config world |
| `'color'` | `{ kind: 'color' }` | `'signal'` | Color is continuous signal |
| `'boolean'` | `{ kind: 'boolean' }` | `'config'` | Toggle is stepwise config |
| `'string'` | `{ kind: 'text' }` | `'scalar'` | Rare, for labels/IDs |

### 2.3 World Classification Rules

**Critical Decision**: How to determine `SlotWorld` from existing params?

**Heuristic Rules** (for automated migration):

1. **Config** (stepwise, triggers topology change):
   - ParamType = `'select'` → Config
   - ParamType = `'boolean'` → Config


2. **Signal** (continuous, per-frame modulation safe):
   - ParamType = `'number'` with continuous range → Signal
   - ParamType = `'color'` → Signal
   - Examples: `Oscillator.amplitude`, `Oscillator.bias`

3. **Scalar** (compile-time constant):
   - ParamType = `'number'` used for domain size, seed, counts → Scalar
   - Requires semantic analysis (block type + param key heuristics)
   - Examples: `GridDomain.width`, `GridDomain.height`

4. **Field** (per-element):
   - NOT derivable from params (params are always singular)
   - Fields only come from explicit Field<T> inputs

**Manual Review Required**: Some params need human judgment (e.g., is `delay` a scalar or signal?).

---

## 3. Migration Strategy

### 3.1 Phase Breakdown

#### Phase 1: Type Definitions (THIS PLAN)
**Scope**: Extend Slot interface, add new types, no code changes
**Output**: Updated `src/editor/types.ts`
**Risk**: None (additive, backward compatible)
**Effort**: 1-2 hours (type definitions + documentation)

#### Phase 2: Migration Helpers
**Scope**: Create utility functions to derive DefaultSource from ParamSchema
**Output**: `src/editor/migration/paramToSlot.ts`
**Functions**:
- `deriveDefaultSource(paramSchema: ParamSchema, slotType: SlotType): DefaultSource`
- `deriveSlotWorld(paramSchema: ParamSchema, blockType: string, paramKey: string): SlotWorld`
- `migrateBlockDefinition(oldDef: BlockDefinition): BlockDefinition` (adds defaultSource to inputs)

**Risk**: Low (utilities, not used in runtime yet)
**Effort**: 4-6 hours

#### Phase 3: Block Definition Updates
**Scope**: Update all ~50 block definitions to include defaultSource in input slots
**Approach**:
1. Run migration helper on each block
2. Manual review of `world` classification (config vs signal vs scalar)
3. Assign `tier` (primary vs secondary) per UI design

**Risk**: Medium (large surface area, requires semantic judgment)
**Effort**: 2-3 days (1-2 blocks/hour, 50 blocks)

#### Phase 4: Compiler + UI Integration
**Scope**: Use defaultSource instead of paramSchema in compiler and Inspector
**Changes**:
- Compiler: Read default values from `slot.defaultSource.value`
- Inspector: Generate UI controls from `slot.defaultSource.uiHint`
- Remove references to `block.defaultParams` and `block.paramSchema`

**Risk**: High (core runtime change)
**Effort**: 3-5 days

#### Phase 5: Cleanup
**Scope**: Remove `paramSchema` and `defaultParams` from BlockDefinition
**Changes**:
- Delete ParamSchema interface
- Delete defaultParams field
- Delete all migration helpers (no longer needed)

**Risk**: Low (final cleanup after everything migrated)
**Effort**: 2-4 hours

### 3.2 Rollout Strategy

**Incremental Rollout** (to avoid big-bang risk):

1. **Dual-Mode Support** (Phases 2-4):
   - Blocks can have EITHER old-style params OR new-style defaultSource
   - Compiler checks for `slot.defaultSource` first, falls back to `defaultParams[slot.id]`
   - Inspector checks for `slot.defaultSource.uiHint` first, falls back to `paramSchema`

2. **Migration Flag** (optional):
   ```typescript
   // src/editor/featureFlags.ts
   export const featureFlags = {
     useSlotDefaultSources: false,  // Flip to true when ready
   };
   ```

3. **Block-by-Block Migration**:
   - Start with simple blocks (Oscillator, Shaper)
   - Validate in UI + compiler before moving to next block
   - TimeRoot blocks last (most critical)

4. **Test Coverage**:
   - Add tests for `deriveDefaultSource()` helper
   - Add tests for dual-mode compiler behavior
   - Update existing block tests to verify defaultSource metadata

---

## 4. Implementation Checklist

### Phase 1: Type Definitions ✅ (THIS PLAN)

- [ ] Add `SlotWorld` type to `src/editor/types.ts`
- [ ] Add `SlotTier` type to `src/editor/types.ts`
- [ ] Add `UIControlHint` type to `src/editor/types.ts`
- [ ] Add `DefaultSource` interface to `src/editor/types.ts`
- [ ] Extend `Slot` interface with optional `defaultSource` and `tier` fields
- [ ] Add JSDoc comments explaining backward compatibility
- [ ] Export new types from `src/editor/blocks/types.ts` for use in block definitions

**Acceptance Criteria**:
- TypeScript compiles without errors
- No breaking changes to existing code (all fields optional)
- Types exported and accessible in block definition files

---

## 5. Example: Before vs After

### Before (Current State)

```typescript
// src/editor/blocks/signal.ts
export const Oscillator = createBlock({
  type: 'Oscillator',
  inputs: [
    input('phase', 'Phase', 'Signal<phase>'),  // No default!
  ],
  outputs: [
    output('out', 'Output', 'Signal<number>'),
  ],
  paramSchema: [
    {
      key: 'shape',
      label: 'Waveform',
      type: 'select',
      options: [
        { value: 'sine', label: 'Sine' },
        { value: 'cosine', label: 'Cosine' },
      ],
      defaultValue: 'sine',
    },
    {
      key: 'amplitude',
      label: 'Amplitude',
      type: 'number',
      min: 0,
      max: 10,
      step: 0.1,
      defaultValue: 1,
    },
  ],
  defaultParams: {
    shape: 'sine',
    amplitude: 1,
  },
});
```

### After (Phase 3+ Target)

```typescript
// src/editor/blocks/signal.ts
export const Oscillator = createBlock({
  type: 'Oscillator',
  inputs: [
    input('phase', 'Phase', 'Signal<phase>', {
      defaultSource: {
        value: 0.0,
        world: 'signal',
        uiHint: { kind: 'slider', min: 0, max: 1, step: 0.01 },
      },
      tier: 'primary',
    }),
    input('shape', 'Waveform', 'Config<WaveShape>', {
      defaultSource: {
        value: 'sine',
        world: 'config',
        uiHint: {
          kind: 'select',
          options: [
            { value: 'sine', label: 'Sine' },
            { value: 'cosine', label: 'Cosine' },
            { value: 'triangle', label: 'Triangle' },
            { value: 'saw', label: 'Sawtooth' },
          ],
        },
      },
      tier: 'primary',
    }),
    input('amplitude', 'Amplitude', 'Signal<number>', {
      defaultSource: {
        value: 1.0,
        world: 'signal',
        uiHint: { kind: 'slider', min: 0, max: 10, step: 0.1 },
      },
      tier: 'secondary',
    }),
    input('bias', 'Bias', 'Signal<number>', {
      defaultSource: {
        value: 0.0,
        world: 'signal',
        uiHint: { kind: 'slider', min: -10, max: 10, step: 0.1 },
      },
      tier: 'secondary',
    }),
  ],
  outputs: [
    output('out', 'Output', 'Signal<number>'),
  ],
  // paramSchema REMOVED
  // defaultParams REMOVED
});
```

**Key Changes**:
1. Former params (`shape`, `amplitude`, `bias`) are now input slots
2. Each input has a `defaultSource` with value + UI metadata
3. `tier` distinguishes primary (shape, amplitude) from secondary (bias)
4. `world` classification: `shape` is config (stepwise), `amplitude`/`bias` are signal (continuous)
5. No separate `paramSchema` or `defaultParams` arrays

---

## 6. UI Implications

### 6.1 Inspector Changes (Phase 4)

**Current**: Inspector shows two sections:
- **INPUTS**: Wired/Bus connections only
- **PARAMETERS**: All params with inline controls

**Target**: Inspector shows one section:
- **INPUTS**: All input slots with three states:
  1. **Default**: Inline control (from `uiHint`)
  2. **Bus**: Chip showing "Bus: phaseA"
  3. **Wire**: Chip showing "Wire: Oscillator.out"

**Layout**:
```
┌─ OSCILLATOR ────────────────────┐
│ Primary Inputs:                 │
│  Phase:     [Default: 0.0▶ ]    │  ← Inline slider
│  Shape:     [▼ Sine     ]       │  ← Inline dropdown
│                                  │
│ ▼ More Inputs                    │  ← Collapsible section
│  Amplitude: [▬▬▬●▬▬▬ 1.0]       │  ← Secondary inputs hidden by default
│  Bias:      [▬▬▬●▬▬▬ 0.0]       │
└──────────────────────────────────┘
```

### 6.2 Connection Interaction (Phase 4)

**When user connects wire/bus**:
1. Inline control collapses
2. Replaced with connection chip: "Bus: phaseA" or "Wire: Osc.out"
3. Chip has [×] button to disconnect → reverts to inline control

**"Drive..." Button**:
- Next to each input slot
- Opens modal to:
  - Subscribe to bus
  - Insert operator chain (e.g., Oscillator → Scale → This Input)

---

## 7. Compiler Implications

### 7.1 Default Source Resolution (Phase 4)

**Current**: Compiler reads `block.defaultParams[key]` for unconnected inputs

**Target**: Compiler reads `inputSlot.defaultSource.value` for unconnected inputs

**Implementation**:
```typescript
// src/editor/compiler/blocks/helpers.ts
function resolveInputValue(
  block: BlockInstance,
  inputSlotId: string,
  patch: PatchDocument
): unknown {
  // Check for wire connection
  const connection = patch.connections.find(
    c => c.to.blockId === block.id && c.to.slotId === inputSlotId
  );
  if (connection) {
    return compileConnection(connection, patch);
  }

  // Check for bus subscription
  const listener = patch.busListeners.find(
    l => l.blockId === block.id && l.slotId === inputSlotId
  );
  if (listener) {
    return compileBusSubscription(listener, patch);
  }

  // Use default source
  const inputSlot = block.definition.inputs.find(s => s.id === inputSlotId);
  if (!inputSlot?.defaultSource) {
    throw new CompileError(`Input '${inputSlotId}' has no default source`);
  }

  return createConstantSource(
    inputSlot.defaultSource.value,
    inputSlot.defaultSource.world
  );
}
```

### 7.2 World-Specific Default Sources

**Signal** Default Source:
```typescript
const constantSignal: Signal<number> = (t, ctx) => defaultValue;
```

**Field** Default Source:
```typescript
const constantField: Field<number> = (seed, n, ctx) => Array(n).fill(defaultValue);
```

**Scalar** Default Source:
```typescript
const scalarValue: number = defaultValue;
```

**Config** Default Source:
```typescript
const configValue: ConfigValue = defaultValue;
// Changing this triggers "topology change" hot-swap (crossfade/freeze-fade)
```

### 7.3 Hot-Swap Behavior by World

| World | Change Triggers | Hot-Swap Strategy |
|-------|-----------------|-------------------|
| `signal` | Parameter edit | **Smooth transition** - no recompile, just update constant |
| `field` | Parameter edit | **Smooth transition** - no recompile, just update constant array |
| `scalar` | Parameter edit | **Recompile** - domain size changed, must rebuild |
| `config` | Parameter edit | **Topology change** - crossfade/freeze-fade (safe swap) |

---

## 8. Risks and Mitigations

### Risk 1: World Misclassification
**Problem**: Automated migration assigns wrong `world` to a param (e.g., `delay` as scalar instead of signal)
**Impact**: Incorrect hot-swap behavior, potential runtime errors
**Mitigation**:
- Manual review of all world assignments (Phase 3)
- Add validation tests: "Does changing this param trigger correct hot-swap?"
- Document heuristics for ambiguous cases

### Risk 2: Breaking UI Workflows
**Problem**: Users expect params to be separate from inputs
**Impact**: Confusion when former params appear as inputs
**Mitigation**:
- Preserve visual distinction (primary vs secondary tiers)
- Add "What's New" doc explaining unified input model
- Gradual rollout with feature flag

### Risk 3: Large Migration Surface
**Problem**: 50+ block definitions need manual updates
**Impact**: Time-consuming, error-prone
**Mitigation**:
- Automated migration helper for 80% of cases
- Scripted validation (check all inputs have defaultSource)
- Block-by-block testing, not big-bang

### Risk 4: Composite Block Complications
**Problem**: Composites have internal parameter mapping (`{ __fromParam: 'exposedParam' }`)
**Impact**: Migration helper may not handle composite params correctly
**Mitigation**:
- Defer composite migration to Phase 3 (after primitives working)
- Special handling for `__fromParam` references
- May require composite-specific migration logic

---

## 9. Success Criteria

### Phase 1 (Type Definitions) - Definition of Done

✅ **Code Quality**:
- [ ] All new types defined in `src/editor/types.ts`
- [ ] Types exported from `src/editor/blocks/types.ts`
- [ ] JSDoc comments on all public types
- [ ] No TypeScript compilation errors

✅ **Backward Compatibility**:
- [ ] All new Slot fields are optional
- [ ] Existing block definitions compile without changes
- [ ] No runtime behavior changes

✅ **Documentation**:
- [ ] Inline comments explain each new type
- [ ] Examples show Before/After usage
- [ ] Migration strategy documented

### Overall Project - Definition of Done (Phases 1-5)

✅ **Functional**:
- [ ] No separate `paramSchema` or `defaultParams` in BlockDefinition
- [ ] All inputs have `defaultSource` metadata
- [ ] Inspector generates UI from slot metadata
- [ ] Compiler resolves defaults from slot metadata
- [ ] Hot-swap behavior correct per world classification

✅ **Testing**:
- [ ] All existing tests pass
- [ ] New tests for defaultSource resolution
- [ ] New tests for world-specific hot-swap behavior

✅ **Performance**:
- [ ] No performance regression in compilation
- [ ] No performance regression in UI rendering

---

## 10. Open Questions

### Q1: Should `tier` be on Slot or DefaultSource?
**Current Plan**: On Slot (since it's UI presentation, not default value concern)
**Alternative**: On DefaultSource (keeps all UI metadata together)
**Decision**: Slot is better - tier applies even when slot is wired/bussed

### Q2: Do we need `SlotWorld` if we have `SlotType`?
**Issue**: SlotType already encodes world (`Signal<T>` vs `Field<T>` vs `Scalar:T`)
**Why separate `world`?**: Config world is not encoded in SlotType string yet
**Resolution**: Add `Config<T>` to SlotType, derive world from SlotType instead?
**Recommendation**: Keep `world` explicit for Phase 1, revisit in Phase 2

### Q3: How to handle multi-value params (vec2, RGB)?
**Current Plan**: Not addressed - out of scope for Phase 1
**Future**: May need compound UI controls (e.g., `{ kind: 'vec2' }`)
**Defer**: To Phase 3+ when actual use cases emerge

### Q4: Should Default Sources be serialized in patch files?
**Current Plan**: No - defaults come from BlockDefinition, not patch
**Rationale**: If user changes inline control, that's a param change (stored in block.params)
**Exception**: If user "detaches" default into explicit constant block (future feature)
**Decision**: Defer to Phase 4 when implementing Inspector integration

---

## 11. Next Steps

1. **Review this plan** with stakeholders (architecture review)
2. **Get approval** for world classification heuristics (Q2 resolution)
3. **Implement Phase 1** (type definitions only, ~2 hours)
4. **Wait for Phase 2 plan** before proceeding with migration helpers

**Not in Scope for Phase 1**:
- Migration helpers (Phase 2)
- Block definition updates (Phase 3)
- Compiler/UI integration (Phase 4)
- Cleanup (Phase 5)

---

## 12. File Change Summary (Phase 1 Only)

| File | Change Type | Description |
|------|-------------|-------------|
| `src/editor/types.ts` | **Modify** | Add SlotWorld, SlotTier, UIControlHint, DefaultSource types; extend Slot interface |
| `src/editor/blocks/types.ts` | **Modify** | Re-export new types for use in block definitions |

**No other files modified in Phase 1.**

---

## Appendix A: Full Type Definitions (Reference)

See Section 1.1 for complete TypeScript definitions.

---

## Appendix B: Migration Helper Pseudocode (Phase 2 Preview)

```typescript
// src/editor/migration/paramToSlot.ts (FUTURE)
export function deriveDefaultSource(
  paramSchema: ParamSchema,
  blockType: string,
  slotType: SlotType
): DefaultSource {
  const world = deriveSlotWorld(paramSchema, blockType, paramSchema.key);
  const uiHint = deriveUIControlHint(paramSchema);

  return {
    value: paramSchema.defaultValue,
    world,
    uiHint,
  };
}

function deriveSlotWorld(
  paramSchema: ParamSchema,
  blockType: string,
  paramKey: string
): SlotWorld {
  // Config: select, boolean
  if (paramSchema.type === 'select' || paramSchema.type === 'boolean') {
    return 'config';
  }

  // Scalar: domain sizes, seeds (heuristic)
  if (isScalarParam(blockType, paramKey)) {
    return 'scalar';
  }

  // Default: signal
  return 'signal';
}

function isScalarParam(blockType: string, paramKey: string): boolean {
  // Heuristic: known scalar params
  const scalarParams = new Map([
    ['GridDomain', ['width', 'height', 'seed']],
    ['RandomDomain', ['count', 'seed']],
  ]);

  return scalarParams.get(blockType)?.includes(paramKey) ?? false;
}

function deriveUIControlHint(paramSchema: ParamSchema): UIControlHint {
  switch (paramSchema.type) {
    case 'number':
      if (paramSchema.min != null && paramSchema.max != null) {
        return {
          kind: 'slider',
          min: paramSchema.min,
          max: paramSchema.max,
          step: paramSchema.step ?? 0.1
        };
      }
      return {
        kind: 'number',
        min: paramSchema.min,
        max: paramSchema.max,
        step: paramSchema.step
      };

    case 'select':
      return {
        kind: 'select',
        options: paramSchema.options ?? []
      };

    case 'color':
      return { kind: 'color' };

    case 'boolean':
      return { kind: 'boolean' };

    case 'string':
      return { kind: 'text' };

    default:
      throw new Error(`Unknown param type: ${paramSchema.type}`);
  }
}
```

---

**END OF PLAN**
