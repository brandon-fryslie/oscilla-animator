# Event System Phase D - Current Status

**Generated**: 2025-12-20-161838
**Phase**: D (BlockReplaced event + final decoupling)
**Previous Phase**: C (Wire events + PatchStore decoupling) - COMPLETED

---

## Phase C Completion Summary

Phase C successfully delivered wire connection events and largely decoupled PatchStore from UIStateStore:

### Completed in Phase C

1. **Wire Connection Events** (`src/editor/events/types.ts`)
   - `WireAddedEvent` (lines 113-128) - Emitted when wire created between blocks
   - `WireRemovedEvent` (lines 130-145) - Emitted when wire removed
   - Both include: wireId, from {blockId, slotId}, to {blockId, slotId}

2. **Event Emission Integration** (`src/editor/stores/PatchStore.ts`)
   - Line 576-578: `connect()` emits `WireAdded` after connection created
   - Line 595-597: `disconnect()` emits `WireRemoved` after removal
   - Cascade deletion (removeBlock) emits events for each removed wire

3. **PatchStore Decoupling - Partial** (`src/editor/stores/PatchStore.ts`)
   - Direct UIStore mutation removed from `removeBlock()` (formerly lines 400-401)
   - `RootStore.setupEventListeners()` (line 77-82) handles block selection clearing via `BlockRemoved` event
   - **REMAINING**: `replaceBlock()` still has direct UIStore mutation (lines 516-517)

4. **Event Integration** (`src/editor/stores/RootStore.ts`)
   - Line 77-82: `BlockRemoved` event listener clears selection if needed
   - Demonstrates event-driven UI coordination pattern

---

## Current Phase D Scope

Phase D focuses on **final PatchStore decoupling** and introduces the `BlockReplaced` event.

### Remaining Cross-Store Coupling

**PatchStore.replaceBlock() → UIStateStore** (lines 516-517 in PatchStore.ts):
```typescript
// Update selection to new block
if (this.root.uiStore.uiState.selectedBlockId === oldBlockId) {
  this.root.uiStore.selectBlock(newBlockId);
}
```

**Impact**: This is the LAST remaining direct cross-store mutation in PatchStore. Once eliminated, PatchStore will be fully decoupled from UIStateStore.

**Context**: This occurs in `replaceBlock()`, which swaps one block for another while preserving connections. The selection update ensures UI follows the replacement.

---

## BlockReplaced Event Requirements

### Current replaceBlock() Behavior

**PatchStore.replaceBlock()** (lines 413-526):
- Creates new block with same lane and position as old block
- Maps connections from old block to new block (preserving compatible connections)
- Removes old block (emits `BlockRemoved`, `WireRemoved` events)
- **Directly mutates** `uiStore.selectedBlockId` if old block was selected
- Returns replacement result with metrics

### Missing Event

From the architectural pattern established in Phases A-C:
- **BlockReplaced** - Not yet defined

### Use Cases

BlockReplaced event enables:
1. **Undo/Redo System**: Track block replacements as atomic operations
2. **Selection Tracking**: Update UI selection reactively without coupling
3. **Audit Log**: Record block type changes and connection preservation
4. **Collaboration**: Sync replacement operations across users (future)

---

## Implementation Analysis

### BlockReplaced Event Design

**Event Payload** (new event type in `src/editor/events/types.ts`):
```typescript
interface BlockReplacedEvent {
  type: 'BlockReplaced';
  oldBlockId: BlockId;
  oldBlockType: BlockType;
  newBlockId: BlockId;
  newBlockType: BlockType;
  preservedConnections: number;
  droppedConnections: Array<{ from: string; to: string }>;
}
```

**Rationale**:
- Includes both old and new block IDs/types for complete audit trail
- Includes connection preservation metrics for debugging/logging
- Emitted AFTER all state changes (new block created, old block removed)
- Selection update moved to event listener in RootStore

### Selection Update Migration

**Current Implementation** (PatchStore.ts lines 516-517):
- Direct mutation immediately after block removal
- Tightly couples PatchStore to UIStateStore
- Occurs in same MobX action as state changes

**Target Implementation**:
- Remove lines 516-517 from PatchStore.replaceBlock()
- Add `BlockReplaced` event listener in RootStore.setupEventListeners()
- Listener checks if `event.oldBlockId === selectedBlockId` and updates to `event.newBlockId` if so
- Maintains same UX (selection follows replacement) without coupling

**Risk**: Very low - same pattern successfully used for `BlockRemoved` and `BusDeleted` events

---

## Event System Maturity

### Events Implemented (13 total)
1. MacroExpanded ✓
2. PatchLoaded ✓
3. PatchCleared ✓
4. CompileSucceeded ✓
5. CompileFailed ✓
6. BlockAdded ✓
7. BlockRemoved ✓
8. WireAdded ✓ (Phase C)
9. WireRemoved ✓ (Phase C)
10. BindingAdded ✓ (Phase B)
11. BindingRemoved ✓ (Phase B)
12. BusCreated ✓ (Phase B)
13. BusDeleted ✓ (Phase B)

### Events for Phase D
- **BlockReplaced** (NEW) - Final piece of PatchStore decoupling

### Events in Remaining Roadmap
- BlockParamsUpdated (future - param change tracking)
- TimeRootChanged (future - runtime coordination)
- PlaybackStarted/PlaybackStopped (future - telemetry)
- DiagnosticAdded/DiagnosticCleared (future - compiler integration)
- Logging events (future - LogStore decoupling)

### Cross-Store Coupling Status

**Eliminated**:
- BusStore → UIStateStore (removed in Phase B) ✓
- PatchStore → UIStateStore in removeBlock() (removed in Phase C) ✓

**Phase D Target**:
- PatchStore → UIStateStore in replaceBlock() (lines 516-517) - FINAL COUPLING

**Remaining After Phase D** (lower priority):
- Multiple stores → LogStore (10+ direct calls in CompilerService) - Logging events
- UIStateStore → PatchStore (layout switching) - Different pattern, acceptable read-only access

---

## Compiler/LogStore Coupling Analysis

### Current LogStore Usage in CompilerService

**Direct logStore calls** (`src/editor/compiler/integration.ts`):
- Line 604: Debug log "Starting compilation..."
- Line 606: Info log "Using UnifiedCompiler..."
- Line 642, 650, 658: Debug logs for composite expansion details
- Line 675: Info log "Compiled successfully (Xms)"
- Line 695: Error logs for each compilation error
- Line 697: Warning log "Compilation failed with N error(s)"
- Line 714: Error log "Unexpected error: ..."
- Line 803: Debug log "Auto-compile triggered"

**Total**: ~10 direct logStore calls

**Assessment**:
- These are **informational/debugging** logs, not state mutations
- Logging is cross-cutting concern (acceptable to have direct access)
- Converting to events may be overkill for debug logging
- **Recommendation**: LOW PRIORITY - defer to optional future phase

### Compiler Seed Access

**Read-only UIStore access** (`src/editor/compiler/integration.ts`):
- Line 668: `const seed: Seed = store.uiStore.settings.seed;`
- Line 792: Same pattern in unified compiler path

**Assessment**:
- This is **configuration read**, not mutation
- Compiler needs seed for deterministic compilation
- Read-only coupling is generally acceptable
- **Recommendation**: ACCEPTABLE - no event needed

---

## Test Coverage

### Existing Tests
- Wire event tests: `WireAdded`, `WireRemoved` emission (Phase C)
- Block event tests: `BlockAdded`, `BlockRemoved` emission (Phase A)
- Bus event tests: `BindingAdded`, `BusCreated`, etc. (Phase B)
- Integration tests: Event-driven selection clearing for blocks and buses

### Tests Needed for Phase D
1. Unit: `replaceBlock()` emits `BlockReplaced` with correct payload
2. Unit: `BlockReplaced` event includes all replacement metadata
3. Integration: Replacing selected block updates `uiStore.selectedBlockId` to new block
4. Integration: Replacing non-selected block preserves selection
5. Integration: `BlockReplaced` event listener in RootStore works correctly
6. Unit: Connection preservation metrics in event match actual results

---

## Technical Constraints

1. **Event Synchronicity**: All events must remain synchronous (design requirement)
2. **Post-Commit Emission**: Events emitted AFTER state changes
3. **Non-Blocking Handlers**: Event handlers cannot affect control flow
4. **No Reentrancy**: Events cannot trigger state mutations in domain stores
5. **Complete Audit Trail**: `BlockReplaced` must include enough data to reconstruct the operation

---

## Known Edge Cases

### BlockReplaced Event

1. **Failed Replacement**: If replacement fails (e.g., invalid block type), no event should be emitted
   - Current code returns early with `success: false` result
   - Event only emitted on successful replacement

2. **Connection Preservation**: Event payload must accurately reflect which connections were preserved/dropped
   - Current code already tracks this in `mapping` object
   - Event can directly include this data

3. **Selection Transfer**: Selection update must occur even if listener added after replacement
   - Event pattern ensures consistent behavior
   - Test: Add listener after replacement, verify it would have updated correctly

4. **Multiple Listeners**: If multiple listeners update selection, last one wins
   - MobX handles this gracefully (last write wins)
   - Not a problem in practice (only RootStore should listen)

---

## Metrics

- **Total Events Defined**: 13 (after Phase C)
- **Event Listeners**: 3 (MacroExpanded, BusDeleted, BlockRemoved)
- **Emission Points**: 15+ identified locations
- **Cross-Store Coupling Sites**: 1 remaining (PatchStore.replaceBlock → UIStateStore)
- **Direct LogStore Calls**: ~10 (deferred to future phase)

---

## Phase D Success Criteria

Phase D complete when:
1. `BlockReplaced` event defined in `src/editor/events/types.ts`
2. `PatchStore.replaceBlock()` emits `BlockReplaced` event on success
3. Direct UIStore mutation removed from `PatchStore.replaceBlock()` (lines 516-517)
4. `RootStore.setupEventListeners()` subscribes to `BlockReplaced` and updates selection
5. All unit and integration tests pass
6. **Zero direct cross-store mutations in PatchStore** (full decoupling achieved)
7. Event payload includes complete replacement metadata

---

## Remaining Roadmap (Post-Phase D)

### High-Value Events (Future Phases)

**BlockParamsUpdated Event** (Medium Priority)
- **Trigger**: `PatchStore.updateBlockParams()`
- **Use Case**: Undo/redo, param change history, collaboration sync
- **Payload**: `{ blockId, changedParams, oldValues, newValues }`
- **Coupling Eliminated**: None (no coupling here, just observability)
- **Effort**: Small (1-2 hours)

**TimeRootChanged Event** (High Priority for Runtime)
- **Trigger**: When TimeRoot block replaced or params changed
- **Use Case**: Player needs to reconfigure time model
- **Payload**: `{ timeModel: TimeModel }`
- **Coupling Eliminated**: Player → Compiler (indirect)
- **Effort**: Medium (needs TimeRoot detection logic)

### Medium-Value Events (Optional)

**PlaybackStarted/PlaybackStopped Events** (Low Priority)
- **Trigger**: `UIStateStore.play()`, `UIStateStore.pause()`
- **Use Case**: Telemetry, analytics, external integrations
- **Payload**: `{ timestamp: number }`
- **Coupling Eliminated**: None (observability only)
- **Effort**: Small (1 hour)

**CompileStarted Event** (Low Priority)
- **Trigger**: Beginning of `CompilerService.compile()`
- **Use Case**: Loading indicators, performance tracking
- **Payload**: `{ blockCount: number, connectionCount: number }`
- **Coupling Eliminated**: None
- **Effort**: Trivial (30 mins)

### Low-Value / Optional Events

**DiagnosticAdded/DiagnosticCleared Events** (Very Low Priority)
- **Trigger**: Compiler validation errors
- **Use Case**: External error tracking, IDE integration
- **Payload**: `{ diagnostics: Array<...> }`
- **Coupling Eliminated**: None (diagnostic state doesn't exist yet)
- **Effort**: Medium (needs diagnostic state infrastructure)
- **Note**: Would require implementing a diagnostic state system first

**Logging Events** (Very Low Priority)
- **Trigger**: Replace ~10 direct `logStore` calls with events
- **Use Case**: Complete LogStore decoupling
- **Events**: `LogDebug`, `LogInfo`, `LogWarn`, `LogError`
- **Coupling Eliminated**: CompilerService → LogStore
- **Effort**: Medium (2-3 hours)
- **Note**: May be overkill for debug logging - logging is cross-cutting concern

**Selection Change Events** (Very Low Priority)
- **Trigger**: `uiStore.selectedBlockId` changes
- **Use Case**: Analytics, external UI coordination
- **Payload**: `{ oldBlockId, newBlockId }`
- **Coupling Eliminated**: None (observability only)
- **Effort**: Small (1 hour)
- **Note**: Not needed for decoupling - selection is already reactive via MobX

---

## Recommendations

### Phase D Priority: HIGH
- Completes PatchStore decoupling (major architectural goal)
- Minimal effort, clear requirements
- Follows established pattern from Phases A-C
- **Decision: PROCEED with Phase D**

### Post-Phase D Priorities

**Tier 1 (High Value, Consider Next)**:
1. **BlockParamsUpdated** - Enables undo/redo for param changes
2. **TimeRootChanged** - Critical for proper runtime/player coordination

**Tier 2 (Medium Value, Optional)**:
3. **PlaybackStarted/PlaybackStopped** - Nice for telemetry
4. **CompileStarted** - Useful for loading states

**Tier 3 (Low Value, Defer Indefinitely)**:
5. **Logging Events** - Overkill for cross-cutting debug logs
6. **DiagnosticAdded/DiagnosticCleared** - No diagnostic system exists yet
7. **Selection Change Events** - MobX reactivity already sufficient

---

## Phase D Implementation Estimate

- **Event Definition**: 15 minutes (straightforward interface)
- **Event Emission**: 15 minutes (add emit() call in replaceBlock)
- **Selection Listener**: 15 minutes (add listener in RootStore)
- **Remove Coupling**: 5 minutes (delete 2 lines)
- **Unit Tests**: 30 minutes (2-3 test cases)
- **Integration Tests**: 30 minutes (selection update scenarios)
- **Total**: ~2 hours

**Confidence**: Very High (identical pattern to Phase C)
