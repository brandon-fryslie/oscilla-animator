# Status Evaluation: Event System Implementation
Timestamp: 2025-12-20-143632
Confidence: FRESH
Git Commit: c69c1fa
Files in Scope: 12

## Scope
Feature: Implement typed, scoped event system per design-docs/4-Event-System/1-Events.md

## What Exists

### Store Architecture (COMPLETE)
**Files**: `src/editor/stores/*.ts`
- **Status**: COMPLETE
- **Evidence**:
  - `RootStore.ts`: Top-level store container (lines 13-182)
  - `PatchStore.ts`: Block/connection management (lines 45-667)
  - `BusStore.ts`: Bus management
  - `UIStateStore.ts`: UI state
  - `CompositeStore.ts`: Composite definitions
- **Architecture**: MobX observable stores, clear hierarchy

**Assessment**: Store architecture is mature and well-organized. RootStore is the natural place for event dispatcher ownership.

### LogStore (COMPLETE - Singleton Pattern)
**File**: `src/editor/logStore.ts`
- **Status**: COMPLETE
- **Evidence**: Lines 25-261
- **Functionality**:
  - Observable log entries
  - `autoClearOnMacro: boolean = true` flag (line 43)
  - `clear()` method (lines 196-199)
  - Singleton export: `export const logStore = new LogStore()` (line 260)
- **Current Pattern**: Singleton (not integrated into RootStore)

**Assessment**: LogStore is the primary consumer for MacroExpanded event. Already has state management for auto-clear behavior.

### Compiler Integration (COMPLETE)
**File**: `src/editor/compiler/integration.ts`
- **Status**: COMPLETE
- **Evidence**: Lines 600-713
- **Functionality**:
  - `compile()` method in CompilerService (lines 601-713)
  - Success logging: `logStore.info('compiler', 'Compiled successfully')` (line 676)
  - Error logging: `logStore.error('compiler', ...)` (lines 688-692)
  - Returns `CompileResult` with `ok: boolean` and `errors: []`

**Assessment**: Clear hook points for CompileSucceeded and CompileFailed events.

### Macro Expansion (COMPLETE)
**File**: `src/editor/stores/PatchStore.ts`
- **Status**: COMPLETE
- **Evidence**: Lines 229-320
- **Functionality**:
  - `expandMacro(expansion: MacroExpansion): BlockId`
  - Clears patch first (line 231)
  - Creates blocks with ref-to-id mapping (lines 237-259)
  - Creates connections (lines 262-268)
  - Returns first block ID (line 319)

**Assessment**: Clear emission point for MacroExpanded event. Need to track created block IDs for event payload.

### Patch Lifecycle (COMPLETE)
**File**: `src/editor/stores/RootStore.ts`
- **Status**: COMPLETE
- **Evidence**:
  - `loadPatch(patch: Patch)`: Lines 103-150
  - `clearPatch()`: Lines 162-177
  - `loadDemoAnimation()`: Lines 179-181

**Assessment**: Clear emission points for PatchLoaded and PatchCleared events.

### Block Management (COMPLETE)
**File**: `src/editor/stores/PatchStore.ts`
- **Status**: COMPLETE
- **Evidence**:
  - `addBlock(...)`: Lines 178-223
  - `removeBlock(id: BlockId)`: Lines 362-384

**Assessment**: Clear emission points for BlockAdded and BlockRemoved events.

## What's Missing

### MISSING: Event System Infrastructure
**Status**: NOT_STARTED
**Required**: Core event dispatcher and type definitions

**Need to Create**:
1. **`src/editor/events/types.ts`** - Event type union and interfaces
2. **`src/editor/events/EventDispatcher.ts`** - Event emitter class
3. **`src/editor/events/index.ts`** - Public API exports

**Design Requirements** (from design doc):
- Typed discriminated union (no stringly-typed event names)
- Synchronous-only (no async handlers)
- Non-blocking (handlers can't affect control flow)
- Scoped to EditorStore instance
- Traceable (easy logging/debugging)
- Testable

**API Surface**:
```typescript
class EventDispatcher {
  emit<T extends EditorEvent>(event: T): void
  on<T extends EditorEvent['type']>(
    type: T,
    handler: (event: Extract<EditorEvent, { type: T }>) => void
  ): () => void
  subscribe(handler: (event: EditorEvent) => void): () => void
}
```

### MISSING: Event Type Definitions
**Status**: NOT_STARTED
**Required**: Discriminated union for all domain events

**Phase A Events** (from design doc):
```typescript
type EditorEvent =
  | { type: 'MacroExpanded'; macroId: string; createdBlockIds: string[] }
  | { type: 'PatchLoaded'; blockCount: number; connectionCount: number }
  | { type: 'PatchCleared' }
  | { type: 'CompileSucceeded'; durationMs: number }
  | { type: 'CompileFailed'; errorCount: number; errors: CompileError[] }
  | { type: 'DiagnosticCleared' }
  | { type: 'BlockAdded'; blockId: string; blockType: string; laneId: string }
  | { type: 'BlockRemoved'; blockId: string }
```

**Note**: DiagnosticCleared is in design doc but no diagnostic system exists yet. Will defer to Phase B.

### MISSING: RootStore Event Integration
**Status**: NOT_STARTED
**Required**: Add EventDispatcher to RootStore

**Changes Needed** in `src/editor/stores/RootStore.ts`:
```typescript
import { EventDispatcher } from '../events';

export class RootStore {
  // Existing stores
  patchStore: PatchStore;
  busStore: BusStore;
  uiStore: UIStateStore;
  compositeStore: CompositeStore;

  // NEW
  events: EventDispatcher;

  constructor() {
    this.events = new EventDispatcher();
    // ... existing store initialization
  }
}
```

### MISSING: Event Emissions
**Status**: NOT_STARTED
**Required**: Add emit calls at lifecycle points

**Emission Points**:
1. **PatchStore.expandMacro()** (line 229) - Emit MacroExpanded
2. **RootStore.loadPatch()** (line 103) - Emit PatchLoaded
3. **RootStore.clearPatch()** (line 162) - Emit PatchCleared
4. **CompilerService.compile()** (line 675/678) - Emit CompileSucceeded/Failed
5. **PatchStore.addBlock()** (line 178) - Emit BlockAdded
6. **PatchStore.removeBlock()** (line 362) - Emit BlockRemoved

**Critical Pattern**: Emit AFTER state changes committed, never before.

**Status**: NOT_STARTED
**Required**: LogStore subscribes to MacroExpanded event

**Use Case**: Auto-clear logs when macro expanded (if `autoClearOnMacro` enabled)

**Implementation Pattern**:
```typescript
// In LogStore constructor or setup function
store.events.on('MacroExpanded', () => {
  if (this.autoClearOnMacro) {
    this.clear();
  }
});
```

**Architectural Question**: LogStore is currently a singleton, but events are on RootStore instance. Need to either:
1. Pass RootStore to LogStore constructor
3. Convert LogStore to instance owned by RootStore

**Recommendation**: Option 3 (integrate LogStore into RootStore) for consistency.

### MISSING: Test Coverage
**Status**: NOT_STARTED
**Required**: Unit tests for event system

**Test Files to Create**:
1. **`src/editor/events/__tests__/EventDispatcher.test.ts`** - Core emitter tests
2. **`src/editor/__tests__/event-integration.test.ts`** - Store integration tests

**Test Cases**:
- Event emission works
- Multiple handlers receive events
- Unsubscribe works
- Handler errors are isolated (don't break other handlers)
- MacroExpanded clears logs when enabled
- MacroExpanded preserves logs when disabled

## Data Flow Verification

### Current State (No Events)
| Action | Process | Side Effects |
|--------|---------|--------------|
| Expand Macro | `PatchStore.expandMacro()` | None (needs manual coupling) |
| Load Patch | `RootStore.loadPatch()` | None |
| Compile | `CompilerService.compile()` | Direct log calls |

### Target State (With Events)
|--------|------|-----------|
| Expand Macro | MacroExpanded | LogStore.clear() (if enabled) |
| Load Patch | PatchLoaded | (future: analytics, UI updates) |
| Compile Success | CompileSucceeded | (future: status updates) |
| Compile Fail | CompileFailed | (future: error panel) |
| Add Block | BlockAdded | (future: analytics) |
| Remove Block | BlockRemoved | (future: undo stack) |

**Decoupling Benefit**: LogStore doesn't need to be imported in PatchStore.

## Implementation Risks

### Risk: Circular Dependencies
**Concern**: RootStore creates stores, stores emit via RootStore.events
**Mitigation**: Events created first in RootStore constructor, passed to stores
**Impact**: LOW - Standard dependency injection pattern

### Risk: Synchronous Handler Performance
**Concern**: Many handlers on high-frequency events could slow UI
**Mitigation**: Design doc explicitly forbids high-frequency events (frame ticks, etc.)
**Impact**: NONE - Only lifecycle events in Phase A

### Risk: Handler Error Propagation
**Mitigation**: EventDispatcher must try/catch each handler
**Impact**: MEDIUM - Must implement error isolation

**Required Pattern**:
```typescript
emit(event: EditorEvent): void {
  for (const handler of this.handlers) {
    try {
      handler(event);
    } catch (error) {
      console.error('Event handler error:', error);
      // Isolated - other handlers still run
    }
  }
}
```

### Risk: Forgetting to Unsubscribe
**Concern**: Memory leaks from dangling handlers
**Mitigation**: Return unsubscribe function from `on()`, document cleanup requirements
**Impact**: MEDIUM - Need to document cleanup patterns

**Pattern**:
```typescript
// Component lifecycle
const unsubscribe = store.events.on('MacroExpanded', handler);
// ... later
unsubscribe();
```

### Risk: LogStore Singleton vs. Instance
**Concern**: LogStore is singleton but events are scoped to RootStore instance
**Decision**: Convert LogStore to RootStore-owned instance for consistency
**Impact**: LOW - Small refactor, improves architecture

## Test Suite Assessment

**Existing Tests**: None for event system (doesn't exist yet)

**Required Tests**:
1. **EventDispatcher unit tests** - Core functionality
2. **Event emission tests** - Verify events emitted at correct times
4. **MacroExpanded integration test** - End-to-end log clearing

**Coverage Gap**: Complete (new feature, no existing coverage)

## Known LLM Blind Spots Check

- [x] **State persistence**: Events are ephemeral (no persistence needed)
- [x] **Second run**: Idempotent emissions (safe to emit multiple times)
- [x] **Concurrent access**: Single-threaded (no concurrency issues)
- [x] **Error handling**: Must isolate handler errors (see Risk section)
- [x] **Edge cases**: Empty handler list (no-op, safe)
- [ ] **Unsubscribe timing**: Need to verify cleanup in React components

**Blind Spot Alert**: React component cleanup patterns - need to ensure `useEffect` cleanup calls unsubscribe.

## Ambiguities Found

### Ambiguity 1: LogStore Singleton Pattern
**Question**: Should LogStore remain a singleton or be integrated into RootStore?
**Current**: Singleton (`export const logStore = new LogStore()`)
**Spec Says**: Events should be scoped (per EditorStore instance)
**Implication**: If multiple RootStore instances possible (e.g., tests), singleton breaks scoping

**Recommendation**: Integrate LogStore into RootStore (like other stores)

### Ambiguity 2: DiagnosticCleared Event
**Question**: What is "DiagnosticCleared" in design doc?
**Current State**: No diagnostic system exists in codebase
**Evidence**: Grep for "diagnostic" found no results

**Recommendation**: Defer DiagnosticCleared to Phase B (not in initial implementation)

### Ambiguity 3: MacroId in MacroExpanded Event
**Question**: What is "macroId" for MacroExpanded event?
**Current State**: `expandMacro()` receives `MacroExpansion` object, not macro ID
**Evidence**: `PatchStore.ts` line 229

**Options**:
1. Add macro type to MacroExpansion interface
2. Use macro's first block type as ID
3. Omit macroId (just emit createdBlockIds)

**Recommendation**: Option 2 or 3 - use expansion.blocks[0].type or omit

## Recommendations

### Priority 1: Create Event Infrastructure (REQUIRED)
**Files**:
- `src/editor/events/types.ts` - Event type definitions
- `src/editor/events/EventDispatcher.ts` - Core dispatcher
- `src/editor/events/index.ts` - Public API

**Rationale**: Foundation for all other work

### Priority 2: Integrate LogStore into RootStore (REQUIRED)
**File**: `src/editor/stores/RootStore.ts`
**Changes**:
- Import LogStore class (not singleton)
- Add `logStore: LogStore` property
- Instantiate in constructor
- Update all imports that use singleton

**Rationale**: Fixes scoping issue, improves architecture consistency

### Priority 3: Add Event Emissions (REQUIRED)
**Files**: Multiple (see "MISSING: Event Emissions" section)
**Pattern**: `this.root.events.emit({ type: '...', ...payload })`

**Rationale**: Connect lifecycle points to event system

**File**: `src/editor/stores/RootStore.ts` (constructor)
**Code**:
```typescript
this.logStore = new LogStore();
this.events.on('MacroExpanded', () => {
  if (this.logStore.autoClearOnMacro) {
    this.logStore.clear();
  }
});
```

**Rationale**: Implements immediate use case (console-clear-on-macro)

### Priority 5: Add Test Coverage (RECOMMENDED)
**Files**: See "MISSING: Test Coverage" section

**Rationale**: Ensure event system works correctly, prevent regressions

## Persistent Runtime Checks

### Existing Checks
| Check Command | Purpose | Status |
|---------------|---------|--------|
| `just test` | Unit tests | Will add new tests |
| `just typecheck` | Type checking | Must pass |
| `just lint` | Code style | Must pass |
| `just check` | All checks | Must pass |

### New Checks (Manual)
1. **Event emission verification**:
   - Load macro, check MacroExpanded emitted
   - Load patch, check PatchLoaded emitted
   - Trigger compile, check CompileSucceeded/Failed emitted

2. **Log auto-clear verification**:
   - Add log entries
   - Load macro
   - Verify logs cleared (if auto-clear enabled)
   - Disable auto-clear
   - Load macro again
   - Verify logs preserved

## Phase B Events (Deferred)

Per design doc, these are Phase B (not implementing now):
- **CompileStarted** - Before compilation
- **ProgramSwapped** - Hot swap complete
- **PlaybackStarted/Stopped** - Transport state
- **BusCreated/Deleted** - Bus management
- **TimeRootChanged** - TimeRoot swap
- **CompositeEdited/Saved** - Composite authoring

**Rationale**: Phase A focuses on immediate value (macro log clearing, compile lifecycle).

## Dependencies

**None** - Event system is self-contained, no external dependencies.

## Migration Path

**Current**: Direct coupling (e.g., PatchStore imports logStore singleton)
**Target**: Event-driven decoupling

**Migration Strategy**:
1. Implement event system
2. Add emissions alongside existing direct calls
4. Verify both paths work
5. Remove direct coupling (future refactor)

**Risk**: LOW - Additive change, no breaking changes

## Verdict

- [x] **CONTINUE** - Path is clear, well-specified
- [ ] PAUSE - Ambiguities noted but not blockers

**Next Steps**:
1. Clarify macroId format for MacroExpanded event (use first block type or omit)
2. Implement event infrastructure (EventDispatcher + types)
3. Integrate LogStore into RootStore (break singleton pattern)
4. Add event emissions at lifecycle points
6. Add test coverage

**Complexity**: MEDIUM (new system, but well-specified)
**Risk**: LOW (additive, non-breaking)
**Dependencies**: NONE
**Immediate Value**: Decouples log clearing from macro expansion
