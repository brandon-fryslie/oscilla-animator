# Event System Phase B - Implementation Plan

**Generated**: 2025-12-20-145757
**Source**: STATUS-2025-12-20-145757.md
**Design Doc**: design-docs/4-Event-System/1-Events.md

---

## Executive Summary

Event System Phase A successfully established the event infrastructure with 7 core events and the EventDispatcher. Phase B focuses on **decoupling cross-store dependencies** and **converting UI coordination to events**.

**Total Gap**: 15+ cross-store coupling sites, 10+ direct logging calls, 8 missing event types

**Recommended Focus**: Prioritize bus lifecycle events and connection events (P0-P1), defer selection events and advanced diagnostics (P2-P3).

**Sprint Scope**: 2-3 deliverables per sprint to maintain quality and avoid architectural drift.

---

## Work Package Breakdown

### P0 (Critical): Bus Lifecycle Events

These events are foundational for bus system observability and are referenced in multiple stores.

---

#### P0-1: BindingAdded and BindingRemoved Events

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: None
**Spec Reference**: design-docs/4-Event-System/1-Events.md lines 40-41 • **STATUS Reference**: STATUS-2025-12-20-145757.md "Missing Events from Design Doc"

##### Description
Emit events when bus bindings (publishers/listeners) are created or removed. This decouples stores from directly observing bus routing changes.

**Current Coupling**:
- `PatchStore.removeBlock()` directly filters `busStore.publishers` and `busStore.listeners`
- No visibility into when bindings are added outside of block lifecycle

**Target Architecture**:
- `BusStore.addPublisher()` emits `BindingAdded` with `{ bindingId, busId, blockId, port, direction: 'publish' }`
- `BusStore.addListener()` emits `BindingAdded` with `{ bindingId, busId, blockId, port, direction: 'subscribe' }`
- `BusStore.removePublisher()` emits `BindingRemoved`
- `BusStore.removeListener()` emits `BindingRemoved`

##### Acceptance Criteria
- [ ] `BindingAddedEvent` and `BindingRemovedEvent` types defined in `types.ts`
- [ ] `BusStore.addPublisher()` emits `BindingAdded` after publisher created
- [ ] `BusStore.addListener()` emits `BindingAdded` after listener created
- [ ] `BusStore.removePublisher()` emits `BindingRemoved` after removal
- [ ] `BusStore.removeListener()` emits `BindingRemoved` after removal
- [ ] Events include: bindingId, busId, blockId, port, direction ('publish' | 'subscribe')
- [ ] Unit tests verify events emitted with correct payloads

##### Technical Notes
- Reuse existing `root.events` dispatcher (already passed to BusStore constructor)
- Direction field disambiguates publishers from listeners
- Consider future use: bus activity visualization, binding history tracking

---

#### P0-2: BusCreated and BusDeleted Events

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: None
**Spec Reference**: design-docs/4-Event-System/1-Events.md lines 42-43 • **STATUS Reference**: STATUS-2025-12-20-145757.md "Missing Events from Design Doc"

##### Description
Emit events when buses are created or deleted. Currently `BusStore.deleteBus()` directly mutates `uiStore` selection state - this should be event-driven.

**Current Coupling**:
- `BusStore.deleteBus()` (line 153-154) directly clears `uiStore.uiState.selectedBusId`

**Target Architecture**:
- `BusStore.createBus()` emits `BusCreated` with `{ busId, name, type }`
- `BusStore.deleteBus()` emits `BusDeleted` with `{ busId, name }`
- `UIStateStore` subscribes to `BusDeleted` and clears selection if needed

##### Acceptance Criteria
- [ ] `BusCreatedEvent` and `BusDeletedEvent` types defined in `types.ts`
- [ ] `BusStore.createBus()` emits `BusCreated` after bus added
- [ ] `BusStore.deleteBus()` emits `BusDeleted` before removal (includes name)
- [ ] Direct mutation of `uiStore.selectedBusId` removed from `BusStore.deleteBus()`
- [ ] `RootStore.setupEventListeners()` subscribes to `BusDeleted` and clears selection
- [ ] Events include: busId, bus name, bus type (for BusCreated)
- [ ] Unit tests verify selection cleared on BusDeleted event

##### Technical Notes
- Emit `BusDeleted` BEFORE removal so event contains bus data
- UIStore listener should check if deleted bus was selected
- Default buses created at startup will emit `BusCreated` events (expected)

---

### P1 (High): Connection Lifecycle Events

Connection events enable observability of patch graph changes and unlock future features like undo/redo.

---

#### P1-1: ConnectionAdded and ConnectionRemoved Events

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: None
**Spec Reference**: design-docs/4-Event-System/1-Events.md (implied by patch lifecycle) • **STATUS Reference**: STATUS-2025-12-20-145757.md "Missing Events"

##### Description
Emit events when connections are created or removed. This provides visibility into patch topology changes.

**Current State**:
- `PatchStore.connect()` creates connections silently
- `PatchStore.disconnect()` removes connections silently
- No way to observe connection changes without polling

**Target Architecture**:
- `PatchStore.connect()` emits `ConnectionAdded` with `{ connectionId, from, to }`
- `PatchStore.disconnect()` emits `ConnectionRemoved` with `{ connectionId, from, to }`
- Future consumers: undo/redo system, patch diff visualization

##### Acceptance Criteria
- [ ] `ConnectionAddedEvent` and `ConnectionRemovedEvent` types defined in `types.ts`
- [ ] `PatchStore.connect()` emits `ConnectionAdded` after connection created
- [ ] `PatchStore.disconnect()` emits `ConnectionRemoved` after removal
- [ ] Events include: connectionId, from {blockId, slotId}, to {blockId, slotId}
- [ ] Macro expansion connections emit individual `ConnectionAdded` events
- [ ] Unit tests verify events emitted for direct and macro-expansion connections
- [ ] Event payload matches Connection type structure

##### Technical Notes
- Macro expansion can create many connections - each should emit an event
- Consider batching for performance if >50 connections added at once
- Connection data in event allows reconstruction of patch topology

---

### P2 (Medium): Decouple Cross-Store Selection State

Remove direct mutations of UIStateStore from domain stores.

---

#### P2-1: Remove UIStore Mutation from PatchStore.removeBlock

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: None
**Spec Reference**: design-docs/4-Event-System/1-Events.md Phase B principles • **STATUS Reference**: STATUS-2025-12-20-145757.md "Store-to-Store Coupling"

##### Description
`PatchStore.removeBlock()` currently directly clears `uiStore.selectedBlockId` if the removed block was selected. This should be event-driven via the existing `BlockRemoved` event.

**Current Coupling** (PatchStore.ts line 400-401):
```typescript
if (this.root.uiStore.uiState.selectedBlockId === id) {
  this.root.uiStore.uiState.selectedBlockId = null;
}
```

**Target Architecture**:
- Remove direct mutation from `PatchStore.removeBlock()`
- `RootStore.setupEventListeners()` subscribes to `BlockRemoved` and clears selection

##### Acceptance Criteria
- [ ] Direct `uiStore.selectedBlockId` mutation removed from `PatchStore.removeBlock()`
- [ ] `RootStore.setupEventListeners()` adds handler for `BlockRemoved` event
- [ ] Handler checks if removed block was selected and clears selection
- [ ] Existing `BlockRemoved` event already includes blockId (no changes needed)
- [ ] Integration test: removing selected block clears selection
- [ ] Integration test: removing non-selected block preserves selection

##### Technical Notes
- Reuse existing `BlockRemoved` event (Phase A)
- Similar pattern to `MacroExpanded` → auto-clear logs
- Demonstrates event-driven UI state management pattern

---

### P2 (Medium): Convert Logging to Event-Driven

Replace direct `logStore` calls with event subscriptions.

---

#### P2-2: Compilation Logging via Events

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: None
**Spec Reference**: design-docs/4-Event-System/1-Events.md Phase C principles • **STATUS Reference**: STATUS-2025-12-20-145757.md "UI Coordination Opportunities"

##### Description
Currently `compiler/integration.ts` directly calls `logStore.info()`, `logStore.warn()`, and `logStore.error()`. Convert these to be driven by compilation events.

**Current Coupling** (compiler/integration.ts):
- Line 675: `logStore.info('compiler', 'Compiled successfully')`
- Line 695-697: `logStore.error()` for each compilation error
- Line 714: `logStore.error()` for unexpected errors

**Target Architecture**:
- Extend `CompileSucceeded` event with `{ durationMs, blockCount, busCount }`
- Extend `CompileFailed` event with `{ errors: CompileError[] }`
- `RootStore` subscribes to these events and logs appropriately
- Remove direct `logStore` calls from compiler

##### Acceptance Criteria
- [ ] `CompileSucceeded` event includes duration, block count, bus count
- [ ] `CompileFailed` event includes full error array (not just count)
- [ ] `RootStore.setupEventListeners()` subscribes to `CompileSucceeded` and logs
- [ ] `RootStore.setupEventListeners()` subscribes to `CompileFailed` and logs each error
- [ ] Direct `logStore` calls removed from `compiler/integration.ts` (except debug logs)
- [ ] Compilation log messages match previous format (for consistency)
- [ ] Integration test: compilation success logs appear in log panel

##### Technical Notes
- Keep debug-level logging direct for now (low-priority noise)
- Error logging should iterate over `errors` array and log each with block context
- Log format: `"${err.code}: ${err.message}${location}"`
- Success log format: `"Compiled successfully (${durationMs}ms)"`

---

### P3 (Low): Additional Events for Completeness

Optional events that improve observability but aren't required for core functionality.

---

#### P3-1: BlockParamsUpdated Event

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: None
**Spec Reference**: design-docs/4-Event-System/1-Events.md (implied) • **STATUS Reference**: STATUS-2025-12-20-145757.md "Technical Debt"

##### Description
Emit event when block parameters are updated. Useful for undo/redo and parameter change tracking.

**Current State**:
- `PatchStore.updateBlockParams()` modifies params silently
- No way to observe parameter changes

**Target Architecture**:
- `PatchStore.updateBlockParams()` emits `BlockParamsUpdated` with `{ blockId, params }`
- Future use: undo/redo, parameter history, change visualization

##### Acceptance Criteria
- [ ] `BlockParamsUpdatedEvent` type defined in `types.ts`
- [ ] `PatchStore.updateBlockParams()` emits event after update
- [ ] Event includes: blockId, updated params (full object)
- [ ] Unit tests verify event emitted with correct payload
- [ ] Event not emitted if params unchanged (optimization)

##### Technical Notes
- Consider deep equality check to avoid spurious events
- Params are mutable objects - event should contain copy or diff
- High-frequency event if user drags slider - may need throttling

---

#### P3-2: PlaybackStarted and PlaybackStopped Events

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: None
**Spec Reference**: design-docs/4-Event-System/1-Events.md lines 53-54 • **STATUS Reference**: STATUS-2025-12-20-145757.md "Missing Events from Design Doc"

##### Description
Emit events when playback starts/stops. Enables runtime telemetry and debugging.

**Current State**:
- `UIStateStore.play()` and `pause()` modify `isPlaying` silently
- No visibility into playback state changes

**Target Architecture**:
- `UIStateStore.play()` emits `PlaybackStarted`
- `UIStateStore.pause()` emits `PlaybackStopped`
- Future use: playback telemetry, timeline markers

##### Acceptance Criteria
- [ ] `PlaybackStartedEvent` and `PlaybackStoppedEvent` types defined
- [ ] `UIStateStore.play()` emits `PlaybackStarted` after state change
- [ ] `UIStateStore.pause()` emits `PlaybackStopped` after state change
- [ ] Events include: timestamp (for telemetry)
- [ ] Unit tests verify events emitted on play/pause

##### Technical Notes
- Low priority - primarily for debugging/telemetry
- Could extend with `{ currentTime, speed }` if needed
- Consider logging playback events for session replay

---

## Dependency Graph

```
P0-1 (BindingAdded/Removed) → No dependencies
P0-2 (BusCreated/Deleted)   → No dependencies
P1-1 (ConnectionAdded/Removed) → No dependencies
P2-1 (Remove UIStore Mutation) → Depends on existing BlockRemoved event (Phase A ✓)
P2-2 (Compilation Logging)    → Depends on CompileSucceeded/Failed events (Phase A ✓)
P3-1 (BlockParamsUpdated)     → No dependencies
P3-2 (Playback Events)        → No dependencies
```

**Critical Path**: P0-1 → P0-2 (bus events foundational for decoupling)

---

## Recommended Sprint Planning

### Sprint 1: Bus Lifecycle Events (P0)
**Scope**: Deliver P0-1 and P0-2
**Outcome**: Bus system fully observable via events, UIStore decoupled from BusStore

**Work Items**:
1. Add BindingAdded/BindingRemoved event types
2. Emit events from BusStore add/remove methods
3. Add BusCreated/BusDeleted event types
4. Emit events from BusStore create/delete methods
5. Move selection clearing to RootStore event listener
6. Write unit tests for all bus events

**Acceptance**: All bus lifecycle changes emit events, no direct UIStore mutations in BusStore

---

### Sprint 2: Connection Events + Selection Decoupling (P1-P2)
**Scope**: Deliver P1-1 and P2-1
**Outcome**: Connection changes observable, PatchStore fully decoupled from UIStore

**Work Items**:
1. Add ConnectionAdded/ConnectionRemoved event types
2. Emit events from PatchStore connect/disconnect methods
3. Remove UIStore mutation from PatchStore.removeBlock()
4. Add BlockRemoved event listener to RootStore
5. Write unit tests for connection events
6. Integration tests for selection clearing

**Acceptance**: All connection changes emit events, PatchStore has zero UIStore imports

---

### Sprint 3: Logging Decoupling (P2-P2)
**Scope**: Deliver P2-2
**Outcome**: Compiler fully decoupled from LogStore, logging is event-driven

**Work Items**:
1. Extend CompileSucceeded event with metadata
2. Extend CompileFailed event with error array
3. Add compilation event listeners to RootStore
4. Remove direct logStore calls from compiler/integration.ts
5. Integration tests for compilation logging

**Acceptance**: Compiler emits events only, RootStore handles all logging

---

### Future (P3): Nice-to-Have Events
**Scope**: P3-1, P3-2 as capacity allows
**Outcome**: Comprehensive event coverage for advanced features (undo/redo, telemetry)

---

## Risk Assessment

### High-Risk Items
1. **Event Ordering**: Ensuring events emitted AFTER state committed (mitigated by explicit checks)
2. **Performance**: Connection events during macro expansion (mitigate with batch flag)
3. **Breaking Changes**: Changing event payloads mid-implementation (mitigate with tests)

### Medium-Risk Items
1. **Event Fatigue**: Too many events for trivial changes (mitigate with P3 deferral)
2. **Testing Complexity**: Async event tests (mitigate with synchronous design)

### Low-Risk Items
1. **Documentation**: Keeping event docs in sync (low impact, easy to fix)

---

## Success Criteria

**Phase B Complete When**:
- [ ] All P0 items delivered and tested
- [ ] All P1 items delivered and tested
- [ ] At least 1 P2 item delivered (demonstrates UI coordination pattern)
- [ ] Zero direct cross-store mutations for implemented events
- [ ] Event types documented in `types.ts`
- [ ] Integration tests cover event-driven flows

**Long-term Success**:
- Event system becomes default coordination mechanism
- New features naturally use events (not direct coupling)
- UI coordination happens via event subscriptions
