# Full System Design - Status Report
**Generated:** 2024-12-19
**Topic:** Complete alignment review of synthesized design docs vs planning docs vs codebase

---

## Executive Summary

This report documents a comprehensive review of three sources:
1. **Synthesized Design Docs** (`design-docs/3-Synthesized/00-11`) - The authoritative specification
2. **Planning Docs** (`.agent_planning/full-system-design/00-13`) - Prior planning work
3. **Actual Codebase** - Current implementation state

The system is at a critical junction: Phase 1 (Bus-Aware Compiler) is largely complete, but the transition to Phase 2/3 (Fields, Time/Phase) is blocked by missing TimeRoot compiler implementations.

---

## SECTION 1: INCONSISTENCIES BETWEEN DOCUMENT SETS

### 1.1 TimeRoot Architecture Divergence

**Synthesized Docs (02-Time-Architecture.md):**

- TimeRoot is a **block** that declares time topology
- TimeRoot outputs include: `t`, `cycleT`, `phase`, `wrap`, `cycleIndex`
- TimeRoot auto-publishes to reserved buses (`phaseA`, `pulse`, `progress`)
- Player receives `TimeModel` from compiler

**Planning Docs (01-time-and-phase.md):**
- Uses "PhaseClock" as primary derived clock concept
- Describes "Loop Clocks" as programs, not blocks
- Uses TimeCtx with `t`, `dt`, `frame`, `mode`
- No explicit mention of TimeRoot blocks
- Describes "PhaseAccumulator" as stateful alternative

**INCONSISTENCY:** The synthesized docs introduce TimeRoot as a first-class block concept that replaces the planning docs' more abstract "loop clock" model. The synthesized docs are more concrete and implementation-focused.

**RESOLUTION NEEDED:** Confirm that TimeRoot blocks (as defined in 02-Time-Architecture.md) supersede the planning docs' PhaseClock-centric model.

---

### 1.2 Time Context Structure

**Synthesized Docs:**
- Uses unbounded `t` (time in milliseconds)
- No `mode` field in TimeCtx
- TimeModel determines UI behavior, not TimeCtx

**Planning Docs (00-core-invariants.md):**
- TimeCtx includes: `t`, `dt`, `frame`, `mode` ("scrub" or "performance")
- Mode field influences how stateful blocks behave

**Codebase (src/core/types.ts):**
- Uses `Time` (milliseconds)
- Has `Env` with `dt` and `runState`
- `RunState` enum: `run`, `pause`, `stopped`, `scrub`

**INCONSISTENCY:** Three different models for time context structure. The codebase has `runState`, planning docs have `mode`, synthesized docs de-emphasize mode.

**RESOLUTION NEEDED:** Clarify the canonical TimeCtx structure. Does it include `mode`/`runState`? How does this interact with TimeModel?

---

### 1.3 Roadmap Terminology

**Synthesized Docs (11-Roadmap.md):**
- Uses "WP0" through "WP9" (Work Packages)
- Focused on TimeRoot, Buses, Fields, Domains, Render

**Planning Docs (13-engineering-phases.md):**
- Uses "Phase 0" through "Phase 8"
- More granular breakdown
- Includes "UX Polish" and "Composites" as separate phases

**INCONSISTENCY:** Different numbering and scope for roadmap phases.

**RESOLUTION NEEDED:** Confirm which roadmap is authoritative. The synthesized docs' WP0-WP9 appears more current.

---

### 1.4 PhaseClock vs TimeRoot Responsibilities

**Synthesized Docs (02-Time-Architecture.md):**
- PhaseClock is a **secondary** clock block, NOT a topology declaration

- PhaseClock requires `tIn` OR `phaseIn` input

**Planning Docs (01-time-and-phase.md, 10-canonical-primitives.md):**
- PhaseClock is the primary derived phase mechanism
- Takes `period`, `offset`, `phaseOffset` as inputs
- Implementation: `phase(t) = fract((t + offset)/period + phaseOffset)`

**Codebase (src/editor/blocks/time-root.ts):**

- No PhaseClock block definition visible in new block system

**INCONSISTENCY:** The role of PhaseClock vs TimeRoot is unclear. Are they both needed? What's the hierarchy?

**RESOLUTION NEEDED:** Clarify: Is PhaseClock a derivative of TimeRoot outputs, or an independent concept? The synthesized docs suggest PhaseClock receives time from TimeRoot, not from raw `t`.

---

### 1.5 Block Naming Conventions

**Synthesized Docs (09-Blocks.md):**


**Planning Docs (10-canonical-primitives.md):**
- Uses names like: `DomainN`, `PositionMapGrid`, `FieldHash01ById`

**Codebase:**
- Uses mix: `DomainN`, `PositionMapGrid` (in blocks/domain.ts)

**INCONSISTENCY:** Block naming differs between docs. E.g., `GridDomain` vs `PositionMapGrid`, `StableIdHash` vs `FieldHash01ById`.

**RESOLUTION NEEDED:** Establish canonical block names. The synthesized docs should be authoritative.

---

## SECTION 2: AMBIGUITIES IN THE DESIGN

### 2.1 TimeRoot Input Constraints

**Question:** Can TimeRoot blocks have inputs? The synthesized docs say "TimeRoot cannot have upstream dependencies," but:

- If these are Signals, they must come from somewhere

**Ambiguity:** What counts as an "upstream dependency"? Scalar parameters are clearly allowed. What about optional Signal inputs like `drift`?

**RESOLUTION NEEDED:** Clarify: Are TimeRoot Signal inputs (`phaseOffset`, `drift`) allowed, or should these be scalar-only?

---

### 2.2 Event vs Trigger Terminology

**Synthesized Docs:**
- Uses "Event" type consistently
- `wrap: Event` on TimeRoot outputs
- Combine mode for pulse bus: `or`

**Planning Docs:**
- Uses both "trigger" and "event" interchangeably
- `trig: (signal, trigger)` in block specs

**Codebase (src/core/types.ts):**
- Has `EventStream`, `EventFn`, `Event<A>`
- Uses "trigger" in some contexts

**Ambiguity:** Are "event" and "trigger" the same concept? Is trigger a Signal domain or a special world?

**RESOLUTION NEEDED:** Standardize on one term and clarify the type system.

---

### 2.3 Bus Combine Modes

**Synthesized Docs (03-Buses.md):**
- Lists combine modes: `last`, `sum`, `or`

**Planning Docs (04-buses.md):**
- Lists: `last`, `sum`, `max`, `min`, `mean`, `or`

**Codebase (src/editor/compiler/compileBusAware.ts):**
- Implements: `sum`, `average`, `max`, `min`, `last`, `layer`

**Ambiguity:** Which combine modes are canonical? What is "layer"? Is it the same as "last"?

**RESOLUTION NEEDED:** Confirm canonical combine mode set and their semantics.

---

### 2.4 Domain Mismatch Handling

**Both docs say:** "Domain mismatch is a compile error"

**Question:** What constitutes a "domain mismatch"?
- Two Field buses with different element counts?
- A Field from DomainA and a Field from DomainB?
- Can adapters bridge domains?

**Ambiguity:** The rules for when domains match are not fully specified.

**RESOLUTION NEEDED:** Define precise domain matching rules.

---

### 2.5 Field Bus Combine Semantics

**Docs state:** Field buses combine pointwise, same domain required.

**Question:** If I have two Field<number> buses from the same domain, combining with `sum`:
- Is the result evaluated lazily?
- Does combining produce a new FieldExpr node?
- When does materialization happen?

**Ambiguity:** The lazy evaluation semantics for combined Field buses are not specified.

**RESOLUTION NEEDED:** Clarify Field bus combination produces FieldExpr nodes, not materialized arrays.

---

### 2.6 Adapter vs Lens Terminology

**Synthesized Docs (04-Adapters.md):**
- Uses "Adapters" and "Lenses" interchangeably
- "Adapters (also called Lenses)"

**Planning Docs (05-lenses.md):**
- Uses "Lenses" exclusively
- More detailed lens step library

**Codebase:**
- Uses `LensDefinition` in types
- Uses `adapterChain` in Publisher/Listener

**Ambiguity:** Are adapters and lenses the same? The codebase suggests adapters are per-publisher, lenses are per-listener.

**RESOLUTION NEEDED:** Clarify: Are these synonyms or distinct concepts?

---

### 2.7 State Block Scrub Policy

**Both docs mention:** State blocks must declare a "scrub policy"

**Question:** What are the valid scrub policies?
- "reconstructable from TimeCtx"?
- "performance-only"?
- Something else?

**Ambiguity:** No concrete scrub policy enum or interface is defined.

**RESOLUTION NEEDED:** Define the scrub policy interface and valid values.

---

### 2.8 Composite Expansion Timing

**Planning Docs (06-compiler-runtime.md):**
- "Do composite expansion in the unified compiler, not in editorToPatch()"
- Recommends keeping authoring format with composite references

**Synthesized Docs (05-Compilation.md):**
- "Composites are resolved (expanded) during compilation"

**Codebase:**
- `expandMacro()` exists in PatchStore (editor-level expansion)
- Compiler also has composite handling

**Ambiguity:** Should composites expand in editor or compiler? When should state IDs be assigned?

**RESOLUTION NEEDED:** Clarify composite expansion strategy.

---

### 2.9 Hot Swap State Key Derivation

**Synthesized Docs (06-Runtime.md):**
- `StateKey = { blockId: string, internalKey?: string }`
- "For composites: internal nodes derive stable IDs from composite instance + internalStableKey"

**Question:** How are stable IDs generated for:
- Blocks inside expanded composites?
- Blocks that reference other blocks?
- Domain elements?

**Ambiguity:** The exact algorithm for StateKey derivation is not specified.

**RESOLUTION NEEDED:** Define StateKey generation algorithm.

---

### 2.10 Export Phase-Driven Sampling

**Synthesized Docs (08-Export.md):**
- Describes "phase-driven sampling" for cycle export
- "Supply CycleRoot with phaseOverride"

**Question:** How does phaseOverride work mechanically?
- Is it a special export context?
- Does it bypass the normal evaluation?
- How does it interact with secondary PhaseClocks?

**Ambiguity:** The phase-driven export mechanism is described conceptually but not technically.

**RESOLUTION NEEDED:** Define the technical approach for phase-driven export.

---

## SECTION 3: UNANSWERED QUESTIONS

### 3.1 Architectural Questions

**Q1:** Should the system support both TimeRoot-based topology AND the older PhaseClock-as-primary model during migration? Or hard-switch to TimeRoot?

**Q2:** What happens to patches created before TimeRoot existed? Migration path?

**Q3:** Is there a default TimeRoot if the user doesn't add one? Or is it a hard error?

**Q4:** Can multiple Domains coexist in a patch? How do they interact?

**Q5:** How does the system handle Domain size changes during hot swap?

---

### 3.2 Implementation Questions

**Q6:** The unified compiler is behind a feature flag. When should it become default?

**Q7:** How should TypeDesc validation errors be presented in UI?

**Q8:** What's the performance target for Field evaluation? (elements/frame)

**Q9:** Should lens steps be fused during compilation or at evaluation time?

**Q10:** How does the system handle circular bus dependencies? (A publishes to B, B publishes to A)

---

### 3.3 UX Questions

**Q11:** The Time Console has three modes (Finite/Cyclic/Infinite). Should mode switching require TimeRoot block replacement?

**Q12:** How should the UI communicate "pending swap at next pulse"?



**Q14:** Should the Bus Board show Field buses differently from Signal buses?

**Q15:** How should "Heavy" operations (Signal→Field broadcast) be presented in UI?

---

### 3.4 Missing Block Definitions

**Q16:** The synthesized docs define blocks like `ColorLFO`, `PulseDivider`, `EnvelopeAD`. Are these all v1 requirements?

**Q17:** What blocks are needed for the Golden Patch that don't exist yet?

**Q18:** Should there be a `FieldReduce` block for Field→Signal conversion?

---

### 3.5 Export Questions

**Q19:** What video/image formats are targeted for v1 export?

**Q20:** How does SVG export handle FieldExpr? Pre-materialize keyframes?

**Q21:** Should infinite patches be exportable as video? What's the default capture duration?

---

## SECTION 4: CODEBASE VS SPEC GAPS

### Critical Implementation Gaps

| Spec Requirement | Status | Notes |
|------------------|--------|-------|

| FiniteTimeRoot compiler | NOT IMPLEMENTED | Block defined, no compiler |
| InfiniteTimeRoot compiler | NOT IMPLEMENTED | Block defined, no compiler |
| TimeModel extraction | NOT IMPLEMENTED | Types exist, no generation |
| Player TimeModel integration | NOT IMPLEMENTED | Player still uses loopMode |
| Exactly-one-TimeRoot validation | PARTIAL | Feature-flagged, not always enforced |
| DomainN compiler | NOT IMPLEMENTED | Block defined, no compiler |
| PositionMapGrid compiler | NOT IMPLEMENTED | Block defined, no compiler |
| Field lazy evaluation | PARTIAL | Some infrastructure, incomplete |
| Lens compilation | NOT IMPLEMENTED | Types exist, no compile logic |
| Phase-driven export | NOT IMPLEMENTED | No export pipeline |
| Hot swap scheduling | NOT IMPLEMENTED | No pulse boundary detection |

### Partial Implementations

| Component | State | Missing |
|-----------|-------|---------|
| Bus compilation | 90% | Lens application, some validation |
| BusStore | 95% | Field bus combine semantics |
| TypeDesc system | 95% | Some edge case validation |
| Block registry | 80% | Missing many block compilers |
| Time Console | 40% | Cyclic/Infinite modes are stubs |

### Legacy Code to Remove

| Item | Location | Notes |
|------|----------|-------|
| `loopMode` in Player | player.ts | Replace with TimeModel |
| `maxTime` property | player.ts | TimeModel determines duration |
| `playDirection` | player.ts | TimeModel determines behavior |
| Legacy block compilers | compiler/blocks/legacy/ | Migrate or remove |
| Wire-only compilation | compile.ts | Deprecate once buses complete |

---

## SECTION 5: RECOMMENDED ACTIONS

### Immediate Documentation Updates

1. **Unify TimeCtx definition** - Pick one structure and update all docs
2. **Standardize block names** - Use synthesized docs as authority
3. **Clarify adapter vs lens** - Define precisely
4. **Define scrub policy interface** - Concrete types needed
5. **Specify combine mode set** - Document all valid modes

### Design Decisions Needed

1. **TimeRoot input policy** - What inputs are allowed on TimeRoot?
2. **Event vs Trigger** - Pick one term
3. **Composite expansion timing** - Editor or compiler?
4. **Domain matching rules** - When do domains "match"?
5. **Export phase mechanism** - Technical approach

### Implementation Priorities (Based on WP0-WP2)

1. **WP0: Lock Contracts** - Enforce TimeRoot validation, reserved bus types
2. **WP1: TimeRoot Compilers** - Implement all three TimeRoot block compilers
3. **WP1: TimeModel Extraction** - Generate TimeModel from compiled patch
4. **WP1: Player Rewrite** - Remove loopMode, integrate TimeModel
5. **WP2: Complete Bus Compilation** - Add lens compilation

---

## VERDICT

**Status: PAUSE**

Before proceeding with implementation planning, the following must be clarified:

1. TimeRoot input policy (Q: Are Signal inputs allowed?)
2. Event vs Trigger terminology (Pick one)
3. Adapter vs Lens distinction (Clarify relationship)
4. Combine mode canonical set (Which modes are v1?)
5. Composite expansion timing (Editor or compiler?)

These questions block precise implementation planning. Resolution should take <30 minutes of user input.

---
