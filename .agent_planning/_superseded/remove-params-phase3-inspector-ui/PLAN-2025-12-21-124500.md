# Remove Parameters Phase 3: Inspector UI for Inline Default Controls

**Generated**: 2025-12-21 12:45:00
**Source Status**: STATUS-2025-12-21.md
**Spec Reference**: design-docs/10-Refactor-for-UI-prep/14-RemoveParams.md
**Phase**: 3 of 4 (Phase 1: Block Migration, Phase 2: Compiler, **Phase 3: Inspector UI**, Phase 4: BusBoard Integration)

---

## Executive Summary

Transform Inspector from separate "Parameters" and "Inputs" sections into a unified "Inputs" section where each input shows its connection state (Default / Wire / Bus) and provides inline controls for Default Source values. This is the UI manifestation of the architectural principle: **parameters are just inputs with implicit Default Source blocks**.

**Core Insight**: An input is always fed by something. That something is either:
- A Default Source (inline control visible)
- A wire connection (show connected block chip)
- A bus subscription (show bus chip with optional lens)

---

## Current State Analysis

### Current Inspector Structure (Inspector.tsx lines 812-862)

```typescript
// Side-by-side Inputs/Outputs (lines 774-810)
<div className="ports-row">
  <div className="ports-col">
    <span className="ports-header">Inputs</span>
    {block.inputs.map(slot => (
      <PortItem slot={slot} ... />  // Just shows connection dot
    ))}
  </div>
  <div className="ports-col">
    <span className="ports-header">Outputs</span>
    {block.outputs.map(slot => (
      <PortItem slot={slot} ... />
    ))}
  </div>
</div>

// SEPARATE Parameters section (lines 813-862)
{Object.keys(block.params).length > 0 && (
  <div className="insp-section">
    <span className="insp-section-title">Parameters</span>
    <div className="param-grid">
      {Object.entries(block.params).map(([key, value]) => {
        const schema = definition?.paramSchema.find(s => s.key === key);
        return (
          <div className="param-row">
            <label className="param-key">{schema?.label ?? key}</label>
            {/* Render control based on schema.type */}
          </div>
        );
      })}
    </div>
  </div>
)}
```

### Current Parameter Control Rendering (lines 823-858)

**Control Types Supported:**
1. **Select dropdown** - `schema.type === 'select'` with `schema.options`
2. **Boolean checkbox** - `typeof value === 'boolean'`
3. **Number input** - `typeof value === 'number'` with optional min/max/step
4. **Text input** - fallback for strings

**Example (Oscillator block):**
```typescript
paramSchema: [
  { key: 'shape', label: 'Waveform', type: 'select',
    options: [{ value: 'sine', label: 'Sine' }, ...], defaultValue: 'sine' },
  { key: 'amplitude', label: 'Amplitude', type: 'number',
    min: 0, max: 10, step: 0.1, defaultValue: 1 },
  { key: 'bias', label: 'Bias', type: 'number',
    min: -10, max: 10, step: 0.1, defaultValue: 0 },
]
```

---

## Target State: Unified Inputs Section

### Visual Mockup

```
┌─ INPUTS ────────────────────────────────────────┐
│ PRIMARY                                          │
│ ┌─ phase ─────────────────────────────────────┐ │
│ │ ○ Default   [Drive…]                        │ │
│ │ ├─ [sine ▾] [  1.0  ] [  0.0  ]            │ │  ← Inline controls for Default Source
│ │ └─ shape    amplitude   bias                │ │
│ └─────────────────────────────────────────────┘ │
│                                                  │
│ ┌─ radius ────────────────────────────────────┐ │
│ │ ● Bus: energy  [×] [Edit…]                 │ │  ← Bus subscription chip
│ │ └─ via scale(×10, +2)                       │ │  ← Lens indicator
│ └─────────────────────────────────────────────┘ │
│                                                  │
│ ┌─ positions ─────────────────────────────────┐ │
│ │ ● Wire: GridDomain.targets  [→] [×]        │ │  ← Wire connection chip
│ └─────────────────────────────────────────────┘ │
│                                                  │
│ SECONDARY                                [More ▾]│
│ (collapsed by default)                           │
└──────────────────────────────────────────────────┘
```

### Three Connection States

| State | Visual | Controls Visible |
|-------|--------|------------------|
| **Default** | `○ Default [Drive…]` + inline controls | ✅ Full param controls |
| **Wire** | `● Wire: BlockName.portName [→] [×]` | ❌ Chip only |
| **Bus** | `● Bus: busName [×] [Edit…]` (+ lens if present) | ❌ Chip only |

### Input Row Hierarchy

```typescript
interface InputRowState {
  // Core identity
  slotId: string;
  label: string;
  type: SlotType;

  // Connection state (mutually exclusive)
  connection:
    | { kind: 'default'; params: BlockParams }        // Show inline controls
    | { kind: 'wire'; sourceBlock: Block; sourceSlot: Slot }  // Show wire chip
    | { kind: 'bus'; busId: string; lens?: AdapterStep[] };   // Show bus chip

  // UI metadata
  tier: 'primary' | 'secondary';  // From block definition or heuristic
}
```

---

## Implementation Plan

### Phase 1: Connection State Detection (Foundation)

**File**: `src/editor/Inspector.tsx` (new helper functions)

**Task 1.1**: Create `getInputConnectionState()` helper
```typescript
function getInputConnectionState(
  blockId: string,
  slotId: string,
  patchStore: PatchStore,
  busStore: BusStore
): InputConnectionState {
  // 1. Check for wire connection (highest precedence)
  const wireConnection = patchStore.connections.find(
    c => c.to.blockId === blockId && c.to.slotId === slotId
  );
  if (wireConnection) {
    return {
      kind: 'wire',
      connectionId: wireConnection.id,
      sourceBlockId: wireConnection.from.blockId,
      sourceSlotId: wireConnection.from.slotId,
    };
  }

  // 2. Check for bus subscription
    l => l.to.blockId === blockId && l.to.slotId === slotId
  );
    return {
      kind: 'bus',
    };
  }

  // 3. Default state (no connection)
  return { kind: 'default' };
}

type InputConnectionState =
  | { kind: 'default' }
  | { kind: 'wire'; connectionId: string; sourceBlockId: string; sourceSlotId: string }
```

**Task 1.2**: Create `getDefaultSourceParams()` helper
```typescript
// Extract params that apply to this specific input
// For now, assume all block params are Default Source params for first input
// Later phases will map params to specific inputs
function getDefaultSourceParams(
  block: Block,
  slotId: string,
  definition: BlockDefinition
): { params: BlockParams; schema: ParamSchema[] } {
  // Phase 3: Simple mapping (all params belong to first input with no connection)
  // Phase 4 will add proper param-to-input mapping metadata
  return {
    params: block.params,
    schema: definition.paramSchema,
  };
}
```

**Deliverable**: Two pure helper functions with unit tests

---

### Phase 2: Unified Input Row Component

**File**: `src/editor/Inspector.tsx` (new component)

**Task 2.1**: Create `InputRow` component
```typescript
const InputRow = observer(({
  block,
  slot,
  tier,
  connectionState,
  onDrive,
  onDisconnect,
  onEditLens,
}: {
  block: Block;
  slot: Slot;
  tier: 'primary' | 'secondary';
  connectionState: InputConnectionState;
  onDrive: () => void;           // Open drive menu (wire/bus selection)
  onDisconnect: () => void;      // Remove wire/bus connection
  onEditLens?: () => void;       // Edit bus lens (if bus connection)
}) => {
  const store = useStore();
  const definition = getBlockDefinition(block.type);

  return (
    <div className="input-row" data-tier={tier}>
      <div className="input-header">
        <span className="input-label">{slot.label}</span>
        {connectionState.kind === 'default' && (
          <>
            <span className="connection-indicator default">○ Default</span>
            <button className="drive-btn" onClick={onDrive}>Drive…</button>
          </>
        )}
        {connectionState.kind === 'wire' && (
          <ConnectionChip
            kind="wire"
            sourceBlockId={connectionState.sourceBlockId}
            sourceSlotId={connectionState.sourceSlotId}
            onNavigate={() => store.uiStore.selectBlock(connectionState.sourceBlockId)}
            onDisconnect={onDisconnect}
          />
        )}
        {connectionState.kind === 'bus' && (
          <ConnectionChip
            kind="bus"
            busId={connectionState.busId}
            lens={connectionState.lens}
            onEdit={onEditLens}
            onDisconnect={onDisconnect}
          />
        )}
      </div>

      {/* Only show controls for Default state */}
      {connectionState.kind === 'default' && (
        <DefaultSourceControls
          block={block}
          slot={slot}
          definition={definition}
        />
      )}
    </div>
  );
});
```

**Task 2.2**: Create `ConnectionChip` component
```typescript
const ConnectionChip = observer(({
  kind,
  sourceBlockId,
  sourceSlotId,
  busId,
  lens,
  onNavigate,
  onEdit,
  onDisconnect,
}: {
  kind: 'wire' | 'bus';
  sourceBlockId?: string;
  sourceSlotId?: string;
  busId?: string;
  lens?: AdapterStep[];
  onNavigate?: () => void;
  onEdit?: () => void;
  onDisconnect: () => void;
}) => {
  const store = useStore();

  if (kind === 'wire') {
    const sourceBlock = store.patchStore.blocks.find(b => b.id === sourceBlockId);
    const sourceSlot = sourceBlock?.outputs.find(s => s.id === sourceSlotId);
    return (
      <div className="connection-chip wire">
        <span className="chip-icon">●</span>
        <span className="chip-label">
          Wire: {sourceBlock?.label ?? 'Unknown'}.{sourceSlot?.label ?? sourceSlotId}
        </span>
        <button className="chip-navigate" onClick={onNavigate} title="Navigate to source">→</button>
        <button className="chip-disconnect" onClick={onDisconnect} title="Disconnect">×</button>
      </div>
    );
  }

  // Bus connection
  const bus = store.busStore.buses.find(b => b.id === busId);
  return (
    <div className="connection-chip bus">
      <span className="chip-icon">●</span>
      <span className="chip-label">Bus: {bus?.name ?? busId}</span>
      {lens && lens.length > 0 && (
        <span className="chip-lens" title={describeLens(lens)}>
          via {describeLens(lens)}
        </span>
      )}
      {onEdit && <button className="chip-edit" onClick={onEdit}>Edit…</button>}
      <button className="chip-disconnect" onClick={onDisconnect} title="Unsubscribe">×</button>
    </div>
  );
});

function describeLens(lens: AdapterStep[]): string {
  // Simple lens description for now
  if (lens.length === 1) {
    return `${lens[0].adapterId}(...)`;
  }
  return `${lens.length} adapters`;
}
```

**Task 2.3**: Create `DefaultSourceControls` component
```typescript
const DefaultSourceControls = observer(({
  block,
  slot,
  definition,
}: {
  block: Block;
  slot: Slot;
  definition: BlockDefinition;
}) => {
  const store = useStore();
  const { params, schema } = getDefaultSourceParams(block, slot.id, definition);

  if (schema.length === 0) return null;

  return (
    <div className="default-source-controls">
      {schema.map(paramDef => {
        const value = params[paramDef.key];
        return (
          <div key={paramDef.key} className="control-item">
            <label className="control-label">{paramDef.label}</label>
            {renderParamControl(paramDef, value, (newValue) => {
              store.patchStore.updateBlockParams(block.id, { [paramDef.key]: newValue });
            })}
          </div>
        );
      })}
    </div>
  );
});

// Extract existing param rendering logic into reusable helper
function renderParamControl(
  schema: ParamSchema,
  value: unknown,
  onChange: (newValue: unknown) => void
): JSX.Element {
  // Exact same logic as current lines 823-858 in Inspector.tsx
  if (schema.type === 'select' && schema.options) {
    return (
      <select className="param-input" value={String(value)} onChange={e => onChange(e.target.value)}>
        {schema.options.map(opt => (
          <option key={opt.value} value={opt.value}>{opt.label}</option>
        ))}
      </select>
    );
  }
  if (typeof value === 'boolean') {
    return <input type="checkbox" checked={value} onChange={e => onChange(e.target.checked)} />;
  }
  if (typeof value === 'number') {
    return (
      <input
        type="number"
        className="param-input"
        value={value}
        step={schema.step ?? (value < 1 ? 0.1 : 1)}
        min={schema.min}
        max={schema.max}
        onChange={e => onChange(parseFloat(e.target.value) || 0)}
      />
    );
  }
  return (
    <input
      type="text"
      className="param-input"
      value={String(value)}
      onChange={e => onChange(e.target.value)}
    />
  );
}
```

**Deliverable**: Three new components with proper MobX reactivity

---

### Phase 3: Primary/Secondary Input Tiering

**File**: `src/editor/blocks/types.ts` (extend BlockDefinition)

**Task 3.1**: Add input tier metadata to Slot type
```typescript
export interface Slot {
  readonly id: string;
  readonly label: string;
  readonly type: SlotType;
  readonly tier?: 'primary' | 'secondary';  // NEW: UI prominence hint
}
```

**Task 3.2**: Update block definitions to mark secondary inputs

**Example (RenderInstances2D):**
```typescript
inputs: [
  input('domain', 'Domain', 'Domain', { tier: 'primary' }),
  input('positions', 'Positions', 'Field<vec2>', { tier: 'primary' }),
  input('radius', 'Radius', 'Field<number>', { tier: 'primary' }),
  input('color', 'Color', 'Field<color>', { tier: 'primary' }),
  input('opacity', 'Opacity', 'Signal<number>', { tier: 'secondary' }),  // Under "More"
  input('glowEnabled', 'Glow', 'Signal<boolean>', { tier: 'secondary' }),
  input('glowIntensity', 'Glow Intensity', 'Signal<number>', { tier: 'secondary' }),
],
```

**Task 3.3**: Heuristic fallback for blocks without tier metadata
```typescript
function getInputTier(slot: Slot, index: number): 'primary' | 'secondary' {
  // 1. Explicit tier annotation
  if (slot.tier) return slot.tier;

  // 2. Heuristic: first 4 inputs are primary, rest secondary
  return index < 4 ? 'primary' : 'secondary';
}
```

**Deliverable**: Updated Slot interface + tier heuristic

---

### Phase 4: Integrated Inputs Section

**File**: `src/editor/Inspector.tsx` (replace current Inputs section)

**Task 4.1**: Replace ports-row with unified InputsSection component
```typescript
const InputsSection = observer(({ block }: { block: Block }) => {
  const store = useStore();
  const definition = getBlockDefinition(block.type);
  const [showSecondary, setShowSecondary] = useState(false);

  const inputsWithState = block.inputs.map((slot, index) => ({
    slot,
    tier: getInputTier(slot, index),
    connectionState: getInputConnectionState(block.id, slot.id, store.patchStore, store.busStore),
  }));

  const primaryInputs = inputsWithState.filter(i => i.tier === 'primary');
  const secondaryInputs = inputsWithState.filter(i => i.tier === 'secondary');

  const handleDrive = useCallback((slotId: string) => {
    // Open drive menu (future: modal or dropdown with Wire/Bus options)
    // For Phase 3: Just open port wiring panel
    store.uiStore.setSelectedPort({
      blockId: block.id,
      slotId: slotId,
      direction: 'input',
    });
  }, [block.id, store]);

  const handleDisconnect = useCallback((slotId: string, connectionState: InputConnectionState) => {
    if (connectionState.kind === 'wire') {
      store.patchStore.disconnect(connectionState.connectionId);
    } else if (connectionState.kind === 'bus') {
    }
  }, [store]);

  return (
    <div className="insp-section inputs-section">
      <div className="insp-section-header">
        <span className="insp-section-title">Inputs</span>
      </div>

      {/* Primary Inputs (always visible) */}
      <div className="inputs-tier primary">
        {primaryInputs.length === 0 ? (
          <span className="ports-none">No inputs</span>
        ) : (
          primaryInputs.map(({ slot, tier, connectionState }) => (
            <InputRow
              key={slot.id}
              block={block}
              slot={slot}
              tier={tier}
              connectionState={connectionState}
              onDrive={() => handleDrive(slot.id)}
              onDisconnect={() => handleDisconnect(slot.id, connectionState)}
            />
          ))
        )}
      </div>

      {/* Secondary Inputs (collapsible) */}
      {secondaryInputs.length > 0 && (
        <>
          <div className="inputs-tier-toggle" onClick={() => setShowSecondary(!showSecondary)}>
            <span className="toggle-label">More</span>
            <span className="toggle-count">{secondaryInputs.length}</span>
            <span className="toggle-icon">{showSecondary ? '▴' : '▾'}</span>
          </div>
          {showSecondary && (
            <div className="inputs-tier secondary">
              {secondaryInputs.map(({ slot, tier, connectionState }) => (
                <InputRow
                  key={slot.id}
                  block={block}
                  slot={slot}
                  tier={tier}
                  connectionState={connectionState}
                  onDrive={() => handleDrive(slot.id)}
                  onDisconnect={() => handleDisconnect(slot.id, connectionState)}
                />
              ))}
            </div>
          )}
        </>
      )}
    </div>
  );
});
```

**Task 4.2**: Replace current Inputs + Parameters sections
```typescript
// OLD (lines 774-862):
// <div className="ports-row">...</div>  ← DELETE
// <div className="insp-section">PARAMETERS...</div>  ← DELETE

// NEW:
<InputsSection block={block} />
<OutputsSection block={block} />  // Keep outputs separate for now
```

**Deliverable**: Unified Inputs section replacing both old sections

---

### Phase 5: Styling

**File**: `src/editor/Inspector.css` (new styles)

**Task 5.1**: Add InputRow styles
```css
/* Unified Input Row */
.input-row {
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding: 8px;
  background: #1a1a1a;
  border: 1px solid #2a2a2a;
  border-radius: 4px;
  margin-bottom: 6px;
}

.input-row[data-tier="secondary"] {
  background: #151515;
}

.input-header {
  display: flex;
  align-items: center;
  gap: 8px;
}

.input-label {
  font-size: 11px;
  font-weight: 600;
  color: #ccc;
  flex: 1;
}

.connection-indicator {
  font-size: 10px;
  color: #666;
}

.connection-indicator.default {
  color: #666;
}

.drive-btn {
  padding: 2px 8px;
  background: #2a2a3a;
  border: 1px solid #3a3a4a;
  border-radius: 4px;
  color: #60a5fa;
  font-size: 10px;
  cursor: pointer;
  transition: background 0.1s;
}

.drive-btn:hover {
  background: #3a3a4a;
}

/* Connection Chips */
.connection-chip {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 3px 8px;
  border-radius: 12px;
  font-size: 10px;
  flex: 1;
}

.connection-chip.wire {
  background: #1a2a1a;
  border: 1px solid #2a4a2a;
}

.connection-chip.bus {
  background: #1a1a2a;
  border: 1px solid #2a2a4a;
}

.chip-icon {
  font-size: 8px;
}

.connection-chip.wire .chip-icon {
  color: #4ade80;
}

.connection-chip.bus .chip-icon {
  color: #60a5fa;
}

.chip-label {
  color: #ccc;
  flex: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.chip-lens {
  color: #888;
  font-size: 9px;
  font-style: italic;
}

.chip-navigate,
.chip-edit,
.chip-disconnect {
  padding: 1px 4px;
  background: transparent;
  border: 1px solid transparent;
  color: #666;
  font-size: 10px;
  cursor: pointer;
  border-radius: 3px;
  transition: all 0.1s;
}

.chip-navigate:hover {
  background: #2a3a2a;
  border-color: #4ade80;
  color: #4ade80;
}

.chip-edit:hover {
  background: #2a2a3a;
  border-color: #60a5fa;
  color: #60a5fa;
}

.chip-disconnect:hover {
  background: #3a2020;
  border-color: #ef4444;
  color: #ef4444;
}

/* Default Source Controls */
.default-source-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  padding-top: 4px;
  border-top: 1px solid #252525;
}

.control-item {
  display: flex;
  flex-direction: column;
  gap: 2px;
  min-width: 80px;
}

.control-label {
  font-size: 9px;
  color: #888;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}

/* Reuse existing param-input styles */

/* Input Tiers */
.inputs-tier.primary {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.inputs-tier.secondary {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-top: 6px;
}

.inputs-tier-toggle {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 8px;
  margin-top: 6px;
  background: #1a1a1a;
  border: 1px solid #2a2a2a;
  border-radius: 4px;
  cursor: pointer;
  transition: background 0.1s;
}

.inputs-tier-toggle:hover {
  background: #252525;
}

.toggle-label {
  font-size: 10px;
  color: #888;
  text-transform: uppercase;
  flex: 1;
}

.toggle-count {
  font-size: 9px;
  color: #666;
  background: #252525;
  padding: 1px 6px;
  border-radius: 8px;
}

.toggle-icon {
  font-size: 10px;
  color: #666;
}
```

**Deliverable**: Complete CSS for new components

---

## State Management

### No New MobX Stores Required

All state comes from existing stores:
- **PatchStore**: `blocks`, `connections` (for wire detection)
- **UIStateStore**: `selectedPort` (for Drive menu navigation)

### Reactivity Pattern

```typescript
// InputRow is observer - reacts to:
// 1. Connection changes (wire added/removed)

// 2. Param value changes
const { params } = getDefaultSourceParams(...);  // Reads block.params

// 3. Bus metadata changes
const bus = store.busStore.buses.find(...);  // Reads busStore.buses
```

**No explicit subscriptions needed** - MobX will track reads and re-render on changes.

---

## Migration Strategy

### Step-by-Step Replacement

1. **Add new components** (Phase 2) - No breaking changes, just new code
2. **Add tier metadata** (Phase 3) - Additive only, with heuristic fallback
3. **Replace Inspector sections** (Phase 4) - **BREAKING CHANGE**
   - Remove old `ports-row` (lines 774-810)
   - Remove old `Parameters` section (lines 813-862)
   - Add new `<InputsSection />` and `<OutputsSection />`
4. **Verify visual parity** - Ensure all blocks render correctly

### Backwards Compatibility

**Blocks without tier metadata**: Use heuristic (first 4 inputs = primary)
**Blocks with no params**: Show just connection state, no controls
**Blocks with no inputs**: Show "No inputs" message

---

## Testing Strategy

### Manual Testing Checklist

**Test Case 1: Default State**
- [ ] Oscillator block with no connections shows inline controls for shape/amplitude/bias
- [ ] Controls are interactive (change values, verify block.params updates)
- [ ] "Drive…" button is visible

**Test Case 2: Wire Connection**
- [ ] Connect Oscillator.phase to PhaseClock.phase
- [ ] Inline controls disappear
- [ ] Wire chip shows "Wire: PhaseClock.phase"
- [ ] Navigate button (→) selects PhaseClock
- [ ] Disconnect button (×) removes wire

**Test Case 3: Bus Subscription**
- [ ] Subscribe Oscillator.phase to phaseA bus
- [ ] Bus chip shows "Bus: phaseA"
- [ ] If lens applied, shows "via scale(...)"
- [ ] Disconnect button removes subscription

**Test Case 4: Primary/Secondary Tiers**
- [ ] RenderInstances2D shows domain/positions/radius/color as primary
- [ ] opacity/glowEnabled/glowIntensity under "More" (collapsed)
- [ ] Click "More" expands secondary inputs
- [ ] Secondary inputs have slightly dimmer background

**Test Case 5: No Inputs**
- [ ] TimeRoot blocks (no inputs) show "No inputs" message
- [ ] No crash or layout issues

### Automated Testing

**Unit Tests** (new file: `src/editor/__tests__/Inspector.inputs.test.tsx`):
```typescript
describe('InputRow', () => {
  it('shows Default state with controls when no connection', () => { ... });
  it('shows Wire chip when wire connected', () => { ... });
  it('shows Bus chip when bus subscribed', () => { ... });
  it('calls onDrive when Drive button clicked', () => { ... });
  it('calls onDisconnect when disconnect clicked', () => { ... });
});

describe('getInputConnectionState', () => {
  it('returns default when no wire or bus', () => { ... });
  it('returns wire when connection exists', () => { ... });
  it('prioritizes wire over bus', () => { ... });
});

describe('getInputTier', () => {
  it('uses explicit tier if present', () => { ... });
  it('falls back to heuristic (first 4 = primary)', () => { ... });
});
```

**Integration Tests**: Use Chrome DevTools MCP to verify UI rendering
- Load patch with various block types
- Verify Inspector shows correct connection states
- Verify param controls work correctly

---

## Known Limitations & Future Work

### Phase 3 Limitations

1. **No param-to-input mapping**: All params currently belong to "the block", not specific inputs
   - **Future**: Add `inputBinding` metadata to ParamSchema to map params to specific inputs

2. **No Default Source block materialization**: Params stored directly on Block
   - **Future**: Create implicit DefaultSource nodes in semantic graph for proper compilation

3. **Drive menu is just port wiring panel**: No streamlined "Add Bus Subscription" flow
   - **Future**: Modal with "Connect Wire" / "Subscribe to Bus" / "Insert Operator Chain" options

4. **No lens editing UI**: Bus subscriptions show lens but can't edit inline
   - **Future**: Lens editor modal (Phase 4 or later)

### Recommended Next Steps (Phase 4)

2. **Param-to-input binding metadata**: Extend ParamSchema with `inputId` field
3. **Drive menu UX**: Modal for quick bus subscription without full port panel
4. **Lens editor**: Inline lens configuration UI

---

## Definition of Done

### Functional Requirements

- [ ] **FR1**: Inspector no longer has separate "PARAMETERS" section
- [ ] **FR2**: Inputs section shows all inputs with connection state indicators
- [ ] **FR3**: Default state shows inline param controls (same as current param controls)
- [ ] **FR4**: Wire state shows connection chip with source block/slot and navigate button
- [ ] **FR5**: Bus state shows bus chip with bus name, optional lens, and disconnect button
- [ ] **FR6**: Primary inputs visible by default, secondary under "More" (collapsible)
- [ ] **FR7**: "Drive…" button opens port wiring panel (existing functionality)
- [ ] **FR8**: Disconnect buttons remove wire/bus connections correctly
- [ ] **FR9**: Navigate button on wire chips selects source block

### Code Quality Requirements

- [ ] **CQ1**: All new components are MobX observers with proper reactivity
- [ ] **CQ2**: Helper functions are pure (no side effects, testable)
- [ ] **CQ3**: CSS follows existing Inspector.css conventions (BEM-like naming)
- [ ] **CQ4**: TypeScript types are explicit (no `any`, proper interfaces)
- [ ] **CQ5**: Backwards compatible with blocks lacking tier metadata

### Testing Requirements

- [ ] **T1**: Manual testing checklist completed (all 5 test cases pass)
- [ ] **T2**: Unit tests for `getInputConnectionState()` helper (>80% coverage)
- [ ] **T3**: Unit tests for `InputRow` component (connection states render correctly)
- [ ] **T4**: Chrome DevTools MCP verification of UI rendering

### Documentation Requirements

- [ ] **D1**: Inline code comments explain connection state logic
- [ ] **D2**: CSS comments group related styles
- [ ] **D3**: Update this plan with any implementation deviations

---

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| **Breaking existing param workflows** | High | Medium | Thorough manual testing of all block types |
| **Performance regression (too many observers)** | Medium | Low | Use computed values, avoid inline functions |
| **Styling conflicts with existing CSS** | Low | Low | Use unique class names, test in Chrome |
| **Incomplete tier metadata** | Low | High | Heuristic fallback ensures no crashes |

---

## Appendix A: File Inventory

### Files to Modify

| File | Lines Changed | Change Type |
|------|---------------|-------------|
| `src/editor/Inspector.tsx` | ~200 added, ~100 removed | Major refactor |
| `src/editor/Inspector.css` | ~150 added | Additive |
| `src/editor/blocks/types.ts` | ~5 added (Slot.tier) | Additive |
| `src/editor/blocks/utils.ts` | ~10 added (input() helper) | Additive |

### Files to Create

| File | Purpose |
|------|---------|
| `src/editor/__tests__/Inspector.inputs.test.tsx` | Unit tests for new components |

### Files to Read (Dependencies)

| File | Why |
|------|-----|
| `src/editor/stores/PatchStore.ts` | connections, updateBlockParams() |
| `src/editor/blocks/types.ts` | BlockDefinition, ParamSchema |

---

## Appendix B: Example Block Transformations

### Before (Current)

**Oscillator block in Inspector:**
```
┌─ Oscillator ──────────────────┐
│ INPUTS                         │
│ • phase          ○             │  ← Just connection dot
│                                │
│ OUTPUTS                        │
│ • out            ○             │
│                                │
│ PARAMETERS                     │  ← Separate section
│ Waveform    [sine ▾]          │
│ Amplitude   [1.0    ]          │
│ Bias        [0.0    ]          │
└────────────────────────────────┘
```

### After (Target)

**Oscillator block in Inspector:**
```
┌─ Oscillator ──────────────────┐
│ INPUTS                         │
│ ┌─ phase ────────────────────┐│
│ │ ○ Default   [Drive…]       ││
│ │ [sine ▾] [1.0] [0.0]       ││  ← Inline controls
│ │ shape   amplitude  bias     ││
│ └────────────────────────────┘│
│                                │
│ OUTPUTS                        │
│ • out            ○             │
└────────────────────────────────┘
```

**After connection to bus:**
```
┌─ Oscillator ──────────────────┐
│ INPUTS                         │
│ ┌─ phase ────────────────────┐│
│ │ ● Bus: phaseA  [×] [Edit…]││  ← Bus chip (no controls)
│ └────────────────────────────┘│
│                                │
│ OUTPUTS                        │
│ • out            ○             │
└────────────────────────────────┘
```

---

## Questions for Clarification

**Q1**: Should secondary inputs be collapsed by default, or expanded?
**A1**: Collapsed by default (minimize visual clutter for common workflows)

**Q2**: Should "Drive…" button open port wiring panel, or a new modal?
**A2**: Port wiring panel for Phase 3 (reuse existing UI), new modal in Phase 4

**Q3**: How to handle blocks with 10+ parameters (e.g., complex render blocks)?
**A3**: Rely on tier system - most should be secondary. Consider scroll container if needed.

**Q4**: Should we show param controls even when input has default value but no connection?
**A4**: Yes - Default state always shows controls, regardless of whether user has changed values

---

## Success Metrics

**User-facing improvements:**
- ✅ No mental distinction between "parameters" and "inputs"
- ✅ Clear visual indication of how each input is fed (Default / Wire / Bus)
- ✅ Inline controls reduce clicks (no separate parameter section)
- ✅ Consistent UX: everything is an input, everything can be driven

**Code quality improvements:**
- ✅ Fewer UI concepts (one section instead of two)
- ✅ Reusable `InputRow` component for future work
- ✅ Foundation for Default Source materialization (Phase 4)

**Alignment with spec:**
- ✅ Implements design-docs/10-Refactor-for-UI-prep/14-RemoveParams.md vision
- ✅ Makes parameters a UI concern, not a core type system concern
- ✅ Prepares for full Default Source block implementation

---

**End of Plan**
