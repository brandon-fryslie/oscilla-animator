# Status Evaluation: TypeWorld Unification

**Date:** 2025-12-30
**Evaluator:** project-evaluator
**Scope:** Issues #1, #4, #7 from Type System & Conversion Red Flags audit
**Git Commit:** 21cae9f

---

## Executive Summary

**Status:** UNFIXED - Issues #1, #4, #7 remain as originally documented

**Previous Work:** Sprint 1 made two commits (28c5307, 7139829) that addressed Issues #2, #3, #5, #6, but did NOT fix Issues #1, #4, #7. The commits improved type compatibility and added compile-time error detection for adapters/lenses, but did not unify the TypeWorld vocabularies or implement transform chain execution.

**Current Risk Level:** MEDIUM
- Issue #1 (TypeWorld mismatch): Latent type system confusion, will cause bugs when TypeDesc flows across boundaries
- Issue #4 (Transform runtime error): Silent - only fires if transform chains are actually created (currently never happens in compiler)
- Issue #7 (Config vs special): Related to #1, creates semantic inconsistency

**Recommendation:** CONTINUE - Issues are well-understood, no new ambiguities. Can be fixed incrementally.

---

## Issue #1: Two Different TypeDesc Definitions

### Current State

**UNFIXED** - Two incompatible TypeWorld enums still exist:

**File 1:** `src/editor/compiler/ir/types.ts:25`
```typescript
export type TypeWorld = "signal" | "field" | "scalar" | "event" | "special";
```

**File 2:** `src/editor/ir/types/TypeDesc.ts:41`
```typescript
export type TypeWorld = 'signal' | 'event' | 'field' | 'scalar' | 'config';
```

**Difference:**
- IR compiler uses `'special'`
- Editor type system uses `'config'`
- These are INCOMPATIBLE enum values

### Impact

**Where the mismatch happens:**

1. **Pass 2 (pass2-types.ts:108-121)** uses `'special'` for Domain, Scene, RenderTree types
2. **typeConversion.ts:53-73** uses `'config'` for the SAME types
3. Code paths that bridge these systems will fail type checks or have runtime inconsistencies

**Evidence from grep:**
```
pass2-types.ts:113:    Domain: { world: "special", domain: "domain" },
typeConversion.ts:53:  'Domain': createTypeDesc({ world: 'config', domain: 'domain' }),
```

Same semantic type (`Domain`) gets different `world` values depending on which code path created it.

### Files That Need Changes

**Option A: Unify to 'config'**
- Modify: `src/editor/compiler/ir/types.ts:25` → change `'special'` to `'config'`
- Search-replace: All uses of `world: "special"` → `world: "config"`
- Files affected: ~20 files (from grep results)

**Option B: Unify to 'special'**
- Modify: `src/editor/ir/types/TypeDesc.ts:41` → change `'config'` to `'special'`
- Modify: `typeConversion.ts` → change all `'config'` to `'special'`
- Files affected: ~15 files

### Recommended Approach

**Choose 'config' over 'special'** - Rationale:

1. **Semantic clarity:** "config" accurately describes these types (compile-time configuration values)
2. **Existing usage:** Editor type system already uses 'config' consistently
3. **Bus eligibility:** TypeDesc.ts:175 already has `if (type.world === 'config') return false` logic
4. **Documentation:** TypeDesc.ts:40 documents 'config' as "Configuration values (not runtime)"

**'special' is vague** - what makes something "special"? Unclear. "config" is precise.

### Implementation Plan

1. Change `src/editor/compiler/ir/types.ts:25` → replace `"special"` with `"config"`
2. Search for `world: "special"` in all `.ts` files, replace with `world: "config"`
3. Update tests that assert on `world: "special"`
4. Run typecheck + tests to verify

**Estimated effort:** 2-3 hours

---

## Issue #4: Transform Chains Runtime Error

### Current State

**UNFIXED** - Runtime throws when Transform FieldHandle is materialized:

**Location:** `src/editor/runtime/field/Materializer.ts:1174`
```typescript
throw new Error(`fillBufferTransform: transform chain evaluation not implemented`);
```

**TODO comment at line 1161:**
```typescript
// TODO: Phase 6 - actually apply transform chain to source field
```

### Why This Hasn't Caused Failures

**Transform chains are NEVER created by the compiler.**

**Evidence:**
- Searched for calls to `builder.transformChain()` in compiler passes
- Only found in TESTS: `builder.test.ts:370` and `builder.test.ts:392`
- NO production compiler code creates transform chains
- IR builder has the infrastructure (`transformChain()` method exists) but nothing calls it

**When would this fire?**
- If a compiler pass creates a TransformChainIR and references it with `fieldTransform()` or `sigTransform()`
- Currently never happens
- Would only happen if Issue #2 (type conversion paths) were fully implemented

### Dependencies and Risks

**Depends on:**
- Transform chain creation logic (doesn't exist yet)
- Decision on how adapters/lenses should work in IR mode
- Type conversion infrastructure

**Risk level:** LOW (short-term), MEDIUM (long-term)
- Won't fire in current codebase
- But it's a landmine for future work on type conversions
- Current compile-time error for adapters/lenses (Issue #5 fix) prevents this path from being reached

### Two Paths Forward

**Option A: Implement Transform Execution**
- Implement `fillBufferTransform()` logic
- Apply transform chain steps to source field
- Support ScaleBias, Cast, Map, etc. (see transforms.ts:58-72)
- Effort: 1-2 weeks (complex, needs careful design)

**Option B: Add Compile-Time Detection**
- Detect when transform chains are created
- Emit compile error: "Transform chains not yet supported in IR mode"
- Similar to Issue #5 fix for adapters/lenses
- Effort: 1-2 hours

### Recommended Approach

**Option B (compile-time detection) for now.**

**Rationale:**
1. Transform chains are never created - not urgent
2. Compile error is fail-fast and clear
3. Defers complex implementation to when type conversion system is designed
4. Consistent with Issue #5 fix approach

**Future work (Sprint 4+):**
- Design type conversion system holistically
- Implement transform chain execution as part of that effort
- Current TODO comment already documents this as "Phase 6"

---

## Issue #7: Config vs Special World Mismatch

### Current State

**UNFIXED** - Same as Issue #1, this is a manifestation of the TypeWorld vocabulary split.

**Evidence:**
```
typeConversion.ts:53:  'Domain': createTypeDesc({ world: 'config', domain: 'domain' }),
pass2-types.ts:113:    Domain: { world: "special", domain: "domain" },
```

### Resolution

**Same fix as Issue #1** - unify to 'config'.

No separate work needed - fixing Issue #1 resolves this automatically.

---

## Ambiguities

**NONE** - All issues are well-understood:

1. Issue #1: Clear vocabulary mismatch, clear fix (unify to 'config')
2. Issue #4: Clear missing implementation, clear options (compile error vs full impl)
3. Issue #7: Duplicate of Issue #1

**No questions need answers before proceeding.**

---

## Risk Assessment

### Issue #1: TypeWorld Vocabulary

**Risk:** MEDIUM
- Type compatibility checks may give wrong results across code boundaries
- Bus eligibility checks may behave inconsistently
- Runtime type assertions may fail unexpectedly

**Mitigation:**
- Unify to 'config' quickly (2-3 hours)
- Run full test suite after change
- Grep for all `world: "special"` to ensure none are missed

### Issue #4: Transform Runtime Error

**Risk:** LOW (current), MEDIUM (future)
- Won't fire now (no transform chains created)
- But blocks future type conversion work
- Clear error message makes debugging easy if it does fire

**Mitigation:**
- Add compile-time detection now (1-2 hours)
- Implement proper execution later when type conversion system is designed
- Document in HANDOFF.md that transform execution is deferred

### Issue #7: Config vs Special

**Risk:** Same as Issue #1 (it's the same bug)

---

## Dependencies

**Issue #1 (TypeWorld unification):**
- No dependencies - can be fixed immediately
- Does NOT require other issues to be fixed first

**Issue #4 (Transform runtime error):**
- No dependencies for Option B (compile error)
- Option A (full implementation) depends on type conversion design

**Issue #7:**
- Fixed by Issue #1 fix

**Dependency graph:**
```
Issue #1 (TypeWorld unify) ─┐
                             ├──> Can be fixed independently
Issue #4 (Transform error)  ─┤
                             │
Issue #7 (Config vs special) ┴──> Automatically resolved by Issue #1
```

---

## Files Summary

### Issue #1: TypeWorld Unification

**Primary files:**
- `src/editor/compiler/ir/types.ts` - Change TypeWorld enum
- `src/editor/compiler/passes/pass2-types.ts` - Update type mappings
- `src/editor/ir/types/TypeDesc.ts` - Already uses 'config' (no change)
- `src/editor/ir/types/typeConversion.ts` - Already uses 'config' (no change)

**Secondary files (search-replace `"special"` → `"config"`):**
- Block compilers in `src/editor/compiler/blocks/domain/`
- Runtime executor in `src/editor/runtime/executor/`
- Type adapter tests
- Debug tools

**Estimated:** ~20 files

### Issue #4: Transform Chains

**Compile-time detection approach:**
- `src/editor/compiler/passes/pass2-types.ts` - Detect transform chain creation
- `src/editor/compiler/types.ts` - Add error code `UnsupportedTransformChainInIRMode`

**Full implementation approach (deferred):**
- `src/editor/runtime/field/Materializer.ts:1150-1175` - Implement fillBufferTransform
- Transform step evaluators (map, scaleBias, cast, etc.)
- Integration tests

---

## Recommended Next Steps

### Immediate (Sprint 2)

1. **Fix Issue #1 (TypeWorld unification to 'config')**
   - Priority: P1 (should fix before other type system work)
   - Effort: 2-3 hours
   - Risk: Low (mechanical search-replace with test verification)

2. **Fix Issue #4 (compile-time transform detection)**
   - Priority: P2 (nice to have, prevents future confusion)
   - Effort: 1-2 hours
   - Risk: Low (similar to Issue #5 fix already done)

### Deferred (Sprint 4+)

3. **Implement Issue #4 (transform chain execution)**
   - Priority: P3 (not needed until type conversion system designed)
   - Effort: 1-2 weeks
   - Risk: Medium (complex, needs careful design)
   - Prerequisite: Type conversion system design

---

## Test Strategy

### Issue #1: TypeWorld Unification

**Existing tests:** Should continue to pass
- Type compatibility tests in `TypeDesc.test.ts`
- Pass 2 type inference tests
- Bus eligibility tests

**Add tests:**
- Type roundtrip: editor TypeDesc → IR TypeDesc → back (should be stable)
- Domain type has `world: 'config'` in both systems
- Bus eligibility rejects 'config' world types

### Issue #4: Transform Runtime Error

**Option B (compile error):**
- Test that creating transform chain emits compile error
- Error message is clear and actionable
- Similar to adapter/lens tests from Issue #5 fix

**Option A (full impl, if pursued):**
- Unit tests for each transform step type
- Integration tests for transform chains
- Performance tests (transform overhead)

---

## Verdict

**Workflow:** CONTINUE

**Rationale:**
- All issues well-understood
- Clear fix paths identified
- No ambiguities blocking work
- Can be fixed incrementally
- Low risk

**Issues can be fixed by implementer** - no design decisions needed, just mechanical changes plus one policy decision (compile error vs full impl for transforms).

**Recommended order:**
1. Issue #1 first (foundational)
2. Issue #4 Option B (quick win)
3. Issue #4 Option A (future sprint when needed)

---

## References

**Original audit:** `.agent_planning/compiler-audit-redflag/STATUS-2025-12-28.md`
- Issue #1: Lines mentioning TypeDesc definitions
- Issue #4: Lines about transform runtime error
- Issue #7: Lines about config vs special mismatch

**Previous work:**
- Commit 28c5307: Fixed Issues #2, #3, #6
- Commit 7139829: Fixed Issue #5

**Key files:**
- TypeDesc definitions: `src/editor/compiler/ir/types.ts`, `src/editor/ir/types/TypeDesc.ts`
- Type conversion: `src/editor/ir/types/typeConversion.ts`
- Pass 2: `src/editor/compiler/passes/pass2-types.ts`
- Transform runtime: `src/editor/runtime/field/Materializer.ts`
- Transform IR: `src/editor/compiler/ir/transforms.ts`
