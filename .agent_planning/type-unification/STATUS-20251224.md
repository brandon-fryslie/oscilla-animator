# Evaluation: Type Unification
**Timestamp:** 2025-12-24-150000
**Scope:** topic/type-unification (Phase 1, Topic 1)
**Git Commit:** b0ef07c
**Confidence:** FRESH

---

## Executive Summary

**Completion:** 40% | **Critical Gaps:** 3 | **Verdict:** CONTINUE with clarifications

The type unification infrastructure is **partially complete**. Two parallel type systems exist as documented in the HANDOFF, but key bridging utilities and the unified IR type system are missing. The codebase has tests failing due to unrelated issues (lanes API changes), which creates noise but doesn't block this topic.

---

## Current State Assessment

### What Exists Today

#### 1. Editor Type System (`src/editor/types.ts`)

**Complete and well-structured:**
- ✅ `TypeDesc` interface with `world`, `domain`, `category`, `busEligible`, `semantics`, `unit`
- ✅ `TypeWorld = 'signal' | 'field' | 'scalar' | 'config'`
- ✅ `CoreDomain` union (number, vec2, color, boolean, time, phase, rate, trigger)
- ✅ `InternalDomain` union (point, duration, hsl, path, etc.)
- ✅ `SLOT_TYPE_TO_TYPE_DESC` mapping (Record<SlotType, TypeDesc>)
- ✅ Helper functions: `isDirectlyCompatible()`, `isBusEligible()`, `validateDefaultValue()`

**Status:** **COMPLETE** for editor needs. This is production-ready.

#### 2. Compiler Type System (`src/editor/compiler/types.ts`)

**Complete but divergent:**
- ✅ `ValueKind` as flat string union ('Scalar:number', 'Signal:phase', 'Field<Point>', etc.)
- ✅ `Artifact` discriminated union with `kind: ValueKind` and `value: T`
- ✅ `TimeModel` variants (FiniteTimeModel, CyclicTimeModel, InfiniteTimeModel)
- ✅ `CompiledProgram` interface wrapping `Program<RenderTree>` + `TimeModel`

**Status:** **COMPLETE** for current compiler. Works fine, but is NOT the IR target.

#### 3. Semantic Kernel (`src/editor/semantic/index.ts`)

**Centralized type compatibility logic:**
- ✅ `isDirectlyCompatible(from: TypeDesc, to: TypeDesc)`
- ✅ Compatible domain sets (point/vec2, number/unit, renderTree/renderNode/render)
- ✅ One-way assignability rules (sceneTargets → vec2/point)
- ⚠️ Uses TypeDesc but has **no conversion utilities for ValueKind**

**Status:** **PARTIAL** - Good design, missing bridges.

#### 4. Unified Compiler Experiments (`src/editor/compiler/unified/`)

**Early prototypes exist:**
- ✅ `Domain.ts` - Element identity system for Field<T> evaluation
- ✅ `FieldExpr.ts` - Lazy field expressions (prototype)
- ✅ `TimeCtx.ts` - Time context for unified compiler
- ❌ **No IR type definitions** in this directory
- ❌ **No TypeDesc usage** - still uses old ValueKind

**Status:** **EXPLORATORY** - Useful concepts, but not IR-aligned.

---

## What's Missing for Type Unification

### Gap 1: No `src/editor/ir/` Directory

**Critical missing infrastructure:**

The HANDOFF specifies a complete `src/editor/ir/` structure:
```
src/editor/ir/
├── types/
│   ├── TypeDesc.ts           # ❌ MISSING
│   ├── Indices.ts            # ❌ MISSING (Topic 2)
│   ├── DebugIndex.ts         # ❌ MISSING (Topic 2)
│   ├── typeConversion.ts     # ❌ MISSING (critical bridge)
│   └── __tests__/
├── schema/
│   └── CompiledProgramIR.ts  # ❌ MISSING (Topic 3)
├── time/
│   └── TimeDerivation.ts     # ❌ MISSING (Topic 4)
└── index.ts                  # ❌ MISSING
```

**Impact:** Zero IR types exist. The migration cannot proceed to Phase 2 without these.

**Evidence:** `find src/editor -type d -name "ir"` returns nothing.

---

### Gap 2: Missing Type Conversion Utilities

**The handoff specifies these critical bridges:**

#### `valueKindToTypeDesc(kind: ValueKind): TypeDesc`

**Not found anywhere in codebase.**

This is THE key function to unify the two systems. Without it:
- Cannot map compiler artifacts to TypeDesc for validation
- Cannot bridge existing compiler output to IR
- Cannot implement adapter path resolution based on TypeDesc

**Expected signature (from HANDOFF):**
```typescript
export function valueKindToTypeDesc(kind: ValueKind): TypeDesc {
  const mapping: Record<string, TypeDesc> = {
    'Scalar:number': { world: 'scalar', domain: 'number' },
    'Signal:number': { world: 'signal', domain: 'number' },
    'Signal:phase': { world: 'signal', domain: 'phase01' },  // ⚠️ domain mismatch
    'Field<Point>': { world: 'field', domain: 'vec2', semantics: 'point' },
    // ... 40+ more mappings
  };
  return mapping[kind] ?? { world: 'special', domain: 'unknown' };
}
```

#### `slotTypeToTypeDesc(slot: SlotType): TypeDesc`

**Partially exists as `SLOT_TYPE_TO_TYPE_DESC` lookup, but NOT a function.**

The HANDOFF expects a **parsing function** that can handle:
- Extracting inner types: `'Signal<phase>'` → `{ world: 'signal', domain: 'phase01' }`
- Semantic mapping: `'Field<Point>'` → `{ world: 'field', domain: 'vec2', semantics: 'point' }`

Current `SLOT_TYPE_TO_TYPE_DESC` is a **static Record** (844 lines in types.ts), which works but:
- ❌ Cannot handle dynamic SlotType strings not in the mapping
- ❌ No parser for generic patterns like `Signal<T>` or `Field<T>`
- ⚠️ Some mappings look questionable (see Ambiguities below)

---

### Gap 3: TypeDesc Domain Mismatches

**The HANDOFF spec uses different domain names than current code:**

| HANDOFF Domain | Current Domain | Used In |
|----------------|----------------|---------|
| `phase01` | `phase` | Signal<phase>, TimeRoot outputs |
| `unit01` | `number` (semantics: 'unit(0..1)') | Signal<Unit> |
| `timeMs` | `time` (unit: 'ms' or 'seconds') | Signal<time>, Signal<Time> |
| `trigger` | `trigger` | ✅ Match |
| `vec2` | `vec2` OR `point` | Field<vec2> vs Field<Point> |

**Impact:** If we implement the HANDOFF spec as-is, we'll have:
- Editor using `phase`, IR using `phase01` → **conversion layer needed**
- OR: Change HANDOFF spec to match current domains → **spec update required**

**Evidence:**
- `src/editor/types.ts:29` - `type CoreDomain = ... | 'phase' | ...`
- HANDOFF line 169 - `| 'phase01'`

---

## Ambiguities Found

### Ambiguity 1: Domain Naming Convention

**Question:** Should we use the HANDOFF domain names (`phase01`, `unit01`, `timeMs`) or keep current names (`phase`, `time`)?

**Context:** Current code is production-tested. HANDOFF names are more explicit but require migration.

**Options:**
- **A:** Use HANDOFF names, add conversion layer in `typeConversion.ts`
- **B:** Update HANDOFF spec to match current domains (simpler)
- **C:** Hybrid: Add `semantics` field to TypeDesc to clarify ambiguity

**Impact:** Choice A means every TypeDesc comparison needs conversion. Choice B is simpler but diverges from spec.

**Recommendation:** **Option B** - Update spec to match working code. Add semantics for precision:
```typescript
// Instead of domain: 'phase01'
{ world: 'signal', domain: 'phase', semantics: '0..1' }
```

---

### Ambiguity 2: `SlotType` String Format

**Question:** Are SlotType strings standardized, or can they be arbitrary?

**Context:** HANDOFF assumes we can **parse** slot types like `'Signal<T>'`. Current code uses **hardcoded strings** like `'Signal<phase>'` and `'Signal<Phase>'` (inconsistent capitalization).

**Evidence:**
```typescript
// From types.ts
| 'Signal<phase>'     // lowercase
| 'Signal<Point>'     // uppercase
| 'Signal<Unit>'      // uppercase
| 'Signal<PhaseSample>'  // uppercase compound
```

**Options:**
- **A:** Enforce strict naming (lowercase primitives, PascalCase compounds) and parse
- **B:** Keep lookup table, add validation for unknown types
- **C:** Migrate to canonical TypeDesc everywhere, deprecate SlotType strings

**Impact:** Parsing requires regex/pattern matching, error-prone. Lookup is fast but inflexible.

**Recommendation:** **Option B** for now (Phase 1). **Option C** for Phase 3+ (full IR migration).

---

### Ambiguity 3: `world: 'event'` vs `world: 'signal'` for Events

**Question:** Are events a separate world or a signal domain?

**Context:**
- HANDOFF line 158: `type TypeWorld = ... | 'event' | 'special'`
- Current code line 17: `type TypeWorld = 'signal' | 'field' | 'scalar' | 'config'`
- BUT: Current code line 860: `'Event<any>': { world: 'signal', domain: 'trigger', ... }`

**Current behavior:** Events are treated as **signals with domain 'trigger'**.

**HANDOFF behavior:** Events are a separate **world**.

**Options:**
- **A:** Keep events as Signal<trigger> (matches current compiler semantics)
- **B:** Add 'event' world, migrate all Event<T> types
- **C:** Add 'event' world but make it alias to Signal<trigger> for compatibility

**Impact:** Choice A is backward compatible. Choice B requires compiler changes.

**Recommendation:** **Option A** - Events ARE signals (discrete, time-indexed). The domain 'trigger' already captures the semantics.

---

## Data Flow Verification

### Type Resolution Flow (Current)

```
SlotType string
    ↓
SLOT_TYPE_TO_TYPE_DESC lookup
    ↓
TypeDesc { world, domain, category, busEligible, semantics }
    ↓
Semantic kernel (isDirectlyCompatible, compatibility sets)
    ↓
Validation result (compatible Y/N)
```

**Status:** ✅ Works for editor UI and validation.

### Compilation Flow (Current)

```
Block definition (inputs/outputs with SlotType)
    ↓
Block compiler (uses ValueKind for artifacts)
    ↓
Artifact { kind: ValueKind, value: T }
    ↓
Type checking (manual string matching on ValueKind)
    ↓
Program<RenderTree>
```

**Gap:** No TypeDesc in compiler. Validation happens via string matching on ValueKind.

### IR Target Flow (Missing)

```
Block definition (SlotType)
    ↓
⚠️ slotTypeToTypeDesc() [MISSING FUNCTION]
    ↓
TypeDesc (unified)
    ↓
IR NodeTable (TypeDesc per port)
    ↓
⚠️ Validation at IR level [NOT IMPLEMENTED]
```

**Status:** ❌ Cannot proceed without conversion utilities.

---

## Test Suite Assessment

### Existing Type Tests

**No dedicated TypeDesc tests found.**

Search results:
```bash
grep -r "TypeDesc" src/editor/__tests__/ --include="*.test.ts"
# Returns: ZERO results
```

**Bus compilation tests** (`bus-compilation.test.ts`) exist and use SLOT_TYPE_TO_TYPE_DESC, but don't test the TypeDesc system itself.

**Recommendation:** Topic 1 MUST include TypeDesc property tests:
- Type equality edge cases
- Compatibility rules
- Conversion round-trips (SlotType → TypeDesc → validation)

---

## Implementation Gaps vs HANDOFF Spec

### HANDOFF Deliverable 1: `src/editor/ir/types/TypeDesc.ts`

**Status:** ❌ NOT STARTED

**What's specified:**
- Unified TypeWorld, TypeDomain enums
- TypeDesc interface (already exists in `types.ts`)
- Helper functions: `typeEquals()`, `isCompatible()`, `isBusEligible()`, `getTypeCategory()`

**Gap:** Need to **extract** current `types.ts` TypeDesc into new IR module, then add helpers.

---

### HANDOFF Deliverable 2: Bridge Utilities

**Status:** ❌ NOT STARTED

**What's specified:**
- `valueKindToTypeDesc(kind: ValueKind): TypeDesc`
- `slotTypeToTypeDesc(slot: SlotType): TypeDesc`
- `domainFromString(s: string): TypeDomain`

**Gap:** None of these exist. Critical for unification.

---

### HANDOFF Deliverable 3: Tests

**Status:** ❌ NOT STARTED

**What's specified:**
- `TypeDesc.test.ts` - type equality, compatibility, bus eligibility
- `typeConversion.test.ts` - ValueKind/SlotType conversion round-trips

**Gap:** Zero test coverage for TypeDesc system.

---

## Dependencies and Risks

### Dependencies

**This topic blocks:**
- Topic 2 (dense-id-system) - needs TypeDesc for type tables
- Topic 3 (ir-core-types) - NodeIR ports use TypeDesc
- Topic 4 (timemodel-ir) - TimeModelIR already exists in compiler/types.ts, just needs IR wrapper

**This topic depends on:**
- ✅ Current type systems (exist, stable)
- ✅ Semantic kernel (exists, works)

**Risk Level:** **LOW** - Isolated type definitions, no runtime changes.

---

### Risks

#### Risk 1: Domain Name Divergence (MEDIUM)

**Problem:** HANDOFF uses different domain names than production code.

**Mitigation:** Clarify with user BEFORE implementing. Prefer adapting spec to code (less churn).

---

#### Risk 2: SlotType Parsing Complexity (LOW)

**Problem:** Parsing `'Signal<phase>'` requires regex or string manipulation.

**Mitigation:** Keep lookup table approach. Add fallback parser only for unknown types.

---

#### Risk 3: Breaking Existing Code (LOW)

**Problem:** Adding new IR types might conflict with current editor types.

**Mitigation:** Phase 1 is pure additive - no changes to existing files. Use new `ir/` namespace.

---

## Recommendations

### Priority 1: Clarify Domain Naming (BLOCKER)

**Action:** User decision required.

**Question:** Use HANDOFF domain names (`phase01`, `unit01`, `timeMs`) or current names (`phase`, `time`)?

**Rationale:** This affects every TypeDesc in the system. Must be decided before writing code.

---

### Priority 2: Create IR Directory Structure

**Action:** Implement HANDOFF file structure:
```bash
mkdir -p src/editor/ir/types/__tests__
mkdir -p src/editor/ir/schema/__tests__
mkdir -p src/editor/ir/time/__tests__
```

**Files to create:**
1. `src/editor/ir/types/TypeDesc.ts` - Re-export current TypeDesc + new helpers
2. `src/editor/ir/types/typeConversion.ts` - Bridge utilities
3. `src/editor/ir/types/__tests__/TypeDesc.test.ts`
4. `src/editor/ir/types/__tests__/typeConversion.test.ts`

---

### Priority 3: Implement Bridge Utilities

**Action:** Write conversion functions per HANDOFF spec (with domain name decisions applied).

**Critical functions:**
- `valueKindToTypeDesc()` - 40+ case mapping
- `slotTypeToTypeDesc()` - Parser or extended lookup table
- `domainFromString()` - Helper for parsing

**Test strategy:** Round-trip tests. Every ValueKind → TypeDesc → validate.

---

### Priority 4: Add TypeDesc Property Tests

**Action:** Write comprehensive test suite for TypeDesc system.

**Coverage needed:**
- Type equality (with/without semantics)
- Compatibility rules (signal→field, scalar→signal promotions)
- Bus eligibility (core vs internal)
- Category derivation

---

## Workflow Recommendation

✅ **CONTINUE** - Issues are clear, path forward is well-defined.

**Next steps:**
1. User clarifies domain naming convention (1 hour)
2. Implementer creates IR directory structure (30 min)
3. Implementer writes bridge utilities (4 hours)
4. Implementer writes test suite (3 hours)
5. Run `just check` - should pass with ZERO runtime impact

**Estimated complexity:** **MEDIUM** - Mostly straightforward mapping, but need careful attention to domain naming and conversion edge cases.

---

## Evidence Summary

### Files Read
- `/Users/bmf/code/oscilla-animator_codex/.worktrees/ir-compiler/src/editor/types.ts` (986 lines)
- `/Users/bmf/code/oscilla-animator_codex/.worktrees/ir-compiler/src/editor/compiler/types.ts` (522 lines)
- `/Users/bmf/code/oscilla-animator_codex/.worktrees/ir-compiler/src/editor/semantic/index.ts` (partial)
- `/Users/bmf/code/oscilla-animator_codex/.worktrees/ir-compiler/src/editor/compiler/unified/Domain.ts` (141 lines)
- `/Users/bmf/code/oscilla-animator_codex/.worktrees/ir-compiler/HANDOFF-IR-COMPILER.md` (1590 lines)

### Key Findings
- ✅ TypeDesc interface exists and is well-designed
- ✅ SLOT_TYPE_TO_TYPE_DESC mapping is comprehensive
- ❌ Zero IR type files exist (`src/editor/ir/` directory missing)
- ❌ No ValueKind → TypeDesc conversion utilities
- ❌ No TypeDesc test coverage
- ⚠️ Domain naming divergence between HANDOFF and current code
- ⚠️ Tests failing due to unrelated lanes API changes (noise, not blocker)

---

## Metadata

**Evaluation completed:** 2025-12-24 15:00
**Lines of code examined:** ~3200
**Test failures (unrelated):** 46 TypeScript errors in composite tests (lanes API)
**Critical decisions needed:** 1 (domain naming)
**Estimated implementation time:** 8-10 hours
**Risk level:** LOW (isolated type definitions)
