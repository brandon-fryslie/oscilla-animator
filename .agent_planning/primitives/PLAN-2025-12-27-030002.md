# Sprint Plan: Primitive Capability Enforcement Foundation

**Generated**: 2025-12-27-030002
**Source STATUS**: STATUS-2025-12-27-030200.md
**Topic**: Primitives & Kernel Architecture
**Spec Reference**: design-docs/7-Primitives/3-Registry-Gating.md

---

## Executive Summary

**Current State** (from STATUS-2025-12-27-030200.md):
- Implementation: ~25% complete
- Critical gaps: 8 identified
- Test suite: 1873 passing, 79 failing
- Verdict: CONTINUE - gaps are well-defined, no blocking ambiguities

**This Sprint Goal**: Add capability enforcement to the block registry so the primitive set can be locked.

The design docs specify a comprehensive closed primitive set with capability-based enforcement. The current codebase has **none of the enforcement mechanisms** in place:
- BlockDefinition lacks `capability` and `kernelId` fields
- No KERNEL_PRIMITIVES allowlist exists
- No validation functions exist (validateBlockDefinition, validatePureBlockOutput)
- No CI checks exist

**This sprint focuses on foundational enforcement only** - establishing the gating mechanism that prevents unauthorized kernel primitives. The 3D types and future IO slots are explicitly OUT OF SCOPE.

**Sprint Scope**: 2-3 deliverables maximum (per constraint)

---

## Sprint Deliverables

### Deliverable 1: Add Capability Metadata to BlockDefinition

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: None
**Spec Reference**: 3-Registry-Gating.md:15-102 • **Status Reference**: STATUS-2025-12-27-030200.md:30-54

#### Description

Update the BlockDefinition type to include capability and kernelId fields as specified in the design docs. This is the foundational change that enables all enforcement mechanisms.

Currently (from `src/editor/blocks/types.ts:27-102`):
```typescript
interface BlockDefinition {
  type: string;
  label: string;
  // NO capability field
  // NO kernelId field
  // ...
}
```

Required changes:
1. Add capability types to `src/editor/types.ts`:
   - `KernelCapability = 'time' | 'identity' | 'state' | 'render' | 'io'`
   - `Capability = KernelCapability | 'pure'`
   - `KernelId` union type (11 specific IDs)
   - `PureCompileKind = 'operator' | 'composite' | 'spec'`

2. Convert BlockDefinition to discriminated union in `src/editor/blocks/types.ts`:
   - `KernelBlockDefinition` (has `capability: KernelCapability` + `kernelId: KernelId`)
   - `PureBlockDefinition` (has `capability: 'pure'` + `compileKind: PureCompileKind`)

3. Update ALL existing block definitions with capability field:
   - TimeRoot blocks → `capability: 'time'`, `kernelId: 'FiniteTimeRoot' | 'CycleTimeRoot' | 'InfiniteTimeRoot'`
   - Domain blocks → `capability: 'identity'`, `kernelId: 'DomainN' | 'SVGSampleDomain'`
   - RenderInstances2D → `capability: 'render'`, `kernelId: 'RenderInstances'`
   - All operator/composite blocks → `capability: 'pure'`, `compileKind: 'operator' | 'composite'`

#### Acceptance Criteria

- [ ] `KernelCapability`, `Capability`, `KernelId`, and `PureCompileKind` types exist in `src/editor/types.ts`
- [ ] BlockDefinition is a discriminated union (KernelBlockDefinition | PureBlockDefinition) in `src/editor/blocks/types.ts`
- [ ] All TimeRoot blocks have `capability: 'time'` and correct kernelId
- [ ] All Domain blocks have `capability: 'identity'` and correct kernelId
- [ ] RenderInstances2D has `capability: 'render'` and `kernelId: 'RenderInstances'`
- [ ] All operator and composite blocks have `capability: 'pure'` and appropriate compileKind
- [ ] TypeScript compilation succeeds with no errors
- [ ] Existing tests pass or are updated to accommodate new fields

#### Technical Notes

**Breaking Change**: This is a schema-breaking change. Every BlockDefinition must be updated.

**Migration Strategy**:
1. Add types first
2. Update BlockDefinition interface
3. Fix compilation errors file-by-file
4. Use compiler-driven approach: let TypeScript errors guide the updates

**Form vs Capability**:
- `form` (primitive/composite/macro) = HOW the block is structured
- `capability` (time/identity/state/render/io/pure) = WHAT authority it claims
- These are orthogonal: a primitive can be pure (e.g., AddBlock), and a composite is always pure

**GridDomain Ambiguity**: STATUS notes GridDomain is treated as primitive in code but spec says composite. For this sprint, keep as-is (primitive with `capability: 'identity'`). Document decision.

---

### Deliverable 2: Create KERNEL_PRIMITIVES Allowlist and Validation

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: Deliverable 1 (capability field must exist)
**Spec Reference**: 3-Registry-Gating.md:108-204 • **Status Reference**: STATUS-2025-12-27-030200.md:56-84

#### Description

Create the single source of truth for which blocks are allowed to claim non-pure capabilities, and add runtime validation that enforces this list.

Currently (from STATUS):
- File `src/editor/blocks/kernel-primitives.ts` **DOES NOT EXIST**
- Function `validateBlockDefinition()` **DOES NOT EXIST**
- Registry does no validation - just concatenates arrays

Required implementation:

1. **Create `src/editor/blocks/kernel-primitives.ts`**:
```typescript
export const KERNEL_PRIMITIVES = {
  // Time Authority (3)
  'FiniteTimeRoot': 'time',
  'CycleTimeRoot': 'time',
  'InfiniteTimeRoot': 'time',

  // Identity Authority (2)
  'DomainN': 'identity',
  'SVGSampleDomain': 'identity',

  // State Authority (2) - future slots for user-facing blocks
  'IntegrateBlock': 'state',
  'HistoryBlock': 'state',

  // Render Authority (3, some future)
  'RenderInstances': 'render',
  'RenderStrokes': 'render',      // Future slot
  'RenderProgramStack': 'render', // Future slot

  // IO Authority (2, future)
  'TextSource': 'io',
  'ImageSource': 'io',
} as const satisfies Record<string, KernelCapability>;
```

2. **Create `src/editor/blocks/registry-validation.ts`**:
   - `validateBlockDefinition(def: BlockDefinition): void` - throws on violation
   - Rules:
     - Non-pure capability must be in KERNEL_PRIMITIVES
     - Capability must match KERNEL_PRIMITIVES entry
     - Composites must be pure
     - Macros must be pure

3. **Integrate validation into registry loading**:
   - Call `validateBlockDefinition()` for each block in `src/editor/blocks/registry.ts`
   - Fail fast on startup if violations exist

#### Acceptance Criteria

- [ ] `src/editor/blocks/kernel-primitives.ts` exists with frozen KERNEL_PRIMITIVES constant
- [ ] KERNEL_PRIMITIVES contains exactly 11 entries (3 time, 2 identity, 2 state, 3 render, 2 io)
- [ ] `src/editor/blocks/registry-validation.ts` exists with validateBlockDefinition()
- [ ] validateBlockDefinition() throws error if block claims non-pure capability not in KERNEL_PRIMITIVES
- [ ] validateBlockDefinition() throws error if capability doesn't match KERNEL_PRIMITIVES entry
- [ ] validateBlockDefinition() throws error if composite/macro claims non-pure capability
- [ ] Registry calls validateBlockDefinition() for every block on load
- [ ] Application starts successfully with current block set (no violations)
- [ ] Test: Adding a fake block with `capability: 'time'` and type not in KERNEL_PRIMITIVES throws error

#### Technical Notes

**Future Slots**: The spec includes `RenderStrokes`, `RenderProgramStack`, `TextSource`, and `ImageSource` as future slots. Include them in KERNEL_PRIMITIVES now (as comments if blocks don't exist yet) to prevent accidental name collisions.

**Error Messages**: Make error messages actionable. Example:
```
Block "FakeTimeRoot" claims capability "time" but is not in KERNEL_PRIMITIVES.
Only the following blocks may have time capability: FiniteTimeRoot, CycleTimeRoot, InfiniteTimeRoot
```

**Integration Point**: The registry currently loads blocks from multiple sources:
```typescript
const ALL_INDIVIDUAL_BLOCKS: BlockDefinition[] = [
  ...Object.values(DomainBlocks),
  ...Object.values(TimeRootBlocks),
  // ...
];
```

Add validation loop after this concatenation:
```typescript
for (const def of ALL_INDIVIDUAL_BLOCKS) {
  validateBlockDefinition(def);
}
```

---

### Deliverable 3: Add Pure Block Compilation Enforcement

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: Deliverable 1, Deliverable 2
**Spec Reference**: 3-Registry-Gating.md:206-355 • **Status Reference**: STATUS-2025-12-27-030200.md:86-95

#### Description

Add compile-time enforcement that pure blocks cannot emit artifacts that require kernel capabilities (RenderTree, Domain, State, ExternalAsset).

Currently (from STATUS):
- Function `validatePureBlockOutput()` **DOES NOT EXIST**
- Pure blocks can currently emit anything - no constraints

The spec requires pure blocks to compile to restricted AST (SignalExpr, FieldExpr) rather than arbitrary closures. This prevents pure blocks from secretly allocating memory, creating domains, or emitting render trees.

Required implementation:

1. **Define allowed AST types** (in `src/editor/compiler/pure-operator-ast.ts`):
   - `SignalExpr` - pure signal expressions
   - `FieldExpr` - pure field expressions
   - Function types: `UnaryFn`, `BinaryFn`, `MapFn`, `ZipFn`, `ReduceFn`

2. **Create validation** (in `src/editor/compiler/pure-block-validator.ts`):
   - `validatePureBlockOutput(blockType, compileKind, outputs): void`
   - Check each output artifact:
     - Pure blocks CANNOT emit RenderTree/RenderTreeProgram
     - Pure blocks CANNOT emit Domain
     - Pure blocks CANNOT emit StateHandle/HistoryBuffer
     - Pure blocks CANNOT emit ExternalAsset
     - Operator blocks MUST produce AST nodes (SignalExpr/FieldExpr), not raw closures

3. **Integrate into compilation**:
   - Call `validatePureBlockOutput()` after block compilation
   - Location: where blocks are lowered to IR (likely in `src/editor/compiler/`)

#### Acceptance Criteria

- [ ] `src/editor/compiler/pure-operator-ast.ts` exists with SignalExpr and FieldExpr type definitions
- [ ] `src/editor/compiler/pure-block-validator.ts` exists with validatePureBlockOutput()
- [ ] validatePureBlockOutput() rejects RenderTree/Domain/State/ExternalAsset artifacts from pure blocks
- [ ] validatePureBlockOutput() enforces AST-only outputs for compileKind:'operator' blocks
- [ ] Validation is called during block compilation (integration point identified and implemented)
- [ ] All existing pure blocks pass validation (no violations in current codebase)
- [ ] Test: Pure block attempting to emit RenderTree throws compile error
- [ ] Test: Pure operator block producing raw closure (not AST) throws compile error

#### Technical Notes

**AST vs Closures**: The spec is very clear that pure operator blocks must produce AST nodes, not functions. This enables:
- Verification of purity by inspection
- Compiler optimizations (constant folding, fusion)
- Expression tree debugging
- Shader/expression export

**Artifact Kinds**: Will need to examine the current IR/artifact system to understand what `artifact.kind` values exist. Likely in `src/editor/compiler/ir/` or similar.

**Integration Challenge**: Need to identify where block compilation happens and where to insert validation. Likely candidates:
- Block compiler pass (src/editor/compiler/passes/)
- IR builder (src/editor/compiler/ir/)

**Gradual Rollout**: If existing pure blocks violate constraints, this can be a compile-time warning initially, then upgraded to error once violations are fixed.

---

## Out of Scope (Deferred to Future Sprints)

The following items from the STATUS report are explicitly **NOT** in this sprint:

1. **State Block UI Exposure** (Phase 2)
   - Creating user-facing BlockDefinitions for IntegrateBlock/HistoryBlock
   - Currently they exist as compiler-internal classes only
   - STATUS reference: lines 154-172

2. **CI Enforcement** (Phase 4)
   - Pre-commit hooks (`.husky/pre-commit`)
   - CI script (`scripts/check-kernel-primitives.ts`)
   - GitHub Actions workflow (`.github/workflows/check-primitives.yml`)
   - STATUS reference: lines 99-109

3. **3D Type System** (Phase 5 / Future)
   - Adding vec3, mat4, quat, camera, light, mesh, material types
   - Updating RenderNode structure
   - STATUS reference: lines 111-151

**Rationale**: This sprint focuses on the **foundational gating mechanism** only. Once capability enforcement works, subsequent sprints can add state blocks, CI checks, and 3D types without risk of violating the primitive closure.

---

## Dependency Graph

```
Deliverable 1: Capability Metadata
    ↓
Deliverable 2: KERNEL_PRIMITIVES + Validation
    ↓
Deliverable 3: Pure Block Enforcement
```

All deliverables are sequential - each depends on the previous one completing.

---

## Risk Assessment

### High Risk

1. **Schema Migration Completeness**
   - Risk: Missing a block definition during capability field addition
   - Mitigation: Use TypeScript compiler errors as checklist. Each missing field will be a compile error.
   - Impact: HIGH - incomplete migration breaks type safety

2. **Test Suite Breakage**
   - Risk: 79 tests already failing; schema change will break more
   - Mitigation: Fix tests file-by-file as part of deliverable acceptance criteria
   - Impact: MEDIUM - tests are not critical for enforcement mechanism validation

### Medium Risk

3. **Artifact Kind Mismatch**
   - Risk: validatePureBlockOutput checks for artifact kinds that don't exist or have different names
   - Mitigation: Survey IR/artifact system first, align validator with actual kinds
   - Impact: MEDIUM - validation would fail to catch violations

4. **GridDomain Classification**
   - Risk: Spec says composite, code treats as primitive
   - Mitigation: Document decision, keep as primitive for now, defer resolution
   - Impact: LOW - doesn't block enforcement, just needs alignment

### Low Risk

5. **Future Slot Naming**
   - Risk: RenderInstances vs RenderInstances2D mismatch
   - Risk: Future slots (RenderStrokes, TextSource) may have different names when implemented
   - Mitigation: Use spec names in KERNEL_PRIMITIVES, add aliases if needed
   - Impact: LOW - easy to refactor

---

## Recommended Sprint Execution Order

1. **Start with Deliverable 1** - Add capability types and update BlockDefinition
   - This is foundational and will surface all the blocks that need updating
   - Let TypeScript compiler drive the work

2. **Validate with Deliverable 2** - Add KERNEL_PRIMITIVES and registration validation
   - Ensures the schema changes actually work
   - Provides immediate feedback if blocks claim wrong capabilities

3. **Enforce with Deliverable 3** - Add pure block compilation validation
   - Completes the enforcement stack
   - Prevents future violations at compile time

**Total Sprint Complexity**: 3 deliverables, 8-12 days estimated effort

---

## Definition of Done (Sprint-Level)

This sprint is complete when:

- [ ] All 3 deliverables have their acceptance criteria met
- [ ] TypeScript compiles with no errors
- [ ] Application starts successfully with no validation errors
- [ ] Existing test suite status is no worse than baseline (79 failing is acceptable, >79 is not)
- [ ] Manual verification: Adding a test block with unauthorized capability throws error
- [ ] Documentation: KERNEL_PRIMITIVES is the authoritative list, frozen and locked

---

## Questions and Blockers

None identified. The STATUS report confirms:
- Spec provides complete guidance
- Implementation gaps are clearly defined
- No ambiguities require user clarification

Proceed with implementation.
