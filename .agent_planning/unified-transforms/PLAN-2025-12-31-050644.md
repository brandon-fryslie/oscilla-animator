# IR Transform Implementation Plan
**Generated**: 2025-12-31-050644
**Source STATUS**: STATUS-2025-12-31-ir-transforms.md
**Source Evaluation**: AUDIT-2025-12-31.md
**Source Specs**:
- `plans/PLAN-UNIFIED-TRANSFORMS-LENSES-ADAPTERS.md`
- `STATUS-2025-12-31-ir-transforms.md` §"Complexity Tiers"

---

## Executive Summary

**Current State**: Unified transforms infrastructure is **COMPLETE** (Sprint 5 infrastructure). Only 3 of 41 transforms (7%) have `compileToIR` implementations:
- ✅ ConstToSignal:float adapter
- ✅ scale lens
- ✅ clamp lens

**Goal**: Implement `compileToIR` for 22 additional transforms across 3 sprints, achieving **61% coverage** (25/41 transforms).

**Total Effort**: 3 sprints, estimated 6-8 days total
**Risk Level**: Low (infrastructure complete, copy-paste pattern established)

**Strategy**: Implement transforms in complexity tiers, prioritizing high-value operations:
1. **Sprint 1**: Quick wins (8 transforms) - Trivial identity/single-op implementations
2. **Sprint 2**: Phase transforms (6 transforms) - High-value phase manipulation
3. **Sprint 3**: Math transforms (8 transforms) - Common mathematical operations

**Coverage Milestones**:
- Current: 3/41 (7%)
- After Sprint 1: 11/41 (27%)
- After Sprint 2: 17/41 (41%)
- After Sprint 3: 25/41 (61%) ← **Target**

---

## Infrastructure Review (Already Complete)

### What Exists ✅

Per AUDIT-2025-12-31.md and STATUS-2025-12-31-ir-transforms.md:

1. **IR Node Types** (`src/editor/compiler/ir/transforms.ts`):
   ```typescript
   export interface TransformStepAdapter {
     kind: "adapter";
     adapterId: string;
     params?: Record<string, number>;
   }

   export interface TransformStepLens {
     kind: "lens";
     lensId: string;
     params?: Record<string, number>;
   }
   ```

2. **Registry Support**:
   - `AdapterDef.compileToIR` field (AdapterRegistry.ts line 29)
   - `LensDef.compileToIR` field (LensRegistry.ts line 30)
   - Context types: `AdapterIRCtx`, `LensIRCtx`

3. **Pass 8 Integration** (`pass8-link-resolution.ts`):
   - `applyAdapterChain()` (lines 398-452)
   - `applyLensStack()` (lines 460-521)
   - Clear error messages for unsupported transforms

4. **Validation** (`transforms/validate.ts`):
   - `validateForIRMode()` - fails fast with actionable errors

### Implementation Pattern (Established)

All three existing implementations follow this pattern:

```typescript
compileToIR: (input, params, ctx) => {
  // 1. Validate input kind
  if (input.k !== 'sig') return null;

  // 2. Validate param kinds (scalar const only currently)
  if (param?.k !== 'scalarConst') return null;

  // 3. Extract param values from const pool
  const value = ctx.builder.getConstPool()[param.constId];

  // 4. Build IR nodes (sigConst, sigZip with OpCodes)
  const outputType: IRTypeDesc = { world: 'signal', domain: 'float' };
  const paramSigId = ctx.builder.sigConst(value, outputType);
  const result = ctx.builder.sigZip(
    input.id,
    paramSigId,
    { kind: 'opcode', opcode: OpCode.Mul },
    outputType
  );

  // 5. Allocate slot and register
  const slot = ctx.builder.allocValueSlot(outputType);
  ctx.builder.registerSigSlot(result, slot);

  // 6. Return packed ValueRef
  return { k: 'sig', id: result, slot };
}
```

**No infrastructure work needed** - just copy-paste and modify OpCodes.

---

## Sprint 1: Quick Wins (Tier 1 Trivial)
**Duration**: 2-3 days
**Transforms**: 8 (identity + single OpCode operations)
**Goal**: Low-hanging fruit that enables multi-domain support

### Deliverable 1: ConstToSignal Domain Variants (3 adapters)
**Effort**: 0.5 day
**Status**: Not Started
**Dependencies**: None (copy from ConstToSignal:float)
**Spec Reference**: STATUS §"Tier 1: Trivial" • **Status Reference**: STATUS-2025-12-31-ir-transforms.md lines 270-283

#### Description
Implement `compileToIR` for remaining ConstToSignal domain variants. These are **identical** to the existing ConstToSignal:float implementation, only changing the `domain` field in `IRTypeDesc`.

**Current**: Only `ConstToSignal:float` implemented
**Target**: Add `vec2`, `color`, `boolean` variants

#### Files to Modify
**`src/editor/adapters/AdapterRegistry.ts`**:

1. **ConstToSignal:vec2** (line ~158):
   ```typescript
   compileToIR: (input, ctx) => {
     if (input.k !== 'scalarConst') return null;
     const constValue = ctx.builder.getConstPool()[input.constId];
     const outputType: IRTypeDesc = { world: 'signal', domain: 'vec2' }; // ← Change
     const sigId = ctx.builder.sigConst(constValue, outputType);
     const slot = ctx.builder.allocValueSlot(outputType);
     ctx.builder.registerSigSlot(sigId, slot);
     return { k: 'sig', id: sigId, slot };
   }
   ```

2. **ConstToSignal:color** (line ~172):
   - Same as vec2, change domain to `'color'`

3. **ConstToSignal:boolean** (line ~186):
   - Same pattern, change domain to `'boolean'`
   - Consider coercing value to 0/1 if needed

#### Acceptance Criteria
- [ ] ConstToSignal:vec2 has `compileToIR` implementation
- [ ] ConstToSignal:color has `compileToIR` implementation
- [ ] ConstToSignal:boolean has `compileToIR` implementation
- [ ] All three compile scalar const to signal const correctly
- [ ] Unit tests verify IR node generation for each domain
- [ ] Integration test: Wire with vec2 ConstToSignal adapter compiles in IR mode
- [ ] `just check` passes

#### Technical Notes
- **Copy-paste safe**: These are 100% identical except for domain string
- **No new OpCodes needed**: Uses existing `sigConst()`
- **Test pattern**: Same as float variant tests

---

### Deliverable 2: Phase Identity Adapters (2 adapters)
**Effort**: 0.5 day
**Status**: Not Started
**Dependencies**: None (trivial identity transforms)
**Spec Reference**: STATUS §"Tier 1: Trivial" • **Status Reference**: STATUS-2025-12-31-ir-transforms.md lines 272-275

#### Description
Implement `compileToIR` for PhaseToNumber adapters. These are **identity transforms** - phase is already a number, so they return the input unchanged.

**Adapters**:
- `PhaseToNumber:signal` - signal in, signal out (same value)
- `PhaseToNumber:scalar` - scalar in, scalar out (same value)

#### Files to Modify
**`src/editor/adapters/AdapterRegistry.ts`**:

1. **PhaseToNumber:signal** (line ~320):
   ```typescript
   compileToIR: (input, ctx) => {
     // Phase is already a number, this is identity transform
     if (input.k !== 'sig') return null;
     // Return input unchanged (no IR nodes needed)
     return input;
   }
   ```

2. **PhaseToNumber:scalar** (line ~334):
   ```typescript
   compileToIR: (input, ctx) => {
     // Scalar phase to scalar number is identity
     if (input.k !== 'scalarConst') return null;
     return input;
   }
   ```

#### Acceptance Criteria
- [ ] PhaseToNumber:signal returns input unchanged
- [ ] PhaseToNumber:scalar returns input unchanged
- [ ] No new IR nodes generated (identity = passthrough)
- [ ] Unit tests verify identity behavior
- [ ] Integration test: Wire with PhaseToNumber adapter compiles in IR mode
- [ ] `just check` passes

#### Technical Notes
- **Simplest possible implementation**: 3 lines total
- **No OpCodes needed**: Pure identity
- **Optimization**: No IR nodes generated, zero runtime overhead

---

### Deliverable 3: Simple Math Lenses (3 lenses)
**Effort**: 1 day
**Status**: Not Started
**Dependencies**: None (single OpCode operations)
**Spec Reference**: STATUS §"Tier 1: Trivial" • **Status Reference**: STATUS-2025-12-31-ir-transforms.md lines 276-282

#### Description
Implement `compileToIR` for simple single-OpCode lenses. These follow the exact pattern as `scale` and `clamp`, just using different OpCodes.

**Lenses**:
- `polarity` - Negate or absolute value (OpCode.Neg or OpCode.Abs)
- `vec2GainBias` - Component-wise scale + offset (copy scale pattern, vec2 domain)
- `translate2d` - 2D translation (copy scale pattern for offset only)

#### Files to Modify
**`src/editor/lenses/LensRegistry.ts`**:

1. **polarity lens** (line ~150):
   ```typescript
   compileToIR: (input, params, ctx) => {
     if (input.k !== 'sig') return null;
     const modeParam = params.mode;
     if (modeParam?.k !== 'scalarConst') return null;

     const mode = ctx.builder.getConstPool()[modeParam.constId];
     const outputType: IRTypeDesc = { world: 'signal', domain: 'float' };

     // mode: 0 = bipolar (negate), 1 = unipolar (abs)
     const opcode = mode === 1 ? OpCode.Abs : OpCode.Neg;
     const result = ctx.builder.sigUnary(input.id, { kind: 'opcode', opcode }, outputType);

     const slot = ctx.builder.allocValueSlot(outputType);
     ctx.builder.registerSigSlot(result, slot);
     return { k: 'sig', id: result, slot };
   }
   ```

2. **vec2GainBias lens** (line ~450):
   ```typescript
   compileToIR: (input, params, ctx) => {
     // Copy scale lens implementation exactly, change domain to 'vec2'
     if (input.k !== 'sig') return null;
     const gainParam = params.gain;
     const biasParam = params.bias;
     if (gainParam?.k !== 'scalarConst' || biasParam?.k !== 'scalarConst') {
       return null;
     }

     const gain = ctx.builder.getConstPool()[gainParam.constId];
     const bias = ctx.builder.getConstPool()[biasParam.constId];
     const outputType: IRTypeDesc = { world: 'signal', domain: 'vec2' }; // ← vec2

     let result = input.id;
     if (gain !== 1) {
       const gainSigId = ctx.builder.sigConst(gain, outputType);
       result = ctx.builder.sigZip(result, gainSigId,
                                    { kind: 'opcode', opcode: OpCode.Mul },
                                    outputType);
     }
     if (bias !== 0) {
       const biasSigId = ctx.builder.sigConst(bias, outputType);
       result = ctx.builder.sigZip(result, biasSigId,
                                    { kind: 'opcode', opcode: OpCode.Add },
                                    outputType);
     }

     const slot = ctx.builder.allocValueSlot(outputType);
     ctx.builder.registerSigSlot(result, slot);
     return { k: 'sig', id: result, slot };
   }
   ```

3. **translate2d lens** (line ~470):
   ```typescript
   compileToIR: (input, params, ctx) => {
     // Similar to vec2GainBias but offset only (no gain)
     if (input.k !== 'sig') return null;
     const offsetParam = params.offset;
     if (offsetParam?.k !== 'scalarConst') return null;

     const offset = ctx.builder.getConstPool()[offsetParam.constId];
     const outputType: IRTypeDesc = { world: 'signal', domain: 'vec2' };

     if (offset === 0) return input; // Optimization: no-op

     const offsetSigId = ctx.builder.sigConst(offset, outputType);
     const result = ctx.builder.sigZip(input.id, offsetSigId,
                                        { kind: 'opcode', opcode: OpCode.Add },
                                        outputType);

     const slot = ctx.builder.allocValueSlot(outputType);
     ctx.builder.registerSigSlot(result, slot);
     return { k: 'sig', id: result, slot };
   }
   ```

#### Acceptance Criteria
- [ ] polarity lens has `compileToIR` implementation
- [ ] vec2GainBias lens has `compileToIR` implementation
- [ ] translate2d lens has `compileToIR` implementation
- [ ] polarity uses OpCode.Neg or OpCode.Abs correctly
- [ ] vec2GainBias applies gain and bias with vec2 domain
- [ ] translate2d applies offset with vec2 domain
- [ ] Unit tests verify OpCode selection and IR node generation
- [ ] Integration test: Wire with polarity lens compiles in IR mode
- [ ] Integration test: Wire with vec2GainBias lens compiles in IR mode
- [ ] `just check` passes

#### Technical Notes
- **polarity**: May need to check if `sigUnary()` exists, or use `sigZip` with constant -1
- **vec2GainBias**: Direct copy-paste from scale lens
- **translate2d**: Simplified version of vec2GainBias (offset only)
- **Optimization**: Skip operations when param is identity value (0 or 1)

---

### Sprint 1 Summary
**Total Effort**: 2-3 days
**Deliverables**: 3
**Transforms**: 8 (3 adapters + 2 adapters + 3 lenses)
**Coverage**: 3 → 11/41 (27%)

**Critical Path**:
- Day 1: ConstToSignal variants + PhaseToNumber adapters (5 transforms)
- Day 2: Simple math lenses (3 transforms)
- Day 3: Testing and verification

**Verification**:
- `just check` passes
- All existing IR tests pass
- Manual test: Create patch using each new transform in IR mode
- Compare: Same behavior in closure vs IR mode

**Impact**: Enables basic multi-domain support (vec2, color, boolean) and phase identity conversions.

---

## Sprint 2: Phase Transforms (Tier 2 High-Value)
**Duration**: 2-3 days
**Transforms**: 6 (phase manipulation adapters + lenses)
**Goal**: Enable phase domain workflows critical for animation

### Deliverable 4: Phase Domain Adapters (2 adapters)
**Effort**: 1 day
**Status**: Not Started
**Dependencies**: Sprint 1 complete (pattern established)
**Spec Reference**: STATUS §"Tier 2: Simple" • **Status Reference**: STATUS-2025-12-31-ir-transforms.md lines 286-292

#### Description
Implement `compileToIR` for phase normalization adapters. These use modulo 1.0 operation to wrap values into [0, 1) range.

**Adapters**:
- `NormalizeToPhase:signal` - Wrap signal to phase range
- `NormalizeToPhase:scalar` - Wrap scalar constant to phase range (compile-time)

#### Files to Modify
**`src/editor/adapters/AdapterRegistry.ts`**:

1. **NormalizeToPhase:signal** (line ~280):
   ```typescript
   compileToIR: (input, ctx) => {
     if (input.k !== 'sig') return null;

     const outputType: IRTypeDesc = { world: 'signal', domain: 'float' };
     const oneConstId = ctx.builder.sigConst(1.0, outputType);

     // result = input % 1.0
     const result = ctx.builder.sigZip(
       input.id,
       oneConstId,
       { kind: 'opcode', opcode: OpCode.Mod },
       outputType
     );

     const slot = ctx.builder.allocValueSlot(outputType);
     ctx.builder.registerSigSlot(result, slot);
     return { k: 'sig', id: result, slot };
   }
   ```

2. **NormalizeToPhase:scalar** (line ~294):
   ```typescript
   compileToIR: (input, ctx) => {
     if (input.k !== 'scalarConst') return null;

     // Compile-time modulo
     const value = ctx.builder.getConstPool()[input.constId];
     const normalized = value % 1.0;

     // Create new const with normalized value
     const outputType: IRTypeDesc = { world: 'signal', domain: 'float' };
     const sigId = ctx.builder.sigConst(normalized, outputType);
     const slot = ctx.builder.allocValueSlot(outputType);
     ctx.builder.registerSigSlot(sigId, slot);
     return { k: 'sig', id: sigId, slot };
   }
   ```

#### Acceptance Criteria
- [ ] NormalizeToPhase:signal has `compileToIR` implementation
- [ ] NormalizeToPhase:scalar has `compileToIR` implementation
- [ ] Signal variant uses OpCode.Mod with 1.0
- [ ] Scalar variant performs compile-time modulo
- [ ] Unit tests verify phase normalization (2.3 → 0.3, -0.5 → 0.5)
- [ ] Integration test: Wire with NormalizeToPhase adapter compiles in IR mode
- [ ] `just check` passes

#### Technical Notes
- **OpCode.Mod**: May need to verify modulo OpCode exists in IR
- **Negative handling**: JavaScript modulo may return negative for negative inputs, may need adjustment
- **Optimization**: Scalar variant computes at compile-time (zero runtime cost)

---

### Deliverable 5: Phase Manipulation Lenses (4 lenses)
**Effort**: 1.5 days
**Status**: Not Started
**Dependencies**: Deliverable 4 (NormalizeToPhase pattern)
**Spec Reference**: STATUS §"Tier 2: Simple" • **Status Reference**: STATUS-2025-12-31-ir-transforms.md lines 286-299

#### Description
Implement `compileToIR` for phase-specific lenses. These are critical for animation looping and timing control.

**Lenses**:
- `phaseOffset` - Add offset, modulo 1.0 (phase shift)
- `phaseScale` - Multiply phase, modulo 1.0 (speed change)
- `quantize` - Step rounding (general-purpose, not phase-specific)
- `pingPong` - Triangle wave mapping (conditional, more complex)

#### Files to Modify
**`src/editor/lenses/LensRegistry.ts`**:

1. **phaseOffset lens** (line ~250):
   ```typescript
   compileToIR: (input, params, ctx) => {
     if (input.k !== 'sig') return null;
     const offsetParam = params.offset;
     if (offsetParam?.k !== 'scalarConst') return null;

     const offset = ctx.builder.getConstPool()[offsetParam.constId];
     const outputType: IRTypeDesc = { world: 'signal', domain: 'float' };

     // result = (input + offset) % 1.0
     const offsetSigId = ctx.builder.sigConst(offset, outputType);
     const added = ctx.builder.sigZip(input.id, offsetSigId,
                                       { kind: 'opcode', opcode: OpCode.Add },
                                       outputType);

     const oneConstId = ctx.builder.sigConst(1.0, outputType);
     const result = ctx.builder.sigZip(added, oneConstId,
                                        { kind: 'opcode', opcode: OpCode.Mod },
                                        outputType);

     const slot = ctx.builder.allocValueSlot(outputType);
     ctx.builder.registerSigSlot(result, slot);
     return { k: 'sig', id: result, slot };
   }
   ```

2. **phaseScale lens** (line ~270):
   ```typescript
   compileToIR: (input, params, ctx) => {
     if (input.k !== 'sig') return null;
     const scaleParam = params.scale;
     if (scaleParam?.k !== 'scalarConst') return null;

     const scale = ctx.builder.getConstPool()[scaleParam.constId];
     const outputType: IRTypeDesc = { world: 'signal', domain: 'float' };

     // result = (input * scale) % 1.0
     const scaleSigId = ctx.builder.sigConst(scale, outputType);
     const scaled = ctx.builder.sigZip(input.id, scaleSigId,
                                        { kind: 'opcode', opcode: OpCode.Mul },
                                        outputType);

     const oneConstId = ctx.builder.sigConst(1.0, outputType);
     const result = ctx.builder.sigZip(scaled, oneConstId,
                                        { kind: 'opcode', opcode: OpCode.Mod },
                                        outputType);

     const slot = ctx.builder.allocValueSlot(outputType);
     ctx.builder.registerSigSlot(result, slot);
     return { k: 'sig', id: result, slot };
   }
   ```

3. **quantize lens** (line ~220):
   ```typescript
   compileToIR: (input, params, ctx) => {
     if (input.k !== 'sig') return null;
     const stepsParam = params.steps;
     if (stepsParam?.k !== 'scalarConst') return null;

     const steps = ctx.builder.getConstPool()[stepsParam.constId];
     const outputType: IRTypeDesc = { world: 'signal', domain: 'float' };

     // result = floor(input * steps) / steps
     const stepsSigId = ctx.builder.sigConst(steps, outputType);
     const scaled = ctx.builder.sigZip(input.id, stepsSigId,
                                        { kind: 'opcode', opcode: OpCode.Mul },
                                        outputType);
     const floored = ctx.builder.sigUnary(scaled,
                                           { kind: 'opcode', opcode: OpCode.Floor },
                                           outputType);
     const result = ctx.builder.sigZip(floored, stepsSigId,
                                        { kind: 'opcode', opcode: OpCode.Div },
                                        outputType);

     const slot = ctx.builder.allocValueSlot(outputType);
     ctx.builder.registerSigSlot(result, slot);
     return { k: 'sig', id: result, slot };
   }
   ```

4. **pingPong lens** (line ~260):
   ```typescript
   compileToIR: (input, params, ctx) => {
     if (input.k !== 'sig') return null;

     const outputType: IRTypeDesc = { world: 'signal', domain: 'float' };

     // pingPong(x) = 1 - abs(2 * (x % 1.0) - 1)
     // Step 1: x % 1.0
     const oneConstId = ctx.builder.sigConst(1.0, outputType);
     const normalized = ctx.builder.sigZip(input.id, oneConstId,
                                             { kind: 'opcode', opcode: OpCode.Mod },
                                             outputType);

     // Step 2: 2 * normalized
     const twoConstId = ctx.builder.sigConst(2.0, outputType);
     const doubled = ctx.builder.sigZip(normalized, twoConstId,
                                         { kind: 'opcode', opcode: OpCode.Mul },
                                         outputType);

     // Step 3: doubled - 1
     const minusOne = ctx.builder.sigZip(doubled, oneConstId,
                                          { kind: 'opcode', opcode: OpCode.Sub },
                                          outputType);

     // Step 4: abs(minusOne)
     const absValue = ctx.builder.sigUnary(minusOne,
                                            { kind: 'opcode', opcode: OpCode.Abs },
                                            outputType);

     // Step 5: 1 - absValue
     const result = ctx.builder.sigZip(oneConstId, absValue,
                                        { kind: 'opcode', opcode: OpCode.Sub },
                                        outputType);

     const slot = ctx.builder.allocValueSlot(outputType);
     ctx.builder.registerSigSlot(result, slot);
     return { k: 'sig', id: result, slot };
   }
   ```

#### Acceptance Criteria
- [ ] phaseOffset lens has `compileToIR` implementation
- [ ] phaseScale lens has `compileToIR` implementation
- [ ] quantize lens has `compileToIR` implementation
- [ ] pingPong lens has `compileToIR` implementation
- [ ] phaseOffset wraps to [0, 1) range correctly
- [ ] phaseScale maintains phase domain after multiplication
- [ ] quantize produces step-quantized output
- [ ] pingPong produces triangle wave (0→1→0 over [0, 1) input)
- [ ] Unit tests verify each lens with known input/output pairs
- [ ] Integration test: Phase lenses work in IR mode
- [ ] `just check` passes

#### Technical Notes
- **OpCode requirements**: Need Mod, Floor, Abs (verify all exist)
- **pingPong complexity**: Multi-step expression, verify precedence
- **Optimization**: phaseOffset/phaseScale can skip mod if offset/scale is identity
- **Testing**: Use known phase values (0, 0.25, 0.5, 0.75, 1.0) to verify correctness

---

### Sprint 2 Summary
**Total Effort**: 2-3 days
**Deliverables**: 2
**Transforms**: 6 (2 adapters + 4 lenses)
**Coverage**: 11 → 17/41 (41%)

**Critical Path**:
- Day 1: NormalizeToPhase adapters (2 transforms)
- Day 2: phaseOffset, phaseScale, quantize lenses (3 transforms)
- Day 3: pingPong lens + testing (1 transform)

**Verification**:
- `just check` passes
- All existing IR tests pass
- Manual test: Create animation patch with phase manipulation in IR mode
- Compare: Phase wrapping/scaling works identically in closure vs IR mode

**Impact**: Enables critical animation workflows (phase offset for delay, phase scale for speed control, ping-pong for reversing loops).

---

## Sprint 3: Common Math Transforms (Tier 2 Remainder)
**Duration**: 2-3 days
**Transforms**: 8 (math operations + color transforms)
**Goal**: Complete high-value mathematical operations

### Deliverable 6: Duration Adapters (2 adapters)
**Effort**: 0.5 day
**Status**: Not Started
**Dependencies**: Sprint 2 complete (pattern established)
**Spec Reference**: STATUS §"Tier 2: Simple" • **Status Reference**: STATUS-2025-12-31-ir-transforms.md lines 290-292

#### Description
Implement `compileToIR` for duration conversion adapters. These are simple multiply/divide by 1000.

**Adapters**:
- `NumberToDurationMs` - Multiply by 1000 (seconds → milliseconds)
- `DurationToNumberMs` - Divide by 1000 (milliseconds → seconds)

#### Files to Modify
**`src/editor/adapters/AdapterRegistry.ts`**:

1. **NumberToDurationMs** (line ~348):
   ```typescript
   compileToIR: (input, ctx) => {
     if (input.k !== 'sig') return null;

     const outputType: IRTypeDesc = { world: 'signal', domain: 'float' };
     const thousandSigId = ctx.builder.sigConst(1000.0, outputType);
     const result = ctx.builder.sigZip(input.id, thousandSigId,
                                        { kind: 'opcode', opcode: OpCode.Mul },
                                        outputType);

     const slot = ctx.builder.allocValueSlot(outputType);
     ctx.builder.registerSigSlot(result, slot);
     return { k: 'sig', id: result, slot };
   }
   ```

2. **DurationToNumberMs** (line ~362):
   ```typescript
   compileToIR: (input, ctx) => {
     if (input.k !== 'sig') return null;

     const outputType: IRTypeDesc = { world: 'signal', domain: 'float' };
     const thousandSigId = ctx.builder.sigConst(1000.0, outputType);
     const result = ctx.builder.sigZip(input.id, thousandSigId,
                                        { kind: 'opcode', opcode: OpCode.Div },
                                        outputType);

     const slot = ctx.builder.allocValueSlot(outputType);
     ctx.builder.registerSigSlot(result, slot);
     return { k: 'sig', id: result, slot };
   }
   ```

#### Acceptance Criteria
- [ ] NumberToDurationMs has `compileToIR` implementation
- [ ] DurationToNumberMs has `compileToIR` implementation
- [ ] NumberToDurationMs multiplies by 1000 correctly
- [ ] DurationToNumberMs divides by 1000 correctly
- [ ] Unit tests verify conversion (1.5s → 1500ms, 3000ms → 3s)
- [ ] Integration test: Duration adapters work in IR mode
- [ ] `just check` passes

#### Technical Notes
- **Trivial implementation**: Copy scale lens, use fixed constant
- **Domain note**: Duration is just float with semantic meaning
- **Optimization**: None needed (constant multiplication is cheap)

---

### Deliverable 7: Advanced Math Lenses (4 lenses)
**Effort**: 1.5 days
**Status**: Not Started
**Dependencies**: Sprint 2 complete (OpCode pattern established)
**Spec Reference**: STATUS §"Tier 2: Simple" • **Status Reference**: STATUS-2025-12-31-ir-transforms.md lines 286-301

#### Description
Implement `compileToIR` for common mathematical operations. These require multiple OpCodes but follow established patterns.

**Lenses**:
- `deadzone` - Conditional zero (if abs(x) < threshold, return 0, else x)
- `mapRange` - Linear remap with optional clamp (high value, commonly used)
- `softclip` - Smooth saturation (may need tanh OpCode or approximation)
- `wrapMode` - Wrap/clamp/mirror modes (conditional)

#### Files to Modify
**`src/editor/lenses/LensRegistry.ts`**:

1. **deadzone lens** (line ~180):
   ```typescript
   compileToIR: (input, params, ctx) => {
     if (input.k !== 'sig') return null;
     const thresholdParam = params.threshold;
     if (thresholdParam?.k !== 'scalarConst') return null;

     const threshold = ctx.builder.getConstPool()[thresholdParam.constId];
     const outputType: IRTypeDesc = { world: 'signal', domain: 'float' };

     // if (abs(x) < threshold) return 0; else return x;
     // Approximate with: x * step(abs(x) - threshold)
     const absX = ctx.builder.sigUnary(input.id,
                                        { kind: 'opcode', opcode: OpCode.Abs },
                                        outputType);

     const thresholdSigId = ctx.builder.sigConst(threshold, outputType);
     const diff = ctx.builder.sigZip(absX, thresholdSigId,
                                      { kind: 'opcode', opcode: OpCode.Sub },
                                      outputType);

     // step(x) = x < 0 ? 0 : 1
     const gate = ctx.builder.sigUnary(diff,
                                        { kind: 'opcode', opcode: OpCode.Step },
                                        outputType);

     const result = ctx.builder.sigZip(input.id, gate,
                                        { kind: 'opcode', opcode: OpCode.Mul },
                                        outputType);

     const slot = ctx.builder.allocValueSlot(outputType);
     ctx.builder.registerSigSlot(result, slot);
     return { k: 'sig', id: result, slot };
   }
   ```

2. **mapRange lens** (line ~305):
   ```typescript
   compileToIR: (input, params, ctx) => {
     if (input.k !== 'sig') return null;
     const inMinParam = params.inMin;
     const inMaxParam = params.inMax;
     const outMinParam = params.outMin;
     const outMaxParam = params.outMax;
     const clampParam = params.clamp;

     if (inMinParam?.k !== 'scalarConst' || inMaxParam?.k !== 'scalarConst' ||
         outMinParam?.k !== 'scalarConst' || outMaxParam?.k !== 'scalarConst' ||
         clampParam?.k !== 'scalarConst') {
       return null;
     }

     const inMin = ctx.builder.getConstPool()[inMinParam.constId];
     const inMax = ctx.builder.getConstPool()[inMaxParam.constId];
     const outMin = ctx.builder.getConstPool()[outMinParam.constId];
     const outMax = ctx.builder.getConstPool()[outMaxParam.constId];
     const clamp = ctx.builder.getConstPool()[clampParam.constId];

     const outputType: IRTypeDesc = { world: 'signal', domain: 'float' };

     // result = ((x - inMin) / (inMax - inMin)) * (outMax - outMin) + outMin
     const inMinSigId = ctx.builder.sigConst(inMin, outputType);
     const shifted = ctx.builder.sigZip(input.id, inMinSigId,
                                         { kind: 'opcode', opcode: OpCode.Sub },
                                         outputType);

     const inRange = inMax - inMin;
     const inRangeSigId = ctx.builder.sigConst(inRange, outputType);
     const normalized = ctx.builder.sigZip(shifted, inRangeSigId,
                                            { kind: 'opcode', opcode: OpCode.Div },
                                            outputType);

     const outRange = outMax - outMin;
     const outRangeSigId = ctx.builder.sigConst(outRange, outputType);
     const scaled = ctx.builder.sigZip(normalized, outRangeSigId,
                                        { kind: 'opcode', opcode: OpCode.Mul },
                                        outputType);

     const outMinSigId = ctx.builder.sigConst(outMin, outputType);
     let result = ctx.builder.sigZip(scaled, outMinSigId,
                                      { kind: 'opcode', opcode: OpCode.Add },
                                      outputType);

     // Optional clamp
     if (clamp > 0) {
       const minClampSigId = ctx.builder.sigConst(Math.min(outMin, outMax), outputType);
       const maxClampSigId = ctx.builder.sigConst(Math.max(outMin, outMax), outputType);

       const clampedMax = ctx.builder.sigZip(result, maxClampSigId,
                                              { kind: 'opcode', opcode: OpCode.Min },
                                              outputType);
       result = ctx.builder.sigZip(clampedMax, minClampSigId,
                                    { kind: 'opcode', opcode: OpCode.Max },
                                    outputType);
     }

     const slot = ctx.builder.allocValueSlot(outputType);
     ctx.builder.registerSigSlot(result, slot);
     return { k: 'sig', id: result, slot };
   }
   ```

3. **softclip lens** (line ~170):
   ```typescript
   compileToIR: (input, params, ctx) => {
     if (input.k !== 'sig') return null;
     const thresholdParam = params.threshold;
     if (thresholdParam?.k !== 'scalarConst') return null;

     const threshold = ctx.builder.getConstPool()[thresholdParam.constId];
     const outputType: IRTypeDesc = { world: 'signal', domain: 'float' };

     // softclip(x) = tanh(x / threshold) * threshold
     // If tanh OpCode doesn't exist, use approximation:
     // tanh(x) ≈ x / (1 + abs(x))

     const thresholdSigId = ctx.builder.sigConst(threshold, outputType);
     const normalized = ctx.builder.sigZip(input.id, thresholdSigId,
                                            { kind: 'opcode', opcode: OpCode.Div },
                                            outputType);

     // Check if OpCode.Tanh exists, otherwise approximate
     let tanh;
     if (OpCode.Tanh !== undefined) {
       tanh = ctx.builder.sigUnary(normalized,
                                    { kind: 'opcode', opcode: OpCode.Tanh },
                                    outputType);
     } else {
       // Approximation: x / (1 + abs(x))
       const absX = ctx.builder.sigUnary(normalized,
                                          { kind: 'opcode', opcode: OpCode.Abs },
                                          outputType);
       const oneConstId = ctx.builder.sigConst(1.0, outputType);
       const denom = ctx.builder.sigZip(oneConstId, absX,
                                         { kind: 'opcode', opcode: OpCode.Add },
                                         outputType);
       tanh = ctx.builder.sigZip(normalized, denom,
                                  { kind: 'opcode', opcode: OpCode.Div },
                                  outputType);
     }

     const result = ctx.builder.sigZip(tanh, thresholdSigId,
                                        { kind: 'opcode', opcode: OpCode.Mul },
                                        outputType);

     const slot = ctx.builder.allocValueSlot(outputType);
     ctx.builder.registerSigSlot(result, slot);
     return { k: 'sig', id: result, slot };
   }
   ```

4. **wrapMode lens** (line ~290):
   ```typescript
   compileToIR: (input, params, ctx) => {
     if (input.k !== 'sig') return null;
     const modeParam = params.mode;
     if (modeParam?.k !== 'scalarConst') return null;

     const mode = ctx.builder.getConstPool()[modeParam.constId];
     const outputType: IRTypeDesc = { world: 'signal', domain: 'float' };

     // mode: 0 = wrap, 1 = clamp, 2 = mirror
     // For IR mode, implement conditionally based on mode value

     if (mode === 0) {
       // Wrap: x % 1.0
       const oneConstId = ctx.builder.sigConst(1.0, outputType);
       const result = ctx.builder.sigZip(input.id, oneConstId,
                                          { kind: 'opcode', opcode: OpCode.Mod },
                                          outputType);
       const slot = ctx.builder.allocValueSlot(outputType);
       ctx.builder.registerSigSlot(result, slot);
       return { k: 'sig', id: result, slot };
     } else if (mode === 1) {
       // Clamp: clamp(x, 0, 1)
       const zeroConstId = ctx.builder.sigConst(0.0, outputType);
       const oneConstId = ctx.builder.sigConst(1.0, outputType);
       const clampedMax = ctx.builder.sigZip(input.id, oneConstId,
                                              { kind: 'opcode', opcode: OpCode.Min },
                                              outputType);
       const result = ctx.builder.sigZip(clampedMax, zeroConstId,
                                          { kind: 'opcode', opcode: OpCode.Max },
                                          outputType);
       const slot = ctx.builder.allocValueSlot(outputType);
       ctx.builder.registerSigSlot(result, slot);
       return { k: 'sig', id: result, slot };
     } else if (mode === 2) {
       // Mirror: pingPong pattern
       // 1 - abs(2 * (x % 1.0) - 1)
       const oneConstId = ctx.builder.sigConst(1.0, outputType);
       const normalized = ctx.builder.sigZip(input.id, oneConstId,
                                              { kind: 'opcode', opcode: OpCode.Mod },
                                              outputType);
       const twoConstId = ctx.builder.sigConst(2.0, outputType);
       const doubled = ctx.builder.sigZip(normalized, twoConstId,
                                           { kind: 'opcode', opcode: OpCode.Mul },
                                           outputType);
       const minusOne = ctx.builder.sigZip(doubled, oneConstId,
                                            { kind: 'opcode', opcode: OpCode.Sub },
                                            outputType);
       const absValue = ctx.builder.sigUnary(minusOne,
                                              { kind: 'opcode', opcode: OpCode.Abs },
                                              outputType);
       const result = ctx.builder.sigZip(oneConstId, absValue,
                                          { kind: 'opcode', opcode: OpCode.Sub },
                                          outputType);
       const slot = ctx.builder.allocValueSlot(outputType);
       ctx.builder.registerSigSlot(result, slot);
       return { k: 'sig', id: result, slot };
     } else {
       // Unknown mode, fallback
       return null;
     }
   }
   ```

#### Acceptance Criteria
- [ ] deadzone lens has `compileToIR` implementation
- [ ] mapRange lens has `compileToIR` implementation
- [ ] softclip lens has `compileToIR` implementation
- [ ] wrapMode lens has `compileToIR` implementation
- [ ] deadzone zeroes values below threshold
- [ ] mapRange remaps [inMin, inMax] → [outMin, outMax] correctly
- [ ] mapRange clamp mode works (optional)
- [ ] softclip smoothly saturates values
- [ ] wrapMode wrap/clamp/mirror modes work correctly
- [ ] Unit tests verify each lens with known input/output pairs
- [ ] Integration test: Math lenses work in IR mode
- [ ] `just check` passes

#### Technical Notes
- **OpCode requirements**: Need Step (for deadzone), potentially Tanh (for softclip)
- **softclip fallback**: If Tanh doesn't exist, use approximation formula
- **mapRange complexity**: High-value lens, commonly used despite multi-step
- **wrapMode branching**: Compile-time branch based on mode param (acceptable)
- **Testing**: Use edge cases (0, 0.5, 1.0, negatives) to verify correctness

---

### Deliverable 8: Color Lenses (2 lenses)
**Effort**: 1 day
**Status**: Not Started
**Dependencies**: Sprint 2 complete (pattern established)
**Spec Reference**: STATUS §"Tier 2: Simple" • **Status Reference**: STATUS-2025-12-31-ir-transforms.md lines 296-299

#### Description
Implement `compileToIR` for basic color manipulation lenses. These operate component-wise on RGB values.

**Lenses**:
- `colorGain` - RGB multiply (component-wise scale)
- `contrast` - RGB contrast adjustment (scale around 0.5 midpoint)

#### Files to Modify
**`src/editor/lenses/LensRegistry.ts`**:

1. **colorGain lens** (line ~580):
   ```typescript
   compileToIR: (input, params, ctx) => {
     if (input.k !== 'sig') return null;
     const gainParam = params.gain;
     if (gainParam?.k !== 'scalarConst') return null;

     const gain = ctx.builder.getConstPool()[gainParam.constId];
     const outputType: IRTypeDesc = { world: 'signal', domain: 'color' };

     // Component-wise multiply (assuming color domain supports scalar multiply)
     const gainSigId = ctx.builder.sigConst(gain, outputType);
     const result = ctx.builder.sigZip(input.id, gainSigId,
                                        { kind: 'opcode', opcode: OpCode.Mul },
                                        outputType);

     const slot = ctx.builder.allocValueSlot(outputType);
     ctx.builder.registerSigSlot(result, slot);
     return { k: 'sig', id: result, slot };
   }
   ```

2. **contrast lens** (line ~610):
   ```typescript
   compileToIR: (input, params, ctx) => {
     if (input.k !== 'sig') return null;
     const contrastParam = params.contrast;
     if (contrastParam?.k !== 'scalarConst') return null;

     const contrast = ctx.builder.getConstPool()[contrastParam.constId];
     const outputType: IRTypeDesc = { world: 'signal', domain: 'color' };

     // contrast(x) = (x - 0.5) * contrast + 0.5
     const halfSigId = ctx.builder.sigConst(0.5, outputType);
     const centered = ctx.builder.sigZip(input.id, halfSigId,
                                          { kind: 'opcode', opcode: OpCode.Sub },
                                          outputType);

     const contrastSigId = ctx.builder.sigConst(contrast, outputType);
     const scaled = ctx.builder.sigZip(centered, contrastSigId,
                                        { kind: 'opcode', opcode: OpCode.Mul },
                                        outputType);

     const result = ctx.builder.sigZip(scaled, halfSigId,
                                        { kind: 'opcode', opcode: OpCode.Add },
                                        outputType);

     const slot = ctx.builder.allocValueSlot(outputType);
     ctx.builder.registerSigSlot(result, slot);
     return { k: 'sig', id: result, slot };
   }
   ```

#### Acceptance Criteria
- [ ] colorGain lens has `compileToIR` implementation
- [ ] contrast lens has `compileToIR` implementation
- [ ] colorGain multiplies RGB components correctly
- [ ] contrast scales around 0.5 midpoint (gray)
- [ ] Unit tests verify color transformations
- [ ] Integration test: Color lenses work in IR mode
- [ ] `just check` passes

#### Technical Notes
- **Color domain**: Verify OpCodes work with color domain (component-wise)
- **RGB assumption**: Assumes color is [R, G, B] vector
- **Optimization**: Same pattern as scale/offset for float domain
- **Testing**: Use known colors ([0.5, 0.5, 0.5], [1, 0, 0]) to verify

---

### Sprint 3 Summary
**Total Effort**: 2-3 days
**Deliverables**: 3
**Transforms**: 8 (2 adapters + 4 lenses + 2 lenses)
**Coverage**: 17 → 25/41 (61%)

**Critical Path**:
- Day 1: Duration adapters + deadzone lens (3 transforms)
- Day 2: mapRange + softclip + wrapMode lenses (3 transforms)
- Day 3: Color lenses + testing (2 transforms)

**Verification**:
- `just check` passes
- All existing IR tests pass
- Manual test: Create patch using each new transform in IR mode
- Compare: Same behavior in closure vs IR mode
- Verify color transforms work correctly

**Impact**: Completes high-value mathematical operations (mapRange is critical) and basic color support.

---

## Post-Sprint 3: Remaining Work (Deferred)

### Not Included in This Plan (19 transforms)

**Tier 3: Moderate Complexity (10 transforms)** - 8-12 hours:
- ease lens (curve lookup)
- rotate2d lens (2D rotation matrix)
- clampBounds lens (component-wise clamp)
- swirl lens (polar transform)
- normalize lens (vec2 normalization)
- hueShift lens (RGB→HSL→RGB)
- saturate lens (HSL saturation)
- clampGamut lens (RGB clamp)
- phaseQuantize lens (phase step quantize)
- phaseWindow lens (phase windowing)

**Tier 4: Complex (Stateful - 3 transforms)** - 16-24 hours:
- slew lens (requires IR state)
- hysteresis lens (requires IR state)
- smoothPath lens (requires IR state)

**Tier 4: Complex (Field - 6 transforms)** - 8-12 hours:
- BroadcastScalarToField:* adapters (depends on field IR maturity)
- BroadcastSignalToField:* adapters (depends on field IR maturity)
- ReduceFieldToSignal:* adapter (expensive, rarely used)

**Recommendation**: Address Tier 3 in future sprints if coverage gap becomes blocking. Defer Tier 4 indefinitely (stateful requires new infrastructure, field depends on field IR maturity).

---

## Dependency Graph

```
Sprint 1 (Quick Wins)
  └─> Deliverable 1: ConstToSignal variants (3 adapters)
  └─> Deliverable 2: Phase identity adapters (2 adapters)
  └─> Deliverable 3: Simple math lenses (3 lenses)

Sprint 2 (Phase Transforms) [depends on Sprint 1 pattern]
  └─> Deliverable 4: Phase domain adapters (2 adapters)
  └─> Deliverable 5: Phase manipulation lenses (4 lenses)

Sprint 3 (Math Transforms) [depends on Sprint 2 pattern]
  └─> Deliverable 6: Duration adapters (2 adapters)
  └─> Deliverable 7: Advanced math lenses (4 lenses)
  └─> Deliverable 8: Color lenses (2 lenses)
```

**No blocking dependencies** - all sprints build on established patterns from existing implementations.

---

## Risk Assessment

### Low Risk ✅

**All deliverables** (infrastructure complete, pattern established):
- Copy-paste implementation from existing transforms
- No new IR node types needed
- No runtime changes required
- Clear test pattern from scale/clamp examples

**Mitigation**: Implement one transform at a time, test immediately

### Medium Risk ⚠️

**OpCode availability**:
- Some OpCodes may not exist (Tanh, Step, Floor)
- May need fallback approximations

**Mitigation**: Check OpCode enum before implementation, use approximations if needed

**Color domain support**:
- Component-wise operations may need verification
- RGB vector operations may differ from float

**Mitigation**: Test color operations early, consult IR documentation

### No High Risk Items

All work is incremental and follows established patterns.

---

## Testing Strategy

### Unit Tests (Required for each transform)

**Test coverage**:
- Scalar const params → IR nodes generated correctly
- Signal inputs → transformed signals
- Null/invalid inputs → null return (graceful fallback)
- Edge cases (zero, negative, boundary values)

**Example test pattern** (copy from scale lens tests):
```typescript
describe('phaseOffset lens compileToIR', () => {
  it('should compile offset=0.25', () => {
    const input = { k: 'sig', id: sigId, slot: 0 };
    const params = {
      offset: { k: 'scalarConst', constId: 0 } // pool[0] = 0.25
    };
    const result = phaseOffsetLens.compileToIR(input, params, ctx);
    expect(result).toBeDefined();
    expect(result.k).toBe('sig');
  });

  it('should return null for non-signal input', () => {
    const input = { k: 'scalarConst', constId: 0 };
    const result = phaseOffsetLens.compileToIR(input, params, ctx);
    expect(result).toBeNull();
  });
});
```

### Integration Tests (Required for Pass 8)

**Test coverage**:
- Wire with new adapter → transformed connection
- Listener with new lens → transformed listener
- Error messages for unsupported transforms (verify clarity)

### Runtime Tests (Required for end-to-end)

**Test coverage**:
- Compiled IR executes correctly
- Output matches closure mode (equivalence test)
- Performance is acceptable (no significant regression)

**Equivalence test pattern**:
```typescript
it('phaseOffset produces same output in closure vs IR mode', () => {
  const patch = createPatchWithPhaseOffset();
  const closureOutput = compilePatch(patch, { mode: 'closure' });
  const irOutput = compilePatch(patch, { mode: 'ir' });
  expect(irOutput).toEqual(closureOutput);
});
```

---

## Implementation Guidelines

### Copy-Paste Checklist

When implementing a new transform:

1. **Find similar existing transform** (scale lens for math ops, ConstToSignal for adapters)
2. **Copy entire `compileToIR` function**
3. **Modify:**
   - [ ] OpCode (Mul → Add, etc.)
   - [ ] Domain (float → vec2, color, etc.)
   - [ ] Param names (scale → offset, etc.)
   - [ ] Param count (single → multiple)
4. **Verify:**
   - [ ] Input validation (sig/scalarConst check)
   - [ ] Param validation (scalarConst check)
   - [ ] Slot allocation and registration
   - [ ] Return packed ValueRef
5. **Test:**
   - [ ] Unit test with known input/output
   - [ ] Integration test in IR mode
   - [ ] Equivalence test (closure vs IR)

### OpCode Reference

**Arithmetic**:
- `OpCode.Add` - Addition
- `OpCode.Sub` - Subtraction
- `OpCode.Mul` - Multiplication
- `OpCode.Div` - Division
- `OpCode.Mod` - Modulo

**Comparison/Clamping**:
- `OpCode.Min` - Minimum of two values
- `OpCode.Max` - Maximum of two values

**Unary**:
- `OpCode.Neg` - Negate
- `OpCode.Abs` - Absolute value
- `OpCode.Floor` - Floor (may not exist, check)
- `OpCode.Tanh` - Hyperbolic tangent (may not exist, check)
- `OpCode.Step` - Step function (may not exist, check)

**If OpCode missing**: Use approximation or return `null` for now.

---

## Success Criteria (Final Definition of Done)

### Per-Sprint DOD

**Sprint 1 Complete**:
- [ ] 8 transforms have `compileToIR` implementations
- [ ] All ConstToSignal variants (float/vec2/color/boolean) work in IR mode
- [ ] PhaseToNumber adapters work (identity passthrough)
- [ ] Simple math lenses (polarity, vec2GainBias, translate2d) work
- [ ] All existing IR tests pass
- [ ] `just check` passes
- [ ] Coverage: 11/41 (27%)

**Sprint 2 Complete**:
- [ ] 6 phase transforms have `compileToIR` implementations
- [ ] NormalizeToPhase adapters work in IR mode
- [ ] Phase manipulation lenses (phaseOffset, phaseScale, quantize, pingPong) work
- [ ] All existing IR tests pass
- [ ] `just check` passes
- [ ] Coverage: 17/41 (41%)

**Sprint 3 Complete**:
- [ ] 8 math/color transforms have `compileToIR` implementations
- [ ] Duration adapters work in IR mode
- [ ] Advanced math lenses (deadzone, mapRange, softclip, wrapMode) work
- [ ] Color lenses (colorGain, contrast) work
- [ ] All existing IR tests pass
- [ ] `just check` passes
- [ ] Coverage: 25/41 (61%)

### Overall Definition of Done (All Sprints Complete)

**Architecture**:
- [ ] 22 new transforms have `compileToIR` implementations
- [ ] All implementations follow established pattern
- [ ] No infrastructure changes needed (uses existing IR primitives)

**Testing**:
- [ ] All new transforms have unit tests
- [ ] All new transforms have integration tests
- [ ] All new transforms have equivalence tests (closure vs IR)
- [ ] All existing tests pass (no regressions)
- [ ] `just check` passes

**Manual Verification**:
- [ ] Create patch with ConstToSignal:vec2 in IR mode → works
- [ ] Create patch with phaseOffset in IR mode → works
- [ ] Create patch with mapRange in IR mode → works
- [ ] Create patch with colorGain in IR mode → works
- [ ] All new transforms produce same output in closure vs IR mode

**Documentation**:
- [ ] Update STATUS file with new coverage numbers
- [ ] Document any OpCode approximations used
- [ ] List remaining unsupported transforms (Tier 3-5)

---

## Rollback Plan

**If Sprint 1 fails**:
- Revert adapter/lens registry changes
- Remove `compileToIR` implementations
- No impact on existing IR mode (only 3 transforms affected)

**If Sprint 2 fails**:
- Revert Sprint 2 changes
- Keep Sprint 1 implementations (independent)
- Phase transforms remain unsupported in IR mode

**If Sprint 3 fails**:
- Revert Sprint 3 changes
- Keep Sprint 1+2 implementations (independent)
- Math/color transforms remain unsupported in IR mode

**Critical Safety**: Each transform is independently revertable (single function change).

---

## Next Steps

**Immediate Actions** (ready to start Sprint 1):
1. Begin Deliverable 1: Copy ConstToSignal:float to vec2/color/boolean variants
2. Verify OpCode enum includes all needed operations
3. Write unit tests for ConstToSignal variants

**Before Starting Sprint 2**:
1. Verify OpCode.Mod exists (needed for phase normalization)
2. Verify OpCode.Floor exists (needed for quantize)

**Before Starting Sprint 3**:
1. Verify OpCode.Step exists (needed for deadzone)
2. Verify OpCode.Tanh exists (needed for softclip, or prepare approximation)
3. Verify color domain OpCodes work component-wise

**Recommended Starting Point**: Sprint 1, Deliverable 1 (ConstToSignal variants - lowest risk, highest value for multi-domain support)
