# Sprint Plan: IR Compiler to Rendering Wireup

**Generated**: 2026-01-04-010206
**Source STATUS**: EVALUATION-20260104.md
**Topic**: ir-render-wireup
**Sprint Scope**: Wire IR compiler pipeline to rendering (2-3 deliverables)

---

## Executive Summary

**Current State**: The IR compiler pipeline (passes 1-8) is fully implemented and tested, but **not wired to rendering**. The entry point (`compileBusAware.ts`) contains a stub that immediately returns `NotImplemented` errors, blocking all compilation.

**Gap**: Single critical blocker - the stub at `compileBusAware.ts:68-84` prevents the pass pipeline from being invoked. All infrastructure exists downstream (schedule builder, runtime adapter, Player integration).

**Sprint Goal**: Replace the stub with actual pass invocation to enable end-to-end compilation from Patch → CompiledProgramIR → visible rendering.

**Total Work Items**: 3 (P0: 1, P1: 2)
**Estimated Effort**: 3-5 days
**Risk Level**: Medium (straightforward wiring, but integration untested)

---

## Backlog by Priority

### P0 (Critical): Wire compileBusAware.ts to Pass Pipeline

**Status**: Not Started
**Effort**: Medium (3-5 hours)
**Dependencies**: None (all passes already exist)
**Spec Reference**: [04-compilation.md § Pipeline] • **Status Reference**: [EVALUATION-20260104.md § Critical Gap lines 106-196]

#### Description

Replace the stub in `compileBusAware.ts:68-84` with actual invocation of the pass pipeline. The stub currently returns `NotImplemented` errors immediately, preventing any compilation from occurring. This is the single blocker preventing the IR compiler from rendering anything.

The pass pipeline must be invoked sequentially:
1. Pass 1 (Normalize) - Graph normalization with D3 integration
2. Pass 2 (Types) - Type checking and validation
3. Pass 3 (Time Topology) - TimeRoot analysis and TimeModel inference
4. Pass 4 (DepGraph) - Dependency graph construction
5. Pass 5 (SCC) - Cycle validation with memory boundary checks
6. Pass 6 (Block Lowering) - Block → IR lowering
7. Pass 8 (Link Resolution) - Final IR linking (Pass 7 removed - buses treated as blocks)

After passes complete, call `buildCompiledProgram()` to generate the execution schedule, then wrap with `IRRuntimeAdapter` to create a `Program<RenderTree>` compatible with Player.

**Implementation Plan**:

1. **Import Required Modules**:
   ```typescript
   import {
     pass1Normalize,
     pass2TypeGraph,
     pass3TimeTopology,
     pass4DepGraph,
     pass5CycleValidation,
     pass6BlockLowering,
     pass8LinkResolution,
   } from './passes';
   import { buildCompiledProgram } from './ir/buildSchedule';
   import { IRRuntimeAdapter } from '../runtime/executor/IRRuntimeAdapter';
   ```

2. **Replace Stub (lines 68-84)** with pass pipeline:
   ```typescript
   export function compileBusAwarePatch(
     patch: CompilerPatch,
     registry: BlockRegistry,
     seed: number,
     ctx: CompileContext,
     options?: CompileOptions,
   ): CompileResult {
     // Early exit if IR not enabled (should never happen - default is true)
     if (!options?.emitIR) {
       return {
         ok: false,
         errors: [{
           code: 'NotImplemented',
           severity: 'error',
           title: 'Legacy Compiler Removed',
           message: 'The legacy compiler has been removed. Enable emitIR flag.',
         }],
       };
     }

     // Pass 1: Normalize
     const normalized = pass1Normalize(patch);

     // Pass 2: Type Graph
     const typed = pass2TypeGraph(normalized);

     // Pass 3: Time Topology
     const timeResolved = pass3TimeTopology(typed);

     // Pass 4: Dependency Graph
     const depGraphResult = pass4DepGraph(timeResolved);
     if (!depGraphResult.ok) {
       return { ok: false, errors: depGraphResult.errors };
     }

     // Pass 5: SCC Validation
     const sccResult = pass5CycleValidation(depGraphResult.depGraph);
     if (!sccResult.ok) {
       return { ok: false, errors: sccResult.errors };
     }

     // Pass 6: Block Lowering
     const lowerResult = pass6BlockLowering(sccResult.acyclicGraph, registry);
     if (!lowerResult.ok) {
       return { ok: false, errors: lowerResult.errors };
     }

     // Pass 8: Link Resolution
     const linkResult = pass8LinkResolution(lowerResult.unlinkedFragments);
     if (!linkResult.ok) {
       return { ok: false, errors: linkResult.errors };
     }

     // Build schedule from IR
     const program = buildCompiledProgram(
       linkResult.linkedGraphIR.builderIR,
       patch.patchId,
       patch.patchRevision ?? 0,
       seed,
       ctx.debugConfig?.schedule,
     );

     // Wrap in runtime adapter
     const adapter = new IRRuntimeAdapter(program);

     return {
       ok: true,
       program: adapter.createProgram(),
       timeModel: program.timeModel,
       errors: [],
     };
   }
   ```

3. **Error Handling Strategy**:
   - Passes 1-3: Direct return values (NormalizedPatch, TypedPatch, TimeResolvedPatch)
   - Passes 4-8: Result objects with `ok` field - check and early return on failure
   - Each pass validates its inputs and emits structured errors with codes (TR-xxx, FB-xxx)
   - Propagate errors to UI via CompileResult.errors

4. **Edge Cases**:
   - **Empty patch**: Pass 1 may emit `EmptyPatch` error - allow this to propagate (integration.ts handles it specially)
   - **Missing TimeRoot**: Pass 3 will emit TR-001 error
   - **Multiple TimeRoots**: Pass 3 will emit TR-002 error
   - **Illegal feedback**: Pass 5 will emit FB-301/FB-302/FB-303 errors
   - **Missing block compiler**: Pass 6 will emit compile error if block type has no compiler in registry

**Files Modified**:
- `src/editor/compiler/compileBusAware.ts` (replace lines 68-84, ~100 lines added)

**Files Referenced**:
- `src/editor/compiler/passes/index.ts` (pass exports)
- `src/editor/compiler/ir/buildSchedule.ts` (schedule builder)
- `src/editor/runtime/executor/IRRuntimeAdapter.ts` (adapter interface)
- `src/editor/compiler/types.ts` (CompileResult, CompileError, BlockRegistry)

#### Acceptance Criteria

- [ ] `compileBusAwarePatch()` invokes all 7 passes sequentially (1, 2, 3, 4, 5, 6, 8)
- [ ] Each pass result is validated before proceeding to next pass
- [ ] Errors from any pass are propagated via `CompileResult.errors` array
- [ ] `buildCompiledProgram()` is called with correct arguments (builderIR, patchId, patchRevision, seed)
- [ ] `IRRuntimeAdapter.createProgram()` returns a `Program<RenderTree>` compatible with Player
- [ ] CompileResult includes both `program` and `timeModel` on success
- [ ] TypeScript compilation succeeds (`just typecheck` passes)
- [ ] No regression in existing tests (`just test` passes)
- [ ] Empty patch handling works correctly (EmptyPatch error propagates)

#### Technical Notes

**Pass Return Types**:
- Pass 1: Returns `NormalizedPatch` directly (no Result wrapper)
- Pass 2: Returns `TypedPatch` directly (no Result wrapper)
- Pass 3: Returns `TimeResolvedPatch` directly (no Result wrapper)
- Pass 4: Returns `{ ok: boolean, depGraph?: DepGraphWithTimeModel, errors: CompileError[] }`
- Pass 5: Returns `{ ok: boolean, acyclicGraph?: AcyclicOrLegalGraph, errors: CompileError[] }`
- Pass 6: Returns `{ ok: boolean, unlinkedFragments?: UnlinkedIRFragments, errors: CompileError[] }`
- Pass 8: Returns `{ ok: boolean, linkedGraphIR?: LinkedGraphIR, errors: CompileError[] }`

**Why passes 1-3 don't fail**:
- They may mutate the patch structure but never return Result objects
- Errors are detected downstream (e.g., Pass 3 finds TimeRoot, Pass 4 detects topology errors)
- This is intentional - early passes are pure transformations

**Schedule Builder**:
- Converts `BuilderProgramIR` (linked IR graph) to `CompiledProgramIR` (execution schedule)
- Schedule includes: time derivation, signal evaluation, field materialization, 3D projection, render assembly
- Deterministic ordering based on dependency graph from Pass 4

**Runtime Adapter**:
- Implements `Program<RenderTree>` interface expected by Player
- `createProgram()` returns object with `run(ctx) => RenderTree` method
- Internally calls `executeAndGetFrame(tMs)` to produce `RenderFrameIR`

---

### P1 (High): Integration Test for End-to-End Pipeline

**Status**: Not Started
**Effort**: Small (1-2 hours)
**Dependencies**: P0 (compileBusAware wiring)
**Spec Reference**: [04-compilation.md § Pipeline] • **Status Reference**: [EVALUATION-20260104.md § Test Coverage lines 283-293]

#### Description

Create an end-to-end integration test that verifies the complete compilation pipeline from Patch JSON → CompiledProgramIR → RenderFrameIR. This test ensures all passes work together correctly and that the runtime adapter produces valid output.

Currently, only individual passes (3, 4, 5) have unit tests. No test exists that exercises the full pipeline end-to-end.

**Test Structure**:

```typescript
// src/editor/compiler/__tests__/ir-pipeline-integration.test.ts
import { describe, it, expect } from 'vitest';
import { compileBusAwarePatch } from '../compileBusAware';
import { getBlockRegistry } from '../../blocks/registry';

describe('IR Pipeline Integration', () => {
  it('compiles minimal patch with TimeRoot + Domain + Render', () => {
    // Arrange: Create minimal patch
    const patch = {
      patchId: 'test-patch',
      patchRevision: 1,
      blocks: [
        { id: 'time', type: 'InfiniteTimeRoot', params: {} },
        { id: 'domain', type: 'Domain', params: { count: 10 } },
        { id: 'render', type: 'RenderInstances2D', params: {} },
      ],
      edges: [
        { from: { blockId: 'time', portId: 't' }, to: { blockId: 'domain', portId: 'time' } },
        { from: { blockId: 'domain', portId: 'index' }, to: { blockId: 'render', portId: 'instances' } },
      ],
    };

    const registry = getBlockRegistry();
    const seed = 12345;
    const ctx = {};

    // Act: Compile patch
    const result = compileBusAwarePatch(patch, registry, seed, ctx, { emitIR: true });

    // Assert: Compilation succeeds
    expect(result.ok).toBe(true);
    expect(result.program).toBeDefined();
    expect(result.timeModel).toBeDefined();
    expect(result.timeModel?.kind).toBe('infinite');
    expect(result.errors).toHaveLength(0);

    // Assert: Program can execute
    const frame = result.program!.run({ t: 0, seed, dt: 16, runState: {} });
    expect(frame).toBeDefined();
    expect(frame.renderTree).toBeDefined();
  });

  it('fails with clear error when no TimeRoot present', () => {
    const patch = {
      patchId: 'test-patch',
      patchRevision: 1,
      blocks: [
        { id: 'domain', type: 'Domain', params: { count: 10 } },
      ],
      edges: [],
    };

    const registry = getBlockRegistry();
    const result = compileBusAwarePatch(patch, registry, 12345, {}, { emitIR: true });

    expect(result.ok).toBe(false);
    expect(result.errors).toHaveLength(1);
    expect(result.errors[0].code).toBe('TR-001'); // No Time Topology
  });

  it('fails with clear error when multiple TimeRoots present', () => {
    const patch = {
      patchId: 'test-patch',
      patchRevision: 1,
      blocks: [
        { id: 'time1', type: 'InfiniteTimeRoot', params: {} },
        { id: 'time2', type: 'InfiniteTimeRoot', params: {} },
      ],
      edges: [],
    };

    const registry = getBlockRegistry();
    const result = compileBusAwarePatch(patch, registry, 12345, {}, { emitIR: true });

    expect(result.ok).toBe(false);
    expect(result.errors[0].code).toBe('TR-002'); // Conflicting Topology
  });
});
```

**Files Created**:
- `src/editor/compiler/__tests__/ir-pipeline-integration.test.ts` (new file, ~100 lines)

**Files Referenced**:
- Existing pass tests: `pass3-time.test.ts`, `pass4-depgraph.test.ts`, `pass5-scc.test.ts`

#### Acceptance Criteria

- [ ] Test file created at `src/editor/compiler/__tests__/ir-pipeline-integration.test.ts`
- [ ] Test case 1: Minimal valid patch (TimeRoot + Domain + Render) compiles successfully
- [ ] Test case 2: Patch without TimeRoot fails with TR-001 error
- [ ] Test case 3: Patch with multiple TimeRoots fails with TR-002 error
- [ ] Successful compilation produces non-null `program` and `timeModel`
- [ ] Program.run() executes without throwing and produces RenderTree
- [ ] All tests pass (`just test` or `just test-file <path>`)
- [ ] Test runs in <5 seconds (no browser automation needed)

#### Technical Notes

**Test Fixture Strategy**:
- Use minimal patches (3-5 blocks) to avoid complexity
- Test one topology feature per test case
- Reuse BlockRegistry from production code (`getBlockRegistry()`)
- Use fixed seeds for reproducibility

**Coverage Goals**:
- Happy path: Valid patch compiles and renders
- Error path: Invalid topology errors detected
- Boundary: Empty patch, single block, etc.

**Not Testing** (defer to future):
- Performance under load
- Complex feedback loops (tested in pass5-scc.test.ts)
- All block types (tested in block-specific tests)
- Hot swap (separate concern)

---

### P1 (High): Verify CompilerService Integration

**Status**: Not Started
**Effort**: Small (30 mins - 1 hour)
**Dependencies**: P0 (compileBusAware wiring)
**Spec Reference**: [04-compilation.md § Output] • **Status Reference**: [EVALUATION-20260104.md § Hook CompilerService lines 215-237]

#### Description

Verify that `CompilerService.getProgram()` correctly extracts the IR-wrapped program from compilation results and returns it to the Player. The current implementation at `integration.ts:1061-1072` should already work if `CompileResult` has the right shape, but this needs explicit verification.

**Current Implementation**:
```typescript
// src/editor/compiler/integration.ts:1061-1072
getProgram(): CompiledProgram | null {
  const hasProgram = lastResult?.program != null || lastResult?.canvasProgram != null;
  if (!hasProgram || lastResult?.timeModel == null) {
    return null;
  }
  return {
    program: lastResult.program,
    canvasProgram: lastResult.canvasProgram,
    timeModel: lastResult.timeModel,
  };
}
```

**Verification Steps**:

1. **Static Analysis**: Confirm `CompileResult` shape matches `CompiledProgram`:
   - `CompileResult.program` is `Program<RenderTree> | undefined`
   - `CompileResult.timeModel` is `TimeModel | undefined`
   - `getProgram()` returns `{ program?, canvasProgram?, timeModel }`
   - IRRuntimeAdapter.createProgram() returns `Program<RenderTree>`

2. **Runtime Verification**: Load editor with a simple patch and verify:
   - Compilation succeeds (check DevTools console for errors)
   - CompilerService.getProgram() returns non-null
   - Player.preview receives valid program
   - Canvas renders visible output (not blank/error state)

3. **Manual Testing** (using Chrome DevTools MCP):
   - Open editor at `http://localhost:5173`
   - Create patch with TimeRoot + Domain + RenderInstances2D
   - Observe compilation in Network panel (should see no errors)
   - Take snapshot of canvas - should show rendered output
   - Check console for any IR-related warnings/errors

**Expected Outcome**:
- No code changes needed if CompileResult shape is correct
- If integration broken, likely due to missing field or type mismatch
- Document findings in work log or SUMMARY

**Files Inspected**:
- `src/editor/compiler/integration.ts` (CompilerService.getProgram)
- `src/editor/compiler/types.ts` (CompileResult, CompiledProgram)
- `src/editor/runtime/executor/IRRuntimeAdapter.ts` (createProgram return type)

#### Acceptance Criteria

- [ ] Static analysis confirms CompileResult → CompiledProgram type compatibility
- [ ] IRRuntimeAdapter.createProgram() return type matches Program<RenderTree>
- [ ] Manual test: Editor loads without TypeScript errors
- [ ] Manual test: Simple patch compiles successfully (no console errors)
- [ ] Manual test: Canvas shows rendered output (not blank)
- [ ] Manual test: Player.preview receives valid program from getProgram()
- [ ] No code changes needed OR clear fix identified if broken
- [ ] Findings documented in SUMMARY-planner file or work log

#### Technical Notes

**Why This Might Already Work**:
- `compileBusAwarePatch()` returns `CompileResult` with correct fields
- `IRRuntimeAdapter.createProgram()` implements `Program<RenderTree>`
- `getProgram()` just passes fields through
- No transformation needed beyond what P0 does

**Why This Might Fail**:
- Missing field in CompileResult (e.g., `canvasProgram` not set)
- Type mismatch between IRRuntimeAdapter output and Program<RenderTree>
- Player expects different interface than what adapter provides
- Hot swap logic broken (not tested in P0)

**Fallback Plan**:
- If broken, create minimal fix and add to P0 scope
- If working, document success and close this item immediately

---

## Deferred Work (Out of Sprint Scope)

### Missing Block Compilers (P2 - If Needed)

**Reason for Deferral**: User mentioned "2-3 missing block definitions" but `just typecheck` passes cleanly. Either already fixed OR errors are runtime (not compile-time). Will emerge naturally during integration testing if present.

**Original Priority**: P2 (Medium)
**Trigger**: If integration test reveals missing compilers in Pass 6
**Estimated Effort**: 1-3 hours (depends on how many blocks)

**Investigation Plan** (if triggered):
1. Run integration test suite
2. Identify blocks causing Pass 6 errors (code "MissingBlockCompiler")
3. Check `src/editor/blocks/registry.ts` validation output
4. Add missing compilers to `src/editor/compiler/blocks/<category>/`

### Hot Swap Verification (P3 - Nice to Have)

**Reason for Deferral**: Not critical for initial wireup. Hot swap tested separately once basic rendering works.

**Original Priority**: P3 (Low)
**Estimated Effort**: 2-3 hours
**Spec Reference**: [05-runtime.md § Hot Swap]

**Test Plan** (if time permits):
1. Compile patch → get program A
2. Modify scalar parameter → get program B
3. Call `adapter.swapProgram(programB)`
4. Verify Player continues rendering without flicker
5. Verify state preserved across swap (if stateful blocks present)

---

## Dependency Graph

```
P0: Wire compileBusAware.ts
    ↓ (blocks until wired)
P1: Integration Test ←─┐
    ↓                   │
P1: Verify CompilerService (can run in parallel)

[Deferred]
P2: Missing Block Compilers (triggered by integration test failures)
P3: Hot Swap Verification (separate sprint)
```

**Critical Path**: P0 → P1 (Integration Test)
**Parallel Work**: P1 (CompilerService verification) can start immediately after P0

---

## Risk Assessment

| Risk | Severity | Likelihood | Mitigation |
|------|----------|------------|------------|
| Pass pipeline fails on real patches | HIGH | Medium | Start with minimal test patches, add complexity incrementally |
| Missing block compilers cause runtime errors | MEDIUM | Low | Registry validation catches at module load time (lines 101-110) |
| Schedule generation incomplete | MEDIUM | Low | buildSchedule.ts already tested with pass outputs |
| Adapter doesn't match Player interface | LOW | Low | IRRuntimeAdapter implements Program<T> interface |
| Integration test reveals structural issues | MEDIUM | Medium | Keep test scope small, focus on happy path first |
| Empty patch handling broken | LOW | Low | integration.ts already handles EmptyPatch specially |

**Overall Risk**: MEDIUM
**Confidence**: HIGH (all infrastructure exists, just needs wiring)

---

## Recommended Sprint Flow

### Day 1: P0 Wiring (3-5 hours)
1. Replace stub in compileBusAware.ts (2-3 hours)
2. Fix TypeScript errors (30 mins)
3. Run `just check` to verify no regressions (15 mins)
4. Manual smoke test with simple patch (30 mins)

### Day 2: P1 Integration Test (1-2 hours)
1. Create test file structure (15 mins)
2. Write minimal valid patch test (30 mins)
3. Write error case tests (30 mins)
4. Run and debug (30 mins)

### Day 2-3: P1 CompilerService Verification (30 mins - 1 hour)
1. Static type analysis (15 mins)
2. Manual browser testing with Chrome DevTools MCP (30 mins)
3. Document findings (15 mins)

### Day 3: Contingency & Cleanup
- Fix any issues discovered in testing
- Address missing block compilers if they emerge
- Update documentation if needed
- Prepare for handoff or next sprint

**Total Estimated Time**: 5-8 hours active work over 2-3 days

---

## Blockers and Questions

### Question 1: Empty Patch Behavior

**Question**: When patch has 0 blocks, should pass pipeline fail gracefully or emit specific EmptyPatch error?

**Current Behavior** (from integration.ts:986-1003):
```typescript
const isEmptyPatch = result.errors.length === 1 &&
                     result.errors[0].code === 'EmptyPatch';

if (isEmptyPatch) {
  // Silently clear state - no error logging for empty patch
  lastDecorations = emptyDecorations();
  // Still emit CompileFinished event
}
```

**Impact**: LOW (edge case)
**Resolution**: Follow existing pattern - if Pass 1 emits EmptyPatch error, allow it to propagate. Integration layer already handles it.

### Question 2: Legacy Compiler Fallback

**Question**: When `emitIR: false`, should compilation fail or fall back to legacy compiler?

**Current**: Stub always fails regardless of flag.

**Recommendation**: Fail with clear error "Legacy compiler removed, enable emitIR flag"
**Rationale**: Legacy compiler deprecated, IR is the canonical path forward
**Impact**: MEDIUM (affects backward compatibility if anyone disables flag)

### Question 3: Missing Block Compiler Behavior

**Question**: If a block type has no compiler in Pass 6, what happens?

**Options**:
- A: Fail compilation with clear error "No compiler for block type X"
- B: Skip block (dangerous - silent failure)
- C: Use default/fallback compiler

**Current**: Unknown - needs code inspection of pass6-block-lowering.ts
**Impact**: HIGH if option B (silent failure)
**Resolution**: Will be discovered during P0 implementation. Likely option A based on error-first design philosophy.

---

## Success Criteria (Sprint Complete When...)

- [ ] P0: compileBusAware.ts wired to pass pipeline
- [ ] P0: TypeScript compilation succeeds (`just typecheck`)
- [ ] P0: Existing tests pass (`just test`)
- [ ] P1: Integration test written and passing
- [ ] P1: CompilerService integration verified (manual test)
- [ ] Simple patch renders visible output in browser
- [ ] No silent failures or suppressed errors
- [ ] All acceptance criteria met for P0 and P1 items

**Definition of Done**: See DOD-2026-01-04-010206.md

---

## Relevant Files

### Must Modify
- `src/editor/compiler/compileBusAware.ts` (replace stub, ~100 lines added)
- `src/editor/compiler/__tests__/ir-pipeline-integration.test.ts` (new test file, ~100 lines)

### Must Read
- `src/editor/compiler/passes/index.ts` (pass exports and signatures)
- `src/editor/compiler/ir/buildSchedule.ts` (schedule builder function)
- `src/editor/runtime/executor/IRRuntimeAdapter.ts` (adapter interface)
- `src/editor/compiler/types.ts` (CompileResult, CompileError, BlockRegistry)
- `design-docs/spec/04-compilation.md` (compilation spec)
- `design-docs/spec/05-runtime.md` (runtime spec)

### May Need
- `src/editor/compiler/integration.ts` (if getProgram needs changes)
- `src/editor/blocks/registry.ts` (if missing compilers identified)
- `src/editor/compiler/blocks/` (if new block compilers needed)

### Test References
- `src/editor/compiler/passes/__tests__/pass3-time.test.ts` (example pass test)
- `src/editor/compiler/passes/__tests__/pass4-depgraph.test.ts` (example pass test)
- `src/editor/compiler/passes/__tests__/pass5-scc.test.ts` (example pass test)

---

## Next Steps After Sprint

1. **Performance profiling**: Measure compilation time for real patches
2. **Error message quality**: Improve error messages with better context/suggestions
3. **Hot swap testing**: Verify state preservation across program swaps
4. **Canvas renderer**: Wire up canvasProgram path (currently only SVG works)
5. **Debug tooling**: Expose IR schedule in debug panel for inspection
6. **Documentation**: Update compilation docs with IR architecture details
