# Diagnostics System - Current State Assessment (REVISED)

**Generated:** 2025-12-20-174727
**Topic:** Diagnostics System Implementation
**Evaluator:** status-planner
**Source Design Doc:** design-docs/4-Event-System/3.5-Events-and-Payloads-Schema.md

---

## Executive Summary

The Oscilla Animator project requires a **minimal, coherent diagnostics system** based on 5 snapshot-based events (NOT per-diagnostic events). The authoritative design doc (`3.5-Events-and-Payloads-Schema.md`) specifies a fundamentally different architecture than originally planned:

**Key Architectural Principle:**
- Diagnostics are delivered as **snapshots** in lifecycle events (GraphCommitted, CompileFinished, RuntimeHealthSnapshot)
- **NO DiagnosticAdded/Resolved/Cleared events** (these would spam EventHub)
- DiagnosticHub consumes lifecycle events and maintains diagnostic state internally

**Current State:** Not Started (0% complete)
**Blockers:** None - greenfield implementation
**Dependencies:** EventDispatcher operational, but current events need replacement

---

## What Exists Today

### Event System Infrastructure (Needs Revision)
- **EventDispatcher** (`src/editor/events/EventDispatcher.ts`): Synchronous event dispatcher (operational)
- **14 Event Types** defined in `src/editor/events/types.ts`:
  - ❌ `CompileSucceeded`, `CompileFailed` - **REPLACE** with single `CompileFinished` event
  - ❌ `BlockAdded`, `BlockRemoved`, `WireAdded`, `WireRemoved`, etc. - **REPLACE** with single `GraphCommitted` event
  - ✅ Keep: `MacroExpanded`, `PatchLoaded`, `PatchCleared` (UI-only, DiagnosticHub ignores)
- **EventDispatcher integration** in RootStore (line 30): Operational

### LogStore (Legacy, Needs Replacement)
- **LogStore** (`src/editor/logStore.ts`): String-based logging, not structured
- **Usage in compiler**: `compiler/integration.ts` uses `logStore.warn()`, `logStore.error()`
- **Migration Path**: Replace with diagnostic emission in `CompileFinished` event payload

### Store Architecture (Ready for Extension)
- **RootStore pattern**: Established (PatchStore, BusStore, UIStateStore, CompositeStore)
- **MobX observables**: All stores use `makeObservable()` pattern

---

## What Does NOT Exist

### Core Diagnostic Types (0% complete)
- [ ] `Diagnostic` record type (code, severity, domain, primaryTarget, affectedTargets, message, payload, metadata)
- [ ] `TargetRef` union type (block, port, bus, binding, timeRoot, graphSpan)
- [ ] `DiagnosticCode` enum (E_TIME_ROOT_MISSING, E_TYPE_MISMATCH, W_BUS_EMPTY, etc.)
- [ ] `Severity` enum (hint, info, warn, error, fatal)
- [ ] `Domain` enum (authoring, compile, runtime, perf)
- [ ] Structured payload types per diagnostic code

### Required Events (0% complete, REPLACES 14 existing events)

**1. GraphCommitted** (REPLACES: BlockAdded, BlockRemoved, WireAdded, WireRemoved, BindingAdded, BindingRemoved, BusCreated, BusDeleted)
- [ ] Event type definition
- [ ] Payload: patchId, patchRevision (monotonic), reason (userEdit|macroExpand|undo|redo)
- [ ] diffSummary: counts (blocksAdded/Removed, busesChanged)
- [ ] affectedBlockIds[], affectedBusIds[]
- [ ] Emission from PatchStore after graph mutations

**2. CompileStarted**
- [ ] Event type definition
- [ ] Payload: compileId (UUID), patchRevision, trigger (graphCommitted|manual|startup)
- [ ] Emission from compiler on compile start

**3. CompileFinished** (REPLACES: CompileSucceeded, CompileFailed)
- [ ] Event type definition
- [ ] Payload: compileId, patchRevision, status (ok|failed), durationMs
- [ ] **diagnostics: Diagnostic[] snapshot** (complete, structured)
- [ ] programMeta (if ok): timelineHint, timeRootKind, busUsageSummary
- [ ] Emission from compiler on completion (regardless of success/failure)

**4. ProgramSwapped**
- [ ] Event type definition
- [ ] Payload: patchRevision, compileId, swapMode (hard|soft|deferred), swapLatencyMs
- [ ] Emission from Player when new program becomes active

**5. RuntimeHealthSnapshot** (throttled 2-5Hz, Phase 2 if complex)
- [ ] Event type definition
- [ ] Payload: frameBudget (fpsEstimate, avgFrameMs), evalStats
- [ ] nanCount, infCount, fieldMaterializations
- [ ] diagnosticsDelta (raised/resolved ids) OR full snapshot
- [ ] Emission from Player at fixed 2-5Hz rate

### DiagnosticHub (0% complete, DIFFERENT CONTRACT)
- [ ] Class definition
- [ ] **Snapshot-based state management** (NOT per-diagnostic add/resolve)
- [ ] Event subscriptions:
  - On `GraphCommitted`: run fast authoring validators, update authoring snapshot
  - On `CompileStarted`: mark compile diagnostics "pending"
  - On `CompileFinished`: **replace** compile snapshot with event payload
  - On `ProgramSwapped`: set active revision pointer
  - On `RuntimeHealthSnapshot`: update runtime diagnostics (dedupe/expire)
- [ ] Stable ID generation for deduplication (`hash(code + primaryTarget + signature)`)
- [ ] Namespace separation (compile snapshot, runtime rolling window, authoring, export)
- [ ] Query methods: `getAll(filters?)`, `getByRevision(patchRevision)`, `getActive()`

### DiagnosticStore (0% complete)
- [ ] MobX observable store wrapping DiagnosticHub
- [ ] Computed properties: activeDiagnostics, errorCount, warningCount
- [ ] Reactivity: auto-updates when hub state changes via events

### Compiler Integration (0% complete)
- [ ] Replace `logStore.warn()` / `logStore.error()` with diagnostic list building
- [ ] Emit diagnostics in `CompileFinished` event payload:
  - E_TIME_ROOT_MISSING (error)
  - E_TIME_ROOT_MULTIPLE (error)
  - E_TYPE_MISMATCH (error)
  - W_BUS_EMPTY (warning)
  - W_GRAPH_UNUSED_OUTPUT (warning)
- [ ] Emit `CompileStarted` at beginning of compile
- [ ] Emit single `CompileFinished` (not split success/fail)

### PatchStore Integration (0% complete)
- [ ] Emit `GraphCommitted` after any graph mutation
- [ ] Implement patchRevision counter (monotonic)
- [ ] Compute diffSummary on mutations
- [ ] Track affectedBlockIds/affectedBusIds

### Player Integration (Phase 2)
- [ ] Emit `ProgramSwapped` when program becomes active
- [ ] Emit `RuntimeHealthSnapshot` at 2-5Hz
- [ ] Collect runtime stats (NaN/Inf counts, frame budget, field materializations)

---

## Gap Analysis

### Foundation Gaps (Critical - P0)
1. **No diagnostic type definitions** - Core types do not exist
2. **Wrong event architecture** - Current events (14 types) conflict with design doc (5 types)
3. **No DiagnosticHub with snapshot semantics** - Hub needs to consume events, not produce them
4. **No GraphCommitted event** - Replaces 8 fine-grained events
5. **No CompileFinished single event** - Current CompileSucceeded/CompileFailed are wrong model
6. **No patchRevision counter** - Monotonic revision tracking missing

### Integration Gaps (High - P1)
1. **Compiler doesn't build diagnostic snapshots** - Still using logStore
2. **PatchStore doesn't emit GraphCommitted** - Graph mutations untracked
3. **Compiler doesn't emit CompileStarted/CompileFinished** - Lifecycle boundaries missing

### Polish Gaps (Medium - P2, Future)
1. **Runtime diagnostics** - ProgramSwapped, RuntimeHealthSnapshot (Phase 2)
2. **FixAction system** - Not in Phase 1 scope
3. **Diagnostic console UI** - Not in Phase 1 scope

---

## Design Doc Compliance

### Fully Specified (Ready to Implement)
- **Minimal event set** (3.5-Events-and-Payloads-Schema.md): 5 events, fully specified payloads
- **DiagnosticHub contract** (§ "How DiagnosticHub uses these"): Exact event handling logic
- **Snapshot semantics** (§ "Design principle"): No per-diagnostic events, snapshots only
- **Why this is minimal and future-proof** (§ end): 5 events, low frequency, semantically strong

### Needs Clarification
- **Authoring validators** - What fast validators run on GraphCommitted? (e.g., "missing TimeRoot" is compile-time)
- **RuntimeHealthSnapshot complexity** - Phase 1 or Phase 2?
- **LogStore deprecation timeline** - Immediate or gradual?

---

## Quantitative Metrics

| Category | Count | Status |
|----------|-------|--------|
| Core types defined | 0 / 5 | Not started |
| Events (new model) | 0 / 5 | Not started |
| Events (deprecated) | 14 / 14 | Need removal/consolidation |
| DiagnosticHub methods | 0 / 6 | Not started |
| DiagnosticStore computed | 0 / 3 | Not started |
| Compiler integration points | 0 / 3 | Not started |
| PatchStore integration | 0 / 2 | Not started |
| Canonical diagnostic codes | 0 / 5 (Phase 1) | Not started |
| Test files | 0 / 3 | Not started |

---

## Dependencies and Blockers

### Dependencies (Available)
- MobX (installed, operational)
- EventDispatcher (operational, needs event type updates)
- RootStore pattern (established)
- Compiler infrastructure (integration points identified)

### Blockers
- **None** - All dependencies satisfied, greenfield implementation

---

## Recommended Sprint Scope (Phase 1)

**Focus:** Foundation types, 5 minimal events, DiagnosticHub with snapshot semantics, compiler integration

**In Scope:**
1. Core types (Diagnostic, TargetRef, DiagnosticCode, Severity, Domain)
2. **Replace 14 events with 5 events** (GraphCommitted, CompileStarted, CompileFinished, ProgramSwapped, RuntimeHealthSnapshot - defer last if complex)
3. DiagnosticHub class with snapshot-based state management
4. DiagnosticStore (MobX observable wrapper)
5. PatchStore integration (patchRevision counter, GraphCommitted emission)
6. Compiler integration (build diagnostic snapshots, emit CompileStarted/CompileFinished)
7. Unit tests (event payloads, DiagnosticHub snapshot logic, compiler diagnostic emission)

**Out of Scope (Future):**
- RuntimeHealthSnapshot implementation (defer to Phase 2 if complex)
- FixAction execution system
- UI components (diagnostic console, badges)
- Advanced polish (semantic addressing, grouping)

**Deferred Decision:**
- RuntimeHealthSnapshot complexity - implement in Phase 1 if straightforward, otherwise Phase 2

---

## Key Architectural Decisions

### Why Snapshot Semantics?
From design doc: "DiagnosticHub wants to 'replace compile snapshot' regardless of success. A single event makes downstream logic simpler and prevents branching duplication."

### Why 5 Events, Not 20?
From design doc: "Only 5 events are required for a complete diagnostic system. They are low frequency and semantically strong."

### What About Per-Frame Events?
From design doc: "Events you do not need for diagnostics: Per-frame tick events, Per-block 'evaluated' events, Per-bus 'value changed' events. Those are for internal profiling tools, not the core event spine."

---

## Next Steps

1. Define core types in `src/editor/diagnostics/types.ts`
2. Define 5 new event types, deprecate/remove 14 old events in `src/editor/events/types.ts`
3. Add patchRevision counter to PatchStore, emit GraphCommitted
4. Implement DiagnosticHub with snapshot-based state in `src/editor/diagnostics/DiagnosticHub.ts`
5. Create DiagnosticStore in `src/editor/stores/DiagnosticStore.ts`
6. Update compiler to emit CompileStarted/CompileFinished with diagnostic snapshot
7. Write tests for each component

---

**Status:** Ready for implementation (design doc authoritative)
**Risk Level:** Low (greenfield, rigorously specified)
**Estimated Complexity:** Medium (8-12 complexity points, not time-based)
