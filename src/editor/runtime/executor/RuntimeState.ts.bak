/**
 * Runtime State - Per-Frame Execution State
 *
 * Container for all runtime state needed during frame execution.
 *
 * Contains:
 * - ValueStore: per-frame slot-based value storage
 * - StateBuffer: cross-frame persistent state
 * - FrameCache: memoization cache with signal/field caches
 * - frameId: monotonic frame counter
 *
 * References:
 * - HANDOFF.md Topic 3 (ScheduleExecutor)
 * - design-docs/12-Compiler-Final/17-Scheduler-Full.md §8
 * - .agent_planning/scheduled-runtime/PLAN-2025-12-26-092613.md (Phase 6 Sprint 2)
 */

import type { ValueStore, StateBuffer } from "../../compiler/ir";
import {
  createValueStore,
  createStateBuffer,
  initializeState,
} from "../../compiler/ir/stores";
import type { SlotMeta } from "../../compiler/ir/stores";
import type { CompiledProgramIR } from "../../compiler/ir/program";
import type { FieldHandle } from "../field/types";
import { preserveState } from "./StateSwap";

// ============================================================================
// RuntimeState Interface
// ============================================================================

/**
 * RuntimeState - Frame Execution State Container
 *
 * Holds all mutable state during frame execution.
 *
 * Lifecycle:
 * - Created once per program
 * - Reused across frames
 * - Updated via hot-swap when program changes
 */
export interface RuntimeState {
  /** Per-frame value storage (slot-based) */
  values: ValueStore;

  /** Persistent state storage (cross-frame) */
  state: StateBuffer;

  /** Frame cache (per-frame memoization) */
  frameCache: FrameCache;

  /** Monotonic frame counter */
  frameId: number;

  /**
   * Hot-swap to a new program while preserving state and time continuity.
   *
   * This is the core jank-free live editing primitive. It creates a new
   * RuntimeState from the new program and preserves matching state cells
   * from the old runtime.
   *
   * State Preservation Contract:
   * - Matching state cells (by nodeId:role) are copied
   * - New state cells are initialized with defaults
   * - Removed state cells are dropped
   * - Layout changes (size/storage type) trigger re-initialization
   *
   * Time Continuity:
   * - frameId preserved (not reset to 0)
   * - FrameCache.frameId preserved
   *
   * Cache Policy:
   * - Per-frame caches invalidated (stamps zeroed, buffer pool cleared)
   * - New caches allocated for new runtime
   *
   * @param newProgram - New compiled program to swap to
   * @returns New RuntimeState with preserved state/time
   *
   * @example
   * ```typescript
   * // Execute frame with old program
   * executor.executeFrame(oldProgram, runtime, tMs);
   *
   * // Compile new program (user edited patch)
   * const newProgram = compile(editedPatch);
   *
   * // Hot-swap (preserves state)
   * runtime = runtime.hotSwap(newProgram);
   *
   * // Continue execution with new program (no visual jank)
   * executor.executeFrame(newProgram, runtime, tMs);
   * ```
   */
  hotSwap(newProgram: CompiledProgramIR): RuntimeState;
}

// ============================================================================
// FrameCache Interface
// ============================================================================

/**
 * FrameCache - Per-Frame Memoization
 *
 * Caches signal values, field handles, and materialized buffers per frame.
 * Implements stamp-based cache invalidation (no array clearing on newFrame).
 *
 * Cache Strategy:
 * - Stamp-based invalidation: stamp[id] === frameId → cache hit
 * - newFrame() increments frameId (stamps < frameId are stale)
 * - invalidate() zeros stamps (forces recomputation)
 * - Buffer pool is cleared on newFrame() (new frame = new materializations)
 *
 * References:
 * - HANDOFF.md Topic 4 (FrameCache System)
 * - design-docs/12-Compiler-Final/17-Scheduler-Full.md §8
 * - .agent_planning/scheduled-runtime/DOD-2025-12-26-092613.md §Deliverable 1
 */
export interface FrameCache {
  /** Current frame ID (monotonic, starts at 1) */
  frameId: number;

  /** Cached signal values (indexed by SigExprId) */
  sigValue: Float64Array;

  /** Frame stamps for signal cache validation */
  sigStamp: Uint32Array;

  /** Cached field handles - lazy recipes (indexed by FieldExprId) */
  fieldHandle: FieldHandle[];

  /** Frame stamps for field cache validation */
  fieldStamp: Uint32Array;

  /** Materialized buffer pool (per-frame cache) */
  fieldBuffers: Map<string, ArrayBufferView>;

  /**
   * Start a new frame.
   * Increments frameId and clears buffer pool.
   * Does NOT clear stamp arrays (stamp comparison handles invalidation).
   */
  newFrame(): void;

  /**
   * Invalidate all caches.
   * Zeros stamp arrays and clears buffer pool.
   * Used during hot-swap or debug reset.
   */
  invalidate(): void;
}

// ============================================================================
// FrameCache Factory
// ============================================================================

/**
 * Create a FrameCache with specified capacities.
 *
 * Allocates typed arrays for signal/field caches.
 * FrameId starts at 1 to avoid collision with initial Uint32Array values (0).
 *
 * @param sigCapacity - Number of signal expressions (max SigExprId + 1)
 * @param fieldCapacity - Number of field expressions (max FieldExprId + 1)
 * @returns Initialized FrameCache
 *
 * @example
 * ```typescript
 * const cache = createFrameCache(1024, 512);
 * console.log(cache.frameId); // 1 (NOT 0)
 * console.log(cache.sigValue.length); // 1024
 * console.log(cache.fieldHandle.length); // 512
 * ```
 */
export function createFrameCache(
  sigCapacity: number,
  fieldCapacity: number
): FrameCache {
  // Allocate signal cache arrays
  const sigValue = new Float64Array(sigCapacity);
  const sigStamp = new Uint32Array(sigCapacity);

  // Allocate field cache arrays
  // FieldHandle[] cannot be pre-allocated with type safety, so use empty array with reserved length
  const fieldHandle: FieldHandle[] = [];
  fieldHandle.length = fieldCapacity;
  const fieldStamp = new Uint32Array(fieldCapacity);

  // Initialize buffer pool
  const fieldBuffers = new Map<string, ArrayBufferView>();

  return {
    frameId: 1, // Start at 1 to avoid collision with initial stamp values (0)
    sigValue,
    sigStamp,
    fieldHandle,
    fieldStamp,
    fieldBuffers,

    newFrame(): void {
      // Increment frameId - this invalidates all cached values
      // (stamps < new frameId are now stale)
      this.frameId++;

      // Clear buffer pool - new frame requires fresh materializations
      this.fieldBuffers.clear();

      // Do NOT zero stamp arrays - stamp comparison is sufficient
      // Do NOT clear sigValue/fieldHandle arrays - stamps invalidate stale entries
    },

    invalidate(): void {
      // Zero all stamp arrays - forces full recomputation
      this.sigStamp.fill(0);
      this.fieldStamp.fill(0);

      // Clear buffer pool
      this.fieldBuffers.clear();

      // Do NOT reset frameId - it's monotonic
    },
  };
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Extract slot metadata from program schedule.
 *
 * This is a placeholder implementation for Sprint 1.
 * In future sprints, the compiler will emit slotMeta directly in CompiledProgramIR.
 *
 * Current strategy:
 * - Scan all steps for inputSlots and outputSlots
 * - Assign f64 storage to all slots by default (conservative)
 * - Use dense offset allocation (offset = slot index)
 *
 * @param program - Compiled program
 * @returns Slot metadata array
 */
function extractSlotMeta(program: CompiledProgramIR): SlotMeta[] {
  const numericSlots = new Set<number>();
  const objectSlots = new Set<number>(); // Slots that hold objects (buffers, handles)

  // Guard against incomplete program objects (used in some tests)
  if (!program.schedule || !program.schedule.steps) {
    return [];
  }

  // Collect all slot indices from schedule steps
  for (const step of program.schedule.steps) {
    switch (step.kind) {
      case "timeDerive":
        numericSlots.add(step.tAbsMsSlot);
        numericSlots.add(step.out.tModelMs);
        if (step.out.phase01 !== undefined) numericSlots.add(step.out.phase01);
        if (step.out.wrapEvent !== undefined)
          numericSlots.add(step.out.wrapEvent);
        if (step.out.progress01 !== undefined)
          numericSlots.add(step.out.progress01);
        break;

      case "nodeEval":
        for (const slot of step.inputSlots) numericSlots.add(slot);
        for (const slot of step.outputSlots) numericSlots.add(slot);
        break;

      case "busEval":
        numericSlots.add(step.outSlot);
        for (const pub of step.publishers) {
          numericSlots.add(pub.srcSlot);
        }
        break;

      case "materialize":
        numericSlots.add(step.materialization.domainSlot);
        // Buffer slots hold objects, not numbers
        objectSlots.add(step.materialization.outBufferSlot);
        break;

      case "materializeColor":
        // MaterializeColor inputs and outputs
        objectSlots.add(step.domainSlot);
        objectSlots.add(step.colorExprSlot);
        objectSlots.add(step.outRSlot);
        objectSlots.add(step.outGSlot);
        objectSlots.add(step.outBSlot);
        objectSlots.add(step.outASlot);
        break;

      case "materializePath":
        // MaterializePath inputs and outputs
        objectSlots.add(step.domainSlot);
        objectSlots.add(step.pathExprSlot);
        objectSlots.add(step.outCmdsSlot);
        objectSlots.add(step.outParamsSlot);
        break;

      case "renderAssemble":
        // RenderAssemble inputs and outputs (all objects)
        objectSlots.add(step.instance2dListSlot);
        objectSlots.add(step.pathBatchListSlot);
        objectSlots.add(step.outFrameSlot);
        break;

      case "debugProbe":
        for (const slot of step.probe.slots) numericSlots.add(slot);
        break;
    }
  }

  // Build metadata for all slots
  const slotMeta: SlotMeta[] = [];

  // Numeric slots get f64 storage
  for (const slot of numericSlots) {
    slotMeta.push({
      slot,
      storage: "f64",
      offset: slot, // Dense allocation: offset = slot index
      type: {
        world: "signal",
        domain: "float",
      },
    });
  }

  // Object slots get object storage
  for (const slot of objectSlots) {
    slotMeta.push({
      slot,
      storage: "object",
      offset: slot, // Dense allocation: offset = slot index
      type: {
        // Field buffers and render trees are "special" world objects
        world: "special",
        domain: "renderTree", // Generic object domain for buffers/trees
      },
    });
  }

  // Sort by slot index for consistent ordering
  slotMeta.sort((a, b) => a.slot - b.slot);

  return slotMeta;
}

// ============================================================================
// Factory Function
// ============================================================================

/**
 * Create RuntimeState from a compiled program.
 *
 * Allocates ValueStore and StateBuffer based on program metadata,
 * and initializes state cells from the constant pool.
 *
 * @param program - Compiled program
 * @returns Initialized RuntimeState
 */
export function createRuntimeState(program: CompiledProgramIR): RuntimeState {
  // Extract slot metadata (placeholder extraction for Sprint 1)
  const slotMeta = extractSlotMeta(program);

  // Create ValueStore with real implementation
  const values = createValueStore(slotMeta);

  // Initialize slots with compile-time values from schedule
  // These include batch descriptor lists for render assembly
  if (program.schedule?.initialSlotValues) {
    for (const [slotStr, value] of Object.entries(program.schedule.initialSlotValues)) {
      const slot = Number(slotStr);
      values.write(slot, value);
    }
  }

  // Create StateBuffer with real implementation
  // Guard against incomplete program objects (used in some tests)
  const stateLayout = program.stateLayout || {
    cells: [],
    f64Size: 0,
    f32Size: 0,
    i32Size: 0,
  };
  const state = createStateBuffer(stateLayout);

  // Initialize state cells with values from const pool
  const constPool = program.constants || {
    json: [],
    f64: new Float64Array([]),
    f32: new Float32Array([]),
    i32: new Int32Array([]),
    constIndex: [],
  };
  initializeState(state, stateLayout, constPool);

  // Create real FrameCache with default capacities
  // TODO: Derive capacities from SignalExprTable and FieldExprTable when available
  const sigCapacity = 1024; // Default signal cache capacity
  const fieldCapacity = 512; // Default field cache capacity
  const frameCache = createFrameCache(sigCapacity, fieldCapacity);

  const runtimeState: RuntimeState = {
    values,
    state,
    frameCache,
    frameId: 0,

    // Hot-swap implementation
    hotSwap(newProgram: CompiledProgramIR): RuntimeState {
      // Create new runtime from new program
      const newRuntime = createRuntimeState(newProgram);

      // Preserve state cells from old to new
      preserveState(this, newRuntime, program, newProgram);

      // Preserve time continuity
      newRuntime.frameId = this.frameId;
      newRuntime.frameCache.frameId = this.frameCache.frameId;

      // Invalidate caches (preserving frameId)
      newRuntime.frameCache.invalidate();

      return newRuntime;
    },
  };

  return runtimeState;
}
