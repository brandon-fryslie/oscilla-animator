import { describe, it, expect, beforeAll } from 'vitest';
import { findAdapterPath } from './autoAdapter';
import { initAdapterRegistry } from './AdapterRegistry';
import { TypeDesc } from '../types';

describe('Auto Adapter Logic', () => {
  beforeAll(() => {
    initAdapterRegistry();
  });

  const SIGNAL_NUM: TypeDesc = { world: 'signal', domain: 'float', category: 'core', busEligible: true };
  const FIELD_NUM: TypeDesc = { world: 'field', domain: 'float', category: 'core', busEligible: true };
  const SIGNAL_PHASE: TypeDesc = { world: 'signal', domain: 'phase', category: 'core', busEligible: true };

  it('finds direct auto path for Signal -> Field (Broadcast)', () => {
    const result = findAdapterPath(SIGNAL_NUM, FIELD_NUM);
    expect(result.ok).toBe(true);
    expect(result.chain).toHaveLength(1);
    expect(result.chain![0].adapterId).toBe('BroadcastSignalToField');
  });

  it('finds suggest path for Number -> Phase', () => {
    const result = findAdapterPath(SIGNAL_NUM, SIGNAL_PHASE);
    // Should be suggest because policy is SUGGEST
    expect(result.ok).toBe(false);
    expect(result.reason).toContain('manual adaptation');
    expect(result.suggestions).toBeDefined();
    expect(result.suggestions![0][0].adapterId).toBe('NormalizeToPhase');
  });

  it('returns ok for identical types', () => {
    const result = findAdapterPath(SIGNAL_NUM, SIGNAL_NUM);
    expect(result.ok).toBe(true);
    expect(result.chain).toHaveLength(0);
  });
});
