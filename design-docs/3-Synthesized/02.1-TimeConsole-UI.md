# Time Console & Modulation Rack — Authoritative UI and Runtime Specification

This document specifies the **Time Console** and **Modulation Rack** systems for Oscilla. It is normative and implementation-facing.

---

## 1. Purpose

The Time Console is the **authoring surface for time**. It replaces any cycle or loop UI previously attached to the Player. The Player is a viewer/transport only.

Time authoring is split into two orthogonal layers:

- **TimeRoot** (topology): Finite or Infinite
- **Modulation Rack** (Global Rails): derived modulation lanes (Phase A/B, Pulse A/B, Energy, Palette)

The Modulation Rack provides **normalled** (default) patch‑level modulation so a new patch moves immediately without wiring. These rails are conceptually distinct from user-created buses:

- **Rails** are a small, fixed set of named modulation channels curated by the app.
- **Buses** are arbitrary user routing fabric (many, configurable, combinable).

Cycles are not topology. They are derived operators that transform the root time signal.

---

## 2. UI Placement

The Time Console MUST be visible whenever a patch is open.

It MAY appear as:
- A panel inside the Inspector
- Or a dedicated right-rail tab next to Buses / Debug

It MUST NOT live in the Player.

---

## 3. TimeRoot Editor (Topology)

Exactly one TimeRoot exists per patch.

### 3.1 Types

The only valid TimeRoots are:

```
FiniteTimeRoot
InfiniteTimeRoot
```

There is no CycleTimeRoot.

### 3.2 FiniteTimeRoot UI

Controls:
- Duration (ms or musical time)
- Cue points (optional)
- Playback policy (view-only):
  - Once
  - Loop
  - Ping-pong

This policy applies to **view-time (tView)**, not the actual root time signal.

### 3.3 InfiniteTimeRoot UI

Controls:
- Minimal: TimeChip
  - Small round 
- Expanded: 

The root time signal always increases monotonically.

## 3.4 Default Modulation Provisioning

When a new patch is created, the Modulation Rack is provisioned so the preview animates immediately:

- **Cycle A** is enabled with period = 2.0s, mode = loop, feeding **phaseA** and **pulseA** rails.
- **Cycle B** is disabled by default (but present) with period = 3.125s, mode = loop, feeding **phaseB** and **pulseB** rails when enabled.
- **Energy** and **Palette** lanes are enabled with default generators.

Rails always exist; lane enablement controls whether the rack actively drives them.

---

## 4. Modulation Rack (Global Rails)

The Modulation Rack is a **patch-level derived modulation system** that generates phase/pulse/energy/palette signals without cluttering the graph.

It is authored in the Time Console and compiled as hidden operators. These operators feed **Global Rails** by default (normalled), and may optionally publish into the user bus fabric when explicitly enabled.

### 4.1 Canonical Cycles

The patch has a fixed set of cycle lanes:

| Lane     | Default | Outputs                                  |
|----------|---------|------------------------------------------|
| Cycle A  | On      | phaseA (rail), pulseA (rail), cycleIndexA (internal)               |
| Cycle B  | Off     | phaseB (rail), pulseB (rail), cycleIndexB (internal)               |
| Energy   | On      | energy (rail)                                    |
| Palette  | On      | palette (rail)                                   |

These are not blocks on the canvas.

### 4.2 Cycle Lane Controls

Each cycle lane exposes:

- Period
- Mode: loop | pingpong | once
- Phase offset
- Rate multiplier
- Enable toggle
- Rail publish toggles per output

Example:
- phaseA → rail `phaseA`
- pulseA → rail `pulseA`
- energy → rail `energy`
- palette → rail `palette`

Defaults on new patch:
- Cycle A enabled, publishing phaseA + pulseA
- Energy + Palette enabled
- Cycle B disabled

### 4.3 Rail Drive Policy (Normalled vs Patched)

Each rail has an explicit drive policy, set in the Time Console:

- **Normalled**: the Modulation Rack drives the rail (default).
- **Patched**: the Modulation Rack is disconnected for that rail; only user publishers drive it.
- **Mixed**: both rack and user publishers drive the rail; the rail’s combine rule applies.

No hidden precedence is allowed. If a user publishes to a rail while it is Normalled, the UI MUST surface this and require an explicit policy choice.

---

## 6. Compilation

The compiler MUST:

1. Compile TimeRoot → root time signal
2. Compile Modulation Rack → derived SignalExpr operators
3. Feed Global Rails before any user blocks execute
4. If enabled, publish selected rail signals into the user bus fabric

Rack publishers behave like normal publishers but are marked:

```
origin = 'timeOverlay'
```

---

## 8. Player Interaction

The Player receives:

- TimeModel from compiler
- Uses view-time mapping only

The Player UI shows:
- TimeModel badge (Finite 12.0s / Infinite)
- View playback mode (once/loop/pingpong)

It does NOT show cycles.

The Player never edits or owns cycles. It only displays the TimeModel and current view‑time mapping.
All cycle editing happens in the Time Console.

## 8.1 Cycle UI Placement

All cycle and phase authoring occurs in the Time Console.

The Player UI is limited to:
- TimeModel badge (Finite / Infinite)
- View playback mode for finite patches (Once / Loop / Ping‑pong)
- speed, and run/freeze
- Note: Scrubbing has been DEFERRED

The Player MUST NOT contain any cycle, phase, or period editing UI.

Rail rows (phaseA, phaseB, pulseA, pulseB, energy, palette) MUST include a shortcut to open the Time Console to the corresponding Modulation Rack lane. These rails MAY be rendered in the Bus Board as a pinned “Global Rails” group, but they are not treated as ordinary user buses.

---

## 9. Why This Exists

This architecture gives:
- Cycles by default
- Infinite nesting via operators
- Zero canvas clutter
- Determinism
- Debuggability
- Rust/WASM-friendly IR

This is the canonical design for Oscilla time authoring.