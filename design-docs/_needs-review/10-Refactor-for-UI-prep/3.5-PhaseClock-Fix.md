If PhaseClock is gone and everything depended on it, the fastest way to get the app working again (without re-introducing the same architectural problem) is to replace “PhaseClock as a block” with a single patch-level time authority that exposes the exact same products PhaseClock used to provide: phase (0→1), time, and optionally pingpong/loop shaping.

The key is: don’t “bring PhaseClock back.” Bring back PhaseClock behavior as TimeRoot outputs + a tiny phase-derivation operator.

⸻

What PhaseClock was really doing

PhaseClock’s functional contract (based on your earlier description) was:
	•	Input: tMs (global time in milliseconds)
	•	Params: durationMs, mode: loop|once|pingpong
	•	Output: phase in [0,1] (with wrapping/pingpong/clamp)
	•	Sometimes: derived triggers on wrap / peaks, etc.

Everything else in your system implicitly assumed:
	•	“there exists a canonical phase signal I can animate against.”

So you need to restore a canonical phase.

⸻

The replacement architecture (the long-term correct one)

1) Require exactly one TimeRoot block per patch

TimeRoot becomes the only source of “timeline semantics.” It outputs:
	•	Signal:TimeMs (monotonic or local, depends on mode)
	•	Signal:phase (0..1) — the canonical replacement for PhaseClock output
	•	Event:pulse (optional, but you’ll want it soon)
	•	TimeModel metadata (finite/cyclic/infinite) for the player UI

TimeRoot has params that cover the PhaseClock modes:
	•	mode: finite | cyclic | infinite
	•	If cyclic: periodMs, shape: loop | pingpong | once (yes, cyclic+once is “play one cycle and hold”)

This instantly gives every patch a “PhaseClock equivalent,” but with correct authority.

2) Auto-provide a default phase bus (phaseA)

On patch init, create bus:
	•	phaseA: (world=signal, domain=phase), combineMode='last', default=0

Then TimeRoot publishes its phase output to phaseA by default.

Now any block that previously “expected PhaseClock” can be migrated to:
	•	listen to phaseA for phase-like modulation

This is the most important compatibility bridge: it prevents you from having to wire phase everywhere.

⸻

How to get your blocks working again (practical migration)

Step A — Add/restore TimeRoot + default buses
	•	Ensure new patches always contain a TimeRoot.
	•	Ensure BusStore.createDefaultBuses() runs on patch creation (phaseA, phaseB, pulse, energy, palette — whatever you’ve standardized).
	•	Ensure TimeRoot auto-publishes to phaseA (and pulse if you have it).

Step B — Create a tiny operator to recreate “PhaseClock variants”

Because PhaseClock often served as “I need another cycle rate,” you want a pure operator block:

PhaseFromTime (pure)
	•	Inputs: Signal:TimeMs (or Signal:phase), Scalar:periodMs, Scalar:mode
	•	Output: Signal:phase

This recreates exactly the old PhaseClock math, but it’s no longer topology—just derivation.

So you can get:
	•	a slow drift phase (period=47s)
	•	a fast tremolo phase (period=0.5s)
	•	pingpong behavior
without reintroducing a second authority.

Step C — Update any block that implicitly assumed “phase exists” to consume from phaseA

There are two patterns you’ll find in the codebase:
	1.	Blocks that literally referenced PhaseClock by type or by hardcoded lookup
→ Replace that dependency with: “get canonical phase signal from TimeRoot output (or from phaseA bus).”
	2.	Blocks that expected a Signal<number> phase input but macros/composites used to supply PhaseClock automatically
→ Update the macro/composite templates so they instead bind to phaseA.

⸻

Player-side fix that prevents the “cut off mid-loop” problem

Previously the player wrapping time could fight an internal phase loop. With TimeRoot:
	•	Player time should be monotonic always.
	•	Player UI uses CompileResult.timeModel only to decide:
	•	how to display the timeline (finite bar vs cyclic ring vs infinite window)
	•	what the default scrub window is
	•	Player must never enforce loop boundaries by wrapping tMs.

TimeRoot does the wrapping (by deriving local timeMs / phase from monotonic transport time).

That guarantees: if TimeRoot is 10s cyclic, you won’t get the “player wraps at 6s” bug ever again.

⸻

If you need a “drop-in compatibility shim” today

If you truly need the fastest “everything compiles again” without touching 50 blocks immediately:

Add a special built-in compile-time provided signal in CompileCtx / runtime ctx:
	•	ctx.phaseA (Signal) sourced from TimeRoot

Then blocks that previously “grabbed PhaseClock” can temporarily call the shim.

But the end goal is still: blocks should either:
	•	take phase as an explicit input (best), or
	•	consume phaseA via the bus system (instrument-friendly default).

⸻

The mental model to keep you out of trouble
	•	TimeRoot = “what time means in this patch”
	•	phaseA = “the canonical musical phase for the patch”
	•	PhaseFromTime / PhaseDerive = “secondary clocks / additional loops”
	•	Player = “transport + viewport”, not loop authority

If you tell me which blocks are currently failing most (error messages or a short list of block types), I can map them to one of the three migration patterns above and tell you exactly which dependency they’re likely missing now.

Got it. Then don’t triage block-by-block. Fix it at the one place that PhaseClock used to “feed the world,” so every block that depended on “there is a phase” gets it again automatically.

Here’s the clean, single-path recovery plan.

⸻

1) Reintroduce PhaseClock behavior as a required TimeRoot output

You need one canonical signal that always exists:
	•	phase: Signal<phase> in [0,1]

Whatever replaced PhaseClock must guarantee:
	•	It exists in every patch
	•	It is produced even if the user adds nothing
	•	It has the same semantics PhaseClock used to provide (loop / pingpong / once)

So: TimeRoot is mandatory, and it owns:
	•	mode: finite | cyclic | infinite
	•	periodMs (for cyclic/infinite rhythm base)
	•	shape: loop | pingpong | once (the old PhaseClock modes)

This makes “PhaseClock” no longer a block; it’s the patch’s time topology.

⸻

2) Make “phaseA” a built-in bus and bind it automatically

You said everything depended on PhaseClock. In practice that means everything depended on a canonical phase source.

So you create it:
	•	Default bus: phaseA (TypeDesc = {world:'signal', domain:'phase'})
	•	Default value: 0
	•	Combine mode: last

Then: TimeRoot always publishes its phase output to phaseA.

Now any block can depend on phaseA existing, without explicit wiring.

This is how you restore global behavior without reintroducing PhaseClock.

⸻

3) Add a compatibility rule: any missing phase input defaults to phaseA

This is the “make it work again” lever.

If a block has an input slot whose TypeDesc is:
	•	world=signal, domain=phase (or your equivalent)

and it is unconnected / unbound:

Compiler injects an implicit listener to phaseA for that input.

Not a UI hack. A compilation rule.

Result:
	•	Old patches compile and run without users doing anything
	•	New patches feel “alive immediately”
	•	Users can still override by explicitly binding another bus or wire

This single rule is what turns “everything fails” into “everything runs again”.

⸻

4) Provide the old “multiple clocks” capability as a pure operator, not topology

PhaseClock used to also be abused as “I need another oscillator/phase at a different rate”.

You’ll still need that, but it must be derivation, not authority:
	•	PhaseDerive (pure): takes timeMs or phase + period + shape → outputs another Signal<phase>

People can publish those to phaseB, phaseC, etc.

But only TimeRoot defines the patch time narrative.

⸻

5) The only two things you must do to stop the hard failure

If blocks “just fail” right now, it’s almost certainly because compilation cannot resolve required inputs that PhaseClock used to supply.

So you implement:
	1.	TimeRoot always exists and always outputs phase
	2.	Implicit phase binding to phaseA for any unbound phase input

That’s it. No whack-a-mole across block implementations.

⸻

Why this is the correct long-term fix (not a band-aid)
	•	It restores the old ergonomic guarantee: “phase exists”
	•	It keeps the new architectural guarantee: “topology has one authority”
	•	It aligns with buses, infinite/ambient, and no-jank swapping

If you want, I can specify the exact matching rule for “which inputs get implicit phaseA” in terms of your existing TypeDesc / SlotType mapping, so there’s no ambiguity about which ports qualify.