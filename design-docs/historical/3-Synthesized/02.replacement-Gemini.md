# Time Architecture

## Fundamental Principle

**There is exactly ONE time system. The patch defines time topology. The player controls transport.**

The player:
- Hosts the runtime
- Observes `TimeModel`
- Controls rate (speed)
- Controls run/freeze
- Controls **View Looping** (for Finite patches only)

The patch (via TimeRoot):
- Declares the `TimeModel` (Finite vs Infinite)
- Defines the fundamental flow of `t`

---

## TimeRoot

Every patch must contain exactly one **TimeRoot** block.

### TimeRoot Types

| Type | Description | Use Case |
| :--- | :--- | :--- |
| `FiniteTimeRoot` | Finite performance with known duration | Logo stingers, intro/outro animations |
| `InfiniteTimeRoot` | Runs unbounded, generative time | Installations, VJ loops, screensavers |



### Constraints
- Exactly one TimeRoot per patch (compile error if 0 or >1)
- TimeRoot cannot have upstream dependencies
- TimeRoot cannot exist inside composite definitions

---

## TimeModel

The compiler outputs a `TimeModel` describing the patch’s topology.

```typescript
type TimeModel =
  | { kind: 'finite'; durationMs: number }
  | { kind: 'infinite' };
```

### TimeCtx (Runtime input)
`TimeCtx` is what flows into the program every frame.

```ts
interface TimeCtx {
  t: number;        // Unbounded, monotonically increasing time in ms
  dt: number;       // Delta time
  seed: number;     // Deterministic seed
}
```

**Rules:**
- `t` never wraps
- `t` never resets when looping playback
- `t` is never clamped by TimeModel

TimeModel constrains **how time is interpreted**, not how time flows.

---

## Player Playback Policy

The Player adapts its transport controls based on the `TimeModel`.

| TimeModel | Player Behavior | Loop Controls |
| :--- | :--- | :--- |
| **Finite** | Timeline View (0..Duration). Scrubbing sets absolute `t`. | **Enabled** (`Once`, `Loop`, `PingPong`). These affect the *View Time*, typically by resetting `t` to 0 or reversing direction when duration is reached. |
| **Infinite** | Sliding Window View. Scrubbing offsets the view window. | **Disabled**. Infinite time cannot be looped. |

---

## Derived Time & Cycles

Cycles are **derived signals**, created by explicit operators layered on top of the unbounded `TimeCtx.t`.

### PhaseFromTime (The Engine of Cycles)
The core operator for cyclic time is `PhaseFromTime`. It converts unbounded milliseconds into a normalized phase (0..1).

**Semantics:**
```
raw = (t * rate) / period
loop:     phase = frac(raw + offset)
pingpong: phase = triangle(raw + offset)
```
* Uses unbounded `t`.
* No dependence on player state.
* Preserves determinism.

The **Modulation Rack** (below) manages a set of these operators automatically for the patch.

---

# Time Console & Modulation Rack

## 1. Purpose

The Time Console is the **authoring surface for time**. It replaces any cycle or loop UI previously attached to the Player.

Time authoring is split into two layers:
1.  **TimeRoot** (Topology): Finite or Infinite.
2.  **Modulation Rack** (Global Rails): Derived modulation lanes (Phase A/B, Pulse, Energy, Palette).

## 2. Modulation Rack (Global Rails)

The Modulation Rack is a system-level component that generates essential signals so patches animate immediately without wiring. It outputs to **Global Rails**.

### The Canonical Rails
A **Rail** is a specialized signal endpoint (similar to a Register) that exists outside the standard block graph.

| Rail | Type | Default Source | Description |
| :--- | :--- | :--- | :--- |
| **`phaseA`** | `Signal<phase>` | Rack Cycle A | Primary motion driver (0..1). |
| **`phaseB`** | `Signal<phase>` | Rack Cycle B | Secondary motion driver (e.g., long evolutions). |
| **`pulse`** | `Event` | Rack Cycle A | Rhythmic triggers / beat clock (derived from Phase A wrap). |
| **`energy`** | `Signal<number>` | Rack Energy | Global intensity envelope. |
| **`palette`** | `Signal<color>` | Rack Palette | Global color theme. |

### Cycle Lane Controls
In the Time Console, "Cycle A" and "Cycle B" lanes allow configuring the internal generators:
- Period (ms)
- Mode (Loop | PingPong | Once)
- Phase Offset
- Rate Multiplier

## 3. Rail Drive Policy

Each Rail has a configurable **Drive Source** managed in the Time Console. This allows the graph to override the Rack.

| Mode | Meaning | Use Case |
| :--- | :--- | :--- |
| **Normalled** | Driven by **Modulation Rack** | Default behavior. The internal generator drives the Rail. |
| **Patched** | Driven by **User Bus** | The internal generator is disconnected. A User Bus (e.g., `KickDrum`) drives the Rail. |
| **Mixed** | Driven by **Both** | Internal + Bus are combined (via `Sum`, `Max`, or `Override` rule). |

### UI Representation
For each Rail row in the Time Console:
```
Phase A: [ Internal ⬤ ] [ Bus ○ ] [ Both ○ ]  -> Bus Selector: (none)
Pulse:   [ Internal ○ ] [ Bus ⬤ ] [ Both ○ ]  -> Bus Selector: KickTriggers
```

## 4. Compilation & Runtime Constraints

Rails enforce strict semantics to allow bidirectional flow (Bus → Rail → Bus) without creating infinite recursion.

### Schedule
1.  **Phase 0:** TimeRoot emits `t`.
2.  **Phase 1:** Modulation Rack calculates Internal candidates (unbounded time → phase).
3.  **Phase 2:** User Graph evaluates (blocks read previous/current rails).
4.  **Phase 3:** Rail Resolution (Internal vs User Bus policy applied).

### Cycle Prevention (The Frame Latch)
If a Rail is in **Patched** mode, and the source Bus depends on that same Rail (algebraic loop):
* The system enforces a **Frame Latch**.
* Rail Reads in the graph see values from `t-1`.
* Rail Writes in the graph contribute to `t`.
* This ensures the graph remains acyclic (DAG).

---

## 5. UI Integration

### Time Console vs Player
* **Time Console:** Where you edit Period, Duration, Rail Sources, and Infinite Generators.
* **Player:** Where you hit Play/Freeze and control Speed.

### Default Provisioning
When a new `InfiniteTimeRoot` patch is created:
- **Cycle A** is enabled (Period = 2.0s, Loop) feeding `phaseA` and `pulse`.
- **Cycle B** is disabled.
- **Energy** and **Palette** are enabled with defaults.

This ensures the user sees motion immediately without adding blocks.