Yes: one patch, one render target, one “master time” — but each child graph can have its own time mapping.

Here’s the clean spec that keeps everything coherent and avoids nasty sync/jank problems.

⸻

1) Patch-level time is singular and authoritative

A patch has exactly one MasterTimeRoot that defines:
	•	t (monotonic time)
	•	transport state (play/pause, rate, direction)
	•	global loop topology (finite / cycle / infinite)
	•	the canonical “phase” buses if you choose to provide them (phaseA etc.)

All graphs live under this same master time.
This is what makes the patch feel like one instrument.

⸻

2) Child graphs do not own time topology

A child graph cannot define an independent TimeRoot in the sense of “this graph is infinite, that graph is finite.” That would fragment the patch.

Instead, each child graph can optionally define a TimeLens (time mapping) that derives local time/phase from master time:

Examples of TimeLens behaviors:
	•	rate: run at 0.5x or 2x speed relative to master
	•	phaseOffset: start at different phase
	•	pingpong: local pingpong while master loops
	•	window: “observe” a sliding window of master time
	•	quantize: lock to beats if you add BPM later
	•	resetOnPulse: restart local phase when a global trigger fires

So each graph has:
	•	TimeLens: Program<TimeCtx> -> Program<TimeCtx> (pure transform of time context)
	•	not a TimeRoot

This matches your overall philosophy: topology is centralized; variety comes from composable transforms.

⸻

3) Rendering: one render target, many render contributions

Each child graph ultimately compiles to something like:
	•	Program<RenderTree> or Program<RenderNode[]>

The patch root then combines them into the final render:
	•	RenderTree = Group(children: [graphA(tree), graphB(tree), ...])

Ordering is deterministic:
	•	root keeps a stable order of child graphs
	•	each graph can be assigned a layer index or z-order at the root level (simple and explicit)

This gives:
	•	multiple “instruments” contributing to one scene
	•	without needing separate render targets

⸻

4) How local time affects buses and signals

All signals in a child graph evaluate against that graph’s derived time context:
	•	master t comes in
	•	graph applies its TimeLens, producing t_local, phase_local, etc.
	•	all internal blocks use t_local when they ask for time

But buses are patch-global, so you need one rule:

Rule: Buses carry values in patch time

A graph may publish either:
	•	patch-time values (default), or
	•	explicitly time-lensed values (if the user chooses)

In practice:
	•	most graphs publish in their own local time (because that’s what they “feel” like)
	•	but the publishing action can show a badge:
	•	“publishing in local time” vs “publishing in patch time”

This avoids confusion when graph B is “half speed” and you’re wondering why its modulation seems slow.

⸻

5) Why this is the best outcome
	•	The patch remains a single coherent performance unit.
	•	You avoid the nightmare of multiple independent transport loops fighting.
	•	You still get the musical effect of polyrhythms and multi-scale looping via TimeLens.
	•	It stays deterministic, composable, and debuggable.

⸻

6) Root-view UX implication

In Patch Root view, each child graph shows a Time Badge:
	•	=1x (no lens)
	•	0.5x
	•	2x
	•	↔ pingpong
	•	+0.25ϕ (phase offset)
	•	reset@pulse

So even at the overview level, users understand “these are running at different temporal relationships” while still being part of one patch.

⸻

If you want to go even tighter: I can specify the exact port/type contract of the MasterTimeRoot + TimeLens node (what signals exist: time, phaseA, pulse, beat, etc.) and how child graphs declare their TimeLens in the data model.